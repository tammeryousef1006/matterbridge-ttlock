/**
 * This file contains the class MatterbridgeEndpoint that extends the Endpoint class from the Matter.js library.
 *
 * @file matterbridgeBehaviors.ts
 * @author Luca Liguori
 * @date 2024-11-07
 * @version 1.0.0
 *
 * Copyright 2024, 2025, 2026 Luca Liguori.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License. *
 */
import { Behavior, MaybePromise, NamedHandler } from '@matter/main';
import { BooleanStateConfiguration } from '@matter/main/clusters/boolean-state-configuration';
import { ColorControl } from '@matter/main/clusters/color-control';
import { FanControl } from '@matter/main/clusters/fan-control';
import { Identify } from '@matter/main/clusters/identify';
import { LevelControl } from '@matter/main/clusters/level-control';
import { WindowCovering } from '@matter/main/clusters/window-covering';
import { Thermostat } from '@matter/main/clusters/thermostat';
import { ValveConfigurationAndControl } from '@matter/main/clusters/valve-configuration-and-control';
import { ModeSelect } from '@matter/main/clusters/mode-select';
import { SmokeCoAlarm } from '@matter/main/clusters/smoke-co-alarm';
import { BooleanStateConfigurationServer } from '@matter/main/behaviors/boolean-state-configuration';
import { OperationalState } from '@matter/main/clusters/operational-state';
import { ModeBase } from '@matter/main/clusters/mode-base';
import { ServiceArea } from '@matter/main/clusters/service-area';
import { IdentifyServer } from '@matter/main/behaviors/identify';
import { OnOffServer } from '@matter/main/behaviors/on-off';
import { LevelControlServer } from '@matter/main/behaviors/level-control';
import { ColorControlServer } from '@matter/main/behaviors/color-control';
import { MovementDirection, MovementType, WindowCoveringServer } from '@matter/main/behaviors/window-covering';
import { DoorLockServer } from '@matter/main/behaviors/door-lock';
import { FanControlServer } from '@matter/main/behaviors/fan-control';
import { ThermostatServer } from '@matter/main/behaviors/thermostat';
import { ValveConfigurationAndControlServer } from '@matter/main/behaviors/valve-configuration-and-control';
import { ModeSelectServer } from '@matter/main/behaviors/mode-select';
import { SmokeCoAlarmServer } from '@matter/main/behaviors/smoke-co-alarm';
import { SwitchServer } from '@matter/main/behaviors/switch';
import { OperationalStateServer } from '@matter/main/behaviors/operational-state';
import { RvcRunModeServer } from '@matter/main/behaviors/rvc-run-mode';
import { RvcCleanModeServer } from '@matter/main/behaviors/rvc-clean-mode';
import { RvcOperationalStateServer } from '@matter/main/behaviors/rvc-operational-state';
import { ServiceAreaServer } from '@matter/main/behaviors/service-area';
import { AnsiLogger } from './logger/export.js';
import { MatterbridgeEndpointCommands } from './matterbridgeEndpoint.js';
export declare class MatterbridgeServerDevice {
    log: AnsiLogger;
    commandHandler: NamedHandler<MatterbridgeEndpointCommands>;
    device: any;
    endpointId: string | undefined;
    endpointNumber: number | undefined;
    constructor(log: AnsiLogger, commandHandler: NamedHandler<MatterbridgeEndpointCommands>, device: any);
    setEndpointId(endpointId: string | undefined): void;
    setEndpointNumber(endpointNumber: number | undefined): void;
    identify({ identifyTime }: Identify.IdentifyRequest): void;
    triggerEffect({ effectIdentifier, effectVariant }: Identify.TriggerEffectRequest): void;
    on(): void;
    off(): void;
    toggle(): void;
    moveToLevel({ level, transitionTime, optionsMask, optionsOverride }: LevelControl.MoveToLevelRequest): void;
    moveToLevelWithOnOff({ level, transitionTime, optionsMask, optionsOverride }: LevelControl.MoveToLevelRequest): void;
    moveToHue({ optionsMask, optionsOverride, hue, direction, transitionTime }: ColorControl.MoveToHueRequest): void;
    moveToSaturation({ optionsMask, optionsOverride, saturation, transitionTime }: ColorControl.MoveToSaturationRequest): void;
    moveToHueAndSaturation({ optionsOverride, optionsMask, saturation, hue, transitionTime }: ColorControl.MoveToHueAndSaturationRequest): void;
    moveToColor({ optionsMask, optionsOverride, colorX, colorY, transitionTime }: ColorControl.MoveToColorRequest): void;
    moveToColorTemperature({ optionsOverride, optionsMask, colorTemperatureMireds, transitionTime }: ColorControl.MoveToColorTemperatureRequest): void;
    upOrOpen(): void;
    downOrClose(): void;
    stopMotion(): void;
    goToLiftPercentage({ liftPercent100thsValue }: WindowCovering.GoToLiftPercentageRequest): void;
    lockDoor(): void;
    unlockDoor(): void;
    step({ direction, wrap, lowestOff }: FanControl.StepRequest): void;
    setpointRaiseLower({ mode, amount }: Thermostat.SetpointRaiseLowerRequest): void;
    open({ openDuration, targetLevel }: ValveConfigurationAndControl.OpenRequest): void;
    close(): void;
    changeToMode({ newMode }: ModeSelect.ChangeToModeRequest): void;
    selfTestRequest(): void;
    enableDisableAlarm({ alarmsToEnableDisable }: BooleanStateConfiguration.EnableDisableAlarmRequest): void;
    pause(): void;
    stop(): void;
    start(): void;
    resume(): void;
    goHome(): void;
    selectAreas({ newAreas }: ServiceArea.SelectAreasRequest): void;
}
export declare class MatterbridgeServer extends Behavior {
    static readonly id = "matterbridge";
    state: MatterbridgeServer.State;
    initialize(): void;
}
export declare namespace MatterbridgeServer {
    class State {
        deviceCommand: MatterbridgeServerDevice;
    }
}
export declare class MatterbridgeIdentifyServer extends IdentifyServer {
    identify({ identifyTime }: Identify.IdentifyRequest): MaybePromise;
    triggerEffect({ effectIdentifier, effectVariant }: Identify.TriggerEffectRequest): MaybePromise;
}
export declare class MatterbridgeOnOffServer extends OnOffServer {
    on(): MaybePromise;
    off(): MaybePromise;
    toggle(): MaybePromise;
}
export declare class MatterbridgeLevelControlServer extends LevelControlServer {
    moveToLevel({ level, transitionTime, optionsMask, optionsOverride }: LevelControl.MoveToLevelRequest): MaybePromise;
    moveToLevelWithOnOff({ level, transitionTime, optionsMask, optionsOverride }: LevelControl.MoveToLevelRequest): MaybePromise;
}
declare const MatterbridgeColorControlServer_base: import("@matter/main").ClusterBehavior.Type<import("@matter/types").ClusterComposer.WithFeatures<import("@matter/types").ClusterType.Of<{
    readonly id: 768;
    readonly name: "ColorControl";
    readonly revision: 7;
    readonly features: {
        readonly hueSaturation: import("@matter/types").BitFlag;
        readonly enhancedHue: import("@matter/types").BitFlag;
        readonly colorLoop: import("@matter/types").BitFlag;
        readonly xy: import("@matter/types").BitFlag;
        readonly colorTemperature: import("@matter/types").BitFlag;
    };
    readonly attributes: {
        readonly remainingTime: import("@matter/types").OptionalAttribute<number, any>;
        readonly driftCompensation: import("@matter/types").OptionalAttribute<ColorControl.DriftCompensation, any>;
        readonly compensationText: import("@matter/types").OptionalAttribute<string, any>;
        readonly colorMode: import("@matter/types").Attribute<ColorControl.ColorMode, any>;
        readonly options: import("@matter/types").WritableAttribute<import("@matter/types").TypeFromPartialBitSchema<{
            executeIfOff: import("@matter/types").BitFlag;
        }>, any>;
        readonly numberOfPrimaries: import("@matter/types").FixedAttribute<number | null, any>;
        readonly primary1X: import("@matter/types").OptionalFixedAttribute<number, any>;
        readonly primary1Y: import("@matter/types").OptionalFixedAttribute<number, any>;
        readonly primary1Intensity: import("@matter/types").OptionalFixedAttribute<number | null, any>;
        readonly primary2X: import("@matter/types").OptionalFixedAttribute<number, any>;
        readonly primary2Y: import("@matter/types").OptionalFixedAttribute<number, any>;
        readonly primary2Intensity: import("@matter/types").OptionalFixedAttribute<number | null, any>;
        readonly primary3X: import("@matter/types").OptionalFixedAttribute<number, any>;
        readonly primary3Y: import("@matter/types").OptionalFixedAttribute<number, any>;
        readonly primary3Intensity: import("@matter/types").OptionalFixedAttribute<number | null, any>;
        readonly primary4X: import("@matter/types").OptionalFixedAttribute<number, any>;
        readonly primary4Y: import("@matter/types").OptionalFixedAttribute<number, any>;
        readonly primary4Intensity: import("@matter/types").OptionalFixedAttribute<number | null, any>;
        readonly primary5X: import("@matter/types").OptionalFixedAttribute<number, any>;
        readonly primary5Y: import("@matter/types").OptionalFixedAttribute<number, any>;
        readonly primary5Intensity: import("@matter/types").OptionalFixedAttribute<number | null, any>;
        readonly primary6X: import("@matter/types").OptionalFixedAttribute<number, any>;
        readonly primary6Y: import("@matter/types").OptionalFixedAttribute<number, any>;
        readonly primary6Intensity: import("@matter/types").OptionalFixedAttribute<number | null, any>;
        readonly whitePointX: import("@matter/types").OptionalWritableAttribute<number, any>;
        readonly whitePointY: import("@matter/types").OptionalWritableAttribute<number, any>;
        readonly colorPointRx: import("@matter/types").OptionalWritableAttribute<number, any>;
        readonly colorPointRy: import("@matter/types").OptionalWritableAttribute<number, any>;
        readonly colorPointRIntensity: import("@matter/types").OptionalWritableAttribute<number | null, any>;
        readonly colorPointGx: import("@matter/types").OptionalWritableAttribute<number, any>;
        readonly colorPointGy: import("@matter/types").OptionalWritableAttribute<number, any>;
        readonly colorPointGIntensity: import("@matter/types").OptionalWritableAttribute<number | null, any>;
        readonly colorPointBx: import("@matter/types").OptionalWritableAttribute<number, any>;
        readonly colorPointBy: import("@matter/types").OptionalWritableAttribute<number, any>;
        readonly colorPointBIntensity: import("@matter/types").OptionalWritableAttribute<number | null, any>;
        readonly enhancedColorMode: import("@matter/types").Attribute<ColorControl.EnhancedColorMode, any>;
        readonly colorCapabilities: import("@matter/types").Attribute<import("@matter/types").TypeFromPartialBitSchema<{
            hueSaturation: import("@matter/types").BitFlag;
            enhancedHue: import("@matter/types").BitFlag;
            colorLoop: import("@matter/types").BitFlag;
            xy: import("@matter/types").BitFlag;
            colorTemperature: import("@matter/types").BitFlag;
        }>, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly hueSaturation: true;
        };
        readonly component: {
            readonly attributes: {
                readonly currentHue: import("@matter/types").Attribute<number, any>;
                readonly currentSaturation: import("@matter/types").Attribute<number, any>;
            };
            readonly commands: {
                readonly moveToHue: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                    hue: import("@matter/types").FieldType<number>;
                    direction: import("@matter/types").FieldType<ColorControl.Direction>;
                    transitionTime: import("@matter/types").FieldType<number>;
                    optionsMask: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                    optionsOverride: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                }>, void, any>;
                readonly moveHue: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                    moveMode: import("@matter/types").FieldType<ColorControl.MoveMode>;
                    rate: import("@matter/types").FieldType<number>;
                    optionsMask: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                    optionsOverride: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                }>, void, any>;
                readonly stepHue: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                    stepMode: import("@matter/types").FieldType<ColorControl.StepMode>;
                    stepSize: import("@matter/types").FieldType<number>;
                    transitionTime: import("@matter/types").FieldType<number>;
                    optionsMask: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                    optionsOverride: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                }>, void, any>;
                readonly moveToSaturation: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                    saturation: import("@matter/types").FieldType<number>;
                    transitionTime: import("@matter/types").FieldType<number>;
                    optionsMask: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                    optionsOverride: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                }>, void, any>;
                readonly moveSaturation: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                    moveMode: import("@matter/types").FieldType<ColorControl.MoveMode>;
                    rate: import("@matter/types").FieldType<number>;
                    optionsMask: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                    optionsOverride: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                }>, void, any>;
                readonly stepSaturation: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                    stepMode: import("@matter/types").FieldType<ColorControl.StepMode>;
                    stepSize: import("@matter/types").FieldType<number>;
                    transitionTime: import("@matter/types").FieldType<number>;
                    optionsMask: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                    optionsOverride: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                }>, void, any>;
                readonly moveToHueAndSaturation: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                    hue: import("@matter/types").FieldType<number>;
                    saturation: import("@matter/types").FieldType<number>;
                    transitionTime: import("@matter/types").FieldType<number>;
                    optionsMask: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                    optionsOverride: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly xy: true;
        };
        readonly component: {
            readonly attributes: {
                readonly currentX: import("@matter/types").Attribute<number, any>;
                readonly currentY: import("@matter/types").Attribute<number, any>;
            };
            readonly commands: {
                readonly moveToColor: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                    colorX: import("@matter/types").FieldType<number>;
                    colorY: import("@matter/types").FieldType<number>;
                    transitionTime: import("@matter/types").FieldType<number>;
                    optionsMask: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                    optionsOverride: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                }>, void, any>;
                readonly moveColor: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                    rateX: import("@matter/types").FieldType<number>;
                    rateY: import("@matter/types").FieldType<number>;
                    optionsMask: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                    optionsOverride: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                }>, void, any>;
                readonly stepColor: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                    stepX: import("@matter/types").FieldType<number>;
                    stepY: import("@matter/types").FieldType<number>;
                    transitionTime: import("@matter/types").FieldType<number>;
                    optionsMask: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                    optionsOverride: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly colorTemperature: true;
        };
        readonly component: {
            readonly attributes: {
                readonly colorTemperatureMireds: import("@matter/types").Attribute<number, any>;
                readonly colorTempPhysicalMinMireds: import("@matter/types").Attribute<number, any>;
                readonly colorTempPhysicalMaxMireds: import("@matter/types").Attribute<number, any>;
                readonly coupleColorTempToLevelMinMireds: import("@matter/types").OptionalAttribute<number, any>;
                readonly startUpColorTemperatureMireds: import("@matter/types").OptionalWritableAttribute<number | null, any>;
            };
            readonly commands: {
                readonly moveToColorTemperature: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                    colorTemperatureMireds: import("@matter/types").FieldType<number>;
                    transitionTime: import("@matter/types").FieldType<number>;
                    optionsMask: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                    optionsOverride: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                }>, void, any>;
                readonly moveColorTemperature: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                    moveMode: import("@matter/types").FieldType<ColorControl.MoveMode>;
                    rate: import("@matter/types").FieldType<number>;
                    colorTemperatureMinimumMireds: import("@matter/types").FieldType<number>;
                    colorTemperatureMaximumMireds: import("@matter/types").FieldType<number>;
                    optionsMask: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                    optionsOverride: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                }>, void, any>;
                readonly stepColorTemperature: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                    stepMode: import("@matter/types").FieldType<ColorControl.StepMode>;
                    stepSize: import("@matter/types").FieldType<number>;
                    transitionTime: import("@matter/types").FieldType<number>;
                    colorTemperatureMinimumMireds: import("@matter/types").FieldType<number>;
                    colorTemperatureMaximumMireds: import("@matter/types").FieldType<number>;
                    optionsMask: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                    optionsOverride: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly enhancedHue: true;
        };
        readonly component: {
            readonly attributes: {
                readonly enhancedCurrentHue: import("@matter/types").Attribute<number, any>;
            };
            readonly commands: {
                readonly enhancedMoveToHue: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                    enhancedHue: import("@matter/types").FieldType<number>;
                    direction: import("@matter/types").FieldType<ColorControl.Direction>;
                    transitionTime: import("@matter/types").FieldType<number>;
                    optionsMask: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                    optionsOverride: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                }>, void, any>;
                readonly enhancedMoveHue: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                    moveMode: import("@matter/types").FieldType<ColorControl.MoveMode>;
                    rate: import("@matter/types").FieldType<number>;
                    optionsMask: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                    optionsOverride: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                }>, void, any>;
                readonly enhancedStepHue: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                    stepMode: import("@matter/types").FieldType<ColorControl.StepMode>;
                    stepSize: import("@matter/types").FieldType<number>;
                    transitionTime: import("@matter/types").FieldType<number>;
                    optionsMask: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                    optionsOverride: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                }>, void, any>;
                readonly enhancedMoveToHueAndSaturation: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                    enhancedHue: import("@matter/types").FieldType<number>;
                    saturation: import("@matter/types").FieldType<number>;
                    transitionTime: import("@matter/types").FieldType<number>;
                    optionsMask: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                    optionsOverride: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly colorLoop: true;
        };
        readonly component: {
            readonly attributes: {
                readonly colorLoopActive: import("@matter/types").Attribute<ColorControl.ColorLoopActive, any>;
                readonly colorLoopDirection: import("@matter/types").Attribute<ColorControl.ColorLoopDirection, any>;
                readonly colorLoopTime: import("@matter/types").Attribute<number, any>;
                readonly colorLoopStartEnhancedHue: import("@matter/types").Attribute<number, any>;
                readonly colorLoopStoredEnhancedHue: import("@matter/types").Attribute<number, any>;
            };
            readonly commands: {
                readonly colorLoopSet: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                    updateFlags: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        updateAction: import("@matter/types").BitFlag;
                        updateDirection: import("@matter/types").BitFlag;
                        updateTime: import("@matter/types").BitFlag;
                        updateStartHue: import("@matter/types").BitFlag;
                    }>>;
                    action: import("@matter/types").FieldType<ColorControl.ColorLoopAction>;
                    direction: import("@matter/types").FieldType<ColorControl.ColorLoopDirection>;
                    time: import("@matter/types").FieldType<number>;
                    startHue: import("@matter/types").FieldType<number>;
                    optionsMask: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                    optionsOverride: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly hueSaturation: true;
        };
        readonly component: {
            readonly commands: {
                readonly stopMoveStep: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                    optionsMask: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                    optionsOverride: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly xy: true;
        };
        readonly component: {
            readonly commands: {
                readonly stopMoveStep: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                    optionsMask: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                    optionsOverride: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly colorTemperature: true;
        };
        readonly component: {
            readonly commands: {
                readonly stopMoveStep: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                    optionsMask: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                    optionsOverride: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        executeIfOff: import("@matter/types").BitFlag;
                    }>>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly enhancedHue: true;
            readonly hueSaturation: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly colorLoop: true;
            readonly enhancedHue: false;
        };
        readonly component: false;
    }];
}>, readonly [ColorControl.Feature.HueSaturation, ColorControl.Feature.Xy, ColorControl.Feature.ColorTemperature]>, typeof ColorControlServer, import("@matter/main/behaviors/color-control").ColorControlInterface>;
export declare class MatterbridgeColorControlServer extends MatterbridgeColorControlServer_base {
    moveToHue({ optionsMask, optionsOverride, hue, direction, transitionTime }: ColorControl.MoveToHueRequest): MaybePromise;
    moveToSaturation({ optionsMask, optionsOverride, saturation, transitionTime }: ColorControl.MoveToSaturationRequest): MaybePromise;
    moveToHueAndSaturation({ optionsOverride, optionsMask, saturation, hue, transitionTime }: ColorControl.MoveToHueAndSaturationRequest): MaybePromise;
    moveToColor({ optionsMask, optionsOverride, colorX, colorY, transitionTime }: ColorControl.MoveToColorRequest): MaybePromise;
    moveToColorTemperature({ optionsOverride, optionsMask, colorTemperatureMireds, transitionTime }: ColorControl.MoveToColorTemperatureRequest): MaybePromise;
}
declare const MatterbridgeWindowCoveringServer_base: import("@matter/main").ClusterBehavior.Type<import("@matter/types").ClusterComposer.WithFeatures<import("@matter/types").ClusterType.Of<{
    readonly id: 258;
    readonly name: "WindowCovering";
    readonly revision: 5;
    readonly features: {
        readonly lift: import("@matter/types").BitFlag;
        readonly tilt: import("@matter/types").BitFlag;
        readonly positionAwareLift: import("@matter/types").BitFlag;
        readonly absolutePosition: import("@matter/types").BitFlag;
        readonly positionAwareTilt: import("@matter/types").BitFlag;
    };
    readonly attributes: {
        readonly type: import("@matter/types").FixedAttribute<WindowCovering.WindowCoveringType, any>;
        readonly configStatus: import("@matter/types").Attribute<import("@matter/types").TypeFromPartialBitSchema<{
            operational: import("@matter/types").BitFlag;
            onlineReserved: import("@matter/types").BitFlag;
            liftMovementReversed: import("@matter/types").BitFlag;
            liftPositionAware: import("@matter/types").BitFlag;
            tiltPositionAware: import("@matter/types").BitFlag;
            liftEncoderControlled: import("@matter/types").BitFlag;
            tiltEncoderControlled: import("@matter/types").BitFlag;
        }>, any>;
        readonly operationalStatus: import("@matter/types").Attribute<import("@matter/types").TypeFromPartialBitSchema<{
            global: import("@matter/types").BitFieldEnum<WindowCovering.MovementStatus>;
            lift: import("@matter/types").BitFieldEnum<WindowCovering.MovementStatus>;
            tilt: import("@matter/types").BitFieldEnum<WindowCovering.MovementStatus>;
        }>, any>;
        readonly endProductType: import("@matter/types").FixedAttribute<WindowCovering.EndProductType, any>;
        readonly mode: import("@matter/types").WritableAttribute<import("@matter/types").TypeFromPartialBitSchema<{
            motorDirectionReversed: import("@matter/types").BitFlag;
            calibrationMode: import("@matter/types").BitFlag;
            maintenanceMode: import("@matter/types").BitFlag;
            ledFeedback: import("@matter/types").BitFlag;
        }>, any>;
        readonly safetyStatus: import("@matter/types").OptionalAttribute<import("@matter/types").TypeFromPartialBitSchema<{
            remoteLockout: import("@matter/types").BitFlag;
            tamperDetection: import("@matter/types").BitFlag;
            failedCommunication: import("@matter/types").BitFlag;
            positionFailure: import("@matter/types").BitFlag;
            thermalProtection: import("@matter/types").BitFlag;
            obstacleDetected: import("@matter/types").BitFlag;
            power: import("@matter/types").BitFlag;
            stopInput: import("@matter/types").BitFlag;
            motorJammed: import("@matter/types").BitFlag;
            hardwareFailure: import("@matter/types").BitFlag;
            manualOperation: import("@matter/types").BitFlag;
            protection: import("@matter/types").BitFlag;
        }>, any>;
    };
    readonly commands: {
        readonly upOrOpen: import("@matter/types").Command<void, void, any>;
        readonly downOrClose: import("@matter/types").Command<void, void, any>;
        readonly stopMotion: import("@matter/types").Command<void, void, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly lift: true;
            readonly positionAwareLift: true;
            readonly absolutePosition: true;
        };
        readonly component: {
            readonly attributes: {
                readonly physicalClosedLimitLift: import("@matter/types").OptionalFixedAttribute<number, any>;
                readonly currentPositionLift: import("@matter/types").OptionalAttribute<number | null, any>;
                readonly installedOpenLimitLift: import("@matter/types").Attribute<number, any>;
                readonly installedClosedLimitLift: import("@matter/types").Attribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly tilt: true;
            readonly positionAwareTilt: true;
            readonly absolutePosition: true;
        };
        readonly component: {
            readonly attributes: {
                readonly physicalClosedLimitTilt: import("@matter/types").OptionalFixedAttribute<number, any>;
                readonly currentPositionTilt: import("@matter/types").OptionalAttribute<number | null, any>;
                readonly installedOpenLimitTilt: import("@matter/types").Attribute<number, any>;
                readonly installedClosedLimitTilt: import("@matter/types").Attribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly lift: true;
        };
        readonly component: {
            readonly attributes: {
                readonly numberOfActuationsLift: import("@matter/types").OptionalAttribute<number, any>;
            };
            readonly commands: {
                readonly goToLiftPercentage: import("@matter/types").OptionalCommand<import("@matter/types").TypeFromFields<{
                    liftPercent100thsValue: import("@matter/types").FieldType<number>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly tilt: true;
        };
        readonly component: {
            readonly attributes: {
                readonly numberOfActuationsTilt: import("@matter/types").OptionalAttribute<number, any>;
            };
            readonly commands: {
                readonly goToTiltPercentage: import("@matter/types").OptionalCommand<import("@matter/types").TypeFromFields<{
                    tiltPercent100thsValue: import("@matter/types").FieldType<number>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly lift: true;
            readonly positionAwareLift: true;
        };
        readonly component: {
            readonly attributes: {
                readonly currentPositionLiftPercentage: import("@matter/types").OptionalAttribute<number | null, any>;
                readonly targetPositionLiftPercent100ths: import("@matter/types").Attribute<number | null, any>;
                readonly currentPositionLiftPercent100ths: import("@matter/types").Attribute<number | null, any>;
            };
            readonly commands: {
                readonly goToLiftPercentage: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                    liftPercent100thsValue: import("@matter/types").FieldType<number>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly tilt: true;
            readonly positionAwareTilt: true;
        };
        readonly component: {
            readonly attributes: {
                readonly currentPositionTiltPercentage: import("@matter/types").OptionalAttribute<number | null, any>;
                readonly targetPositionTiltPercent100ths: import("@matter/types").Attribute<number | null, any>;
                readonly currentPositionTiltPercent100ths: import("@matter/types").Attribute<number | null, any>;
            };
            readonly commands: {
                readonly goToTiltPercentage: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                    tiltPercent100thsValue: import("@matter/types").FieldType<number>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly lift: true;
            readonly absolutePosition: true;
        };
        readonly component: {
            readonly commands: {
                readonly goToLiftValue: import("@matter/types").OptionalCommand<import("@matter/types").TypeFromFields<{
                    liftValue: import("@matter/types").FieldType<number>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly tilt: true;
            readonly absolutePosition: true;
        };
        readonly component: {
            readonly commands: {
                readonly goToTiltValue: import("@matter/types").OptionalCommand<import("@matter/types").TypeFromFields<{
                    tiltValue: import("@matter/types").FieldType<number>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly positionAwareLift: true;
            readonly lift: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly positionAwareTilt: true;
            readonly tilt: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly lift: false;
            readonly tilt: false;
        };
        readonly component: false;
    }];
}>, readonly [WindowCovering.Feature.Lift, WindowCovering.Feature.PositionAwareLift]>, typeof WindowCoveringServer, import("@matter/main/behaviors/window-covering").WindowCoveringInterface>;
export declare class MatterbridgeWindowCoveringServer extends MatterbridgeWindowCoveringServer_base {
    upOrOpen(): MaybePromise;
    downOrClose(): MaybePromise;
    stopMotion(): MaybePromise;
    goToLiftPercentage({ liftPercent100thsValue }: WindowCovering.GoToLiftPercentageRequest): MaybePromise;
    handleMovement(type: MovementType, reversed: boolean, direction: MovementDirection, targetPercent100ths?: number): Promise<void>;
}
export declare class MatterbridgeDoorLockServer extends DoorLockServer {
    lockDoor(): MaybePromise;
    unlockDoor(): MaybePromise;
}
export declare class MatterbridgeModeSelectServer extends ModeSelectServer {
    changeToMode({ newMode }: ModeSelect.ChangeToModeRequest): MaybePromise;
}
declare const MatterbridgeFanControlServer_base: import("@matter/main").ClusterBehavior.Type<import("@matter/types").ClusterComposer.WithFeatures<FanControl.Cluster, readonly [FanControl.Feature.MultiSpeed, FanControl.Feature.Auto, FanControl.Feature.Step]>, typeof FanControlServer, import("@matter/main/behaviors/fan-control").FanControlInterface>;
export declare class MatterbridgeFanControlServer extends MatterbridgeFanControlServer_base {
    step({ direction, wrap, lowestOff }: FanControl.StepRequest): MaybePromise;
}
declare const MatterbridgeThermostatServer_base: import("@matter/main").ClusterBehavior.Type<import("@matter/types").ClusterComposer.WithFeatures<import("@matter/types").ClusterType.Of<{
    readonly id: 513;
    readonly name: "Thermostat";
    readonly revision: 8;
    readonly features: {
        readonly heating: import("@matter/types").BitFlag;
        readonly cooling: import("@matter/types").BitFlag;
        readonly occupancy: import("@matter/types").BitFlag;
        readonly scheduleConfiguration: import("@matter/types").BitFlag;
        readonly setback: import("@matter/types").BitFlag;
        readonly autoMode: import("@matter/types").BitFlag;
        readonly localTemperatureNotExposed: import("@matter/types").BitFlag;
        readonly matterScheduleConfiguration: import("@matter/types").BitFlag;
        readonly presets: import("@matter/types").BitFlag;
    };
    readonly attributes: {
        readonly localTemperature: import("@matter/types").Attribute<number | null, any>;
        readonly outdoorTemperature: import("@matter/types").OptionalAttribute<number | null, any>;
        readonly hvacSystemTypeConfiguration: import("@matter/types").OptionalWritableAttribute<import("@matter/types").TypeFromPartialBitSchema<{
            coolingStage: import("@matter/types").BitField;
            heatingStage: import("@matter/types").BitField;
            heatingIsHeatPump: import("@matter/types").BitFlag;
            heatingUsesFuel: import("@matter/types").BitFlag;
        }>, any>;
        readonly remoteSensing: import("@matter/types").OptionalWritableAttribute<import("@matter/types").TypeFromPartialBitSchema<{
            localTemperature: import("@matter/types").BitFlag;
            outdoorTemperature: import("@matter/types").BitFlag;
            occupancy: import("@matter/types").BitFlag;
        }>, any>;
        readonly controlSequenceOfOperation: import("@matter/types").WritableAttribute<Thermostat.ControlSequenceOfOperation, any>;
        readonly systemMode: import("@matter/types").WritableAttribute<Thermostat.SystemMode, any>;
        readonly temperatureSetpointHold: import("@matter/types").OptionalWritableAttribute<Thermostat.TemperatureSetpointHold, any>;
        readonly temperatureSetpointHoldDuration: import("@matter/types").OptionalWritableAttribute<number | null, any>;
        readonly thermostatProgrammingOperationMode: import("@matter/types").OptionalWritableAttribute<import("@matter/types").TypeFromPartialBitSchema<{
            scheduleActive: import("@matter/types").BitFlag;
            autoRecovery: import("@matter/types").BitFlag;
            economy: import("@matter/types").BitFlag;
        }>, any>;
        readonly thermostatRunningState: import("@matter/types").OptionalAttribute<import("@matter/types").TypeFromPartialBitSchema<{
            heat: import("@matter/types").BitFlag;
            cool: import("@matter/types").BitFlag;
            fan: import("@matter/types").BitFlag;
            heatStage2: import("@matter/types").BitFlag;
            coolStage2: import("@matter/types").BitFlag;
            fanStage2: import("@matter/types").BitFlag;
            fanStage3: import("@matter/types").BitFlag;
        }>, any>;
        readonly setpointChangeSource: import("@matter/types").OptionalAttribute<Thermostat.SetpointChangeSource, any>;
        readonly setpointChangeAmount: import("@matter/types").OptionalAttribute<number | null, any>;
        readonly setpointChangeSourceTimestamp: import("@matter/types").OptionalAttribute<number, any>;
        readonly emergencyHeatDelta: import("@matter/types").OptionalWritableAttribute<number, any>;
        readonly acType: import("@matter/types").OptionalWritableAttribute<Thermostat.AcType, any>;
        readonly acCapacity: import("@matter/types").OptionalWritableAttribute<number, any>;
        readonly acRefrigerantType: import("@matter/types").OptionalWritableAttribute<Thermostat.AcRefrigerantType, any>;
        readonly acCompressorType: import("@matter/types").OptionalWritableAttribute<Thermostat.AcCompressorType, any>;
        readonly acErrorCode: import("@matter/types").OptionalWritableAttribute<import("@matter/types").TypeFromPartialBitSchema<{
            compressorFail: import("@matter/types").BitFlag;
            roomSensorFail: import("@matter/types").BitFlag;
            outdoorSensorFail: import("@matter/types").BitFlag;
            coilSensorFail: import("@matter/types").BitFlag;
            fanFail: import("@matter/types").BitFlag;
        }>, any>;
        readonly acLouverPosition: import("@matter/types").OptionalWritableAttribute<Thermostat.AcLouverPosition, any>;
        readonly acCoilTemperature: import("@matter/types").OptionalAttribute<number | null, any>;
        readonly acCapacityFormat: import("@matter/types").OptionalWritableAttribute<Thermostat.AcCapacityFormat, any>;
        readonly setpointHoldExpiryTimestamp: import("@matter/types").OptionalAttribute<number | null, any>;
    };
    readonly commands: {
        readonly setpointRaiseLower: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
            mode: import("@matter/types").FieldType<Thermostat.SetpointRaiseLowerMode>;
            amount: import("@matter/types").FieldType<number>;
        }>, void, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly occupancy: true;
        };
        readonly component: {
            readonly attributes: {
                readonly occupancy: import("@matter/types").Attribute<import("@matter/types").TypeFromPartialBitSchema<{
                    occupied: import("@matter/types").BitFlag;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly heating: true;
        };
        readonly component: {
            readonly attributes: {
                readonly absMinHeatSetpointLimit: import("@matter/types").OptionalFixedAttribute<number, any>;
                readonly absMaxHeatSetpointLimit: import("@matter/types").OptionalFixedAttribute<number, any>;
                readonly piHeatingDemand: import("@matter/types").OptionalAttribute<number, any>;
                readonly occupiedHeatingSetpoint: import("@matter/types").WritableAttribute<number, any>;
                readonly minHeatSetpointLimit: import("@matter/types").OptionalWritableAttribute<number, any>;
                readonly maxHeatSetpointLimit: import("@matter/types").OptionalWritableAttribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly cooling: true;
        };
        readonly component: {
            readonly attributes: {
                readonly absMinCoolSetpointLimit: import("@matter/types").OptionalFixedAttribute<number, any>;
                readonly absMaxCoolSetpointLimit: import("@matter/types").OptionalFixedAttribute<number, any>;
                readonly piCoolingDemand: import("@matter/types").OptionalAttribute<number, any>;
                readonly occupiedCoolingSetpoint: import("@matter/types").WritableAttribute<number, any>;
                readonly minCoolSetpointLimit: import("@matter/types").OptionalWritableAttribute<number, any>;
                readonly maxCoolSetpointLimit: import("@matter/types").OptionalWritableAttribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly localTemperatureNotExposed: false;
        };
        readonly component: {
            readonly attributes: {
                readonly localTemperatureCalibration: import("@matter/types").OptionalWritableAttribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly cooling: true;
            readonly occupancy: true;
        };
        readonly component: {
            readonly attributes: {
                readonly unoccupiedCoolingSetpoint: import("@matter/types").WritableAttribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly heating: true;
            readonly occupancy: true;
        };
        readonly component: {
            readonly attributes: {
                readonly unoccupiedHeatingSetpoint: import("@matter/types").WritableAttribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly autoMode: true;
        };
        readonly component: {
            readonly attributes: {
                readonly minSetpointDeadBand: import("@matter/types").WritableAttribute<number, any>;
                readonly thermostatRunningMode: import("@matter/types").OptionalAttribute<Thermostat.ThermostatRunningMode, any>;
            };
        };
    }, {
        readonly flags: {
            readonly scheduleConfiguration: true;
        };
        readonly component: {
            readonly attributes: {
                readonly startOfWeek: import("@matter/types").FixedAttribute<Thermostat.StartOfWeek, any>;
                readonly numberOfWeeklyTransitions: import("@matter/types").FixedAttribute<number, any>;
                readonly numberOfDailyTransitions: import("@matter/types").FixedAttribute<number, any>;
            };
            readonly commands: {
                readonly setWeeklySchedule: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                    numberOfTransitionsForSequence: import("@matter/types").FieldType<number>;
                    dayOfWeekForSequence: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        sunday: import("@matter/types").BitFlag;
                        monday: import("@matter/types").BitFlag;
                        tuesday: import("@matter/types").BitFlag;
                        wednesday: import("@matter/types").BitFlag;
                        thursday: import("@matter/types").BitFlag;
                        friday: import("@matter/types").BitFlag;
                        saturday: import("@matter/types").BitFlag;
                        away: import("@matter/types").BitFlag;
                    }>>;
                    modeForSequence: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        heatSetpointPresent: import("@matter/types").BitFlag;
                        coolSetpointPresent: import("@matter/types").BitFlag;
                    }>>;
                    transitions: import("@matter/types").FieldType<import("@matter/types").TypeFromFields<{
                        transitionTime: import("@matter/types").FieldType<number>;
                        heatSetpoint: import("@matter/types").FieldType<number | null>;
                        coolSetpoint: import("@matter/types").FieldType<number | null>;
                    }>[]>;
                }>, void, any>;
                readonly getWeeklySchedule: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                    daysToReturn: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        sunday: import("@matter/types").BitFlag;
                        monday: import("@matter/types").BitFlag;
                        tuesday: import("@matter/types").BitFlag;
                        wednesday: import("@matter/types").BitFlag;
                        thursday: import("@matter/types").BitFlag;
                        friday: import("@matter/types").BitFlag;
                        saturday: import("@matter/types").BitFlag;
                        away: import("@matter/types").BitFlag;
                    }>>;
                    modeToReturn: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        heatSetpointPresent: import("@matter/types").BitFlag;
                        coolSetpointPresent: import("@matter/types").BitFlag;
                    }>>;
                }>, import("@matter/types").TypeFromFields<{
                    numberOfTransitionsForSequence: import("@matter/types").FieldType<number>;
                    dayOfWeekForSequence: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        sunday: import("@matter/types").BitFlag;
                        monday: import("@matter/types").BitFlag;
                        tuesday: import("@matter/types").BitFlag;
                        wednesday: import("@matter/types").BitFlag;
                        thursday: import("@matter/types").BitFlag;
                        friday: import("@matter/types").BitFlag;
                        saturday: import("@matter/types").BitFlag;
                        away: import("@matter/types").BitFlag;
                    }>>;
                    modeForSequence: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        heatSetpointPresent: import("@matter/types").BitFlag;
                        coolSetpointPresent: import("@matter/types").BitFlag;
                    }>>;
                    transitions: import("@matter/types").FieldType<import("@matter/types").TypeFromFields<{
                        transitionTime: import("@matter/types").FieldType<number>;
                        heatSetpoint: import("@matter/types").FieldType<number | null>;
                        coolSetpoint: import("@matter/types").FieldType<number | null>;
                    }>[]>;
                }>, any>;
                readonly clearWeeklySchedule: import("@matter/types").Command<void, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly setback: true;
        };
        readonly component: {
            readonly attributes: {
                readonly occupiedSetback: import("@matter/types").WritableAttribute<number | null, any>;
                readonly occupiedSetbackMin: import("@matter/types").FixedAttribute<number | null, any>;
                readonly occupiedSetbackMax: import("@matter/types").FixedAttribute<number | null, any>;
            };
        };
    }, {
        readonly flags: {
            readonly setback: true;
            readonly occupancy: true;
        };
        readonly component: {
            readonly attributes: {
                readonly unoccupiedSetback: import("@matter/types").WritableAttribute<number | null, any>;
                readonly unoccupiedSetbackMin: import("@matter/types").FixedAttribute<number | null, any>;
                readonly unoccupiedSetbackMax: import("@matter/types").FixedAttribute<number | null, any>;
            };
        };
    }, {
        readonly flags: {
            readonly presets: true;
        };
        readonly component: {
            readonly attributes: {
                readonly presetTypes: import("@matter/types").FixedAttribute<import("@matter/types").TypeFromFields<{
                    presetScenario: import("@matter/types").FieldType<Thermostat.PresetScenario>;
                    numberOfPresets: import("@matter/types").FieldType<number>;
                    presetTypeFeatures: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        automatic: import("@matter/types").BitFlag;
                        supportsNames: import("@matter/types").BitFlag;
                    }>>;
                }>[], any>;
                readonly numberOfPresets: import("@matter/types").FixedAttribute<number, any>;
                readonly activePresetHandle: import("@matter/types").Attribute<Uint8Array<ArrayBufferLike> | null, any>;
                readonly presets: import("@matter/types").WritableAttribute<import("@matter/types").TypeFromFields<{
                    presetHandle: import("@matter/types").FieldType<Uint8Array<ArrayBufferLike> | null>;
                    presetScenario: import("@matter/types").FieldType<Thermostat.PresetScenario>;
                    name: import("@matter/types").OptionalFieldType<string | null>;
                    coolingSetpoint: import("@matter/types").OptionalFieldType<number>;
                    heatingSetpoint: import("@matter/types").OptionalFieldType<number>;
                    builtIn: import("@matter/types").FieldType<boolean | null>;
                }>[], any>;
            };
            readonly commands: {
                readonly setActivePresetRequest: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                    presetHandle: import("@matter/types").FieldType<Uint8Array<ArrayBufferLike> | null>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly matterScheduleConfiguration: true;
        };
        readonly component: {
            readonly attributes: {
                readonly scheduleTypes: import("@matter/types").FixedAttribute<import("@matter/types").TypeFromFields<{
                    systemMode: import("@matter/types").FieldType<Thermostat.SystemMode>;
                    numberOfSchedules: import("@matter/types").FieldType<number>;
                    scheduleTypeFeatures: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                        supportsPresets: import("@matter/types").BitFlag;
                        supportsSetpoints: import("@matter/types").BitFlag;
                        supportsNames: import("@matter/types").BitFlag;
                        supportsOff: import("@matter/types").BitFlag;
                    }>>;
                }>[], any>;
                readonly numberOfSchedules: import("@matter/types").FixedAttribute<number, any>;
                readonly numberOfScheduleTransitions: import("@matter/types").FixedAttribute<number, any>;
                readonly numberOfScheduleTransitionPerDay: import("@matter/types").FixedAttribute<number | null, any>;
                readonly activeScheduleHandle: import("@matter/types").Attribute<Uint8Array<ArrayBufferLike> | null, any>;
                readonly schedules: import("@matter/types").WritableAttribute<import("@matter/types").TypeFromFields<{
                    scheduleHandle: import("@matter/types").FieldType<Uint8Array<ArrayBufferLike> | null>;
                    systemMode: import("@matter/types").FieldType<Thermostat.SystemMode>;
                    name: import("@matter/types").OptionalFieldType<string>;
                    presetHandle: import("@matter/types").OptionalFieldType<Uint8Array<ArrayBufferLike>>;
                    transitions: import("@matter/types").FieldType<import("@matter/types").TypeFromFields<{
                        dayOfWeek: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                            sunday: import("@matter/types").BitFlag;
                            monday: import("@matter/types").BitFlag;
                            tuesday: import("@matter/types").BitFlag;
                            wednesday: import("@matter/types").BitFlag;
                            thursday: import("@matter/types").BitFlag;
                            friday: import("@matter/types").BitFlag;
                            saturday: import("@matter/types").BitFlag;
                            away: import("@matter/types").BitFlag;
                        }>>;
                        transitionTime: import("@matter/types").FieldType<number>;
                        presetHandle: import("@matter/types").OptionalFieldType<Uint8Array<ArrayBufferLike>>;
                        systemMode: import("@matter/types").OptionalFieldType<Thermostat.SystemMode>;
                        coolingSetpoint: import("@matter/types").OptionalFieldType<number>;
                        heatingSetpoint: import("@matter/types").OptionalFieldType<number>;
                    }>[]>;
                    builtIn: import("@matter/types").FieldType<boolean | null>;
                }>[], any>;
            };
            readonly commands: {
                readonly setActiveScheduleRequest: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                    scheduleHandle: import("@matter/types").FieldType<Uint8Array<ArrayBufferLike>>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly autoMode: true;
            readonly heating: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly autoMode: true;
            readonly cooling: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly heating: false;
            readonly cooling: false;
        };
        readonly component: false;
    }];
}>, readonly [Thermostat.Feature.Cooling, Thermostat.Feature.Heating, Thermostat.Feature.AutoMode]>, typeof ThermostatServer, import("@matter/main/behaviors/thermostat").ThermostatInterface>;
export declare class MatterbridgeThermostatServer extends MatterbridgeThermostatServer_base {
    setpointRaiseLower({ mode, amount }: Thermostat.SetpointRaiseLowerRequest): MaybePromise;
}
declare const MatterbridgeValveConfigurationAndControlServer_base: import("@matter/main").ClusterBehavior.Type<import("@matter/types").ClusterComposer.WithFeatures<ValveConfigurationAndControl.Cluster, readonly [ValveConfigurationAndControl.Feature.Level]>, typeof ValveConfigurationAndControlServer, import("@matter/main/behaviors/valve-configuration-and-control").ValveConfigurationAndControlInterface>;
export declare class MatterbridgeValveConfigurationAndControlServer extends MatterbridgeValveConfigurationAndControlServer_base {
    open({ openDuration, targetLevel }: ValveConfigurationAndControl.OpenRequest): MaybePromise;
    close(): MaybePromise;
}
declare const MatterbridgeSmokeCoAlarmServer_base: import("@matter/main").ClusterBehavior.Type<import("@matter/types").ClusterComposer.WithFeatures<import("@matter/types").ClusterType.Of<{
    readonly id: 92;
    readonly name: "SmokeCoAlarm";
    readonly revision: 1;
    readonly features: {
        readonly smokeAlarm: import("@matter/types").BitFlag;
        readonly coAlarm: import("@matter/types").BitFlag;
    };
    readonly attributes: {
        readonly expressedState: import("@matter/types").Attribute<SmokeCoAlarm.ExpressedState, any>;
        readonly batteryAlert: import("@matter/types").Attribute<SmokeCoAlarm.AlarmState, any>;
        readonly deviceMuted: import("@matter/types").OptionalAttribute<SmokeCoAlarm.MuteState, any>;
        readonly testInProgress: import("@matter/types").Attribute<boolean, any>;
        readonly hardwareFaultAlert: import("@matter/types").Attribute<boolean, any>;
        readonly endOfServiceAlert: import("@matter/types").Attribute<SmokeCoAlarm.EndOfService, any>;
        readonly interconnectSmokeAlarm: import("@matter/types").OptionalAttribute<SmokeCoAlarm.AlarmState, any>;
        readonly interconnectCoAlarm: import("@matter/types").OptionalAttribute<SmokeCoAlarm.AlarmState, any>;
        readonly expiryDate: import("@matter/types").OptionalFixedAttribute<number, any>;
    };
    readonly commands: {
        readonly selfTestRequest: import("@matter/types").OptionalCommand<void, void, any>;
    };
    readonly events: {
        readonly lowBattery: import("@matter/types").Event<import("@matter/types").TypeFromFields<{
            alarmSeverityLevel: import("@matter/types").FieldType<SmokeCoAlarm.AlarmState>;
        }>, any>;
        readonly hardwareFault: import("@matter/types").Event<void, any>;
        readonly endOfService: import("@matter/types").Event<void, any>;
        readonly selfTestComplete: import("@matter/types").Event<void, any>;
        readonly alarmMuted: import("@matter/types").OptionalEvent<void, any>;
        readonly muteEnded: import("@matter/types").OptionalEvent<void, any>;
        readonly allClear: import("@matter/types").Event<void, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly smokeAlarm: true;
        };
        readonly component: {
            readonly attributes: {
                readonly smokeState: import("@matter/types").Attribute<SmokeCoAlarm.AlarmState, any>;
                readonly contaminationState: import("@matter/types").OptionalAttribute<SmokeCoAlarm.ContaminationState, any>;
                readonly smokeSensitivityLevel: import("@matter/types").OptionalWritableAttribute<SmokeCoAlarm.Sensitivity, any>;
            };
            readonly events: {
                readonly smokeAlarm: import("@matter/types").Event<import("@matter/types").TypeFromFields<{
                    alarmSeverityLevel: import("@matter/types").FieldType<SmokeCoAlarm.AlarmState>;
                }>, any>;
                readonly interconnectSmokeAlarm: import("@matter/types").OptionalEvent<import("@matter/types").TypeFromFields<{
                    alarmSeverityLevel: import("@matter/types").FieldType<SmokeCoAlarm.AlarmState>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly coAlarm: true;
        };
        readonly component: {
            readonly attributes: {
                readonly coState: import("@matter/types").Attribute<SmokeCoAlarm.AlarmState, any>;
            };
            readonly events: {
                readonly coAlarm: import("@matter/types").Event<import("@matter/types").TypeFromFields<{
                    alarmSeverityLevel: import("@matter/types").FieldType<SmokeCoAlarm.AlarmState>;
                }>, any>;
                readonly interconnectCoAlarm: import("@matter/types").OptionalEvent<import("@matter/types").TypeFromFields<{
                    alarmSeverityLevel: import("@matter/types").FieldType<SmokeCoAlarm.AlarmState>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly smokeAlarm: false;
            readonly coAlarm: false;
        };
        readonly component: false;
    }];
}>, readonly [SmokeCoAlarm.Feature.SmokeAlarm, SmokeCoAlarm.Feature.CoAlarm]>, typeof SmokeCoAlarmServer, import("@matter/main/behaviors/smoke-co-alarm").SmokeCoAlarmInterface>;
export declare class MatterbridgeSmokeCoAlarmServer extends MatterbridgeSmokeCoAlarmServer_base {
    selfTestRequest(): MaybePromise;
}
declare const MatterbridgeBooleanStateConfigurationServer_base: import("@matter/main").ClusterBehavior.Type<import("@matter/types").ClusterComposer.WithFeatures<BooleanStateConfiguration.Cluster, readonly [BooleanStateConfiguration.Feature.Visual, BooleanStateConfiguration.Feature.Audible, BooleanStateConfiguration.Feature.SensitivityLevel]>, typeof BooleanStateConfigurationServer, import("@matter/main/behaviors/boolean-state-configuration").BooleanStateConfigurationInterface>;
export declare class MatterbridgeBooleanStateConfigurationServer extends MatterbridgeBooleanStateConfigurationServer_base {
    enableDisableAlarm({ alarmsToEnableDisable }: BooleanStateConfiguration.EnableDisableAlarmRequest): MaybePromise;
}
export declare class MatterbridgeSwitchServer extends SwitchServer {
    initialize(): void;
}
export declare class MatterbridgeOperationalStateServer extends OperationalStateServer {
    initialize(): MaybePromise;
    pause(): MaybePromise<OperationalState.OperationalCommandResponse>;
    stop(): MaybePromise<OperationalState.OperationalCommandResponse>;
    start(): MaybePromise<OperationalState.OperationalCommandResponse>;
    resume(): MaybePromise<OperationalState.OperationalCommandResponse>;
}
/** ********************************************* RVC  **********************************************************/
export declare class MatterbridgeRvcRunModeServer extends RvcRunModeServer {
    changeToMode({ newMode }: ModeBase.ChangeToModeRequest): MaybePromise<ModeBase.ChangeToModeResponse>;
}
export declare class MatterbridgeRvcCleanModeServer extends RvcCleanModeServer {
    changeToMode({ newMode }: ModeBase.ChangeToModeRequest): MaybePromise<ModeBase.ChangeToModeResponse>;
}
export declare class MatterbridgeRvcOperationalStateServer extends RvcOperationalStateServer {
    pause(): MaybePromise<OperationalState.OperationalCommandResponse>;
    resume(): MaybePromise<OperationalState.OperationalCommandResponse>;
    goHome(): MaybePromise<OperationalState.OperationalCommandResponse>;
}
export declare class MatterbridgeServiceAreaServer extends ServiceAreaServer {
    selectAreas({ newAreas }: ServiceArea.SelectAreasRequest): MaybePromise<ServiceArea.SelectAreasResponse>;
}
export {};
//# sourceMappingURL=matterbridgeBehaviors.d.ts.map