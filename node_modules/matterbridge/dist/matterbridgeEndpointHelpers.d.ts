import { Behavior, ClusterId, Endpoint } from '@matter/main';
import { ClusterType } from '@matter/main/types';
import { PowerSource } from '@matter/main/clusters/power-source';
import { OnOff } from '@matter/main/clusters/on-off';
import { LevelControl } from '@matter/main/clusters/level-control';
import { WindowCovering } from '@matter/main/clusters/window-covering';
import { Thermostat } from '@matter/main/clusters/thermostat';
import { ValveConfigurationAndControl } from '@matter/main/clusters/valve-configuration-and-control';
import { PumpConfigurationAndControl } from '@matter/main/clusters/pump-configuration-and-control';
import { SmokeCoAlarm } from '@matter/main/clusters/smoke-co-alarm';
import { BooleanState } from '@matter/main/clusters/boolean-state';
import { ElectricalPowerMeasurement } from '@matter/main/clusters/electrical-power-measurement';
import { AirQuality } from '@matter/main/clusters/air-quality';
import { OperationalState } from '@matter/main/clusters/operational-state';
import { PowerSourceServer } from '@matter/main/behaviors/power-source';
import { UserLabelServer } from '@matter/main/behaviors/user-label';
import { FixedLabelServer } from '@matter/main/behaviors/fixed-label';
import { BasicInformationServer } from '@matter/main/behaviors/basic-information';
import { BridgedDeviceBasicInformationServer } from '@matter/main/behaviors/bridged-device-basic-information';
import { GroupsServer } from '@matter/main/behaviors/groups';
import { PumpConfigurationAndControlServer } from '@matter/main/behaviors/pump-configuration-and-control';
import { SwitchServer } from '@matter/main/behaviors/switch';
import { BooleanStateServer } from '@matter/main/behaviors/boolean-state';
import { PowerTopologyServer } from '@matter/main/behaviors/power-topology';
import { ElectricalPowerMeasurementServer } from '@matter/main/behaviors/electrical-power-measurement';
import { ElectricalEnergyMeasurementServer } from '@matter/main/behaviors/electrical-energy-measurement';
import { TemperatureMeasurementServer } from '@matter/main/behaviors/temperature-measurement';
import { RelativeHumidityMeasurementServer } from '@matter/main/behaviors/relative-humidity-measurement';
import { PressureMeasurementServer } from '@matter/main/behaviors/pressure-measurement';
import { FlowMeasurementServer } from '@matter/main/behaviors/flow-measurement';
import { IlluminanceMeasurementServer } from '@matter/main/behaviors/illuminance-measurement';
import { OccupancySensingServer } from '@matter/main/behaviors/occupancy-sensing';
import { AirQualityServer } from '@matter/main/behaviors/air-quality';
import { CarbonMonoxideConcentrationMeasurementServer } from '@matter/main/behaviors/carbon-monoxide-concentration-measurement';
import { CarbonDioxideConcentrationMeasurementServer } from '@matter/main/behaviors/carbon-dioxide-concentration-measurement';
import { NitrogenDioxideConcentrationMeasurementServer } from '@matter/main/behaviors/nitrogen-dioxide-concentration-measurement';
import { OzoneConcentrationMeasurementServer } from '@matter/main/behaviors/ozone-concentration-measurement';
import { FormaldehydeConcentrationMeasurementServer } from '@matter/main/behaviors/formaldehyde-concentration-measurement';
import { Pm1ConcentrationMeasurementServer } from '@matter/main/behaviors/pm1-concentration-measurement';
import { Pm25ConcentrationMeasurementServer } from '@matter/main/behaviors/pm25-concentration-measurement';
import { Pm10ConcentrationMeasurementServer } from '@matter/main/behaviors/pm10-concentration-measurement';
import { RadonConcentrationMeasurementServer } from '@matter/main/behaviors/radon-concentration-measurement';
import { TotalVolatileOrganicCompoundsConcentrationMeasurementServer } from '@matter/main/behaviors/total-volatile-organic-compounds-concentration-measurement';
import { AnsiLogger } from 'node-ansi-logger';
import { MatterbridgeEndpoint, MatterbridgeEndpointCommands } from './matterbridgeEndpoint.js';
import { MatterbridgeIdentifyServer, MatterbridgeOnOffServer, MatterbridgeLevelControlServer, MatterbridgeColorControlServer, MatterbridgeWindowCoveringServer, MatterbridgeThermostatServer, MatterbridgeFanControlServer, MatterbridgeDoorLockServer, MatterbridgeModeSelectServer, MatterbridgeValveConfigurationAndControlServer, MatterbridgeSmokeCoAlarmServer, MatterbridgeBooleanStateConfigurationServer, MatterbridgeOperationalStateServer } from './matterbridgeBehaviors.js';
export declare function capitalizeFirstLetter(name: string): string;
export declare function lowercaseFirstLetter(name: string): string;
export declare function checkNotLatinCharacters(deviceName: string): boolean;
export declare function generateUniqueId(deviceName: string): string;
export declare function createUniqueId(param1: string, param2: string, param3: string, param4: string): string;
export declare function getBehaviourTypesFromClusterServerIds(clusterServerList: ClusterId[]): Behavior.Type[];
export declare function getBehaviourTypesFromClusterClientIds(clusterClientList: ClusterId[]): Behavior.Type[];
export declare function getBehaviourTypeFromClusterServerId(clusterId: ClusterId): typeof MatterbridgeIdentifyServer | typeof MatterbridgeColorControlServer | typeof MatterbridgeDoorLockServer | typeof MatterbridgeModeSelectServer | typeof MatterbridgeFanControlServer | typeof MatterbridgeBooleanStateConfigurationServer | typeof MatterbridgeOperationalStateServer | import("@matter/main").ClusterBehavior.Type<import("@matter/main/types").ClusterComposer.WithFeatures<ClusterType.Of<{
    readonly id: 47;
    readonly name: "PowerSource";
    readonly revision: 3;
    readonly features: {
        readonly wired: import("@matter/main/types").BitFlag;
        readonly battery: import("@matter/main/types").BitFlag;
        readonly rechargeable: import("@matter/main/types").BitFlag;
        readonly replaceable: import("@matter/main/types").BitFlag;
    };
    readonly attributes: {
        readonly status: import("@matter/main/types").Attribute<PowerSource.PowerSourceStatus, any>;
        readonly order: import("@matter/main/types").Attribute<number, any>;
        readonly description: import("@matter/main/types").FixedAttribute<string, any>;
        readonly endpointList: import("@matter/main/types").Attribute<import("@matter/main").EndpointNumber[], any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly wired: true;
        };
        readonly component: {
            readonly attributes: {
                readonly wiredAssessedInputVoltage: import("@matter/main/types").OptionalAttribute<number | null, any>;
                readonly wiredAssessedInputFrequency: import("@matter/main/types").OptionalAttribute<number | null, any>;
                readonly wiredCurrentType: import("@matter/main/types").FixedAttribute<PowerSource.WiredCurrentType, any>;
                readonly wiredAssessedCurrent: import("@matter/main/types").OptionalAttribute<number | null, any>;
                readonly wiredNominalVoltage: import("@matter/main/types").OptionalFixedAttribute<number, any>;
                readonly wiredMaximumCurrent: import("@matter/main/types").OptionalFixedAttribute<number, any>;
                readonly wiredPresent: import("@matter/main/types").OptionalAttribute<boolean, any>;
                readonly activeWiredFaults: import("@matter/main/types").OptionalAttribute<PowerSource.WiredFault[], any>;
            };
            readonly events: {
                readonly wiredFaultChange: import("@matter/main/types").OptionalEvent<import("@matter/main/types").TypeFromFields<{
                    current: import("@matter/main/types").FieldType<PowerSource.WiredFault[]>;
                    previous: import("@matter/main/types").FieldType<PowerSource.WiredFault[]>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly battery: true;
        };
        readonly component: {
            readonly attributes: {
                readonly batVoltage: import("@matter/main/types").OptionalAttribute<number | null, any>;
                readonly batPercentRemaining: import("@matter/main/types").OptionalAttribute<number | null, any>;
                readonly batTimeRemaining: import("@matter/main/types").OptionalAttribute<number | null, any>;
                readonly batChargeLevel: import("@matter/main/types").Attribute<PowerSource.BatChargeLevel, any>;
                readonly batReplacementNeeded: import("@matter/main/types").Attribute<boolean, any>;
                readonly batReplaceability: import("@matter/main/types").FixedAttribute<PowerSource.BatReplaceability, any>;
                readonly batPresent: import("@matter/main/types").OptionalAttribute<boolean, any>;
                readonly activeBatFaults: import("@matter/main/types").OptionalAttribute<PowerSource.BatFault[], any>;
            };
            readonly events: {
                readonly batFaultChange: import("@matter/main/types").OptionalEvent<import("@matter/main/types").TypeFromFields<{
                    current: import("@matter/main/types").FieldType<PowerSource.BatFault[]>;
                    previous: import("@matter/main/types").FieldType<PowerSource.BatFault[]>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly replaceable: true;
        };
        readonly component: {
            readonly attributes: {
                readonly batReplacementDescription: import("@matter/main/types").FixedAttribute<string, any>;
                readonly batCommonDesignation: import("@matter/main/types").OptionalFixedAttribute<PowerSource.BatCommonDesignation, any>;
                readonly batAnsiDesignation: import("@matter/main/types").OptionalFixedAttribute<string, any>;
                readonly batIecDesignation: import("@matter/main/types").OptionalFixedAttribute<string, any>;
                readonly batApprovedChemistry: import("@matter/main/types").OptionalFixedAttribute<PowerSource.BatApprovedChemistry, any>;
                readonly batQuantity: import("@matter/main/types").FixedAttribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly replaceable: true;
        };
        readonly component: {
            readonly attributes: {
                readonly batCapacity: import("@matter/main/types").OptionalFixedAttribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly rechargeable: true;
        };
        readonly component: {
            readonly attributes: {
                readonly batCapacity: import("@matter/main/types").OptionalFixedAttribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly rechargeable: true;
        };
        readonly component: {
            readonly attributes: {
                readonly batChargeState: import("@matter/main/types").Attribute<PowerSource.BatChargeState, any>;
                readonly batTimeToFullCharge: import("@matter/main/types").OptionalAttribute<number | null, any>;
                readonly batFunctionalWhileCharging: import("@matter/main/types").Attribute<boolean, any>;
                readonly batChargingCurrent: import("@matter/main/types").OptionalAttribute<number | null, any>;
                readonly activeBatChargeFaults: import("@matter/main/types").OptionalAttribute<PowerSource.BatChargeFault[], any>;
            };
            readonly events: {
                readonly batChargeFaultChange: import("@matter/main/types").OptionalEvent<import("@matter/main/types").TypeFromFields<{
                    current: import("@matter/main/types").FieldType<PowerSource.BatChargeFault[]>;
                    previous: import("@matter/main/types").FieldType<PowerSource.BatChargeFault[]>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly rechargeable: true;
            readonly battery: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly replaceable: true;
            readonly battery: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly wired: true;
            readonly battery: true;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly wired: false;
            readonly battery: false;
        };
        readonly component: false;
    }];
}>, readonly [PowerSource.Feature.Wired]>, typeof PowerSourceServer, {
    components: never[];
}> | typeof UserLabelServer | typeof FixedLabelServer | typeof BasicInformationServer | typeof BridgedDeviceBasicInformationServer | typeof GroupsServer | import("@matter/main").ClusterBehavior.Type<import("@matter/main/types").ClusterComposer.WithFeatures<import("@matter/main/types").ClusterComposer.WithFeatures<import("@matter/main/types").ClusterComposer.WithFeatures<OnOff.Cluster, readonly [OnOff.Feature.Lighting]>, readonly []>, readonly ["Lighting"]>, typeof MatterbridgeOnOffServer, import("@matter/node/behaviors").OnOffInterface> | import("@matter/main").ClusterBehavior.Type<import("@matter/main/types").ClusterComposer.WithFeatures<ClusterType.Of<{
    readonly id: 8;
    readonly name: "LevelControl";
    readonly revision: 6;
    readonly features: {
        readonly onOff: import("@matter/main/types").BitFlag;
        readonly lighting: import("@matter/main/types").BitFlag;
        readonly frequency: import("@matter/main/types").BitFlag;
    };
    readonly attributes: {
        readonly currentLevel: import("@matter/main/types").Attribute<number | null, any>;
        readonly maxLevel: import("@matter/main/types").OptionalAttribute<number, any>;
        readonly options: import("@matter/main/types").WritableAttribute<import("@matter/main/types").TypeFromPartialBitSchema<{
            executeIfOff: import("@matter/main/types").BitFlag;
            coupleColorTempToLevel: import("@matter/main/types").BitFlag;
        }>, any>;
        readonly onOffTransitionTime: import("@matter/main/types").OptionalWritableAttribute<number, any>;
        readonly onLevel: import("@matter/main/types").WritableAttribute<number | null, any>;
        readonly onTransitionTime: import("@matter/main/types").OptionalWritableAttribute<number | null, any>;
        readonly offTransitionTime: import("@matter/main/types").OptionalWritableAttribute<number | null, any>;
        readonly defaultMoveRate: import("@matter/main/types").OptionalWritableAttribute<number | null, any>;
    };
    readonly commands: {
        readonly moveToLevel: import("@matter/main/types").Command<import("@matter/main/types").TypeFromFields<{
            level: import("@matter/main/types").FieldType<number>;
            transitionTime: import("@matter/main/types").FieldType<number | null>;
            optionsMask: import("@matter/main/types").FieldType<import("@matter/main/types").TypeFromPartialBitSchema<{
                executeIfOff: import("@matter/main/types").BitFlag;
                coupleColorTempToLevel: import("@matter/main/types").BitFlag;
            }>>;
            optionsOverride: import("@matter/main/types").FieldType<import("@matter/main/types").TypeFromPartialBitSchema<{
                executeIfOff: import("@matter/main/types").BitFlag;
                coupleColorTempToLevel: import("@matter/main/types").BitFlag;
            }>>;
        }>, void, any>;
        readonly move: import("@matter/main/types").Command<import("@matter/main/types").TypeFromFields<{
            moveMode: import("@matter/main/types").FieldType<LevelControl.MoveMode>;
            rate: import("@matter/main/types").FieldType<number | null>;
            optionsMask: import("@matter/main/types").FieldType<import("@matter/main/types").TypeFromPartialBitSchema<{
                executeIfOff: import("@matter/main/types").BitFlag;
                coupleColorTempToLevel: import("@matter/main/types").BitFlag;
            }>>;
            optionsOverride: import("@matter/main/types").FieldType<import("@matter/main/types").TypeFromPartialBitSchema<{
                executeIfOff: import("@matter/main/types").BitFlag;
                coupleColorTempToLevel: import("@matter/main/types").BitFlag;
            }>>;
        }>, void, any>;
        readonly step: import("@matter/main/types").Command<import("@matter/main/types").TypeFromFields<{
            stepMode: import("@matter/main/types").FieldType<LevelControl.StepMode>;
            stepSize: import("@matter/main/types").FieldType<number>;
            transitionTime: import("@matter/main/types").FieldType<number | null>;
            optionsMask: import("@matter/main/types").FieldType<import("@matter/main/types").TypeFromPartialBitSchema<{
                executeIfOff: import("@matter/main/types").BitFlag;
                coupleColorTempToLevel: import("@matter/main/types").BitFlag;
            }>>;
            optionsOverride: import("@matter/main/types").FieldType<import("@matter/main/types").TypeFromPartialBitSchema<{
                executeIfOff: import("@matter/main/types").BitFlag;
                coupleColorTempToLevel: import("@matter/main/types").BitFlag;
            }>>;
        }>, void, any>;
        readonly stop: import("@matter/main/types").Command<import("@matter/main/types").TypeFromFields<{
            optionsMask: import("@matter/main/types").FieldType<import("@matter/main/types").TypeFromPartialBitSchema<{
                executeIfOff: import("@matter/main/types").BitFlag;
                coupleColorTempToLevel: import("@matter/main/types").BitFlag;
            }>>;
            optionsOverride: import("@matter/main/types").FieldType<import("@matter/main/types").TypeFromPartialBitSchema<{
                executeIfOff: import("@matter/main/types").BitFlag;
                coupleColorTempToLevel: import("@matter/main/types").BitFlag;
            }>>;
        }>, void, any>;
        readonly moveToLevelWithOnOff: import("@matter/main/types").Command<import("@matter/main/types").TypeFromFields<{
            level: import("@matter/main/types").FieldType<number>;
            transitionTime: import("@matter/main/types").FieldType<number | null>;
            optionsMask: import("@matter/main/types").FieldType<import("@matter/main/types").TypeFromPartialBitSchema<{
                executeIfOff: import("@matter/main/types").BitFlag;
                coupleColorTempToLevel: import("@matter/main/types").BitFlag;
            }>>;
            optionsOverride: import("@matter/main/types").FieldType<import("@matter/main/types").TypeFromPartialBitSchema<{
                executeIfOff: import("@matter/main/types").BitFlag;
                coupleColorTempToLevel: import("@matter/main/types").BitFlag;
            }>>;
        }>, void, any>;
        readonly moveWithOnOff: import("@matter/main/types").Command<import("@matter/main/types").TypeFromFields<{
            moveMode: import("@matter/main/types").FieldType<LevelControl.MoveMode>;
            rate: import("@matter/main/types").FieldType<number | null>;
            optionsMask: import("@matter/main/types").FieldType<import("@matter/main/types").TypeFromPartialBitSchema<{
                executeIfOff: import("@matter/main/types").BitFlag;
                coupleColorTempToLevel: import("@matter/main/types").BitFlag;
            }>>;
            optionsOverride: import("@matter/main/types").FieldType<import("@matter/main/types").TypeFromPartialBitSchema<{
                executeIfOff: import("@matter/main/types").BitFlag;
                coupleColorTempToLevel: import("@matter/main/types").BitFlag;
            }>>;
        }>, void, any>;
        readonly stepWithOnOff: import("@matter/main/types").Command<import("@matter/main/types").TypeFromFields<{
            stepMode: import("@matter/main/types").FieldType<LevelControl.StepMode>;
            stepSize: import("@matter/main/types").FieldType<number>;
            transitionTime: import("@matter/main/types").FieldType<number | null>;
            optionsMask: import("@matter/main/types").FieldType<import("@matter/main/types").TypeFromPartialBitSchema<{
                executeIfOff: import("@matter/main/types").BitFlag;
                coupleColorTempToLevel: import("@matter/main/types").BitFlag;
            }>>;
            optionsOverride: import("@matter/main/types").FieldType<import("@matter/main/types").TypeFromPartialBitSchema<{
                executeIfOff: import("@matter/main/types").BitFlag;
                coupleColorTempToLevel: import("@matter/main/types").BitFlag;
            }>>;
        }>, void, any>;
        readonly stopWithOnOff: import("@matter/main/types").Command<import("@matter/main/types").TypeFromFields<{
            optionsMask: import("@matter/main/types").FieldType<import("@matter/main/types").TypeFromPartialBitSchema<{
                executeIfOff: import("@matter/main/types").BitFlag;
                coupleColorTempToLevel: import("@matter/main/types").BitFlag;
            }>>;
            optionsOverride: import("@matter/main/types").FieldType<import("@matter/main/types").TypeFromPartialBitSchema<{
                executeIfOff: import("@matter/main/types").BitFlag;
                coupleColorTempToLevel: import("@matter/main/types").BitFlag;
            }>>;
        }>, void, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly lighting: true;
        };
        readonly component: {
            readonly attributes: {
                readonly remainingTime: import("@matter/main/types").Attribute<number, any>;
                readonly minLevel: import("@matter/main/types").OptionalAttribute<number, any>;
                readonly startUpCurrentLevel: import("@matter/main/types").WritableAttribute<number | null, any>;
            };
        };
    }, {
        readonly flags: {
            readonly lighting: false;
        };
        readonly component: {
            readonly attributes: {
                readonly minLevel: import("@matter/main/types").OptionalAttribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly frequency: true;
        };
        readonly component: {
            readonly attributes: {
                readonly currentFrequency: import("@matter/main/types").Attribute<number, any>;
                readonly minFrequency: import("@matter/main/types").Attribute<number, any>;
                readonly maxFrequency: import("@matter/main/types").Attribute<number, any>;
            };
            readonly commands: {
                readonly moveToClosestFrequency: import("@matter/main/types").Command<import("@matter/main/types").TypeFromFields<{
                    frequency: import("@matter/main/types").FieldType<number>;
                }>, void, any>;
            };
        };
    }];
}>, readonly ["OnOff", "Lighting"]>, typeof MatterbridgeLevelControlServer, import("@matter/node/behaviors").LevelControlInterface> | import("@matter/main").ClusterBehavior.Type<import("@matter/main/types").ClusterComposer.WithFeatures<import("@matter/main/types").ClusterComposer.WithFeatures<ClusterType.Of<{
    readonly id: 258;
    readonly name: "WindowCovering";
    readonly revision: 5;
    readonly features: {
        readonly lift: import("@matter/main/types").BitFlag;
        readonly tilt: import("@matter/main/types").BitFlag;
        readonly positionAwareLift: import("@matter/main/types").BitFlag;
        readonly absolutePosition: import("@matter/main/types").BitFlag;
        readonly positionAwareTilt: import("@matter/main/types").BitFlag;
    };
    readonly attributes: {
        readonly type: import("@matter/main/types").FixedAttribute<WindowCovering.WindowCoveringType, any>;
        readonly configStatus: import("@matter/main/types").Attribute<import("@matter/main/types").TypeFromPartialBitSchema<{
            operational: import("@matter/main/types").BitFlag;
            onlineReserved: import("@matter/main/types").BitFlag;
            liftMovementReversed: import("@matter/main/types").BitFlag;
            liftPositionAware: import("@matter/main/types").BitFlag;
            tiltPositionAware: import("@matter/main/types").BitFlag;
            liftEncoderControlled: import("@matter/main/types").BitFlag;
            tiltEncoderControlled: import("@matter/main/types").BitFlag;
        }>, any>;
        readonly operationalStatus: import("@matter/main/types").Attribute<import("@matter/main/types").TypeFromPartialBitSchema<{
            global: import("@matter/main/types").BitFieldEnum<WindowCovering.MovementStatus>;
            lift: import("@matter/main/types").BitFieldEnum<WindowCovering.MovementStatus>;
            tilt: import("@matter/main/types").BitFieldEnum<WindowCovering.MovementStatus>;
        }>, any>;
        readonly endProductType: import("@matter/main/types").FixedAttribute<WindowCovering.EndProductType, any>;
        readonly mode: import("@matter/main/types").WritableAttribute<import("@matter/main/types").TypeFromPartialBitSchema<{
            motorDirectionReversed: import("@matter/main/types").BitFlag;
            calibrationMode: import("@matter/main/types").BitFlag;
            maintenanceMode: import("@matter/main/types").BitFlag;
            ledFeedback: import("@matter/main/types").BitFlag;
        }>, any>;
        readonly safetyStatus: import("@matter/main/types").OptionalAttribute<import("@matter/main/types").TypeFromPartialBitSchema<{
            remoteLockout: import("@matter/main/types").BitFlag;
            tamperDetection: import("@matter/main/types").BitFlag;
            failedCommunication: import("@matter/main/types").BitFlag;
            positionFailure: import("@matter/main/types").BitFlag;
            thermalProtection: import("@matter/main/types").BitFlag;
            obstacleDetected: import("@matter/main/types").BitFlag;
            power: import("@matter/main/types").BitFlag;
            stopInput: import("@matter/main/types").BitFlag;
            motorJammed: import("@matter/main/types").BitFlag;
            hardwareFailure: import("@matter/main/types").BitFlag;
            manualOperation: import("@matter/main/types").BitFlag;
            protection: import("@matter/main/types").BitFlag;
        }>, any>;
    };
    readonly commands: {
        readonly upOrOpen: import("@matter/main/types").Command<void, void, any>;
        readonly downOrClose: import("@matter/main/types").Command<void, void, any>;
        readonly stopMotion: import("@matter/main/types").Command<void, void, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly lift: true;
            readonly positionAwareLift: true;
            readonly absolutePosition: true;
        };
        readonly component: {
            readonly attributes: {
                readonly physicalClosedLimitLift: import("@matter/main/types").OptionalFixedAttribute<number, any>;
                readonly currentPositionLift: import("@matter/main/types").OptionalAttribute<number | null, any>;
                readonly installedOpenLimitLift: import("@matter/main/types").Attribute<number, any>;
                readonly installedClosedLimitLift: import("@matter/main/types").Attribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly tilt: true;
            readonly positionAwareTilt: true;
            readonly absolutePosition: true;
        };
        readonly component: {
            readonly attributes: {
                readonly physicalClosedLimitTilt: import("@matter/main/types").OptionalFixedAttribute<number, any>;
                readonly currentPositionTilt: import("@matter/main/types").OptionalAttribute<number | null, any>;
                readonly installedOpenLimitTilt: import("@matter/main/types").Attribute<number, any>;
                readonly installedClosedLimitTilt: import("@matter/main/types").Attribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly lift: true;
        };
        readonly component: {
            readonly attributes: {
                readonly numberOfActuationsLift: import("@matter/main/types").OptionalAttribute<number, any>;
            };
            readonly commands: {
                readonly goToLiftPercentage: import("@matter/main/types").OptionalCommand<import("@matter/main/types").TypeFromFields<{
                    liftPercent100thsValue: import("@matter/main/types").FieldType<number>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly tilt: true;
        };
        readonly component: {
            readonly attributes: {
                readonly numberOfActuationsTilt: import("@matter/main/types").OptionalAttribute<number, any>;
            };
            readonly commands: {
                readonly goToTiltPercentage: import("@matter/main/types").OptionalCommand<import("@matter/main/types").TypeFromFields<{
                    tiltPercent100thsValue: import("@matter/main/types").FieldType<number>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly lift: true;
            readonly positionAwareLift: true;
        };
        readonly component: {
            readonly attributes: {
                readonly currentPositionLiftPercentage: import("@matter/main/types").OptionalAttribute<number | null, any>;
                readonly targetPositionLiftPercent100ths: import("@matter/main/types").Attribute<number | null, any>;
                readonly currentPositionLiftPercent100ths: import("@matter/main/types").Attribute<number | null, any>;
            };
            readonly commands: {
                readonly goToLiftPercentage: import("@matter/main/types").Command<import("@matter/main/types").TypeFromFields<{
                    liftPercent100thsValue: import("@matter/main/types").FieldType<number>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly tilt: true;
            readonly positionAwareTilt: true;
        };
        readonly component: {
            readonly attributes: {
                readonly currentPositionTiltPercentage: import("@matter/main/types").OptionalAttribute<number | null, any>;
                readonly targetPositionTiltPercent100ths: import("@matter/main/types").Attribute<number | null, any>;
                readonly currentPositionTiltPercent100ths: import("@matter/main/types").Attribute<number | null, any>;
            };
            readonly commands: {
                readonly goToTiltPercentage: import("@matter/main/types").Command<import("@matter/main/types").TypeFromFields<{
                    tiltPercent100thsValue: import("@matter/main/types").FieldType<number>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly lift: true;
            readonly absolutePosition: true;
        };
        readonly component: {
            readonly commands: {
                readonly goToLiftValue: import("@matter/main/types").OptionalCommand<import("@matter/main/types").TypeFromFields<{
                    liftValue: import("@matter/main/types").FieldType<number>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly tilt: true;
            readonly absolutePosition: true;
        };
        readonly component: {
            readonly commands: {
                readonly goToTiltValue: import("@matter/main/types").OptionalCommand<import("@matter/main/types").TypeFromFields<{
                    tiltValue: import("@matter/main/types").FieldType<number>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly positionAwareLift: true;
            readonly lift: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly positionAwareTilt: true;
            readonly tilt: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly lift: false;
            readonly tilt: false;
        };
        readonly component: false;
    }];
}>, readonly [WindowCovering.Feature.Lift, WindowCovering.Feature.PositionAwareLift]>, readonly ["Lift", "PositionAwareLift"]>, typeof MatterbridgeWindowCoveringServer, import("@matter/node/behaviors").WindowCoveringInterface> | import("@matter/main").ClusterBehavior.Type<import("@matter/main/types").ClusterComposer.WithFeatures<import("@matter/main/types").ClusterComposer.WithFeatures<ClusterType.Of<{
    readonly id: 513;
    readonly name: "Thermostat";
    readonly revision: 8;
    readonly features: {
        readonly heating: import("@matter/main/types").BitFlag;
        readonly cooling: import("@matter/main/types").BitFlag;
        readonly occupancy: import("@matter/main/types").BitFlag;
        readonly scheduleConfiguration: import("@matter/main/types").BitFlag;
        readonly setback: import("@matter/main/types").BitFlag;
        readonly autoMode: import("@matter/main/types").BitFlag;
        readonly localTemperatureNotExposed: import("@matter/main/types").BitFlag;
        readonly matterScheduleConfiguration: import("@matter/main/types").BitFlag;
        readonly presets: import("@matter/main/types").BitFlag;
    };
    readonly attributes: {
        readonly localTemperature: import("@matter/main/types").Attribute<number | null, any>;
        readonly outdoorTemperature: import("@matter/main/types").OptionalAttribute<number | null, any>;
        readonly hvacSystemTypeConfiguration: import("@matter/main/types").OptionalWritableAttribute<import("@matter/main/types").TypeFromPartialBitSchema<{
            coolingStage: import("@matter/main/types").BitField;
            heatingStage: import("@matter/main/types").BitField;
            heatingIsHeatPump: import("@matter/main/types").BitFlag;
            heatingUsesFuel: import("@matter/main/types").BitFlag;
        }>, any>;
        readonly remoteSensing: import("@matter/main/types").OptionalWritableAttribute<import("@matter/main/types").TypeFromPartialBitSchema<{
            localTemperature: import("@matter/main/types").BitFlag;
            outdoorTemperature: import("@matter/main/types").BitFlag;
            occupancy: import("@matter/main/types").BitFlag;
        }>, any>;
        readonly controlSequenceOfOperation: import("@matter/main/types").WritableAttribute<Thermostat.ControlSequenceOfOperation, any>;
        readonly systemMode: import("@matter/main/types").WritableAttribute<Thermostat.SystemMode, any>;
        readonly temperatureSetpointHold: import("@matter/main/types").OptionalWritableAttribute<Thermostat.TemperatureSetpointHold, any>;
        readonly temperatureSetpointHoldDuration: import("@matter/main/types").OptionalWritableAttribute<number | null, any>;
        readonly thermostatProgrammingOperationMode: import("@matter/main/types").OptionalWritableAttribute<import("@matter/main/types").TypeFromPartialBitSchema<{
            scheduleActive: import("@matter/main/types").BitFlag;
            autoRecovery: import("@matter/main/types").BitFlag;
            economy: import("@matter/main/types").BitFlag;
        }>, any>;
        readonly thermostatRunningState: import("@matter/main/types").OptionalAttribute<import("@matter/main/types").TypeFromPartialBitSchema<{
            heat: import("@matter/main/types").BitFlag;
            cool: import("@matter/main/types").BitFlag;
            fan: import("@matter/main/types").BitFlag;
            heatStage2: import("@matter/main/types").BitFlag;
            coolStage2: import("@matter/main/types").BitFlag;
            fanStage2: import("@matter/main/types").BitFlag;
            fanStage3: import("@matter/main/types").BitFlag;
        }>, any>;
        readonly setpointChangeSource: import("@matter/main/types").OptionalAttribute<Thermostat.SetpointChangeSource, any>;
        readonly setpointChangeAmount: import("@matter/main/types").OptionalAttribute<number | null, any>;
        readonly setpointChangeSourceTimestamp: import("@matter/main/types").OptionalAttribute<number, any>;
        readonly emergencyHeatDelta: import("@matter/main/types").OptionalWritableAttribute<number, any>;
        readonly acType: import("@matter/main/types").OptionalWritableAttribute<Thermostat.AcType, any>;
        readonly acCapacity: import("@matter/main/types").OptionalWritableAttribute<number, any>;
        readonly acRefrigerantType: import("@matter/main/types").OptionalWritableAttribute<Thermostat.AcRefrigerantType, any>;
        readonly acCompressorType: import("@matter/main/types").OptionalWritableAttribute<Thermostat.AcCompressorType, any>;
        readonly acErrorCode: import("@matter/main/types").OptionalWritableAttribute<import("@matter/main/types").TypeFromPartialBitSchema<{
            compressorFail: import("@matter/main/types").BitFlag;
            roomSensorFail: import("@matter/main/types").BitFlag;
            outdoorSensorFail: import("@matter/main/types").BitFlag;
            coilSensorFail: import("@matter/main/types").BitFlag;
            fanFail: import("@matter/main/types").BitFlag;
        }>, any>;
        readonly acLouverPosition: import("@matter/main/types").OptionalWritableAttribute<Thermostat.AcLouverPosition, any>;
        readonly acCoilTemperature: import("@matter/main/types").OptionalAttribute<number | null, any>;
        readonly acCapacityFormat: import("@matter/main/types").OptionalWritableAttribute<Thermostat.AcCapacityFormat, any>;
        readonly setpointHoldExpiryTimestamp: import("@matter/main/types").OptionalAttribute<number | null, any>;
    };
    readonly commands: {
        readonly setpointRaiseLower: import("@matter/main/types").Command<import("@matter/main/types").TypeFromFields<{
            mode: import("@matter/main/types").FieldType<Thermostat.SetpointRaiseLowerMode>;
            amount: import("@matter/main/types").FieldType<number>;
        }>, void, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly occupancy: true;
        };
        readonly component: {
            readonly attributes: {
                readonly occupancy: import("@matter/main/types").Attribute<import("@matter/main/types").TypeFromPartialBitSchema<{
                    occupied: import("@matter/main/types").BitFlag;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly heating: true;
        };
        readonly component: {
            readonly attributes: {
                readonly absMinHeatSetpointLimit: import("@matter/main/types").OptionalFixedAttribute<number, any>;
                readonly absMaxHeatSetpointLimit: import("@matter/main/types").OptionalFixedAttribute<number, any>;
                readonly piHeatingDemand: import("@matter/main/types").OptionalAttribute<number, any>;
                readonly occupiedHeatingSetpoint: import("@matter/main/types").WritableAttribute<number, any>;
                readonly minHeatSetpointLimit: import("@matter/main/types").OptionalWritableAttribute<number, any>;
                readonly maxHeatSetpointLimit: import("@matter/main/types").OptionalWritableAttribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly cooling: true;
        };
        readonly component: {
            readonly attributes: {
                readonly absMinCoolSetpointLimit: import("@matter/main/types").OptionalFixedAttribute<number, any>;
                readonly absMaxCoolSetpointLimit: import("@matter/main/types").OptionalFixedAttribute<number, any>;
                readonly piCoolingDemand: import("@matter/main/types").OptionalAttribute<number, any>;
                readonly occupiedCoolingSetpoint: import("@matter/main/types").WritableAttribute<number, any>;
                readonly minCoolSetpointLimit: import("@matter/main/types").OptionalWritableAttribute<number, any>;
                readonly maxCoolSetpointLimit: import("@matter/main/types").OptionalWritableAttribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly localTemperatureNotExposed: false;
        };
        readonly component: {
            readonly attributes: {
                readonly localTemperatureCalibration: import("@matter/main/types").OptionalWritableAttribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly cooling: true;
            readonly occupancy: true;
        };
        readonly component: {
            readonly attributes: {
                readonly unoccupiedCoolingSetpoint: import("@matter/main/types").WritableAttribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly heating: true;
            readonly occupancy: true;
        };
        readonly component: {
            readonly attributes: {
                readonly unoccupiedHeatingSetpoint: import("@matter/main/types").WritableAttribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly autoMode: true;
        };
        readonly component: {
            readonly attributes: {
                readonly minSetpointDeadBand: import("@matter/main/types").WritableAttribute<number, any>;
                readonly thermostatRunningMode: import("@matter/main/types").OptionalAttribute<Thermostat.ThermostatRunningMode, any>;
            };
        };
    }, {
        readonly flags: {
            readonly scheduleConfiguration: true;
        };
        readonly component: {
            readonly attributes: {
                readonly startOfWeek: import("@matter/main/types").FixedAttribute<Thermostat.StartOfWeek, any>;
                readonly numberOfWeeklyTransitions: import("@matter/main/types").FixedAttribute<number, any>;
                readonly numberOfDailyTransitions: import("@matter/main/types").FixedAttribute<number, any>;
            };
            readonly commands: {
                readonly setWeeklySchedule: import("@matter/main/types").Command<import("@matter/main/types").TypeFromFields<{
                    numberOfTransitionsForSequence: import("@matter/main/types").FieldType<number>;
                    dayOfWeekForSequence: import("@matter/main/types").FieldType<import("@matter/main/types").TypeFromPartialBitSchema<{
                        sunday: import("@matter/main/types").BitFlag;
                        monday: import("@matter/main/types").BitFlag;
                        tuesday: import("@matter/main/types").BitFlag;
                        wednesday: import("@matter/main/types").BitFlag;
                        thursday: import("@matter/main/types").BitFlag;
                        friday: import("@matter/main/types").BitFlag;
                        saturday: import("@matter/main/types").BitFlag;
                        away: import("@matter/main/types").BitFlag;
                    }>>;
                    modeForSequence: import("@matter/main/types").FieldType<import("@matter/main/types").TypeFromPartialBitSchema<{
                        heatSetpointPresent: import("@matter/main/types").BitFlag;
                        coolSetpointPresent: import("@matter/main/types").BitFlag;
                    }>>;
                    transitions: import("@matter/main/types").FieldType<import("@matter/main/types").TypeFromFields<{
                        transitionTime: import("@matter/main/types").FieldType<number>;
                        heatSetpoint: import("@matter/main/types").FieldType<number | null>;
                        coolSetpoint: import("@matter/main/types").FieldType<number | null>;
                    }>[]>;
                }>, void, any>;
                readonly getWeeklySchedule: import("@matter/main/types").Command<import("@matter/main/types").TypeFromFields<{
                    daysToReturn: import("@matter/main/types").FieldType<import("@matter/main/types").TypeFromPartialBitSchema<{
                        sunday: import("@matter/main/types").BitFlag;
                        monday: import("@matter/main/types").BitFlag;
                        tuesday: import("@matter/main/types").BitFlag;
                        wednesday: import("@matter/main/types").BitFlag;
                        thursday: import("@matter/main/types").BitFlag;
                        friday: import("@matter/main/types").BitFlag;
                        saturday: import("@matter/main/types").BitFlag;
                        away: import("@matter/main/types").BitFlag;
                    }>>;
                    modeToReturn: import("@matter/main/types").FieldType<import("@matter/main/types").TypeFromPartialBitSchema<{
                        heatSetpointPresent: import("@matter/main/types").BitFlag;
                        coolSetpointPresent: import("@matter/main/types").BitFlag;
                    }>>;
                }>, import("@matter/main/types").TypeFromFields<{
                    numberOfTransitionsForSequence: import("@matter/main/types").FieldType<number>;
                    dayOfWeekForSequence: import("@matter/main/types").FieldType<import("@matter/main/types").TypeFromPartialBitSchema<{
                        sunday: import("@matter/main/types").BitFlag;
                        monday: import("@matter/main/types").BitFlag;
                        tuesday: import("@matter/main/types").BitFlag;
                        wednesday: import("@matter/main/types").BitFlag;
                        thursday: import("@matter/main/types").BitFlag;
                        friday: import("@matter/main/types").BitFlag;
                        saturday: import("@matter/main/types").BitFlag;
                        away: import("@matter/main/types").BitFlag;
                    }>>;
                    modeForSequence: import("@matter/main/types").FieldType<import("@matter/main/types").TypeFromPartialBitSchema<{
                        heatSetpointPresent: import("@matter/main/types").BitFlag;
                        coolSetpointPresent: import("@matter/main/types").BitFlag;
                    }>>;
                    transitions: import("@matter/main/types").FieldType<import("@matter/main/types").TypeFromFields<{
                        transitionTime: import("@matter/main/types").FieldType<number>;
                        heatSetpoint: import("@matter/main/types").FieldType<number | null>;
                        coolSetpoint: import("@matter/main/types").FieldType<number | null>;
                    }>[]>;
                }>, any>;
                readonly clearWeeklySchedule: import("@matter/main/types").Command<void, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly setback: true;
        };
        readonly component: {
            readonly attributes: {
                readonly occupiedSetback: import("@matter/main/types").WritableAttribute<number | null, any>;
                readonly occupiedSetbackMin: import("@matter/main/types").FixedAttribute<number | null, any>;
                readonly occupiedSetbackMax: import("@matter/main/types").FixedAttribute<number | null, any>;
            };
        };
    }, {
        readonly flags: {
            readonly setback: true;
            readonly occupancy: true;
        };
        readonly component: {
            readonly attributes: {
                readonly unoccupiedSetback: import("@matter/main/types").WritableAttribute<number | null, any>;
                readonly unoccupiedSetbackMin: import("@matter/main/types").FixedAttribute<number | null, any>;
                readonly unoccupiedSetbackMax: import("@matter/main/types").FixedAttribute<number | null, any>;
            };
        };
    }, {
        readonly flags: {
            readonly presets: true;
        };
        readonly component: {
            readonly attributes: {
                readonly presetTypes: import("@matter/main/types").FixedAttribute<import("@matter/main/types").TypeFromFields<{
                    presetScenario: import("@matter/main/types").FieldType<Thermostat.PresetScenario>;
                    numberOfPresets: import("@matter/main/types").FieldType<number>;
                    presetTypeFeatures: import("@matter/main/types").FieldType<import("@matter/main/types").TypeFromPartialBitSchema<{
                        automatic: import("@matter/main/types").BitFlag;
                        supportsNames: import("@matter/main/types").BitFlag;
                    }>>;
                }>[], any>;
                readonly numberOfPresets: import("@matter/main/types").FixedAttribute<number, any>;
                readonly activePresetHandle: import("@matter/main/types").Attribute<Uint8Array<ArrayBufferLike> | null, any>;
                readonly presets: import("@matter/main/types").WritableAttribute<import("@matter/main/types").TypeFromFields<{
                    presetHandle: import("@matter/main/types").FieldType<Uint8Array<ArrayBufferLike> | null>;
                    presetScenario: import("@matter/main/types").FieldType<Thermostat.PresetScenario>;
                    name: import("@matter/main/types").OptionalFieldType<string | null>;
                    coolingSetpoint: import("@matter/main/types").OptionalFieldType<number>;
                    heatingSetpoint: import("@matter/main/types").OptionalFieldType<number>;
                    builtIn: import("@matter/main/types").FieldType<boolean | null>;
                }>[], any>;
            };
            readonly commands: {
                readonly setActivePresetRequest: import("@matter/main/types").Command<import("@matter/main/types").TypeFromFields<{
                    presetHandle: import("@matter/main/types").FieldType<Uint8Array<ArrayBufferLike> | null>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly matterScheduleConfiguration: true;
        };
        readonly component: {
            readonly attributes: {
                readonly scheduleTypes: import("@matter/main/types").FixedAttribute<import("@matter/main/types").TypeFromFields<{
                    systemMode: import("@matter/main/types").FieldType<Thermostat.SystemMode>;
                    numberOfSchedules: import("@matter/main/types").FieldType<number>;
                    scheduleTypeFeatures: import("@matter/main/types").FieldType<import("@matter/main/types").TypeFromPartialBitSchema<{
                        supportsPresets: import("@matter/main/types").BitFlag;
                        supportsSetpoints: import("@matter/main/types").BitFlag;
                        supportsNames: import("@matter/main/types").BitFlag;
                        supportsOff: import("@matter/main/types").BitFlag;
                    }>>;
                }>[], any>;
                readonly numberOfSchedules: import("@matter/main/types").FixedAttribute<number, any>;
                readonly numberOfScheduleTransitions: import("@matter/main/types").FixedAttribute<number, any>;
                readonly numberOfScheduleTransitionPerDay: import("@matter/main/types").FixedAttribute<number | null, any>;
                readonly activeScheduleHandle: import("@matter/main/types").Attribute<Uint8Array<ArrayBufferLike> | null, any>;
                readonly schedules: import("@matter/main/types").WritableAttribute<import("@matter/main/types").TypeFromFields<{
                    scheduleHandle: import("@matter/main/types").FieldType<Uint8Array<ArrayBufferLike> | null>;
                    systemMode: import("@matter/main/types").FieldType<Thermostat.SystemMode>;
                    name: import("@matter/main/types").OptionalFieldType<string>;
                    presetHandle: import("@matter/main/types").OptionalFieldType<Uint8Array<ArrayBufferLike>>;
                    transitions: import("@matter/main/types").FieldType<import("@matter/main/types").TypeFromFields<{
                        dayOfWeek: import("@matter/main/types").FieldType<import("@matter/main/types").TypeFromPartialBitSchema<{
                            sunday: import("@matter/main/types").BitFlag;
                            monday: import("@matter/main/types").BitFlag;
                            tuesday: import("@matter/main/types").BitFlag;
                            wednesday: import("@matter/main/types").BitFlag;
                            thursday: import("@matter/main/types").BitFlag;
                            friday: import("@matter/main/types").BitFlag;
                            saturday: import("@matter/main/types").BitFlag;
                            away: import("@matter/main/types").BitFlag;
                        }>>;
                        transitionTime: import("@matter/main/types").FieldType<number>;
                        presetHandle: import("@matter/main/types").OptionalFieldType<Uint8Array<ArrayBufferLike>>;
                        systemMode: import("@matter/main/types").OptionalFieldType<Thermostat.SystemMode>;
                        coolingSetpoint: import("@matter/main/types").OptionalFieldType<number>;
                        heatingSetpoint: import("@matter/main/types").OptionalFieldType<number>;
                    }>[]>;
                    builtIn: import("@matter/main/types").FieldType<boolean | null>;
                }>[], any>;
            };
            readonly commands: {
                readonly setActiveScheduleRequest: import("@matter/main/types").Command<import("@matter/main/types").TypeFromFields<{
                    scheduleHandle: import("@matter/main/types").FieldType<Uint8Array<ArrayBufferLike>>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly autoMode: true;
            readonly heating: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly autoMode: true;
            readonly cooling: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly heating: false;
            readonly cooling: false;
        };
        readonly component: false;
    }];
}>, readonly [Thermostat.Feature.Cooling, Thermostat.Feature.Heating, Thermostat.Feature.AutoMode]>, readonly ["AutoMode", "Heating", "Cooling"]>, typeof MatterbridgeThermostatServer, import("@matter/node/behaviors").ThermostatInterface> | import("@matter/main").ClusterBehavior.Type<import("@matter/main/types").ClusterComposer.WithFeatures<import("@matter/main/types").ClusterComposer.WithFeatures<ValveConfigurationAndControl.Cluster, readonly [ValveConfigurationAndControl.Feature.Level]>, readonly ["Level"]>, typeof MatterbridgeValveConfigurationAndControlServer, import("@matter/node/behaviors").ValveConfigurationAndControlInterface> | import("@matter/main").ClusterBehavior.Type<import("@matter/main/types").ClusterComposer.WithFeatures<ClusterType.Of<{
    readonly id: 512;
    readonly name: "PumpConfigurationAndControl";
    readonly revision: 4;
    readonly features: {
        readonly constantPressure: import("@matter/main/types").BitFlag;
        readonly compensatedPressure: import("@matter/main/types").BitFlag;
        readonly constantFlow: import("@matter/main/types").BitFlag;
        readonly constantSpeed: import("@matter/main/types").BitFlag;
        readonly constantTemperature: import("@matter/main/types").BitFlag;
        readonly automatic: import("@matter/main/types").BitFlag;
        readonly localOperation: import("@matter/main/types").BitFlag;
    };
    readonly attributes: {
        readonly maxPressure: import("@matter/main/types").FixedAttribute<number | null, any>;
        readonly maxSpeed: import("@matter/main/types").FixedAttribute<number | null, any>;
        readonly maxFlow: import("@matter/main/types").FixedAttribute<number | null, any>;
        readonly pumpStatus: import("@matter/main/types").OptionalAttribute<import("@matter/main/types").TypeFromPartialBitSchema<{
            deviceFault: import("@matter/main/types").BitFlag;
            supplyFault: import("@matter/main/types").BitFlag;
            speedLow: import("@matter/main/types").BitFlag;
            speedHigh: import("@matter/main/types").BitFlag;
            localOverride: import("@matter/main/types").BitFlag;
            running: import("@matter/main/types").BitFlag;
            remotePressure: import("@matter/main/types").BitFlag;
            remoteFlow: import("@matter/main/types").BitFlag;
            remoteTemperature: import("@matter/main/types").BitFlag;
        }>, any>;
        readonly effectiveOperationMode: import("@matter/main/types").Attribute<PumpConfigurationAndControl.OperationMode, any>;
        readonly effectiveControlMode: import("@matter/main/types").Attribute<PumpConfigurationAndControl.ControlMode, any>;
        readonly capacity: import("@matter/main/types").Attribute<number | null, any>;
        readonly speed: import("@matter/main/types").OptionalAttribute<number | null, any>;
        readonly lifetimeRunningHours: import("@matter/main/types").OptionalWritableAttribute<number | null, any>;
        readonly power: import("@matter/main/types").OptionalAttribute<number | null, any>;
        readonly lifetimeEnergyConsumed: import("@matter/main/types").OptionalWritableAttribute<number | null, any>;
        readonly operationMode: import("@matter/main/types").WritableAttribute<PumpConfigurationAndControl.OperationMode, any>;
        readonly controlMode: import("@matter/main/types").OptionalWritableAttribute<PumpConfigurationAndControl.ControlMode, any>;
        readonly alarmMask: import("@matter/main/types").OptionalWritableAttribute<number, any>;
    };
    readonly events: {
        readonly supplyVoltageLow: import("@matter/main/types").OptionalEvent<void, any>;
        readonly supplyVoltageHigh: import("@matter/main/types").OptionalEvent<void, any>;
        readonly powerMissingPhase: import("@matter/main/types").OptionalEvent<void, any>;
        readonly systemPressureLow: import("@matter/main/types").OptionalEvent<void, any>;
        readonly systemPressureHigh: import("@matter/main/types").OptionalEvent<void, any>;
        readonly dryRunning: import("@matter/main/types").OptionalEvent<void, any>;
        readonly motorTemperatureHigh: import("@matter/main/types").OptionalEvent<void, any>;
        readonly pumpMotorFatalFailure: import("@matter/main/types").OptionalEvent<void, any>;
        readonly electronicTemperatureHigh: import("@matter/main/types").OptionalEvent<void, any>;
        readonly pumpBlocked: import("@matter/main/types").OptionalEvent<void, any>;
        readonly sensorFailure: import("@matter/main/types").OptionalEvent<void, any>;
        readonly electronicNonFatalFailure: import("@matter/main/types").OptionalEvent<void, any>;
        readonly electronicFatalFailure: import("@matter/main/types").OptionalEvent<void, any>;
        readonly generalFault: import("@matter/main/types").OptionalEvent<void, any>;
        readonly leakage: import("@matter/main/types").OptionalEvent<void, any>;
        readonly airDetection: import("@matter/main/types").OptionalEvent<void, any>;
        readonly turbineOperation: import("@matter/main/types").OptionalEvent<void, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly constantPressure: true;
        };
        readonly component: {
            readonly attributes: {
                readonly minConstPressure: import("@matter/main/types").FixedAttribute<number | null, any>;
                readonly maxConstPressure: import("@matter/main/types").FixedAttribute<number | null, any>;
            };
        };
    }, {
        readonly flags: {
            readonly automatic: true;
        };
        readonly component: {
            readonly attributes: {
                readonly minConstPressure: import("@matter/main/types").OptionalFixedAttribute<number | null, any>;
                readonly maxConstPressure: import("@matter/main/types").OptionalFixedAttribute<number | null, any>;
                readonly minCompPressure: import("@matter/main/types").OptionalFixedAttribute<number | null, any>;
                readonly maxCompPressure: import("@matter/main/types").OptionalFixedAttribute<number | null, any>;
                readonly minConstSpeed: import("@matter/main/types").OptionalFixedAttribute<number | null, any>;
                readonly maxConstSpeed: import("@matter/main/types").OptionalFixedAttribute<number | null, any>;
                readonly minConstFlow: import("@matter/main/types").OptionalFixedAttribute<number | null, any>;
                readonly maxConstFlow: import("@matter/main/types").OptionalFixedAttribute<number | null, any>;
                readonly minConstTemp: import("@matter/main/types").OptionalFixedAttribute<number | null, any>;
                readonly maxConstTemp: import("@matter/main/types").OptionalFixedAttribute<number | null, any>;
            };
        };
    }, {
        readonly flags: {
            readonly compensatedPressure: true;
        };
        readonly component: {
            readonly attributes: {
                readonly minCompPressure: import("@matter/main/types").FixedAttribute<number | null, any>;
                readonly maxCompPressure: import("@matter/main/types").FixedAttribute<number | null, any>;
            };
        };
    }, {
        readonly flags: {
            readonly constantSpeed: true;
        };
        readonly component: {
            readonly attributes: {
                readonly minConstSpeed: import("@matter/main/types").FixedAttribute<number | null, any>;
                readonly maxConstSpeed: import("@matter/main/types").FixedAttribute<number | null, any>;
            };
        };
    }, {
        readonly flags: {
            readonly constantFlow: true;
        };
        readonly component: {
            readonly attributes: {
                readonly minConstFlow: import("@matter/main/types").FixedAttribute<number | null, any>;
                readonly maxConstFlow: import("@matter/main/types").FixedAttribute<number | null, any>;
            };
        };
    }, {
        readonly flags: {
            readonly constantTemperature: true;
        };
        readonly component: {
            readonly attributes: {
                readonly minConstTemp: import("@matter/main/types").FixedAttribute<number | null, any>;
                readonly maxConstTemp: import("@matter/main/types").FixedAttribute<number | null, any>;
            };
        };
    }, {
        readonly flags: {
            readonly constantPressure: false;
            readonly compensatedPressure: false;
            readonly constantFlow: false;
            readonly constantSpeed: false;
            readonly constantTemperature: false;
        };
        readonly component: false;
    }];
}>, readonly ["ConstantSpeed"]>, typeof PumpConfigurationAndControlServer, {
    components: never[];
}> | import("@matter/main").ClusterBehavior.Type<import("@matter/main/types").ClusterComposer.WithFeatures<import("@matter/main/types").ClusterComposer.WithFeatures<ClusterType.Of<{
    readonly id: 92;
    readonly name: "SmokeCoAlarm";
    readonly revision: 1;
    readonly features: {
        readonly smokeAlarm: import("@matter/main/types").BitFlag;
        readonly coAlarm: import("@matter/main/types").BitFlag;
    };
    readonly attributes: {
        readonly expressedState: import("@matter/main/types").Attribute<SmokeCoAlarm.ExpressedState, any>;
        readonly batteryAlert: import("@matter/main/types").Attribute<SmokeCoAlarm.AlarmState, any>;
        readonly deviceMuted: import("@matter/main/types").OptionalAttribute<SmokeCoAlarm.MuteState, any>;
        readonly testInProgress: import("@matter/main/types").Attribute<boolean, any>;
        readonly hardwareFaultAlert: import("@matter/main/types").Attribute<boolean, any>;
        readonly endOfServiceAlert: import("@matter/main/types").Attribute<SmokeCoAlarm.EndOfService, any>;
        readonly interconnectSmokeAlarm: import("@matter/main/types").OptionalAttribute<SmokeCoAlarm.AlarmState, any>;
        readonly interconnectCoAlarm: import("@matter/main/types").OptionalAttribute<SmokeCoAlarm.AlarmState, any>;
        readonly expiryDate: import("@matter/main/types").OptionalFixedAttribute<number, any>;
    };
    readonly commands: {
        readonly selfTestRequest: import("@matter/main/types").OptionalCommand<void, void, any>;
    };
    readonly events: {
        readonly lowBattery: import("@matter/main/types").Event<import("@matter/main/types").TypeFromFields<{
            alarmSeverityLevel: import("@matter/main/types").FieldType<SmokeCoAlarm.AlarmState>;
        }>, any>;
        readonly hardwareFault: import("@matter/main/types").Event<void, any>;
        readonly endOfService: import("@matter/main/types").Event<void, any>;
        readonly selfTestComplete: import("@matter/main/types").Event<void, any>;
        readonly alarmMuted: import("@matter/main/types").OptionalEvent<void, any>;
        readonly muteEnded: import("@matter/main/types").OptionalEvent<void, any>;
        readonly allClear: import("@matter/main/types").Event<void, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly smokeAlarm: true;
        };
        readonly component: {
            readonly attributes: {
                readonly smokeState: import("@matter/main/types").Attribute<SmokeCoAlarm.AlarmState, any>;
                readonly contaminationState: import("@matter/main/types").OptionalAttribute<SmokeCoAlarm.ContaminationState, any>;
                readonly smokeSensitivityLevel: import("@matter/main/types").OptionalWritableAttribute<SmokeCoAlarm.Sensitivity, any>;
            };
            readonly events: {
                readonly smokeAlarm: import("@matter/main/types").Event<import("@matter/main/types").TypeFromFields<{
                    alarmSeverityLevel: import("@matter/main/types").FieldType<SmokeCoAlarm.AlarmState>;
                }>, any>;
                readonly interconnectSmokeAlarm: import("@matter/main/types").OptionalEvent<import("@matter/main/types").TypeFromFields<{
                    alarmSeverityLevel: import("@matter/main/types").FieldType<SmokeCoAlarm.AlarmState>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly coAlarm: true;
        };
        readonly component: {
            readonly attributes: {
                readonly coState: import("@matter/main/types").Attribute<SmokeCoAlarm.AlarmState, any>;
            };
            readonly events: {
                readonly coAlarm: import("@matter/main/types").Event<import("@matter/main/types").TypeFromFields<{
                    alarmSeverityLevel: import("@matter/main/types").FieldType<SmokeCoAlarm.AlarmState>;
                }>, any>;
                readonly interconnectCoAlarm: import("@matter/main/types").OptionalEvent<import("@matter/main/types").TypeFromFields<{
                    alarmSeverityLevel: import("@matter/main/types").FieldType<SmokeCoAlarm.AlarmState>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly smokeAlarm: false;
            readonly coAlarm: false;
        };
        readonly component: false;
    }];
}>, readonly [SmokeCoAlarm.Feature.SmokeAlarm, SmokeCoAlarm.Feature.CoAlarm]>, readonly ["SmokeAlarm", "CoAlarm"]>, typeof MatterbridgeSmokeCoAlarmServer, import("@matter/node/behaviors").SmokeCoAlarmInterface> | import("@matter/main").ClusterBehavior.Type<import("@matter/main/types").ClusterComposer.WithFeatures<ClusterType.Of<{
    readonly id: 59;
    readonly name: "Switch";
    readonly revision: 2;
    readonly features: {
        readonly latchingSwitch: import("@matter/main/types").BitFlag;
        readonly momentarySwitch: import("@matter/main/types").BitFlag;
        readonly momentarySwitchRelease: import("@matter/main/types").BitFlag;
        readonly momentarySwitchLongPress: import("@matter/main/types").BitFlag;
        readonly momentarySwitchMultiPress: import("@matter/main/types").BitFlag;
        readonly actionSwitch: import("@matter/main/types").BitFlag;
    };
    readonly attributes: {
        readonly numberOfPositions: import("@matter/main/types").FixedAttribute<number, any>;
        readonly currentPosition: import("@matter/main/types").Attribute<number, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly momentarySwitchMultiPress: true;
        };
        readonly component: {
            readonly attributes: {
                readonly multiPressMax: import("@matter/main/types").FixedAttribute<number, any>;
            };
            readonly events: {
                readonly multiPressComplete: import("@matter/main/types").Event<import("@matter/main/types").TypeFromFields<{
                    previousPosition: import("@matter/main/types").FieldType<number>;
                    totalNumberOfPressesCounted: import("@matter/main/types").FieldType<number>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly latchingSwitch: true;
        };
        readonly component: {
            readonly events: {
                readonly switchLatched: import("@matter/main/types").Event<import("@matter/main/types").TypeFromFields<{
                    newPosition: import("@matter/main/types").FieldType<number>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly momentarySwitch: true;
        };
        readonly component: {
            readonly events: {
                readonly initialPress: import("@matter/main/types").Event<import("@matter/main/types").TypeFromFields<{
                    newPosition: import("@matter/main/types").FieldType<number>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly momentarySwitchLongPress: true;
        };
        readonly component: {
            readonly events: {
                readonly longPress: import("@matter/main/types").Event<import("@matter/main/types").TypeFromFields<{
                    newPosition: import("@matter/main/types").FieldType<number>;
                }>, any>;
                readonly longRelease: import("@matter/main/types").Event<import("@matter/main/types").TypeFromFields<{
                    previousPosition: import("@matter/main/types").FieldType<number>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly momentarySwitchRelease: true;
        };
        readonly component: {
            readonly events: {
                readonly shortRelease: import("@matter/main/types").Event<import("@matter/main/types").TypeFromFields<{
                    previousPosition: import("@matter/main/types").FieldType<number>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly momentarySwitchMultiPress: true;
            readonly actionSwitch: false;
        };
        readonly component: {
            readonly events: {
                readonly multiPressOngoing: import("@matter/main/types").Event<import("@matter/main/types").TypeFromFields<{
                    newPosition: import("@matter/main/types").FieldType<number>;
                    currentNumberOfPressesCounted: import("@matter/main/types").FieldType<number>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly momentarySwitchRelease: true;
            readonly momentarySwitch: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly momentarySwitchRelease: true;
            readonly actionSwitch: true;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly momentarySwitchLongPress: true;
            readonly momentarySwitch: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly momentarySwitchLongPress: true;
            readonly momentarySwitchRelease: false;
            readonly actionSwitch: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly actionSwitch: true;
            readonly momentarySwitchMultiPress: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly actionSwitch: false;
            readonly momentarySwitchMultiPress: true;
            readonly momentarySwitch: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly actionSwitch: false;
            readonly momentarySwitchMultiPress: true;
            readonly momentarySwitchRelease: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly actionSwitch: true;
            readonly momentarySwitch: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly latchingSwitch: true;
            readonly momentarySwitch: true;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly latchingSwitch: false;
            readonly momentarySwitch: false;
        };
        readonly component: false;
    }];
}>, readonly ["MomentarySwitch", "MomentarySwitchRelease", "MomentarySwitchLongPress", "MomentarySwitchMultiPress"]>, typeof SwitchServer, {
    components: never[];
}> | import("@matter/main").ClusterBehavior.Type<import("@matter/main/types").ElementModifier.WithAlterations<BooleanState.Cluster, import("@matter/main/types").ElementModifier.ElementFlagAlterations<{
    readonly events: {
        readonly stateChange: true;
    };
}>>, typeof BooleanStateServer, {
    components: never[];
}> | import("@matter/main").ClusterBehavior.Type<import("@matter/main/types").ClusterComposer.WithFeatures<ClusterType.Of<{
    readonly id: 156;
    readonly name: "PowerTopology";
    readonly revision: 1;
    readonly features: {
        readonly nodeTopology: import("@matter/main/types").BitFlag;
        readonly treeTopology: import("@matter/main/types").BitFlag;
        readonly setTopology: import("@matter/main/types").BitFlag;
        readonly dynamicPowerFlow: import("@matter/main/types").BitFlag;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly setTopology: true;
        };
        readonly component: {
            readonly attributes: {
                readonly availableEndpoints: import("@matter/main/types").FixedAttribute<import("@matter/main").EndpointNumber[], any>;
            };
        };
    }, {
        readonly flags: {
            readonly dynamicPowerFlow: true;
        };
        readonly component: {
            readonly attributes: {
                readonly activeEndpoints: import("@matter/main/types").Attribute<import("@matter/main").EndpointNumber[], any>;
            };
        };
    }, {
        readonly flags: {
            readonly dynamicPowerFlow: true;
            readonly setTopology: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly nodeTopology: true;
            readonly treeTopology: true;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly nodeTopology: true;
            readonly setTopology: true;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly treeTopology: true;
            readonly setTopology: true;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly nodeTopology: false;
            readonly treeTopology: false;
            readonly setTopology: false;
        };
        readonly component: false;
    }];
}>, readonly ["TreeTopology"]>, typeof PowerTopologyServer, {
    components: never[];
}> | import("@matter/main").ClusterBehavior.Type<import("@matter/main/types").ClusterComposer.WithFeatures<ClusterType.Of<{
    readonly id: 144;
    readonly name: "ElectricalPowerMeasurement";
    readonly revision: 1;
    readonly features: {
        readonly directCurrent: import("@matter/main/types").BitFlag;
        readonly alternatingCurrent: import("@matter/main/types").BitFlag;
        readonly polyphasePower: import("@matter/main/types").BitFlag;
        readonly harmonics: import("@matter/main/types").BitFlag;
        readonly powerQuality: import("@matter/main/types").BitFlag;
    };
    readonly attributes: {
        readonly powerMode: import("@matter/main/types").Attribute<ElectricalPowerMeasurement.PowerMode, any>;
        readonly numberOfMeasurementTypes: import("@matter/main/types").FixedAttribute<number, any>;
        readonly accuracy: import("@matter/main/types").FixedAttribute<import("@matter/main/types").TypeFromFields<{
            measurementType: import("@matter/main/types").FieldType<import("@matter/main/types").MeasurementType>;
            measured: import("@matter/main/types").FieldType<boolean>;
            minMeasuredValue: import("@matter/main/types").FieldType<number | bigint>;
            maxMeasuredValue: import("@matter/main/types").FieldType<number | bigint>;
            accuracyRanges: import("@matter/main/types").FieldType<import("@matter/main/types").TypeFromFields<{
                rangeMin: import("@matter/main/types").FieldType<number | bigint>;
                rangeMax: import("@matter/main/types").FieldType<number | bigint>;
                percentMax: import("@matter/main/types").OptionalFieldType<number>;
                percentMin: import("@matter/main/types").OptionalFieldType<number>;
                percentTypical: import("@matter/main/types").OptionalFieldType<number>;
                fixedMax: import("@matter/main/types").OptionalFieldType<number | bigint>;
                fixedMin: import("@matter/main/types").OptionalFieldType<number | bigint>;
                fixedTypical: import("@matter/main/types").OptionalFieldType<number | bigint>;
            }>[]>;
        }>[], any>;
        readonly ranges: import("@matter/main/types").OptionalAttribute<import("@matter/main/types").TypeFromFields<{
            measurementType: import("@matter/main/types").FieldType<import("@matter/main/types").MeasurementType>;
            min: import("@matter/main/types").FieldType<number | bigint>;
            max: import("@matter/main/types").FieldType<number | bigint>;
            startTimestamp: import("@matter/main/types").OptionalFieldType<number>;
            endTimestamp: import("@matter/main/types").OptionalFieldType<number>;
            minTimestamp: import("@matter/main/types").OptionalFieldType<number>;
            maxTimestamp: import("@matter/main/types").OptionalFieldType<number>;
            startSystime: import("@matter/main/types").OptionalFieldType<number | bigint>;
            endSystime: import("@matter/main/types").OptionalFieldType<number | bigint>;
            minSystime: import("@matter/main/types").OptionalFieldType<number | bigint>;
            maxSystime: import("@matter/main/types").OptionalFieldType<number | bigint>;
        }>[], any>;
        readonly voltage: import("@matter/main/types").OptionalAttribute<number | bigint | null, any>;
        readonly activeCurrent: import("@matter/main/types").OptionalAttribute<number | bigint | null, any>;
        readonly activePower: import("@matter/main/types").Attribute<number | bigint | null, any>;
    };
    readonly events: {
        readonly measurementPeriodRanges: import("@matter/main/types").OptionalEvent<import("@matter/main/types").TypeFromFields<{
            ranges: import("@matter/main/types").FieldType<import("@matter/main/types").TypeFromFields<{
                measurementType: import("@matter/main/types").FieldType<import("@matter/main/types").MeasurementType>;
                min: import("@matter/main/types").FieldType<number | bigint>;
                max: import("@matter/main/types").FieldType<number | bigint>;
                startTimestamp: import("@matter/main/types").OptionalFieldType<number>;
                endTimestamp: import("@matter/main/types").OptionalFieldType<number>;
                minTimestamp: import("@matter/main/types").OptionalFieldType<number>;
                maxTimestamp: import("@matter/main/types").OptionalFieldType<number>;
                startSystime: import("@matter/main/types").OptionalFieldType<number | bigint>;
                endSystime: import("@matter/main/types").OptionalFieldType<number | bigint>;
                minSystime: import("@matter/main/types").OptionalFieldType<number | bigint>;
                maxSystime: import("@matter/main/types").OptionalFieldType<number | bigint>;
            }>[]>;
        }>, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly alternatingCurrent: true;
        };
        readonly component: {
            readonly attributes: {
                readonly reactiveCurrent: import("@matter/main/types").OptionalAttribute<number | bigint | null, any>;
                readonly apparentCurrent: import("@matter/main/types").OptionalAttribute<number | bigint | null, any>;
                readonly reactivePower: import("@matter/main/types").OptionalAttribute<number | bigint | null, any>;
                readonly apparentPower: import("@matter/main/types").OptionalAttribute<number | bigint | null, any>;
                readonly rmsVoltage: import("@matter/main/types").OptionalAttribute<number | bigint | null, any>;
                readonly rmsCurrent: import("@matter/main/types").OptionalAttribute<number | bigint | null, any>;
                readonly rmsPower: import("@matter/main/types").OptionalAttribute<number | bigint | null, any>;
                readonly frequency: import("@matter/main/types").OptionalAttribute<number | bigint | null, any>;
                readonly powerFactor: import("@matter/main/types").OptionalAttribute<number | bigint | null, any>;
            };
        };
    }, {
        readonly flags: {
            readonly harmonics: true;
        };
        readonly component: {
            readonly attributes: {
                readonly harmonicCurrents: import("@matter/main/types").Attribute<import("@matter/main/types").TypeFromFields<{
                    order: import("@matter/main/types").FieldType<number>;
                    measurement: import("@matter/main/types").FieldType<number | bigint | null>;
                }>[] | null, any>;
            };
        };
    }, {
        readonly flags: {
            readonly powerQuality: true;
        };
        readonly component: {
            readonly attributes: {
                readonly harmonicPhases: import("@matter/main/types").Attribute<import("@matter/main/types").TypeFromFields<{
                    order: import("@matter/main/types").FieldType<number>;
                    measurement: import("@matter/main/types").FieldType<number | bigint | null>;
                }>[] | null, any>;
            };
        };
    }, {
        readonly flags: {
            readonly polyphasePower: true;
        };
        readonly component: {
            readonly attributes: {
                readonly neutralCurrent: import("@matter/main/types").OptionalAttribute<number | bigint | null, any>;
            };
        };
    }, {
        readonly flags: {
            readonly polyphasePower: true;
            readonly alternatingCurrent: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly harmonics: true;
            readonly alternatingCurrent: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly powerQuality: true;
            readonly alternatingCurrent: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly directCurrent: false;
            readonly alternatingCurrent: false;
        };
        readonly component: false;
    }];
}>, readonly ["AlternatingCurrent"]>, typeof ElectricalPowerMeasurementServer, {
    components: never[];
}> | import("@matter/main").ClusterBehavior.Type<import("@matter/main/types").ClusterComposer.WithFeatures<ClusterType.Of<{
    readonly id: 145;
    readonly name: "ElectricalEnergyMeasurement";
    readonly revision: 1;
    readonly features: {
        readonly importedEnergy: import("@matter/main/types").BitFlag;
        readonly exportedEnergy: import("@matter/main/types").BitFlag;
        readonly cumulativeEnergy: import("@matter/main/types").BitFlag;
        readonly periodicEnergy: import("@matter/main/types").BitFlag;
    };
    readonly attributes: {
        readonly accuracy: import("@matter/main/types").FixedAttribute<import("@matter/main/types").TypeFromFields<{
            measurementType: import("@matter/main/types").FieldType<import("@matter/main/types").MeasurementType>;
            measured: import("@matter/main/types").FieldType<boolean>;
            minMeasuredValue: import("@matter/main/types").FieldType<number | bigint>;
            maxMeasuredValue: import("@matter/main/types").FieldType<number | bigint>;
            accuracyRanges: import("@matter/main/types").FieldType<import("@matter/main/types").TypeFromFields<{
                rangeMin: import("@matter/main/types").FieldType<number | bigint>;
                rangeMax: import("@matter/main/types").FieldType<number | bigint>;
                percentMax: import("@matter/main/types").OptionalFieldType<number>;
                percentMin: import("@matter/main/types").OptionalFieldType<number>;
                percentTypical: import("@matter/main/types").OptionalFieldType<number>;
                fixedMax: import("@matter/main/types").OptionalFieldType<number | bigint>;
                fixedMin: import("@matter/main/types").OptionalFieldType<number | bigint>;
                fixedTypical: import("@matter/main/types").OptionalFieldType<number | bigint>;
            }>[]>;
        }>, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly importedEnergy: true;
            readonly cumulativeEnergy: true;
        };
        readonly component: {
            readonly attributes: {
                readonly cumulativeEnergyImported: import("@matter/main/types").Attribute<import("@matter/main/types").TypeFromFields<{
                    energy: import("@matter/main/types").FieldType<number | bigint>;
                    startTimestamp: import("@matter/main/types").OptionalFieldType<number>;
                    endTimestamp: import("@matter/main/types").OptionalFieldType<number>;
                    startSystime: import("@matter/main/types").OptionalFieldType<number | bigint>;
                    endSystime: import("@matter/main/types").OptionalFieldType<number | bigint>;
                }> | null, any>;
            };
        };
    }, {
        readonly flags: {
            readonly exportedEnergy: true;
            readonly cumulativeEnergy: true;
        };
        readonly component: {
            readonly attributes: {
                readonly cumulativeEnergyExported: import("@matter/main/types").Attribute<import("@matter/main/types").TypeFromFields<{
                    energy: import("@matter/main/types").FieldType<number | bigint>;
                    startTimestamp: import("@matter/main/types").OptionalFieldType<number>;
                    endTimestamp: import("@matter/main/types").OptionalFieldType<number>;
                    startSystime: import("@matter/main/types").OptionalFieldType<number | bigint>;
                    endSystime: import("@matter/main/types").OptionalFieldType<number | bigint>;
                }> | null, any>;
            };
        };
    }, {
        readonly flags: {
            readonly importedEnergy: true;
            readonly periodicEnergy: true;
        };
        readonly component: {
            readonly attributes: {
                readonly periodicEnergyImported: import("@matter/main/types").Attribute<import("@matter/main/types").TypeFromFields<{
                    energy: import("@matter/main/types").FieldType<number | bigint>;
                    startTimestamp: import("@matter/main/types").OptionalFieldType<number>;
                    endTimestamp: import("@matter/main/types").OptionalFieldType<number>;
                    startSystime: import("@matter/main/types").OptionalFieldType<number | bigint>;
                    endSystime: import("@matter/main/types").OptionalFieldType<number | bigint>;
                }> | null, any>;
            };
        };
    }, {
        readonly flags: {
            readonly exportedEnergy: true;
            readonly periodicEnergy: true;
        };
        readonly component: {
            readonly attributes: {
                readonly periodicEnergyExported: import("@matter/main/types").Attribute<import("@matter/main/types").TypeFromFields<{
                    energy: import("@matter/main/types").FieldType<number | bigint>;
                    startTimestamp: import("@matter/main/types").OptionalFieldType<number>;
                    endTimestamp: import("@matter/main/types").OptionalFieldType<number>;
                    startSystime: import("@matter/main/types").OptionalFieldType<number | bigint>;
                    endSystime: import("@matter/main/types").OptionalFieldType<number | bigint>;
                }> | null, any>;
            };
        };
    }, {
        readonly flags: {
            readonly cumulativeEnergy: true;
        };
        readonly component: {
            readonly attributes: {
                readonly cumulativeEnergyReset: import("@matter/main/types").OptionalAttribute<import("@matter/main/types").TypeFromFields<{
                    importedResetTimestamp: import("@matter/main/types").OptionalFieldType<number | null>;
                    exportedResetTimestamp: import("@matter/main/types").OptionalFieldType<number | null>;
                    importedResetSystime: import("@matter/main/types").OptionalFieldType<number | bigint | null>;
                    exportedResetSystime: import("@matter/main/types").OptionalFieldType<number | bigint | null>;
                }> | null, any>;
            };
            readonly events: {
                readonly cumulativeEnergyMeasured: import("@matter/main/types").Event<import("@matter/main/types").TypeFromFields<{
                    energyImported: import("@matter/main/types").OptionalFieldType<import("@matter/main/types").TypeFromFields<{
                        energy: import("@matter/main/types").FieldType<number | bigint>;
                        startTimestamp: import("@matter/main/types").OptionalFieldType<number>;
                        endTimestamp: import("@matter/main/types").OptionalFieldType<number>;
                        startSystime: import("@matter/main/types").OptionalFieldType<number | bigint>;
                        endSystime: import("@matter/main/types").OptionalFieldType<number | bigint>;
                    }>>;
                    energyExported: import("@matter/main/types").OptionalFieldType<import("@matter/main/types").TypeFromFields<{
                        energy: import("@matter/main/types").FieldType<number | bigint>;
                        startTimestamp: import("@matter/main/types").OptionalFieldType<number>;
                        endTimestamp: import("@matter/main/types").OptionalFieldType<number>;
                        startSystime: import("@matter/main/types").OptionalFieldType<number | bigint>;
                        endSystime: import("@matter/main/types").OptionalFieldType<number | bigint>;
                    }>>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly periodicEnergy: true;
        };
        readonly component: {
            readonly events: {
                readonly periodicEnergyMeasured: import("@matter/main/types").Event<import("@matter/main/types").TypeFromFields<{
                    energyImported: import("@matter/main/types").OptionalFieldType<import("@matter/main/types").TypeFromFields<{
                        energy: import("@matter/main/types").FieldType<number | bigint>;
                        startTimestamp: import("@matter/main/types").OptionalFieldType<number>;
                        endTimestamp: import("@matter/main/types").OptionalFieldType<number>;
                        startSystime: import("@matter/main/types").OptionalFieldType<number | bigint>;
                        endSystime: import("@matter/main/types").OptionalFieldType<number | bigint>;
                    }>>;
                    energyExported: import("@matter/main/types").OptionalFieldType<import("@matter/main/types").TypeFromFields<{
                        energy: import("@matter/main/types").FieldType<number | bigint>;
                        startTimestamp: import("@matter/main/types").OptionalFieldType<number>;
                        endTimestamp: import("@matter/main/types").OptionalFieldType<number>;
                        startSystime: import("@matter/main/types").OptionalFieldType<number | bigint>;
                        endSystime: import("@matter/main/types").OptionalFieldType<number | bigint>;
                    }>>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly importedEnergy: false;
            readonly exportedEnergy: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly cumulativeEnergy: false;
            readonly periodicEnergy: false;
        };
        readonly component: false;
    }];
}>, readonly ["ImportedEnergy", "ExportedEnergy", "CumulativeEnergy"]>, typeof ElectricalEnergyMeasurementServer, {
    components: never[];
}> | typeof TemperatureMeasurementServer | typeof RelativeHumidityMeasurementServer | typeof PressureMeasurementServer | typeof FlowMeasurementServer | typeof IlluminanceMeasurementServer | typeof OccupancySensingServer | import("@matter/main").ClusterBehavior.Type<import("@matter/main/types").ClusterComposer.WithFeatures<AirQuality.Cluster, readonly ["Fair", "Moderate", "VeryPoor", "ExtremelyPoor"]>, typeof AirQualityServer, {
    components: never[];
}> | import("@matter/main").ClusterBehavior.Type<import("@matter/main/types").ClusterComposer.WithFeatures<ClusterType.Of<{
    readonly id: 1036;
    readonly name: "CarbonMonoxideConcentrationMeasurement";
    readonly features: {
        readonly numericMeasurement: import("@matter/main/types").BitFlag;
        readonly levelIndication: import("@matter/main/types").BitFlag;
        readonly mediumLevel: import("@matter/main/types").BitFlag;
        readonly criticalLevel: import("@matter/main/types").BitFlag;
        readonly peakMeasurement: import("@matter/main/types").BitFlag;
        readonly averageMeasurement: import("@matter/main/types").BitFlag;
    };
    readonly revision: 3;
    readonly attributes: {
        readonly measurementMedium: import("@matter/main/types").FixedAttribute<import("@matter/main/clusters").ConcentrationMeasurement.MeasurementMedium, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly numericMeasurement: true;
        };
        readonly component: {
            readonly attributes: {
                readonly measuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly minMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly maxMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly uncertainty: import("@matter/main/types").OptionalAttribute<number, any>;
                readonly measurementUnit: import("@matter/main/types").FixedAttribute<import("@matter/main/clusters").ConcentrationMeasurement.MeasurementUnit, any>;
            };
        };
    }, {
        readonly flags: {
            readonly peakMeasurement: true;
        };
        readonly component: {
            readonly attributes: {
                readonly peakMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly peakMeasuredValueWindow: import("@matter/main/types").Attribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly averageMeasurement: true;
        };
        readonly component: {
            readonly attributes: {
                readonly averageMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly averageMeasuredValueWindow: import("@matter/main/types").Attribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly levelIndication: true;
        };
        readonly component: {
            readonly attributes: {
                readonly levelValue: import("@matter/main/types").Attribute<import("@matter/main/clusters").ConcentrationMeasurement.LevelValue, any>;
            };
        };
    }, {
        readonly flags: {
            readonly mediumLevel: true;
            readonly levelIndication: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly criticalLevel: true;
            readonly levelIndication: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly peakMeasurement: true;
            readonly numericMeasurement: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly averageMeasurement: true;
            readonly numericMeasurement: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly numericMeasurement: false;
            readonly levelIndication: false;
        };
        readonly component: false;
    }];
}>, readonly ["NumericMeasurement"]>, typeof CarbonMonoxideConcentrationMeasurementServer, {
    components: never[];
}> | import("@matter/main").ClusterBehavior.Type<import("@matter/main/types").ClusterComposer.WithFeatures<ClusterType.Of<{
    readonly id: 1037;
    readonly name: "CarbonDioxideConcentrationMeasurement";
    readonly features: {
        readonly numericMeasurement: import("@matter/main/types").BitFlag;
        readonly levelIndication: import("@matter/main/types").BitFlag;
        readonly mediumLevel: import("@matter/main/types").BitFlag;
        readonly criticalLevel: import("@matter/main/types").BitFlag;
        readonly peakMeasurement: import("@matter/main/types").BitFlag;
        readonly averageMeasurement: import("@matter/main/types").BitFlag;
    };
    readonly revision: 3;
    readonly attributes: {
        readonly measurementMedium: import("@matter/main/types").FixedAttribute<import("@matter/main/clusters").ConcentrationMeasurement.MeasurementMedium, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly numericMeasurement: true;
        };
        readonly component: {
            readonly attributes: {
                readonly measuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly minMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly maxMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly uncertainty: import("@matter/main/types").OptionalAttribute<number, any>;
                readonly measurementUnit: import("@matter/main/types").FixedAttribute<import("@matter/main/clusters").ConcentrationMeasurement.MeasurementUnit, any>;
            };
        };
    }, {
        readonly flags: {
            readonly peakMeasurement: true;
        };
        readonly component: {
            readonly attributes: {
                readonly peakMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly peakMeasuredValueWindow: import("@matter/main/types").Attribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly averageMeasurement: true;
        };
        readonly component: {
            readonly attributes: {
                readonly averageMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly averageMeasuredValueWindow: import("@matter/main/types").Attribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly levelIndication: true;
        };
        readonly component: {
            readonly attributes: {
                readonly levelValue: import("@matter/main/types").Attribute<import("@matter/main/clusters").ConcentrationMeasurement.LevelValue, any>;
            };
        };
    }, {
        readonly flags: {
            readonly mediumLevel: true;
            readonly levelIndication: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly criticalLevel: true;
            readonly levelIndication: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly peakMeasurement: true;
            readonly numericMeasurement: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly averageMeasurement: true;
            readonly numericMeasurement: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly numericMeasurement: false;
            readonly levelIndication: false;
        };
        readonly component: false;
    }];
}>, readonly ["NumericMeasurement"]>, typeof CarbonDioxideConcentrationMeasurementServer, {
    components: never[];
}> | import("@matter/main").ClusterBehavior.Type<import("@matter/main/types").ClusterComposer.WithFeatures<ClusterType.Of<{
    readonly id: 1043;
    readonly name: "NitrogenDioxideConcentrationMeasurement";
    readonly features: {
        readonly numericMeasurement: import("@matter/main/types").BitFlag;
        readonly levelIndication: import("@matter/main/types").BitFlag;
        readonly mediumLevel: import("@matter/main/types").BitFlag;
        readonly criticalLevel: import("@matter/main/types").BitFlag;
        readonly peakMeasurement: import("@matter/main/types").BitFlag;
        readonly averageMeasurement: import("@matter/main/types").BitFlag;
    };
    readonly revision: 3;
    readonly attributes: {
        readonly measurementMedium: import("@matter/main/types").FixedAttribute<import("@matter/main/clusters").ConcentrationMeasurement.MeasurementMedium, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly numericMeasurement: true;
        };
        readonly component: {
            readonly attributes: {
                readonly measuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly minMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly maxMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly uncertainty: import("@matter/main/types").OptionalAttribute<number, any>;
                readonly measurementUnit: import("@matter/main/types").FixedAttribute<import("@matter/main/clusters").ConcentrationMeasurement.MeasurementUnit, any>;
            };
        };
    }, {
        readonly flags: {
            readonly peakMeasurement: true;
        };
        readonly component: {
            readonly attributes: {
                readonly peakMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly peakMeasuredValueWindow: import("@matter/main/types").Attribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly averageMeasurement: true;
        };
        readonly component: {
            readonly attributes: {
                readonly averageMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly averageMeasuredValueWindow: import("@matter/main/types").Attribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly levelIndication: true;
        };
        readonly component: {
            readonly attributes: {
                readonly levelValue: import("@matter/main/types").Attribute<import("@matter/main/clusters").ConcentrationMeasurement.LevelValue, any>;
            };
        };
    }, {
        readonly flags: {
            readonly mediumLevel: true;
            readonly levelIndication: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly criticalLevel: true;
            readonly levelIndication: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly peakMeasurement: true;
            readonly numericMeasurement: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly averageMeasurement: true;
            readonly numericMeasurement: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly numericMeasurement: false;
            readonly levelIndication: false;
        };
        readonly component: false;
    }];
}>, readonly ["NumericMeasurement"]>, typeof NitrogenDioxideConcentrationMeasurementServer, {
    components: never[];
}> | import("@matter/main").ClusterBehavior.Type<import("@matter/main/types").ClusterComposer.WithFeatures<ClusterType.Of<{
    readonly id: 1045;
    readonly name: "OzoneConcentrationMeasurement";
    readonly features: {
        readonly numericMeasurement: import("@matter/main/types").BitFlag;
        readonly levelIndication: import("@matter/main/types").BitFlag;
        readonly mediumLevel: import("@matter/main/types").BitFlag;
        readonly criticalLevel: import("@matter/main/types").BitFlag;
        readonly peakMeasurement: import("@matter/main/types").BitFlag;
        readonly averageMeasurement: import("@matter/main/types").BitFlag;
    };
    readonly revision: 3;
    readonly attributes: {
        readonly measurementMedium: import("@matter/main/types").FixedAttribute<import("@matter/main/clusters").ConcentrationMeasurement.MeasurementMedium, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly numericMeasurement: true;
        };
        readonly component: {
            readonly attributes: {
                readonly measuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly minMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly maxMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly uncertainty: import("@matter/main/types").OptionalAttribute<number, any>;
                readonly measurementUnit: import("@matter/main/types").FixedAttribute<import("@matter/main/clusters").ConcentrationMeasurement.MeasurementUnit, any>;
            };
        };
    }, {
        readonly flags: {
            readonly peakMeasurement: true;
        };
        readonly component: {
            readonly attributes: {
                readonly peakMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly peakMeasuredValueWindow: import("@matter/main/types").Attribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly averageMeasurement: true;
        };
        readonly component: {
            readonly attributes: {
                readonly averageMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly averageMeasuredValueWindow: import("@matter/main/types").Attribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly levelIndication: true;
        };
        readonly component: {
            readonly attributes: {
                readonly levelValue: import("@matter/main/types").Attribute<import("@matter/main/clusters").ConcentrationMeasurement.LevelValue, any>;
            };
        };
    }, {
        readonly flags: {
            readonly mediumLevel: true;
            readonly levelIndication: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly criticalLevel: true;
            readonly levelIndication: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly peakMeasurement: true;
            readonly numericMeasurement: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly averageMeasurement: true;
            readonly numericMeasurement: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly numericMeasurement: false;
            readonly levelIndication: false;
        };
        readonly component: false;
    }];
}>, readonly ["NumericMeasurement"]>, typeof OzoneConcentrationMeasurementServer, {
    components: never[];
}> | import("@matter/main").ClusterBehavior.Type<import("@matter/main/types").ClusterComposer.WithFeatures<ClusterType.Of<{
    readonly id: 1067;
    readonly name: "FormaldehydeConcentrationMeasurement";
    readonly features: {
        readonly numericMeasurement: import("@matter/main/types").BitFlag;
        readonly levelIndication: import("@matter/main/types").BitFlag;
        readonly mediumLevel: import("@matter/main/types").BitFlag;
        readonly criticalLevel: import("@matter/main/types").BitFlag;
        readonly peakMeasurement: import("@matter/main/types").BitFlag;
        readonly averageMeasurement: import("@matter/main/types").BitFlag;
    };
    readonly revision: 3;
    readonly attributes: {
        readonly measurementMedium: import("@matter/main/types").FixedAttribute<import("@matter/main/clusters").ConcentrationMeasurement.MeasurementMedium, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly numericMeasurement: true;
        };
        readonly component: {
            readonly attributes: {
                readonly measuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly minMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly maxMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly uncertainty: import("@matter/main/types").OptionalAttribute<number, any>;
                readonly measurementUnit: import("@matter/main/types").FixedAttribute<import("@matter/main/clusters").ConcentrationMeasurement.MeasurementUnit, any>;
            };
        };
    }, {
        readonly flags: {
            readonly peakMeasurement: true;
        };
        readonly component: {
            readonly attributes: {
                readonly peakMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly peakMeasuredValueWindow: import("@matter/main/types").Attribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly averageMeasurement: true;
        };
        readonly component: {
            readonly attributes: {
                readonly averageMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly averageMeasuredValueWindow: import("@matter/main/types").Attribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly levelIndication: true;
        };
        readonly component: {
            readonly attributes: {
                readonly levelValue: import("@matter/main/types").Attribute<import("@matter/main/clusters").ConcentrationMeasurement.LevelValue, any>;
            };
        };
    }, {
        readonly flags: {
            readonly mediumLevel: true;
            readonly levelIndication: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly criticalLevel: true;
            readonly levelIndication: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly peakMeasurement: true;
            readonly numericMeasurement: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly averageMeasurement: true;
            readonly numericMeasurement: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly numericMeasurement: false;
            readonly levelIndication: false;
        };
        readonly component: false;
    }];
}>, readonly ["NumericMeasurement"]>, typeof FormaldehydeConcentrationMeasurementServer, {
    components: never[];
}> | import("@matter/main").ClusterBehavior.Type<import("@matter/main/types").ClusterComposer.WithFeatures<ClusterType.Of<{
    readonly id: 1068;
    readonly name: "Pm1ConcentrationMeasurement";
    readonly features: {
        readonly numericMeasurement: import("@matter/main/types").BitFlag;
        readonly levelIndication: import("@matter/main/types").BitFlag;
        readonly mediumLevel: import("@matter/main/types").BitFlag;
        readonly criticalLevel: import("@matter/main/types").BitFlag;
        readonly peakMeasurement: import("@matter/main/types").BitFlag;
        readonly averageMeasurement: import("@matter/main/types").BitFlag;
    };
    readonly revision: 3;
    readonly attributes: {
        readonly measurementMedium: import("@matter/main/types").FixedAttribute<import("@matter/main/clusters").ConcentrationMeasurement.MeasurementMedium, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly numericMeasurement: true;
        };
        readonly component: {
            readonly attributes: {
                readonly measuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly minMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly maxMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly uncertainty: import("@matter/main/types").OptionalAttribute<number, any>;
                readonly measurementUnit: import("@matter/main/types").FixedAttribute<import("@matter/main/clusters").ConcentrationMeasurement.MeasurementUnit, any>;
            };
        };
    }, {
        readonly flags: {
            readonly peakMeasurement: true;
        };
        readonly component: {
            readonly attributes: {
                readonly peakMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly peakMeasuredValueWindow: import("@matter/main/types").Attribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly averageMeasurement: true;
        };
        readonly component: {
            readonly attributes: {
                readonly averageMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly averageMeasuredValueWindow: import("@matter/main/types").Attribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly levelIndication: true;
        };
        readonly component: {
            readonly attributes: {
                readonly levelValue: import("@matter/main/types").Attribute<import("@matter/main/clusters").ConcentrationMeasurement.LevelValue, any>;
            };
        };
    }, {
        readonly flags: {
            readonly mediumLevel: true;
            readonly levelIndication: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly criticalLevel: true;
            readonly levelIndication: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly peakMeasurement: true;
            readonly numericMeasurement: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly averageMeasurement: true;
            readonly numericMeasurement: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly numericMeasurement: false;
            readonly levelIndication: false;
        };
        readonly component: false;
    }];
}>, readonly ["NumericMeasurement"]>, typeof Pm1ConcentrationMeasurementServer, {
    components: never[];
}> | import("@matter/main").ClusterBehavior.Type<import("@matter/main/types").ClusterComposer.WithFeatures<ClusterType.Of<{
    readonly id: 1066;
    readonly name: "Pm25ConcentrationMeasurement";
    readonly features: {
        readonly numericMeasurement: import("@matter/main/types").BitFlag;
        readonly levelIndication: import("@matter/main/types").BitFlag;
        readonly mediumLevel: import("@matter/main/types").BitFlag;
        readonly criticalLevel: import("@matter/main/types").BitFlag;
        readonly peakMeasurement: import("@matter/main/types").BitFlag;
        readonly averageMeasurement: import("@matter/main/types").BitFlag;
    };
    readonly revision: 3;
    readonly attributes: {
        readonly measurementMedium: import("@matter/main/types").FixedAttribute<import("@matter/main/clusters").ConcentrationMeasurement.MeasurementMedium, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly numericMeasurement: true;
        };
        readonly component: {
            readonly attributes: {
                readonly measuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly minMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly maxMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly uncertainty: import("@matter/main/types").OptionalAttribute<number, any>;
                readonly measurementUnit: import("@matter/main/types").FixedAttribute<import("@matter/main/clusters").ConcentrationMeasurement.MeasurementUnit, any>;
            };
        };
    }, {
        readonly flags: {
            readonly peakMeasurement: true;
        };
        readonly component: {
            readonly attributes: {
                readonly peakMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly peakMeasuredValueWindow: import("@matter/main/types").Attribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly averageMeasurement: true;
        };
        readonly component: {
            readonly attributes: {
                readonly averageMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly averageMeasuredValueWindow: import("@matter/main/types").Attribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly levelIndication: true;
        };
        readonly component: {
            readonly attributes: {
                readonly levelValue: import("@matter/main/types").Attribute<import("@matter/main/clusters").ConcentrationMeasurement.LevelValue, any>;
            };
        };
    }, {
        readonly flags: {
            readonly mediumLevel: true;
            readonly levelIndication: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly criticalLevel: true;
            readonly levelIndication: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly peakMeasurement: true;
            readonly numericMeasurement: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly averageMeasurement: true;
            readonly numericMeasurement: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly numericMeasurement: false;
            readonly levelIndication: false;
        };
        readonly component: false;
    }];
}>, readonly ["NumericMeasurement"]>, typeof Pm25ConcentrationMeasurementServer, {
    components: never[];
}> | import("@matter/main").ClusterBehavior.Type<import("@matter/main/types").ClusterComposer.WithFeatures<ClusterType.Of<{
    readonly id: 1069;
    readonly name: "Pm10ConcentrationMeasurement";
    readonly features: {
        readonly numericMeasurement: import("@matter/main/types").BitFlag;
        readonly levelIndication: import("@matter/main/types").BitFlag;
        readonly mediumLevel: import("@matter/main/types").BitFlag;
        readonly criticalLevel: import("@matter/main/types").BitFlag;
        readonly peakMeasurement: import("@matter/main/types").BitFlag;
        readonly averageMeasurement: import("@matter/main/types").BitFlag;
    };
    readonly revision: 3;
    readonly attributes: {
        readonly measurementMedium: import("@matter/main/types").FixedAttribute<import("@matter/main/clusters").ConcentrationMeasurement.MeasurementMedium, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly numericMeasurement: true;
        };
        readonly component: {
            readonly attributes: {
                readonly measuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly minMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly maxMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly uncertainty: import("@matter/main/types").OptionalAttribute<number, any>;
                readonly measurementUnit: import("@matter/main/types").FixedAttribute<import("@matter/main/clusters").ConcentrationMeasurement.MeasurementUnit, any>;
            };
        };
    }, {
        readonly flags: {
            readonly peakMeasurement: true;
        };
        readonly component: {
            readonly attributes: {
                readonly peakMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly peakMeasuredValueWindow: import("@matter/main/types").Attribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly averageMeasurement: true;
        };
        readonly component: {
            readonly attributes: {
                readonly averageMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly averageMeasuredValueWindow: import("@matter/main/types").Attribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly levelIndication: true;
        };
        readonly component: {
            readonly attributes: {
                readonly levelValue: import("@matter/main/types").Attribute<import("@matter/main/clusters").ConcentrationMeasurement.LevelValue, any>;
            };
        };
    }, {
        readonly flags: {
            readonly mediumLevel: true;
            readonly levelIndication: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly criticalLevel: true;
            readonly levelIndication: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly peakMeasurement: true;
            readonly numericMeasurement: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly averageMeasurement: true;
            readonly numericMeasurement: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly numericMeasurement: false;
            readonly levelIndication: false;
        };
        readonly component: false;
    }];
}>, readonly ["NumericMeasurement"]>, typeof Pm10ConcentrationMeasurementServer, {
    components: never[];
}> | import("@matter/main").ClusterBehavior.Type<import("@matter/main/types").ClusterComposer.WithFeatures<ClusterType.Of<{
    readonly id: 1071;
    readonly name: "RadonConcentrationMeasurement";
    readonly features: {
        readonly numericMeasurement: import("@matter/main/types").BitFlag;
        readonly levelIndication: import("@matter/main/types").BitFlag;
        readonly mediumLevel: import("@matter/main/types").BitFlag;
        readonly criticalLevel: import("@matter/main/types").BitFlag;
        readonly peakMeasurement: import("@matter/main/types").BitFlag;
        readonly averageMeasurement: import("@matter/main/types").BitFlag;
    };
    readonly revision: 3;
    readonly attributes: {
        readonly measurementMedium: import("@matter/main/types").FixedAttribute<import("@matter/main/clusters").ConcentrationMeasurement.MeasurementMedium, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly numericMeasurement: true;
        };
        readonly component: {
            readonly attributes: {
                readonly measuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly minMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly maxMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly uncertainty: import("@matter/main/types").OptionalAttribute<number, any>;
                readonly measurementUnit: import("@matter/main/types").FixedAttribute<import("@matter/main/clusters").ConcentrationMeasurement.MeasurementUnit, any>;
            };
        };
    }, {
        readonly flags: {
            readonly peakMeasurement: true;
        };
        readonly component: {
            readonly attributes: {
                readonly peakMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly peakMeasuredValueWindow: import("@matter/main/types").Attribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly averageMeasurement: true;
        };
        readonly component: {
            readonly attributes: {
                readonly averageMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly averageMeasuredValueWindow: import("@matter/main/types").Attribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly levelIndication: true;
        };
        readonly component: {
            readonly attributes: {
                readonly levelValue: import("@matter/main/types").Attribute<import("@matter/main/clusters").ConcentrationMeasurement.LevelValue, any>;
            };
        };
    }, {
        readonly flags: {
            readonly mediumLevel: true;
            readonly levelIndication: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly criticalLevel: true;
            readonly levelIndication: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly peakMeasurement: true;
            readonly numericMeasurement: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly averageMeasurement: true;
            readonly numericMeasurement: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly numericMeasurement: false;
            readonly levelIndication: false;
        };
        readonly component: false;
    }];
}>, readonly ["NumericMeasurement"]>, typeof RadonConcentrationMeasurementServer, {
    components: never[];
}> | import("@matter/main").ClusterBehavior.Type<import("@matter/main/types").ClusterComposer.WithFeatures<ClusterType.Of<{
    readonly id: 1070;
    readonly name: "TotalVolatileOrganicCompoundsConcentrationMeasurement";
    readonly features: {
        readonly numericMeasurement: import("@matter/main/types").BitFlag;
        readonly levelIndication: import("@matter/main/types").BitFlag;
        readonly mediumLevel: import("@matter/main/types").BitFlag;
        readonly criticalLevel: import("@matter/main/types").BitFlag;
        readonly peakMeasurement: import("@matter/main/types").BitFlag;
        readonly averageMeasurement: import("@matter/main/types").BitFlag;
    };
    readonly revision: 3;
    readonly attributes: {
        readonly measurementMedium: import("@matter/main/types").FixedAttribute<import("@matter/main/clusters").ConcentrationMeasurement.MeasurementMedium, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly numericMeasurement: true;
        };
        readonly component: {
            readonly attributes: {
                readonly measuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly minMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly maxMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly uncertainty: import("@matter/main/types").OptionalAttribute<number, any>;
                readonly measurementUnit: import("@matter/main/types").FixedAttribute<import("@matter/main/clusters").ConcentrationMeasurement.MeasurementUnit, any>;
            };
        };
    }, {
        readonly flags: {
            readonly peakMeasurement: true;
        };
        readonly component: {
            readonly attributes: {
                readonly peakMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly peakMeasuredValueWindow: import("@matter/main/types").Attribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly averageMeasurement: true;
        };
        readonly component: {
            readonly attributes: {
                readonly averageMeasuredValue: import("@matter/main/types").Attribute<number | null, any>;
                readonly averageMeasuredValueWindow: import("@matter/main/types").Attribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly levelIndication: true;
        };
        readonly component: {
            readonly attributes: {
                readonly levelValue: import("@matter/main/types").Attribute<import("@matter/main/clusters").ConcentrationMeasurement.LevelValue, any>;
            };
        };
    }, {
        readonly flags: {
            readonly mediumLevel: true;
            readonly levelIndication: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly criticalLevel: true;
            readonly levelIndication: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly peakMeasurement: true;
            readonly numericMeasurement: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly averageMeasurement: true;
            readonly numericMeasurement: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly numericMeasurement: false;
            readonly levelIndication: false;
        };
        readonly component: false;
    }];
}>, readonly ["NumericMeasurement"]>, typeof TotalVolatileOrganicCompoundsConcentrationMeasurementServer, {
    components: never[];
}>;
export declare function getBehaviourTypeFromClusterClientId(_clusterId: ClusterId): void;
export declare function getBehavior(endpoint: MatterbridgeEndpoint, cluster: Behavior.Type | ClusterType | ClusterId | string): Behavior.Type | undefined;
export declare function invokeBehaviorCommand(endpoint: MatterbridgeEndpoint, cluster: Behavior.Type | ClusterType | ClusterId | string, command: keyof MatterbridgeEndpointCommands, params?: Record<string, boolean | number | bigint | string | object | null>): Promise<boolean>;
export declare function addRequiredClusterServers(endpoint: MatterbridgeEndpoint): void;
export declare function addOptionalClusterServers(endpoint: MatterbridgeEndpoint): void;
/**
 * Adds cluster servers to the specified endpoint based on the provided server list.
 *
 * @param {MatterbridgeEndpoint} endpoint - The endpoint to add the cluster servers to.
 * @param {ClusterId[]} serverList - The list of cluster IDs to add.
 * @returns void
 */
export declare function addClusterServers(endpoint: MatterbridgeEndpoint, serverList: ClusterId[]): void;
/**
 * Adds a fixed label to the FixedLabel cluster. The FixedLabel cluster is created if it does not exist.
 *
 * @param {MatterbridgeEndpoint} endpoint - The endpoint to add the cluster servers to.
 * @param {string} label - The label to add.
 * @param {string} value - The value of the label.
 */
export declare function addFixedLabel(endpoint: MatterbridgeEndpoint, label: string, value: string): Promise<void>;
/**
 * Adds a user label to the UserLabel cluster. The UserLabel cluster is created if it does not exist.
 *
 * @param {MatterbridgeEndpoint} endpoint - The endpoint to add the cluster servers to.
 * @param {string} label - The label to add.
 * @param {string} value - The value of the label.
 */
export declare function addUserLabel(endpoint: MatterbridgeEndpoint, label: string, value: string): Promise<void>;
export declare function optionsFor<T extends Behavior.Type>(type: T, options: Behavior.Options<T>): Behavior.Options<T>;
export declare function getClusterId(endpoint: Endpoint, cluster: string): number | undefined;
export declare function getAttributeId(endpoint: Endpoint, cluster: string, attribute: string): number | undefined;
/**
 * Retrieves the value of the provided attribute from the given cluster.
 *
 * @param {MatterbridgeEndpoint} endpoint - The endpoint to retrieve the attribute from.
 * @param {Behavior.Type | ClusterType | ClusterId | string} cluster - The cluster to retrieve the attribute from.
 * @param {string} attribute - The name of the attribute to retrieve.
 * @param {AnsiLogger} [log] - (Optional) The logger to use for logging the retrieve. Errors are logged to the endpoint logger.
 * @returns {any} The value of the attribute, or undefined if the attribute is not found.
 */
export declare function getAttribute(endpoint: MatterbridgeEndpoint, cluster: Behavior.Type | ClusterType | ClusterId | string, attribute: string, log?: AnsiLogger): any;
/**
 * Sets the value of an attribute on a cluster server.
 *
 * @param {MatterbridgeEndpoint} endpoint - The endpoint to set the attribute on.
 * @param {Behavior.Type | ClusterType | ClusterId | string} cluster - The cluster to set the attribute on.
 * @param {string} attribute - The name of the attribute.
 * @param {boolean | number | bigint | string | object | null} value - The value to set for the attribute.
 * @param {AnsiLogger} [log] - (Optional) The logger to use for logging the set. Errors are logged to the endpoint logger.
 * @returns {Promise<boolean>} - A promise that resolves to a boolean indicating whether the attribute was successfully set.
 */
export declare function setAttribute(endpoint: MatterbridgeEndpoint, cluster: Behavior.Type | ClusterType | ClusterId | string, attribute: string, value: boolean | number | bigint | string | object | null, log?: AnsiLogger): Promise<boolean>;
/**
 * Sets the value of an attribute on a cluster server.
 *
 * @param {MatterbridgeEndpoint} endpoint - The endpoint to update the attribute on.
 * @param {Behavior.Type | ClusterType | ClusterId | string} cluster - The cluster to update the attribute on.
 * @param {string} attribute - The name of the attribute.
 * @param {boolean | number | bigint | string | object | null} value - The value to set for the attribute.
 * @param {AnsiLogger} [log] - (Optional) The logger to use for logging the update. Errors are logged to the endpoint logger.
 * @returns {Promise<boolean>} - A promise that resolves to a boolean indicating whether the attribute was successfully set.
 */
export declare function updateAttribute(endpoint: MatterbridgeEndpoint, cluster: Behavior.Type | ClusterType | ClusterId | string, attribute: string, value: boolean | number | bigint | string | object | null, log?: AnsiLogger): Promise<boolean>;
/**
 * Subscribes to the provided attribute on a cluster.
 *
 * @param {MatterbridgeEndpoint} endpoint - The endpoint to subscribe the attribute to.
 * @param {Behavior.Type | ClusterType | ClusterId | string} cluster - The cluster to subscribe the attribute to.
 * @param {string} attribute - The name of the attribute to subscribe to.
 * @param {(newValue: any, oldValue: any) => void} listener - A callback function that will be called when the attribute value changes.
 * @param {AnsiLogger} [log] - Optional logger for logging errors and information.
 * @returns {boolean} - A boolean indicating whether the subscription was successful.
 */
export declare function subscribeAttribute(endpoint: MatterbridgeEndpoint, cluster: Behavior.Type | ClusterType | ClusterId | string, attribute: string, listener: (newValue: any, oldValue: any) => void, log?: AnsiLogger): Promise<boolean>;
/**
 * Get the default OperationalState Cluster Server.
 *
 * @param {OperationalState.OperationalStateEnum} operationalState - The initial operational state.
 */
export declare function getDefaultOperationalStateClusterServer(operationalState?: OperationalState.OperationalStateEnum): Partial<{
    phaseList: string[] | null;
    currentPhase: number | null;
    operationalStateList: {
        operationalStateId: number;
        operationalStateLabel?: string | undefined;
    }[];
    operationalState: number;
    operationalError: {
        errorStateId: number;
        errorStateLabel?: string | undefined;
        errorStateDetails?: string | undefined;
    };
    countdownTime?: number | null | undefined;
}>;
/**
 * Get the default TemperatureMeasurement cluster server options.
 *
 * @param {number | null} measuredValue - The measured value of the temperature x 100.
 * @param {number | null} minMeasuredValue - The minimum measured value of the temperature x 100.
 * @param {number | null} maxMeasuredValue - The maximum measured value of the temperature x 100.
 */
export declare function getDefaultTemperatureMeasurementClusterServer(measuredValue?: number | null, minMeasuredValue?: number | null, maxMeasuredValue?: number | null): Partial<{
    measuredValue: number | null;
    minMeasuredValue: number | null;
    maxMeasuredValue: number | null;
    tolerance?: number | undefined;
}>;
/**
 * Get the default RelativeHumidityMeasurement cluster server options.
 *
 * @param {number | null} measuredValue - The measured value of the relative humidity x 100.
 * @param {number | null} minMeasuredValue - The minimum measured value of the relative humidity x 100.
 * @param {number | null} maxMeasuredValue - The maximum measured value of the relative humidity x 100.
 */
export declare function getDefaultRelativeHumidityMeasurementClusterServer(measuredValue?: number | null, minMeasuredValue?: number | null, maxMeasuredValue?: number | null): Partial<{
    measuredValue: number | null;
    minMeasuredValue: number | null;
    maxMeasuredValue: number | null;
    tolerance?: number | undefined;
}>;
/**
 * Get the default PressureMeasurement cluster server options.
 *
 * @param {number | null} measuredValue - The measured value for the pressure.
 * @param {number | null} minMeasuredValue - The minimum measured value for the pressure.
 * @param {number | null} maxMeasuredValue - The maximum measured value for the pressure.
 */
export declare function getDefaultPressureMeasurementClusterServer(measuredValue?: number | null, minMeasuredValue?: number | null, maxMeasuredValue?: number | null): Partial<{
    measuredValue: number | null;
    minMeasuredValue: number | null;
    maxMeasuredValue: number | null;
    tolerance?: number | undefined;
}>;
/**
 * Get the default IlluminanceMeasurement cluster server options.
 *
 * @param {number | null} measuredValue - The measured value of illuminance.
 * @param {number | null} minMeasuredValue - The minimum measured value of illuminance.
 * @param {number | null} maxMeasuredValue - The maximum measured value of illuminance.
 * @remark The default value for the illuminance measurement is null.
 * This attribute SHALL indicate the illuminance in Lux (symbol lx) as follows:
 *   MeasuredValue = 10,000 x log10(illuminance) + 1,
 *    where 1 lx <= illuminance <= 3.576 Mlx, corresponding to a MeasuredValue in the range 1 to 0xFFFE.
 *  0 indicates a value of illuminance that is too low to be measured
 *  null indicates that the illuminance measurement is invalid.
 */
export declare function getDefaultIlluminanceMeasurementClusterServer(measuredValue?: number | null, minMeasuredValue?: number | null, maxMeasuredValue?: number | null): Partial<{
    measuredValue: number | null;
    minMeasuredValue: number | null;
    maxMeasuredValue: number | null;
    tolerance?: number | undefined;
    lightSensorType?: number | null | undefined;
}>;
/**
 * Get the default FlowMeasurement cluster server options.
 *
 * @param {number | null} measuredValue - The measured value of the flow in 10 x m3/h.
 * @param {number | null} minMeasuredValue - The minimum measured value of the flow in 10 x m3/h.
 * @param {number | null} maxMeasuredValue - The maximum measured value of the flow in 10 x m3/h.
 */
export declare function getDefaultFlowMeasurementClusterServer(measuredValue?: number | null, minMeasuredValue?: number | null, maxMeasuredValue?: number | null): Partial<{
    measuredValue: number | null;
    minMeasuredValue: number | null;
    maxMeasuredValue: number | null;
    tolerance?: number | undefined;
}>;
/**
 * Get the default OccupancySensing cluster server options.
 *
 * @param {boolean} occupied - A boolean indicating whether the occupancy is occupied or not. Default is false.
 * @param {number} holdTime - The hold time in seconds. Default is 30.
 * @param {number} holdTimeMin - The minimum hold time in seconds. Default is 1.
 * @param {number} holdTimeMax - The maximum hold time in seconds. Default is 300.
 *
 * @remark The default value for the occupancy sensor type is PIR.
 * Servers SHALL set these attributes for backward compatibility with clients implementing a cluster revision <= 4 as
 * described in OccupancySensorType and OccupancySensorTypeBitmap Attributes.
 * This replaces the 9 legacy attributes PIROccupiedToUnoccupiedDelay through PhysicalContactUnoccupiedToOccupiedThreshold.
 */
export declare function getDefaultOccupancySensingClusterServer(occupied?: boolean, holdTime?: number, holdTimeMin?: number, holdTimeMax?: number): Partial<{
    occupancy: {
        occupied?: boolean | undefined;
    };
    holdTime?: number | undefined;
    pirOccupiedToUnoccupiedDelay?: number | undefined;
    pirUnoccupiedToOccupiedDelay?: number | undefined;
    pirUnoccupiedToOccupiedThreshold?: number | undefined;
    occupancySensorType: number;
    occupancySensorTypeBitmap: {
        pir?: boolean | undefined;
        ultrasonic?: boolean | undefined;
        physicalContact?: boolean | undefined;
    };
    holdTimeLimits?: {
        holdTimeMin: number;
        holdTimeMax: number;
        holdTimeDefault: number;
    } | undefined;
}>;
//# sourceMappingURL=matterbridgeEndpointHelpers.d.ts.map