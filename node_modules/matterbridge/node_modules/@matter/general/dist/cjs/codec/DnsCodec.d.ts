/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Endian } from "../util/Bytes.js";
import { DataReader } from "../util/DataReader.js";
/**
 * The maximum MDNS message size to usually fit into one UDP network MTU packet. Data are split into multiple messages
 * when needed.
 */
export declare const MAX_MDNS_MESSAGE_SIZE = 1232;
export declare const PtrRecord: (name: string, ptr: string, forInstance?: string, ttl?: number, flushCache?: boolean) => DnsRecord<string>;
export declare const ARecord: (name: string, ip: string, ttl?: number, flushCache?: boolean) => DnsRecord<string>;
export declare const AAAARecord: (name: string, ip: string, ttl?: number, flushCache?: boolean) => DnsRecord<string>;
export declare const TxtRecord: (name: string, entries: string[], forInstance?: string, ttl?: number, flushCache?: boolean) => DnsRecord<string[]>;
export declare const SrvRecord: (name: string, srv: SrvRecordValue, forInstance?: string, ttl?: number, flushCache?: boolean) => DnsRecord<SrvRecordValue>;
export type SrvRecordValue = {
    priority: number;
    weight: number;
    port: number;
    target: string;
};
export type DnsQuery = {
    name: string;
    recordType: DnsRecordType;
    recordClass: DnsRecordClass;
    uniCastResponse?: boolean;
};
export type DnsRecord<T> = {
    name: string;
    recordType: DnsRecordType;
    recordClass: DnsRecordClass;
    flushCache?: boolean;
    ttl: number;
    value: T;
    forInstance?: string;
};
export type DnsMessage = {
    transactionId: number;
    messageType: DnsMessageType;
    queries: DnsQuery[];
    answers: DnsRecord<any>[];
    authorities: DnsRecord<any>[];
    additionalRecords: DnsRecord<any>[];
};
export type DnsMessagePartiallyPreEncoded = Omit<DnsMessage, "answers" | "additionalRecords"> & {
    answers: (DnsRecord<any> | Uint8Array)[];
    additionalRecords: (DnsRecord<any> | Uint8Array)[];
};
export declare enum DnsMessageType {
    Query = 0,
    TruncatedQuery = 512,
    Response = 33792,// Authoritative Answer
    TruncatedResponse = 34304
}
export declare enum DnsRecordType {
    A = 1,
    PTR = 12,
    TXT = 16,
    AAAA = 28,
    SRV = 33,
    NSEC = 47,
    ANY = 255
}
export declare enum DnsRecordClass {
    IN = 1,
    ANY = 255
}
export declare class DnsCodec {
    static decode(message: Uint8Array): DnsMessage | undefined;
    static decodeQuery(reader: DataReader<Endian.Big>, message: Uint8Array): DnsQuery;
    static decodeRecord(reader: DataReader<Endian.Big>, message: Uint8Array): DnsRecord<any>;
    static decodeQName(reader: DataReader<Endian.Big>, message: Uint8Array, visited?: Set<number>): string;
    private static decodeRecordValue;
    static decodeSrvRecord(valueBytes: Uint8Array, message: Uint8Array): SrvRecordValue;
    static decodeTxtRecord(valueBytes: Uint8Array): string[];
    static decodeAaaaRecord(valueBytes: Uint8Array): string;
    static decodeARecord(valueBytes: Uint8Array): string;
    static encode({ messageType, transactionId, queries, answers, authorities, additionalRecords, }: Partial<DnsMessagePartiallyPreEncoded>): Uint8Array;
    static encodeRecord(record: DnsRecord<any>): Uint8Array;
    private static encodeRecordValue;
    static encodeARecord(ip: string): Uint8Array<ArrayBufferLike>;
    static encodeAaaaRecord(ip: string): Uint8Array<ArrayBufferLike>;
    static encodeTxtRecord(entries: string[]): Uint8Array<ArrayBufferLike>;
    static encodeSrvRecord({ priority, weight, port, target }: SrvRecordValue): Uint8Array<ArrayBufferLike>;
    static encodeQName(qname: string): Uint8Array<ArrayBufferLike>;
}
//# sourceMappingURL=DnsCodec.d.ts.map