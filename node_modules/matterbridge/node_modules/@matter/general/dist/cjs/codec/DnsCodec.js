"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var DnsCodec_exports = {};
__export(DnsCodec_exports, {
  AAAARecord: () => AAAARecord,
  ARecord: () => ARecord,
  DnsCodec: () => DnsCodec,
  DnsMessageType: () => DnsMessageType,
  DnsRecordClass: () => DnsRecordClass,
  DnsRecordType: () => DnsRecordType,
  MAX_MDNS_MESSAGE_SIZE: () => MAX_MDNS_MESSAGE_SIZE,
  PtrRecord: () => PtrRecord,
  SrvRecord: () => SrvRecord,
  TxtRecord: () => TxtRecord
});
module.exports = __toCommonJS(DnsCodec_exports);
var import_MatterError = require("../MatterError.js");
var import_Bytes = require("../util/Bytes.js");
var import_DataReader = require("../util/DataReader.js");
var import_DataWriter = require("../util/DataWriter.js");
var import_Ip = require("../util/Ip.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const MAX_MDNS_MESSAGE_SIZE = 1232;
const PtrRecord = (name, ptr, forInstance, ttl = 120, flushCache = false) => ({
  name,
  value: ptr,
  ttl,
  recordType: 12 /* PTR */,
  recordClass: 1 /* IN */,
  flushCache,
  forInstance
});
const ARecord = (name, ip, ttl = 120, flushCache = false) => ({
  name,
  value: ip,
  ttl,
  recordType: 1 /* A */,
  recordClass: 1 /* IN */,
  flushCache
});
const AAAARecord = (name, ip, ttl = 120, flushCache = false) => ({
  name,
  value: ip,
  ttl,
  recordType: 28 /* AAAA */,
  recordClass: 1 /* IN */,
  flushCache
});
const TxtRecord = (name, entries, forInstance, ttl = 120, flushCache = false) => ({
  name,
  value: entries,
  ttl,
  recordType: 16 /* TXT */,
  recordClass: 1 /* IN */,
  flushCache,
  forInstance
});
const SrvRecord = (name, srv, forInstance, ttl = 120, flushCache = false) => ({
  name,
  value: srv,
  ttl,
  recordType: 33 /* SRV */,
  recordClass: 1 /* IN */,
  flushCache,
  forInstance
});
var DnsMessageType = /* @__PURE__ */ ((DnsMessageType2) => {
  DnsMessageType2[DnsMessageType2["Query"] = 0] = "Query";
  DnsMessageType2[DnsMessageType2["TruncatedQuery"] = 512] = "TruncatedQuery";
  DnsMessageType2[DnsMessageType2["Response"] = 33792] = "Response";
  DnsMessageType2[DnsMessageType2["TruncatedResponse"] = 34304] = "TruncatedResponse";
  return DnsMessageType2;
})(DnsMessageType || {});
var DnsRecordType = /* @__PURE__ */ ((DnsRecordType2) => {
  DnsRecordType2[DnsRecordType2["A"] = 1] = "A";
  DnsRecordType2[DnsRecordType2["PTR"] = 12] = "PTR";
  DnsRecordType2[DnsRecordType2["TXT"] = 16] = "TXT";
  DnsRecordType2[DnsRecordType2["AAAA"] = 28] = "AAAA";
  DnsRecordType2[DnsRecordType2["SRV"] = 33] = "SRV";
  DnsRecordType2[DnsRecordType2["NSEC"] = 47] = "NSEC";
  DnsRecordType2[DnsRecordType2["ANY"] = 255] = "ANY";
  return DnsRecordType2;
})(DnsRecordType || {});
var DnsRecordClass = /* @__PURE__ */ ((DnsRecordClass2) => {
  DnsRecordClass2[DnsRecordClass2["IN"] = 1] = "IN";
  DnsRecordClass2[DnsRecordClass2["ANY"] = 255] = "ANY";
  return DnsRecordClass2;
})(DnsRecordClass || {});
class DnsCodec {
  static decode(message) {
    try {
      const reader = new import_DataReader.DataReader(message, import_Bytes.Endian.Big);
      const transactionId = reader.readUInt16();
      const messageType = reader.readUInt16();
      const queriesCount = reader.readUInt16();
      const answersCount = reader.readUInt16();
      const authoritiesCount = reader.readUInt16();
      const additionalRecordsCount = reader.readUInt16();
      const queries = new Array();
      for (let i = 0; i < queriesCount; i++) {
        queries.push(this.decodeQuery(reader, message));
      }
      const answers = new Array();
      for (let i = 0; i < answersCount; i++) {
        answers.push(this.decodeRecord(reader, message));
      }
      const authorities = new Array();
      for (let i = 0; i < authoritiesCount; i++) {
        authorities.push(this.decodeRecord(reader, message));
      }
      const additionalRecords = new Array();
      for (let i = 0; i < additionalRecordsCount; i++) {
        additionalRecords.push(this.decodeRecord(reader, message));
      }
      return { transactionId, messageType, queries, answers, authorities, additionalRecords };
    } catch (error) {
      return void 0;
    }
  }
  static decodeQuery(reader, message) {
    const name = this.decodeQName(reader, message);
    const recordType = reader.readUInt16();
    const classInt = reader.readUInt16();
    const uniCastResponse = (classInt & 32768) !== 0;
    const recordClass = classInt & 32767;
    return { name, recordType, recordClass, uniCastResponse };
  }
  static decodeRecord(reader, message) {
    const name = this.decodeQName(reader, message);
    const recordType = reader.readUInt16();
    const classInt = reader.readUInt16();
    const flushCache = (classInt & 32768) !== 0;
    const recordClass = classInt & 32767;
    const ttl = reader.readUInt32();
    const valueLength = reader.readUInt16();
    const valueBytes = reader.readByteArray(valueLength);
    const value = this.decodeRecordValue(valueBytes, recordType, message);
    return { name, recordType, recordClass, ttl, value, flushCache };
  }
  static decodeQName(reader, message, visited = /* @__PURE__ */ new Set()) {
    if (visited.has(reader.offset)) {
      throw new import_MatterError.UnexpectedDataError(`QNAME pointer loop detected. Index ${reader.offset} visited twice.`);
    }
    visited.add(reader.offset);
    const messageReader = new import_DataReader.DataReader(message, import_Bytes.Endian.Big);
    const qNameItems = new Array();
    while (true) {
      const itemLength = reader.readUInt8();
      if (itemLength === 0) break;
      if ((itemLength & 192) !== 0) {
        if (reader.remainingBytesCount < 1) {
          throw new import_MatterError.UnexpectedDataError("QNAME pointer exceeds remaining bytes.");
        }
        const indexInMessage = reader.readUInt8() | (itemLength & 63) << 8;
        if (indexInMessage >= message.length) {
          throw new import_MatterError.UnexpectedDataError("Invalid compressed QNAME pointer pointing to out of bounds index.");
        }
        messageReader.offset = indexInMessage;
        qNameItems.push(this.decodeQName(messageReader, message, visited));
        break;
      } else if (reader.remainingBytesCount < itemLength + 1) {
        throw new import_MatterError.UnexpectedDataError(`QNAME item length ${itemLength} exceeds remaining bytes.`);
      }
      qNameItems.push(reader.readUtf8String(itemLength));
    }
    return qNameItems.join(".");
  }
  static decodeRecordValue(valueBytes, recordType, message) {
    switch (recordType) {
      case 12 /* PTR */:
        return this.decodeQName(new import_DataReader.DataReader(valueBytes, import_Bytes.Endian.Big), message);
      case 33 /* SRV */:
        return this.decodeSrvRecord(valueBytes, message);
      case 16 /* TXT */:
        return this.decodeTxtRecord(valueBytes);
      case 28 /* AAAA */:
        return this.decodeAaaaRecord(valueBytes);
      case 1 /* A */:
        return this.decodeARecord(valueBytes);
      default:
        return valueBytes;
    }
  }
  static decodeSrvRecord(valueBytes, message) {
    const reader = new import_DataReader.DataReader(valueBytes, import_Bytes.Endian.Big);
    const priority = reader.readUInt16();
    const weight = reader.readUInt16();
    const port = reader.readUInt16();
    const target = this.decodeQName(reader, message);
    return { priority, weight, port, target };
  }
  static decodeTxtRecord(valueBytes) {
    const reader = new import_DataReader.DataReader(valueBytes, import_Bytes.Endian.Big);
    const result = new Array();
    let bytesRead = 0;
    while (bytesRead < valueBytes.length) {
      const length = reader.readUInt8();
      result.push(reader.readUtf8String(length));
      bytesRead += length + 1;
    }
    return result;
  }
  static decodeAaaaRecord(valueBytes) {
    const reader = new import_DataReader.DataReader(valueBytes, import_Bytes.Endian.Big);
    const ipItems = new Array();
    for (let i = 0; i < 8; i++) {
      ipItems.push(reader.readUInt16().toString(16));
    }
    const zeroSequences = new Array();
    for (let i = 0; i < 8; i++) {
      if (ipItems[i] !== "0") continue;
      const start = i;
      i++;
      while (i < 8 && ipItems[i] === "0") {
        i++;
      }
      zeroSequences.push({ start, length: i - start });
    }
    if (zeroSequences.length > 0) {
      zeroSequences.sort((a, b) => a.length - b.length);
      const { start, length } = zeroSequences[0];
      ipItems[start] = "";
      ipItems.splice(start + 1, length - 1);
    }
    return ipItems.join(":");
  }
  static decodeARecord(valueBytes) {
    const reader = new import_DataReader.DataReader(valueBytes, import_Bytes.Endian.Big);
    const ipItems = new Array();
    for (let i = 0; i < 4; i++) {
      ipItems.push(reader.readUInt8().toString());
    }
    return ipItems.join(".");
  }
  static encode({
    messageType,
    transactionId = 0,
    queries = [],
    answers = [],
    authorities = [],
    additionalRecords = []
  }) {
    if (messageType === void 0) throw new import_MatterError.InternalError("Message type must be specified!");
    if (queries.length > 0 && messageType !== 0 /* Query */ && messageType !== 512 /* TruncatedQuery */)
      throw new import_MatterError.InternalError("Queries can only be included in query messages!");
    if (authorities.length > 0) throw new import_MatterError.NotImplementedError("Authority answers are not supported yet!");
    const writer = new import_DataWriter.DataWriter(import_Bytes.Endian.Big);
    writer.writeUInt16(transactionId);
    writer.writeUInt16(messageType);
    writer.writeUInt16(queries.length);
    writer.writeUInt16(answers.length);
    writer.writeUInt16(authorities.length);
    writer.writeUInt16(additionalRecords.length);
    queries.forEach(({ name, recordClass, recordType, uniCastResponse = false }) => {
      writer.writeByteArray(this.encodeQName(name));
      writer.writeUInt16(recordType);
      writer.writeUInt16(recordClass | (uniCastResponse ? 32768 : 0));
    });
    [...answers, ...authorities, ...additionalRecords].forEach((record) => {
      if (record instanceof Uint8Array) {
        writer.writeByteArray(record);
      } else {
        writer.writeByteArray(this.encodeRecord(record));
      }
    });
    return writer.toByteArray();
  }
  static encodeRecord(record) {
    const { name, recordType, recordClass, ttl, value, flushCache = false } = record;
    const writer = new import_DataWriter.DataWriter(import_Bytes.Endian.Big);
    writer.writeByteArray(this.encodeQName(name));
    writer.writeUInt16(recordType);
    writer.writeUInt16(recordClass | (flushCache ? 32768 : 0));
    writer.writeUInt32(ttl);
    const encodedValue = this.encodeRecordValue(value, recordType);
    writer.writeUInt16(encodedValue.length);
    writer.writeByteArray(encodedValue);
    return writer.toByteArray();
  }
  static encodeRecordValue(value, recordType) {
    switch (recordType) {
      case 12 /* PTR */:
        return this.encodeQName(value);
      case 33 /* SRV */:
        return this.encodeSrvRecord(value);
      case 16 /* TXT */:
        return this.encodeTxtRecord(value);
      case 28 /* AAAA */:
        return this.encodeAaaaRecord(value);
      case 1 /* A */:
        return this.encodeARecord(value);
      default:
        if (value instanceof Uint8Array) return value;
        throw new import_MatterError.UnexpectedDataError(`Unsupported record type ${recordType}`);
    }
  }
  static encodeARecord(ip) {
    if (!(0, import_Ip.isIPv4)(ip)) throw new import_MatterError.UnexpectedDataError(`Invalid A Record value: ${ip}`);
    const writer = new import_DataWriter.DataWriter(import_Bytes.Endian.Big);
    ip.split(".").forEach((part) => {
      writer.writeUInt8(parseInt(part));
    });
    return writer.toByteArray();
  }
  static encodeAaaaRecord(ip) {
    if (!(0, import_Ip.isIPv6)(ip)) throw new import_MatterError.UnexpectedDataError(`Invalid AAAA Record value: ${ip}`);
    const writer = new import_DataWriter.DataWriter(import_Bytes.Endian.Big);
    const parts = ip.split(":");
    parts.forEach((part) => {
      if (part === "") {
        const compressedParts = 8 - parts.length;
        for (let i = 0; i < compressedParts; i++) {
          writer.writeUInt16(0);
        }
      }
      writer.writeUInt16(parseInt(part, 16));
    });
    return writer.toByteArray();
  }
  static encodeTxtRecord(entries) {
    const writer = new import_DataWriter.DataWriter(import_Bytes.Endian.Big);
    entries.forEach((entry) => {
      const entryData = import_Bytes.Bytes.fromString(entry);
      writer.writeUInt8(entryData.length);
      writer.writeByteArray(entryData);
    });
    return writer.toByteArray();
  }
  static encodeSrvRecord({ priority, weight, port, target }) {
    const writer = new import_DataWriter.DataWriter(import_Bytes.Endian.Big);
    writer.writeUInt16(priority);
    writer.writeUInt16(weight);
    writer.writeUInt16(port);
    writer.writeByteArray(this.encodeQName(target));
    return writer.toByteArray();
  }
  static encodeQName(qname) {
    const writer = new import_DataWriter.DataWriter(import_Bytes.Endian.Big);
    if (qname !== void 0 && qname.length > 0) {
      qname.split(".").forEach((label) => {
        const labelData = import_Bytes.Bytes.fromString(label);
        writer.writeUInt8(labelData.length);
        writer.writeByteArray(labelData);
      });
    }
    writer.writeUInt8(0);
    return writer.toByteArray();
  }
}
//# sourceMappingURL=DnsCodec.js.map
