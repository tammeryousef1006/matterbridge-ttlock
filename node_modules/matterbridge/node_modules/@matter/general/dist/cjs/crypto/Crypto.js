"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
var Crypto_exports = {};
__export(Crypto_exports, {
  CRYPTO_AUTH_TAG_LENGTH: () => CRYPTO_AUTH_TAG_LENGTH,
  CRYPTO_EC_CURVE: () => CRYPTO_EC_CURVE,
  CRYPTO_EC_KEY_BYTES: () => CRYPTO_EC_KEY_BYTES,
  CRYPTO_ENCRYPT_ALGORITHM: () => CRYPTO_ENCRYPT_ALGORITHM,
  CRYPTO_HASH_ALGORITHM: () => CRYPTO_HASH_ALGORITHM,
  CRYPTO_RANDOM_LENGTH: () => CRYPTO_RANDOM_LENGTH,
  CRYPTO_SYMMETRIC_KEY_LENGTH: () => CRYPTO_SYMMETRIC_KEY_LENGTH,
  Crypto: () => Crypto,
  CryptoVerifyError: () => CryptoVerifyError,
  ec: () => ec
});
module.exports = __toCommonJS(Crypto_exports);
var import_Boot = require("#util/Boot.js");
var mod = __toESM(require("@noble/curves/abstract/modular"), 1);
var utils = __toESM(require("@noble/curves/abstract/utils"), 1);
var import_p256 = require("@noble/curves/p256");
var import_MatterError = require("../MatterError.js");
var import_Bytes = require("../util/Bytes.js");
var import_DataReader = require("../util/DataReader.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const ec = {
  p256: import_p256.p256,
  ...utils,
  ...mod
};
const CRYPTO_RANDOM_LENGTH = 32;
const CRYPTO_ENCRYPT_ALGORITHM = "aes-128-ccm";
const CRYPTO_HASH_ALGORITHM = "sha256";
const CRYPTO_EC_CURVE = "prime256v1";
const CRYPTO_EC_KEY_BYTES = 32;
const CRYPTO_AUTH_TAG_LENGTH = 16;
const CRYPTO_SYMMETRIC_KEY_LENGTH = 16;
class CryptoVerifyError extends import_MatterError.MatterError {
}
class Crypto {
  static get;
  static encrypt = (key, data, nonce, aad) => Crypto.get().encrypt(key, data, nonce, aad);
  static decrypt = (key, data, nonce, aad) => Crypto.get().decrypt(key, data, nonce, aad);
  static getRandomData = (length) => Crypto.get().getRandomData(length);
  static getRandom = () => Crypto.get().getRandomData(CRYPTO_RANDOM_LENGTH);
  static getRandomUInt16 = () => new import_DataReader.DataReader(Crypto.get().getRandomData(2), import_Bytes.Endian.Little).readUInt16();
  static getRandomUInt32 = () => new import_DataReader.DataReader(Crypto.get().getRandomData(4), import_Bytes.Endian.Little).readUInt32();
  static getRandomBigUInt64 = () => new import_DataReader.DataReader(Crypto.get().getRandomData(8), import_Bytes.Endian.Little).readUInt64();
  static getRandomBigInt = (size, maxValue) => {
    const { bytesToNumberBE } = ec;
    if (maxValue === void 0) {
      return bytesToNumberBE(Crypto.getRandomData(size));
    }
    while (true) {
      const random = bytesToNumberBE(Crypto.getRandomData(size));
      if (random < maxValue) return random;
    }
  };
  static ecdhGeneratePublicKey = () => Crypto.get().ecdhGeneratePublicKey();
  static ecdhGeneratePublicKeyAndSecret = (peerPublicKey) => Crypto.get().ecdhGeneratePublicKeyAndSecret(peerPublicKey);
  static ecdhGenerateSecret = (peerPublicKey, ecdh) => Crypto.get().ecdhGenerateSecret(peerPublicKey, ecdh);
  static hash = (data) => Crypto.get().hash(data);
  static pbkdf2 = (secret, salt, iteration, keyLength) => Crypto.get().pbkdf2(secret, salt, iteration, keyLength);
  static hkdf = (secret, salt, info, length) => Crypto.get().hkdf(secret, salt, info, length);
  static hmac = (key, data) => Crypto.get().hmac(key, data);
  static sign = (privateKey, data, dsaEncoding) => Crypto.get().sign(privateKey, data, dsaEncoding);
  static verify = (publicKey, data, signature, dsaEncoding) => Crypto.get().verify(publicKey, data, signature, dsaEncoding);
  static createKeyPair = () => Crypto.get().createKeyPair();
}
import_Boot.Boot.init(() => {
  Crypto.get = () => {
    throw new import_MatterError.NoProviderError("No provider configured");
  };
  if (typeof MatterHooks !== "undefined") {
    MatterHooks.cryptoSetup?.(Crypto);
  }
});
//# sourceMappingURL=Crypto.js.map
