"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
var Spake2p_exports = {};
__export(Spake2p_exports, {
  Spake2p: () => Spake2p
});
module.exports = __toCommonJS(Spake2p_exports);
var import_MatterError = require("../MatterError.js");
var import_Bytes = require("../util/Bytes.js");
var import_DataWriter = require("../util/DataWriter.js");
var import_Crypto = require("./Crypto.js");
var import_CryptoConstants = require("./CryptoConstants.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const {
  p256: { ProjectivePoint, CURVE: P256_CURVE },
  numberToBytesBE,
  bytesToNumberBE,
  mod
} = import_Crypto.ec;
const M = ProjectivePoint.fromHex("02886e2f97ace46e55ba9dd7242579f2993b64e16ef3dcab95afd497333d8fa12f");
const N = ProjectivePoint.fromHex("03d8bbd6c639c62937b04d997f38c3770719c629d7014d49a24b4f98baa1292b49");
const CRYPTO_W_SIZE_BYTES = import_CryptoConstants.CRYPTO_GROUP_SIZE_BYTES + 8;
class Spake2p {
  constructor(context, random, w0) {
    this.context = context;
    this.random = random;
    this.w0 = w0;
  }
  static async computeW0W1({ iterations, salt }, pin) {
    const pinWriter = new import_DataWriter.DataWriter(import_Bytes.Endian.Little);
    pinWriter.writeUInt32(pin);
    const ws = await import_Crypto.Crypto.pbkdf2(pinWriter.toByteArray(), salt, iterations, CRYPTO_W_SIZE_BYTES * 2);
    const w0 = mod(bytesToNumberBE(ws.slice(0, 40)), P256_CURVE.n);
    const w1 = mod(bytesToNumberBE(ws.slice(40, 80)), P256_CURVE.n);
    return { w0, w1 };
  }
  static async computeW0L(pbkdfParameters, pin) {
    const { w0, w1 } = await this.computeW0W1(pbkdfParameters, pin);
    const L = ProjectivePoint.BASE.multiply(w1).toRawBytes(false);
    return { w0, L };
  }
  static create(context, w0) {
    const random = import_Crypto.Crypto.getRandomBigInt(32, P256_CURVE.Fp.ORDER);
    return new Spake2p(context, random, w0);
  }
  computeX() {
    const X = ProjectivePoint.BASE.multiply(this.random).add(M.multiply(this.w0));
    return X.toRawBytes(false);
  }
  computeY() {
    const Y = ProjectivePoint.BASE.multiply(this.random).add(N.multiply(this.w0));
    return Y.toRawBytes(false);
  }
  async computeSecretAndVerifiersFromY(w1, X, Y) {
    const YPoint = ProjectivePoint.fromHex(Y);
    try {
      YPoint.assertValidity();
    } catch (error) {
      throw new import_MatterError.InternalError(`Y is not on the curve: ${error.message}`);
    }
    const yNwo = YPoint.add(N.multiply(this.w0).negate());
    const Z = yNwo.multiply(this.random);
    const V = yNwo.multiply(w1);
    return this.computeSecretAndVerifiers(X, Y, Z.toRawBytes(false), V.toRawBytes(false));
  }
  async computeSecretAndVerifiersFromX(L, X, Y) {
    const XPoint = ProjectivePoint.fromHex(X);
    const LPoint = ProjectivePoint.fromHex(L);
    try {
      XPoint.assertValidity();
    } catch (error) {
      throw new import_MatterError.InternalError(`X is not on the curve: ${error.message}`);
    }
    const Z = XPoint.add(M.multiply(this.w0).negate()).multiply(this.random);
    const V = LPoint.multiply(this.random);
    return this.computeSecretAndVerifiers(X, Y, Z.toRawBytes(false), V.toRawBytes(false));
  }
  async computeSecretAndVerifiers(X, Y, Z, V) {
    const TT_HASH = this.computeTranscriptHash(X, Y, Z, V);
    const Ka = TT_HASH.slice(0, 16);
    const Ke = TT_HASH.slice(16, 32);
    const KcAB = await import_Crypto.Crypto.hkdf(Ka, new Uint8Array(0), import_Bytes.Bytes.fromString("ConfirmationKeys"), 32);
    const KcA = KcAB.slice(0, 16);
    const KcB = KcAB.slice(16, 32);
    const hAY = import_Crypto.Crypto.hmac(KcA, Y);
    const hBX = import_Crypto.Crypto.hmac(KcB, X);
    return { Ke, hAY, hBX };
  }
  computeTranscriptHash(X, Y, Z, V) {
    const TTwriter = new import_DataWriter.DataWriter(import_Bytes.Endian.Little);
    this.addToContext(TTwriter, this.context);
    this.addToContext(TTwriter, import_Bytes.Bytes.fromString(""));
    this.addToContext(TTwriter, import_Bytes.Bytes.fromString(""));
    this.addToContext(TTwriter, M.toRawBytes(false));
    this.addToContext(TTwriter, N.toRawBytes(false));
    this.addToContext(TTwriter, X);
    this.addToContext(TTwriter, Y);
    this.addToContext(TTwriter, Z);
    this.addToContext(TTwriter, V);
    this.addToContext(TTwriter, numberToBytesBE(this.w0, 32));
    return import_Crypto.Crypto.hash(TTwriter.toByteArray());
  }
  addToContext(TTwriter, data) {
    TTwriter.writeUInt64(data.length);
    TTwriter.writeByteArray(data);
  }
}
//# sourceMappingURL=Spake2p.js.map
