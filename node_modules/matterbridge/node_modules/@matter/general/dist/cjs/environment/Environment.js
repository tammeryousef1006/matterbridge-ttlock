"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Environment_exports = {};
__export(Environment_exports, {
  Environment: () => Environment
});
module.exports = __toCommonJS(Environment_exports);
var import_Boot = require("#util/Boot.js");
var import_DiagnosticSource = require("../log/DiagnosticSource.js");
var import_Logger = require("../log/Logger.js");
var import_disposable = require("../polyfills/disposable.js");
var import_Time = require("../time/Time.js");
var import_Lifecycle = require("../util/Lifecycle.js");
var import_Observable = require("../util/Observable.js");
var import_Environmental = require("./Environmental.js");
var import_RuntimeService = require("./RuntimeService.js");
var import_VariableService = require("./VariableService.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_Logger.Logger.get("Environment");
class Environment {
  #services;
  #name;
  #parent;
  #added = (0, import_Observable.Observable)();
  #deleted = (0, import_Observable.Observable)();
  #serviceEvents = /* @__PURE__ */ new Map();
  constructor(name, parent) {
    this.#name = name;
    this.#parent = parent;
  }
  /**
   * Determine if an environmental service is available.
   */
  has(type) {
    return this.#services?.get(type) !== void 0 || (this.#parent?.has(type) ?? false);
  }
  /**
   * Access an environmental service.
   */
  get(type) {
    let instance = this.#services?.get(type) ?? this.#parent?.maybeGet(type);
    if (instance) {
      return instance;
    }
    if (type[import_Environmental.Environmental.create]) {
      this.set(type, instance = type[import_Environmental.Environmental.create](this));
      return instance;
    }
    throw new import_Lifecycle.UnsupportedDependencyError(`Required dependency ${type.name}`, "is not available");
  }
  /**
   * Access an environmental service that may not exist.
   */
  maybeGet(type) {
    if (this.has(type)) {
      return this.get(type);
    }
  }
  /**
   * Remove an environmental service.
   *
   * @param type the class of the service to remove
   * @param instance optional instance expected, if existing instance does not match it is not deleted
   */
  delete(type, instance) {
    if (instance !== void 0 && this.#services?.get(type) !== instance) {
      return;
    }
    this.#services?.delete(type);
    this.#parent?.delete(type);
    this.#deleted.emit(type, instance);
    const serviceEvents = this.#serviceEvents.get(type);
    if (serviceEvents) {
      serviceEvents.deleted.emit(instance);
    }
  }
  /**
   * Remove and close an environmental service.
   */
  close(type) {
    const instance = this.maybeGet(type);
    if (instance !== void 0) {
      this.delete(type, instance);
      return instance.close?.();
    }
  }
  /**
   * Access an environmental service, waiting for any async initialization to complete.
   */
  async load(type) {
    const instance = this.get(type);
    await instance.construction;
    return instance;
  }
  /**
   * Install a preinitialized version of an environmental service.
   */
  set(type, instance) {
    if (!this.#services) {
      this.#services = /* @__PURE__ */ new Map();
    }
    this.#services.set(type, instance);
    this.#added.emit(type, instance);
    const serviceEvents = this.#serviceEvents.get(type);
    if (serviceEvents) {
      serviceEvents.added.emit(instance);
    }
  }
  /**
   * Name of the environment.
   */
  get name() {
    return this.#name;
  }
  get root() {
    return this.#parent?.root ?? this;
  }
  /**
   * Emits on service add.
   *
   * Currently only emits for services owned directly by this environment.
   */
  get added() {
    return this.#added;
  }
  /**
   * Emits on service delete.
   *
   * Currently only emits for services owned directly by this environment.
   */
  get deleted() {
    return this.#deleted;
  }
  /**
   * Obtain an object with events that trigger when a specific service is added or deleted.
   *
   * This is a more convenient way to observe a specific service than {@link added} and {@link deleted}.
   */
  eventsFor(type) {
    let events = this.#serviceEvents.get(type);
    if (events === void 0) {
      events = {
        added: (0, import_Observable.Observable)(),
        deleted: (0, import_Observable.Observable)()
      };
      this.#serviceEvents.set(type, events);
    }
    return events;
  }
  /**
   * The default environment.
   *
   * Currently only emits for services owned directly by this environment.
   */
  static get default() {
    return global;
  }
  /**
   * Set the default environment.
   */
  static set default(env) {
    global = env;
    env.vars.use(() => {
      import_Logger.Logger.level = env.vars.get("log.level", import_Logger.Logger.level);
      import_Logger.Logger.format = env.vars.get("log.format", import_Logger.Logger.format);
      const stackLimit = global.vars.number("log.stack.limit");
      if (stackLimit !== void 0) {
        Error.stackTraceLimit = stackLimit;
      }
    });
  }
  /**
   * Shortcut for accessing {@link VariableService.vars}.
   */
  get vars() {
    return this.get(import_VariableService.VariableService);
  }
  /**
   * Shortcut for accessing {@link RuntimeService}.
   */
  get runtime() {
    return this.get(import_RuntimeService.RuntimeService);
  }
  /**
   * Display tasks that supply diagnostics.
   */
  diagnose() {
    import_Time.Time.getTimer("Diagnostics", 0, () => {
      try {
        logger.notice("Diagnostics follow", import_DiagnosticSource.DiagnosticSource);
      } catch (e) {
        logger.error(`Unhandled error gathering diagnostics:`, e);
      }
    }).start();
  }
  loadVariables() {
    return {};
  }
}
let global;
import_Boot.Boot.init(() => {
  global = new Environment("default");
});
//# sourceMappingURL=Environment.js.map
