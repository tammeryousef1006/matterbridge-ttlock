/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Diagnostic } from "../log/Diagnostic.js";
import { Construction } from "../util/Construction.js";
import { Cancellable, Destructable } from "../util/Lifecycle.js";
import { Multiplex } from "../util/Multiplex.js";
import { Observable } from "../util/Observable.js";
import type { Environment } from "./Environment.js";
import { Environmental } from "./Environmental.js";
/**
 * Handles lifecycle management of other components.
 */
export declare class RuntimeService implements Multiplex {
    #private;
    constructor(environment: Environment);
    /**
     * Add a {@link Worker}.
     *
     * The runtime considers itself "active" if there are one or more workers installed.
     *
     * A worker must either be {@link PromiseLike} or {@link Constructable} for the runtime to detect completion. On
     * completion the worker is removed and destroyed if the worker is {@link Destructable}.
     *
     * Once added, the {@link worker} is owned by the RuntimeService until closed, resolved or removed via
     * {@link delete}.
     */
    add(worker: RuntimeService.Worker | void): void;
    /**
     * Remove a worker.
     */
    delete(worker: RuntimeService.Worker): void;
    /**
     * Emits when a worker is added when previously there were none.
     */
    get started(): Observable<[], void>;
    /**
     * Emits when the last worker departs.
     */
    get stopped(): Observable<[], void>;
    /**
     * Emits when a worker experiences an unhandled error.
     */
    get crashed(): Observable<[cause: any], void>;
    static [Environmental.create](environment: Environment): RuntimeService;
    /**
     * Cancel execution.
     *
     * On cancel the runtime destroys all workers.
     */
    cancel(): void;
    /**
     * Interrupt handler.  Triggered by e.g. on SIGINT on unixish systems.
     *
     * The default implementation cancels the runtime.
     *
     * @returns a boolean indicating whether to continue trapping interrupts
     */
    interrupt(): boolean;
    /**
     * Resolves when no workers are active.
     */
    get inactive(): Promise<void>;
    close(): Promise<void>;
    [Symbol.asyncDispose](): Promise<void>;
    get [Diagnostic.value](): unknown[];
}
export declare namespace RuntimeService {
    const label: unique symbol;
    /**
     * The runtime tracks individual discrete tasks as "workers".
     *
     * The state of the runtime is dependent on installed workers.  Any JS object may be a worker but the runtime's
     * interaction with workers varies as documented here.
     *
     * If a worker is a {@link PromiseLike} the runtime will delete and/or destroy it on completion.
     */
    interface Worker extends Partial<PromiseLike<any>>, Partial<Cancellable>, Partial<Destructable> {
        /**
         * If the worker supports {@link Construction}, the runtime will monitor the worker's lifecycle:
         *
         *   - If the worker crashed (e.g. experiences an error during initialization) the runtime will cancel all
         *     workers and exit
         *
         *   - If the worker is destroyed the runtime deletes it from the set of known workers
         */
        construction?: Construction<any>;
        /**
         * If the worker supports {@link Symbol.asyncDispose} the runtime will invoke when the worker is no longer
         * needed.  This happens if:
         *
         *   - The worker is a {@link PromiseLike} that resolves
         *
         *   - The worker's {@link construction} status changed as noted above
         *
         *   - The runtime is canceled via {@link RuntimeService.cancel}
         */
        [Symbol.asyncDispose]?: () => void | Promise<void>;
        /**
         * Workers may implement {@link Symbol.dispose} to handle disposal.  Works the same as the async equivalent.
         */
        [Symbol.dispose]?: () => void;
        /**
         * If label is present, it will be presented in diagnostics.  This takes precedence over [Diagnostic.value].
         */
        [label]?: unknown;
        /**
         * In diagnostics workers render using toString() unless they provide explicit diagnostics.
         */
        [Diagnostic.value]?: unknown;
    }
}
//# sourceMappingURL=RuntimeService.d.ts.map