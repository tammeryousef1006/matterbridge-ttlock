"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var RuntimeService_exports = {};
__export(RuntimeService_exports, {
  RuntimeService: () => RuntimeService
});
module.exports = __toCommonJS(RuntimeService_exports);
var import_Diagnostic = require("../log/Diagnostic.js");
var import_DiagnosticSource = require("../log/DiagnosticSource.js");
var import_Logger = require("../log/Logger.js");
var import_Lifecycle = require("../util/Lifecycle.js");
var import_Observable = require("../util/Observable.js");
var import_Environmental = require("./Environmental.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_Logger.Logger.get("Runtime");
class RuntimeService {
  #env;
  #workers = /* @__PURE__ */ new Set();
  #cancelled = /* @__PURE__ */ new Set();
  #workerDeleted = (0, import_Observable.Observable)();
  #canceled = false;
  #started = (0, import_Observable.Observable)();
  #stopped = (0, import_Observable.Observable)();
  #crashed = (0, import_Observable.Observable)();
  constructor(environment) {
    this.#env = environment;
    environment.set(RuntimeService, this);
    import_DiagnosticSource.DiagnosticSource.add(this);
  }
  /**
   * Add a {@link Worker}.
   *
   * The runtime considers itself "active" if there are one or more workers installed.
   *
   * A worker must either be {@link PromiseLike} or {@link Constructable} for the runtime to detect completion. On
   * completion the worker is removed and destroyed if the worker is {@link Destructable}.
   *
   * Once added, the {@link worker} is owned by the RuntimeService until closed, resolved or removed via
   * {@link delete}.
   */
  add(worker) {
    if (!worker) {
      return;
    }
    if (this.#workers.has(worker)) {
      return;
    }
    this.#workers.add(worker);
    if (this.#workers.size === 1) {
      this.#started.emit();
    }
    if (worker.then) {
      Promise.resolve(worker).catch((error) => this.#crash(error)).finally(() => this.delete(worker));
      return;
    }
    if (worker.construction?.change) {
      worker.construction.change.on((status) => {
        switch (status) {
          case import_Lifecycle.Lifecycle.Status.Crashed:
            this.#crash();
            break;
          case import_Lifecycle.Lifecycle.Status.Destroyed:
            this.delete(worker);
            break;
        }
      });
    }
  }
  /**
   * Remove a worker.
   */
  delete(worker) {
    if (!this.#workers.has(worker)) {
      return;
    }
    this.#workers.delete(worker);
    this.#cancelled.delete(worker);
    this.#workerDeleted.emit();
    if (this.#workers.size) {
      return;
    }
    this.cancel();
    void this.inactive.finally(() => this.#stopped.emit());
  }
  /**
   * Emits when a worker is added when previously there were none.
   */
  get started() {
    return this.#started;
  }
  /**
   * Emits when the last worker departs.
   */
  get stopped() {
    return this.#stopped;
  }
  /**
   * Emits when a worker experiences an unhandled error.
   */
  get crashed() {
    return this.#crashed;
  }
  static [import_Environmental.Environmental.create](environment) {
    return new this(environment);
  }
  /**
   * Cancel execution.
   *
   * On cancel the runtime destroys all workers.
   */
  cancel() {
    if (this.#canceled) {
      return;
    }
    this.#canceled = true;
    logger.notice("Shutting down");
    for (const worker of this.#workers) {
      const disposal = this.#cancelWorker(worker);
      if (disposal) {
        this.add(disposal);
      }
    }
  }
  /**
   * Interrupt handler.  Triggered by e.g. on SIGINT on unixish systems.
   *
   * The default implementation cancels the runtime.
   *
   * @returns a boolean indicating whether to continue trapping interrupts
   */
  interrupt() {
    this.cancel();
    return false;
  }
  /**
   * Resolves when no workers are active.
   */
  get inactive() {
    if (!this.#workers.size) {
      return Promise.resolve();
    }
    return new Promise((resolve) => {
      const listener = () => {
        if (!this.#workers.size) {
          this.#workerDeleted.off(listener);
          resolve();
        }
      };
      this.#workerDeleted.on(listener);
    });
  }
  async close() {
    this.cancel();
    await this.inactive;
    this.#env.delete(RuntimeService, this);
    import_DiagnosticSource.DiagnosticSource.delete(this);
  }
  [Symbol.asyncDispose]() {
    return this.close();
  }
  get [import_Diagnostic.Diagnostic.value]() {
    return import_Diagnostic.Diagnostic.node("\u{1F6E0}", "Workers", {
      children: [...this.#workers].map((worker) => {
        let diagnostic = worker[RuntimeService.label];
        if (diagnostic === void 0) {
          diagnostic = worker[import_Diagnostic.Diagnostic.value];
          if (diagnostic === void 0) {
            diagnostic = worker.toString();
          }
        }
        return diagnostic;
      })
    });
  }
  #cancelWorker(worker) {
    if (this.#cancelled.has(worker)) {
      return;
    }
    const cancel = () => {
      this.#cancelled.add(worker);
      if (worker.close) {
        this.#cancelled.add(worker);
        return Promise.resolve(worker.close()).finally(() => this.delete(worker));
      }
      if (worker[Symbol.asyncDispose]) {
        this.#cancelled.add(worker);
        return Promise.resolve(worker[Symbol.asyncDispose]?.()).finally(() => this.delete(worker));
      }
      if (worker[Symbol.dispose]) {
        worker[Symbol.dispose]?.();
        this.delete(worker);
        return;
      }
    };
    if (worker.construction) {
      worker.construction.onSuccess(cancel);
      return;
    }
    return cancel();
  }
  #crash(cause) {
    if (cause) {
      logger.error(cause);
    }
    this.crashed.emit(cause);
    this.cancel();
  }
}
((RuntimeService2) => {
  RuntimeService2.label = Symbol("label");
})(RuntimeService || (RuntimeService = {}));
//# sourceMappingURL=RuntimeService.js.map
