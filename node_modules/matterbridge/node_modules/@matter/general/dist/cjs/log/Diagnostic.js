"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Diagnostic_exports = {};
__export(Diagnostic_exports, {
  Diagnostic: () => Diagnostic
});
module.exports = __toCommonJS(Diagnostic_exports);
var import_Bytes = require("#util/Bytes.js");
var import_LogLevel = require("./LogLevel.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
let errorCollector;
function Diagnostic(presentation, value) {
  return {
    [Diagnostic.presentation]: presentation,
    [Diagnostic.value]: value
  };
}
((Diagnostic2) => {
  let Presentation;
  ((Presentation2) => {
    Presentation2["Message"] = "message";
    Presentation2["List"] = "list";
    Presentation2["Squash"] = "squash";
    Presentation2["Strong"] = "strong";
    Presentation2["Weak"] = "weak";
    Presentation2["Flag"] = "flag";
    Presentation2["Error"] = "error";
    Presentation2["Dictionary"] = "dictionary";
    Presentation2["Via"] = "via";
    Presentation2["Added"] = "added";
    Presentation2["Deleted"] = "deleted";
  })(Presentation = Diagnostic2.Presentation || (Diagnostic2.Presentation = {}));
  function Context() {
    let errorsCollected;
    const errorsReported = /* @__PURE__ */ new WeakSet();
    const thisErrorCollector = (error2) => {
      if (errorsReported.has(error2)) {
        return true;
      }
      if (errorsCollected) {
        errorsCollected.push(error2);
      } else {
        errorsCollected = [error2];
      }
      return false;
    };
    return {
      run(fn) {
        const originalErrorCollector = errorCollector;
        try {
          errorCollector = thisErrorCollector;
          const result = fn();
          if (errorsCollected) {
            for (const error2 of errorsCollected) {
              errorsReported.add(error2);
            }
            errorsCollected = void 0;
          }
          return result;
        } finally {
          errorCollector = originalErrorCollector;
        }
      }
    };
  }
  Diagnostic2.Context = Context;
  Diagnostic2.presentation = Symbol("presentation");
  Diagnostic2.value = Symbol("value");
  function message(value2) {
    const { now, level, facility, prefix: nestingPrefix, values } = value2;
    return {
      [Diagnostic2.presentation]: "message" /* Message */,
      now: now ?? /* @__PURE__ */ new Date(),
      level: level ?? import_LogLevel.LogLevel.INFO,
      facility: facility ?? "Diagnostic",
      prefix: nestingPrefix ?? "",
      values: values ?? []
    };
  }
  Diagnostic2.message = message;
  function strong(value2) {
    return Diagnostic2("strong" /* Strong */, value2);
  }
  Diagnostic2.strong = strong;
  function weak(value2) {
    return Diagnostic2("weak" /* Weak */, value2);
  }
  Diagnostic2.weak = weak;
  function flag(value2) {
    return Diagnostic2("flag" /* Flag */, value2);
  }
  Diagnostic2.flag = flag;
  function via(value2) {
    if (value2[Diagnostic2.presentation]) {
      return value2;
    }
    const via2 = new String(value2);
    Object.defineProperty(via2, Diagnostic2.presentation, { value: "via" /* Via */ });
    return via2;
  }
  Diagnostic2.via = via;
  function added(value2) {
    return Diagnostic2("added" /* Added */, value2);
  }
  Diagnostic2.added = added;
  function deleted(value2) {
    return Diagnostic2("deleted" /* Deleted */, value2);
  }
  Diagnostic2.deleted = deleted;
  function node(icon, label, detail) {
    const result = [icon, Diagnostic2.strong(label)];
    if (detail?.self !== void 0) {
      result.push(detail.self);
    }
    if (detail?.children !== void 0) {
      result.push(Diagnostic2.list(detail.children));
    }
    return result;
  }
  Diagnostic2.node = node;
  function list(value2) {
    return Diagnostic2("list" /* List */, value2);
  }
  Diagnostic2.list = list;
  function squash(...values) {
    return Diagnostic2("squash" /* Squash */, values);
  }
  Diagnostic2.squash = squash;
  function dict(entries, suppressUndefinedValues = true) {
    const result = {
      ...entries,
      [Diagnostic2.presentation]: "dictionary" /* Dictionary */
    };
    if (suppressUndefinedValues) {
      for (const key in result) {
        if (result[key] === void 0) {
          delete result[key];
        }
      }
    }
    return result;
  }
  Diagnostic2.dict = dict;
  function error(error2) {
    return formatError(error2);
  }
  Diagnostic2.error = error;
  function lifecycle(status, value2) {
    return Diagnostic2(status, value2);
  }
  Diagnostic2.lifecycle = lifecycle;
  function lifecycleList(map) {
    return Object.entries(map).map(([label, status]) => Diagnostic2(status, label));
  }
  Diagnostic2.lifecycleList = lifecycleList;
  function interval(ms) {
    if (ms < 0) {
      return `${(ms * 1e3).toPrecision(3)}\u03BCs`;
    } else if (ms < 1e3) {
      return `${ms.toPrecision(3)}ms`;
    } else if (ms < 6e4) {
      return `${(ms / 1e3).toPrecision(3)}s`;
    }
    let days;
    if (ms > 864e5) {
      days = `${Math.floor(ms / 864e5)}d `;
      ms %= 864e5;
    } else {
      days = "";
    }
    const hours = Math.floor(ms / 36e5).toString().padStart(2, "0");
    ms %= 36e5;
    const minutes = Math.floor(ms / 6e4).toString().padStart(2, "0");
    ms %= 6e4;
    const seconds = Math.floor(ms).toString().padStart(2, "0");
    return `${days}${hours}:${minutes}:${seconds}`;
  }
  Diagnostic2.interval = interval;
  function elapsed() {
    return {
      startedAt: performance.now(),
      get time() {
        return performance.now() - this.startedAt;
      },
      toString() {
        return interval(this.time);
      }
    };
  }
  Diagnostic2.elapsed = elapsed;
  function upgrade(value2, diagnostic) {
    switch (typeof value2) {
      case "boolean":
        value2 = new Boolean(value2);
        break;
      case "number":
        value2 = new Number(value2);
        break;
      case "string":
        value2 = new String(value2);
        break;
    }
    if (typeof diagnostic === "function") {
      Object.defineProperty(value2, Diagnostic2.value, { get: diagnostic });
    } else {
      Object.defineProperty(value2, Diagnostic2.value, { value: diagnostic });
    }
    return value2;
  }
  Diagnostic2.upgrade = upgrade;
  function hex(value2) {
    return `0x${value2.toString(16)}`;
  }
  Diagnostic2.hex = hex;
  function json(data) {
    return JSON.stringify(data, (_, value2) => {
      if (typeof value2 === "bigint") {
        return value2.toString();
      }
      if (value2 instanceof Uint8Array) {
        return import_Bytes.Bytes.toHex(value2);
      }
      if (value2 === void 0) {
        return "undefined";
      }
      return value2;
    });
  }
  Diagnostic2.json = json;
  function asFlags(flags) {
    return Diagnostic2.flag(Diagnostic2.toFlagString(flags));
  }
  Diagnostic2.asFlags = asFlags;
  function toFlagString(flags) {
    return Object.entries(flags).filter(([, value2]) => !!value2).map(([key]) => key).join(" ");
  }
  Diagnostic2.toFlagString = toFlagString;
  function messageAndStackFor(error2, parentStack) {
    let message2;
    let rawStack;
    if (error2 !== void 0 && error2 !== null) {
      if (typeof error2 === "string" || typeof error2 === "number") {
        return { message: `${error2}` };
      }
      if ("message" in error2) {
        ({ message: message2, stack: rawStack } = error2);
      } else if (error2.message) {
        message2 = typeof error2.message === "string" ? message2 : error2.toString();
      }
    }
    if (message2 === void 0 || message2 === null || message2 === "") {
      if (error2 !== void 0 && error2 !== null) {
        message2 = error2.constructor.name;
        if (!message2 || message2 === "Error") {
          message2 = "(unknown error)";
        }
      } else {
        message2 = "(unknown error)";
      }
    }
    if (!rawStack) {
      return { message: message2 };
    }
    rawStack = rawStack.toString();
    rawStack = rawStack.replace(/^.*?\n\nError: /gs, "Error: ");
    if (rawStack.startsWith("Error: ")) {
      rawStack = rawStack.slice(7);
    }
    const pos = rawStack.indexOf(message2);
    if (pos !== -1) {
      rawStack = rawStack.slice(pos + message2.length).trim();
    }
    let stackLines = rawStack.split("\n").map((line) => line.trim()).filter((line) => line !== "");
    if (stackLines[0] === "Error") {
      stackLines.shift();
    }
    let truncatedToParent = false;
    if (parentStack) {
      let truncateTo = 0;
      stackSearch: for (; truncateTo < stackLines.length - 1; truncateTo++) {
        let parentPos = parentStack.indexOf(stackLines[truncateTo]);
        if (parentPos === -1) {
          continue;
        }
        parentPos++;
        for (let pos2 = truncateTo + 1; pos2 < stackLines.length && parentPos < parentStack.length; pos2++, parentPos++) {
          if (stackLines[pos2] !== parentStack[parentPos]) {
            continue stackSearch;
          }
        }
        stackLines = stackLines.slice(0, truncateTo + 1);
        truncatedToParent = true;
        break;
      }
    }
    const stack = Array();
    for (const line of stackLines) {
      const match1 = line.match(/^at\s+(?:(\S|\S.*\S)\s+\(([^)]+)\)|(<anonymous>))$/);
      if (match1) {
        const value2 = [Diagnostic2.weak("at "), match1[1] ?? match1[3]];
        if (match1[2] !== void 0) {
          value2.push(Diagnostic2.weak(" ("), Diagnostic2.weak(match1[2]), Diagnostic2.weak(")"));
        }
        stack.push(Diagnostic2.squash(...value2));
        continue;
      }
      const match2 = line.match(/^at\s+(\S.*)(:\d+:\d+)$/);
      if (match2) {
        stack.push(Diagnostic2.squash(Diagnostic2.weak("at "), match2[1], Diagnostic2.weak(match2[2])));
        continue;
      }
      stack.push(line);
    }
    if (truncatedToParent) {
      stack.push(Diagnostic2.weak("(see parent frames)"));
    }
    return { message: message2, stack, stackLines };
  }
  Diagnostic2.messageAndStackFor = messageAndStackFor;
})(Diagnostic || (Diagnostic = {}));
function formatError(error, options = {}) {
  const { messagePrefix, parentStack } = options;
  const messageAndStack = Diagnostic.messageAndStackFor(error, parentStack);
  let { stack, stackLines } = messageAndStack;
  let { message } = messageAndStack;
  if (messagePrefix) {
    message = `${messagePrefix} ${message}`;
  }
  message = Diagnostic.upgrade(message, Diagnostic("error" /* Error */, message));
  let cause, errors;
  if (typeof error === "object" && error !== null) {
    ({ cause, errors } = error);
  }
  if (errorCollector?.(error)) {
    stack = stackLines = void 0;
  }
  if (stack === void 0 && cause === void 0 && errors === void 0) {
    return message;
  }
  const list = [message];
  if (stack === void 0) {
    list.push(Diagnostic("list" /* List */, []));
  } else {
    list.push(Diagnostic("list" /* List */, stack));
  }
  for (; typeof cause === "object" && cause !== null; cause = cause.cause) {
    let formatted = formatError(cause, { messagePrefix: "Caused by:", parentStack: stackLines });
    if (formatted[Diagnostic.presentation] === "list" /* List */) {
      formatted = formatted[Diagnostic.value] ?? formatted;
    }
    if (Array.isArray(formatted)) {
      list.push(...formatted);
    } else {
      list.push(formatted);
    }
  }
  if (Array.isArray(errors)) {
    let cause2 = 0;
    list.push(
      Diagnostic.list(
        errors.map((e) => formatError(e, { messagePrefix: `Cause #${cause2++}:`, parentStack: stackLines }))
      )
    );
  }
  return list;
}
//# sourceMappingURL=Diagnostic.js.map
