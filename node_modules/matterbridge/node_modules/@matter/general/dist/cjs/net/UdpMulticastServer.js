"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var UdpMulticastServer_exports = {};
__export(UdpMulticastServer_exports, {
  UdpMulticastServer: () => UdpMulticastServer
});
module.exports = __toCommonJS(UdpMulticastServer_exports);
var import_MatterError = require("#MatterError.js");
var import_Logger = require("../log/Logger.js");
var import_Cache = require("../util/Cache.js");
var import_Error = require("../util/Error.js");
var import_Ip = require("../util/Ip.js");
var import_Network = require("./Network.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_Logger.Logger.get("UdpMulticastServer");
class UdpMulticastServer {
  constructor(network, broadcastAddressIpv4, broadcastAddressIpv6, broadcastPort, serverIpv4, serverIpv6, netInterface) {
    this.network = network;
    this.broadcastAddressIpv4 = broadcastAddressIpv4;
    this.broadcastAddressIpv6 = broadcastAddressIpv6;
    this.broadcastPort = broadcastPort;
    this.serverIpv4 = serverIpv4;
    this.serverIpv6 = serverIpv6;
    this.netInterface = netInterface;
  }
  static async create({
    netInterface,
    broadcastAddressIpv4,
    broadcastAddressIpv6,
    listeningPort,
    network
  }) {
    let ipv4UdpChannel = void 0;
    if (broadcastAddressIpv4 !== void 0) {
      try {
        ipv4UdpChannel = await network.createUdpChannel({
          type: "udp4",
          netInterface,
          listeningPort,
          membershipAddresses: [broadcastAddressIpv4]
        });
      } catch (error) {
        import_Network.NoAddressAvailableError.accept(error);
        logger.info(`IPv4 UDP channel not created because IPv4 is not available: ${(0, import_Error.asError)(error).message}`);
      }
    }
    try {
      return new UdpMulticastServer(
        network,
        broadcastAddressIpv4,
        broadcastAddressIpv6,
        listeningPort,
        ipv4UdpChannel,
        await network.createUdpChannel({
          type: "udp6",
          netInterface,
          listeningPort,
          membershipAddresses: [broadcastAddressIpv6]
        }),
        netInterface
      );
    } catch (error) {
      import_Network.NoAddressAvailableError.accept(error);
      logger.info(`IPv6 UDP interface not created because IPv6 is not available, but required my Matter.`);
      throw error;
    }
  }
  broadcastChannels = new import_Cache.Cache(
    "UDP broadcast channel",
    (netInterface, iPv4) => this.createBroadcastChannel(netInterface, iPv4),
    5 * 60 * 1e3,
    async (_netInterface, channel) => (await channel).close()
  );
  onMessage(listener) {
    this.serverIpv4?.onData((netInterface, peerAddress, _port, message) => {
      if (netInterface === void 0) {
        return;
      }
      listener(message, peerAddress, netInterface);
    });
    this.serverIpv6.onData((netInterface, peerAddress, _port, message) => {
      if (netInterface === void 0) {
        return;
      }
      listener(message, peerAddress, netInterface);
    });
  }
  async send(message, netInterface, uniCastTarget) {
    netInterface = netInterface ?? this.netInterface;
    if (uniCastTarget !== void 0 && netInterface !== void 0) {
      try {
        await (await this.broadcastChannels.get(netInterface, (0, import_Ip.isIPv4)(uniCastTarget))).send(uniCastTarget, this.broadcastPort, message);
      } catch (error) {
        logger.info(`${netInterface} ${uniCastTarget}: ${(0, import_Error.asError)(error).message}`);
      }
    } else {
      const netInterfaces = netInterface !== void 0 ? [{ name: netInterface }] : await this.network.getNetInterfaces();
      await import_MatterError.MatterAggregateError.allSettled(
        netInterfaces.map(async ({ name: netInterface2 }) => {
          const { ipV4, ipV6 } = await this.network.getIpMac(netInterface2) ?? {
            mac: "",
            ipV4: [],
            ipV6: []
          };
          const ips = [...ipV4, ...ipV6];
          await import_MatterError.MatterAggregateError.allSettled(
            ips.map(async (ip) => {
              const iPv4 = ipV4.includes(ip);
              const broadcastTarget = iPv4 ? this.broadcastAddressIpv4 : this.broadcastAddressIpv6;
              if (broadcastTarget == void 0) {
                return;
              }
              try {
                await (await this.broadcastChannels.get(netInterface2, iPv4)).send(broadcastTarget, this.broadcastPort, message);
              } catch (error) {
                logger.info(`${netInterface2}: ${(0, import_Error.asError)(error).message}`);
              }
            }),
            `Error sending UDP Multicast message on interface ${netInterface2}`
          );
        }),
        "Error sending UDP Multicast message"
      );
    }
  }
  async createBroadcastChannel(netInterface, iPv4) {
    return await this.network.createUdpChannel({
      type: iPv4 ? "udp4" : "udp6",
      listeningPort: this.broadcastPort,
      netInterface
    });
  }
  async close() {
    await this.serverIpv4?.close();
    await this.serverIpv6.close();
    await this.broadcastChannels.close();
  }
}
//# sourceMappingURL=UdpMulticastServer.js.map
