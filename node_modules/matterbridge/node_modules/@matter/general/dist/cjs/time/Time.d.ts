/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { CancelablePromise } from "#util/Cancelable.js";
import { Diagnostic } from "../log/Diagnostic.js";
/**
 * Timer and date/time management interface.
 *
 * You may replace this platform abstraction but we provide an implementation compatible with any standard JS
 * environment.
 */
export declare class Time {
    static get: () => Time;
    static startup: {
        systemMs: number;
        processMs: number;
    };
    now(): Date;
    static readonly now: () => Date;
    nowMs(): number;
    static readonly nowMs: () => number;
    /**
     * Create a timer that will call callback after durationMs has passed.
     */
    getTimer(name: string, durationMs: number, callback: Timer.Callback): Timer;
    static readonly getTimer: (name: string, durationMs: number, callback: Timer.Callback) => Timer;
    /**
     * Create a timer that will periodically call callback at intervalMs intervals.
     */
    getPeriodicTimer(name: string, intervalMs: number, callback: Timer.Callback): Timer;
    static readonly getPeriodicTimer: (name: string, intervalMs: number, callback: Timer.Callback) => Timer;
    /**
     * Create a promise that resolves after a specific interval or when canceled, whichever comes first.
     */
    sleep(name: string, durationMs: number): CancelablePromise;
    static sleep(name: string, durationMs: number): CancelablePromise<void>;
    static register(timer: Timer): void;
    static unregister(timer: Timer): void;
    static get timers(): Set<Timer>;
}
export interface Timer {
    /** Name (diagnostics) */
    name: string;
    /** Set to true to indicate the timer should not prevent program exit */
    utility: boolean;
    /** System ID (diagnostics) */
    systemId: unknown;
    /** Interval (diagnostics) */
    intervalMs: number;
    /** Is the timer periodic? (diagnostics) */
    isPeriodic: boolean;
    /** Amount of time interval has been active (diagnostics) */
    elapsed?: Diagnostic.Elapsed;
    /** Is true if this timer is running. */
    isRunning: boolean;
    /** Starts this timer, chainable. */
    start(): Timer;
    /** Stops this timer, chainable. */
    stop(): Timer;
}
export declare namespace Timer {
    type Callback = () => any;
}
export declare class StandardTimer implements Timer {
    #private;
    readonly name: string;
    readonly intervalMs: number;
    private readonly callback;
    readonly isPeriodic: boolean;
    isRunning: boolean;
    get systemId(): number;
    constructor(name: string, intervalMs: number, callback: Timer.Callback, isPeriodic: boolean);
    get utility(): boolean;
    set utility(utility: boolean);
    start(): this;
    stop(): this;
}
//# sourceMappingURL=Time.d.ts.map