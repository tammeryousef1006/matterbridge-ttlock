"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Bytes_exports = {};
__export(Bytes_exports, {
  Bytes: () => Bytes,
  Endian: () => Endian
});
module.exports = __toCommonJS(Bytes_exports);
var import_MatterError = require("../MatterError.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
var Endian = /* @__PURE__ */ ((Endian2) => {
  Endian2[Endian2["Little"] = 0] = "Little";
  Endian2[Endian2["Big"] = 1] = "Big";
  return Endian2;
})(Endian || {});
var Bytes;
((Bytes2) => {
  function toHex(array) {
    const hexArray = new Array();
    hexArray.length = array.length;
    array.forEach((byte) => hexArray.push(byte.toString(16).padStart(2, "0")));
    return hexArray.join("");
  }
  Bytes2.toHex = toHex;
  function toBase64(array) {
    let result = "";
    array.forEach((byte) => result += String.fromCharCode(byte));
    return btoa(result);
  }
  Bytes2.toBase64 = toBase64;
  function dataViewOf(array) {
    return new DataView(array.buffer, array.byteOffset, array.byteLength);
  }
  Bytes2.dataViewOf = dataViewOf;
  function areEqual(array1, array2) {
    if (array1.length !== array2.length) return false;
    return array1.every((value, index) => array2[index] === value);
  }
  Bytes2.areEqual = areEqual;
  function fromHex(hexString) {
    if (hexString.length === 0) return new Uint8Array(0);
    if (hexString.length % 2 !== 0) throw new import_MatterError.UnexpectedDataError("Hex string should have an even length.");
    const bytes = hexString.match(/.{1,2}/g)?.map((byteHex) => parseInt(byteHex, 16));
    if (bytes === void 0) throw new import_MatterError.UnexpectedDataError("Failed to parse the hex string.");
    return Uint8Array.from(bytes);
  }
  Bytes2.fromHex = fromHex;
  function fromBase64(base64String) {
    const raw = atob(base64String);
    let result = "";
    for (let i = 0; i < raw.length; i++) {
      const hex = raw.charCodeAt(i).toString(16);
      result += hex.length === 2 ? hex : "0" + hex;
    }
    return fromHex(result);
  }
  Bytes2.fromBase64 = fromBase64;
  function fromString(string) {
    return new TextEncoder().encode(string);
  }
  Bytes2.fromString = fromString;
  function concat(...arrays) {
    let length = 0;
    arrays.forEach((array) => length += array.length);
    const result = new Uint8Array(length);
    let offset = 0;
    arrays.forEach((array) => {
      result.set(array, offset);
      offset += array.length;
    });
    return result;
  }
  Bytes2.concat = concat;
})(Bytes || (Bytes = {}));
//# sourceMappingURL=Bytes.js.map
