/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import type { Logger } from "#log/Logger.js";
import { MaybePromise } from "./Promises.js";
/**
 * An operation that may be canceled.
 */
export interface Cancelable {
    /**
     * Cancel the operation.
     */
    cancel(reason: any): void;
}
/**
 * A {@link PromiseLike} that may be canceled.
 *
 * Behaves like a normal promise but does not actually extend {@link Promise} because that's a huge PITA.
 */
export declare class CancelablePromise<T = void> implements Promise<T>, Cancelable {
    #private;
    /**
     * Create a new cancelable promise.
     *
     * If the promise is rejected due to cancelation, the {@link executor} callbacks have no effect.
     *
     * If you supply {@link onCancel} it overwrites the {@link CancelablePromise#onCancel} method.
     *
     * @param executor the normal executor supplied to a {@link Promise} constructor
     * @param onCancel rejection handler supplied with a reason and a callback for optionally rejecting the promise
     */
    constructor(executor: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void, onCancel?: (reason: Error) => void);
    /**
     * Cancel the operation.
     */
    cancel(reason?: any): void;
    /**
     * Implement cancelation.  This is only invoked if the promise has not resolved.
     *
     * Throwing causes the promise to reject with the error thrown.  The default implementation rethrows {@link reason}.
     *
     * This is overwritten if there is an "onCancel" argument to the constructor.
     */
    protected onCancel(reason: Error): void;
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null): CancelablePromise<TResult1 | TResult2>;
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null): CancelablePromise<T | TResult>;
    finally(onfinally?: (() => void) | null): CancelablePromise<T>;
    get [Symbol.toStringTag](): string;
    static is<T>(value: MaybePromise<T>): value is CancelablePromise<T>;
    static resolve<T>(value: T): CancelablePromise<T>;
    static reject(cause: any): CancelablePromise<any>;
    static set logger(logger: Logger | Console);
    static get logger(): Logger | Console;
}
/**
 * An {@link AsyncIterator} that may be canceled.
 */
export declare class CancelableAsyncIterator<T, TReturn = T, TNext = void> implements AsyncIterator<T, TReturn, TNext>, Cancelable {
    #private;
    /**
     * Create a new instance.
     *
     * @param next the function that produces results
     * @param onCancel if provided this will overwrite {@link onCancel}
     */
    constructor(next: (...[value]: [] | [TNext]) => Promise<IteratorResult<T, TReturn>>, onCancel?: (reason: Error) => void);
    next(...[value]: [] | [TNext]): Promise<IteratorResult<T, TReturn>>;
    cancel(reason: any): void;
    /**
     * Handle cancelation.
     *
     * If the underlying operation supports cancelation then it is better to use that.  Otherwise throwing
     * {@link reason} (the default behavior) will reject the current (or next) iteration regardless of the state of the
     * underyling operation.
     *
     * @param reason the reason provided to {@link cancel}
     */
    protected onCancel(reason: any): void;
    static is(value: unknown): value is CancelableAsyncIterator<unknown>;
}
/**
 * Create a function that returns a {@link CancelablePromise} and delegates cancelation internally to other async logic.
 *
 * The output function invokes the supplied {@link executor} with an additional "cancelable" argument.  This function
 * wraps supported types (currently {@link CancelablePromise}, {@link CancelableAsyncIterator} and {@link Promise}) with
 * cancelation logic.
 *
 * Any such wrapped object behaves normally but will throw with the cancelation reason on cancel.
 */
export declare function Cancelable<ThisT, ArgsT extends unknown[], ReturnT>(executor: Cancelable.Executor<ThisT, ArgsT, ReturnT>): (this: ThisT, ...args: ArgsT) => CancelablePromise<ReturnT>;
export declare namespace Cancelable {
    interface Delegator {
        <T>(value: T): T;
    }
    interface Executor<ThisT, ArgsT extends unknown[], ReturnT> {
        (this: ThisT, cancelable: Delegator, ...args: ArgsT): MaybePromise<ReturnT>;
    }
}
//# sourceMappingURL=Cancelable.d.ts.map