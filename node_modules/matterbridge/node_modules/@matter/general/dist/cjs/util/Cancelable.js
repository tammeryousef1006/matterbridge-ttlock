"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Cancelable_exports = {};
__export(Cancelable_exports, {
  Cancelable: () => Cancelable,
  CancelableAsyncIterator: () => CancelableAsyncIterator,
  CancelablePromise: () => CancelablePromise
});
module.exports = __toCommonJS(Cancelable_exports);
var import_MatterError = require("#MatterError.js");
var import_Error = require("./Error.js");
var import_Promises = require("./Promises.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
class CancelablePromise {
  #reject;
  #promise;
  #isSettled = false;
  // Cancelable cannot create its own logger because that would create a circular dependency
  static #logger = console;
  /**
   * Create a new cancelable promise.
   *
   * If the promise is rejected due to cancelation, the {@link executor} callbacks have no effect.
   *
   * If you supply {@link onCancel} it overwrites the {@link CancelablePromise#onCancel} method.
   *
   * @param executor the normal executor supplied to a {@link Promise} constructor
   * @param onCancel rejection handler supplied with a reason and a callback for optionally rejecting the promise
   */
  constructor(executor, onCancel) {
    if (onCancel !== void 0) {
      this.onCancel = onCancel;
    }
    this.#promise = new Promise((resolve, reject) => {
      this.#reject = (reason) => {
        this.#isSettled = true;
        reject((0, import_Error.errorOf)(reason));
      };
      executor(
        (value) => {
          if (this.#isSettled) {
            return;
          }
          this.#isSettled = true;
          resolve(value);
        },
        (reason) => {
          if (this.#isSettled) {
            CancelablePromise.logger.warn(`Cancelable promise rejected after settle:`, reason);
            return;
          }
          this.#reject(reason);
        }
      );
    });
  }
  /**
   * Cancel the operation.
   */
  cancel(reason = new import_MatterError.CanceledError()) {
    if (this.#isSettled) {
      return;
    }
    try {
      this.onCancel(reason);
    } catch (e) {
      this.#reject(e);
    }
  }
  /**
   * Implement cancelation.  This is only invoked if the promise has not resolved.
   *
   * Throwing causes the promise to reject with the error thrown.  The default implementation rethrows {@link reason}.
   *
   * This is overwritten if there is an "onCancel" argument to the constructor.
   */
  onCancel(reason) {
    throw reason;
  }
  then(onfulfilled, onrejected) {
    const result = this.#promise.then(onfulfilled, onrejected);
    result.cancel = this.cancel.bind(this);
    return result;
  }
  catch(onrejected) {
    return this.then(onrejected);
  }
  finally(onfinally) {
    const handler = (result) => {
      onfinally?.();
      return result;
    };
    return this.then(handler, handler);
  }
  get [Symbol.toStringTag]() {
    return this.#promise[Symbol.toStringTag];
  }
  static is(value) {
    return import_Promises.MaybePromise.is(value) && typeof value.cancel === "function";
  }
  static resolve(value) {
    const result = Promise.resolve(value);
    result.cancel = () => {
    };
    return result;
  }
  static reject(cause) {
    const result = Promise.reject((0, import_Error.errorOf)(cause));
    result.cancel = () => {
    };
    return result;
  }
  static set logger(logger) {
    this.#logger = logger;
  }
  static get logger() {
    return this.#logger;
  }
}
class CancelableAsyncIterator {
  // The result of the final iteration
  #settled;
  // The input next implementation
  #next;
  // We race against this promise to detect cancelation during next()
  #canceled;
  // Rejects #canceled
  #reject;
  /**
   * Create a new instance.
   *
   * @param next the function that produces results
   * @param onCancel if provided this will overwrite {@link onCancel}
   */
  constructor(next, onCancel) {
    this.#next = next;
    this.#canceled = new Promise((_resolve, reject) => this.#reject = reject);
    if (onCancel !== void 0) {
      this.onCancel = onCancel;
    }
  }
  next(...[value]) {
    if (this.#settled) {
      return Promise.resolve({ done: true });
    }
    const next = value === void 0 ? this.#next() : this.#next(value);
    next.catch((reason) => {
      if (this.#settled) {
        CancelablePromise.logger.warn(`Cancelable async iterator rejected after return:`, reason);
      }
    });
    return Promise.race([next, this.#canceled]).then(
      (result) => {
        if (result.done) {
          this.#settled = true;
        }
        return result;
      },
      (reason) => {
        this.#settled = true;
        throw reason;
      }
    );
  }
  cancel(reason) {
    if (this.#settled) {
      return;
    }
    try {
      this.onCancel(reason);
    } catch (e) {
      this.#reject(e);
    }
  }
  /**
   * Handle cancelation.
   *
   * If the underlying operation supports cancelation then it is better to use that.  Otherwise throwing
   * {@link reason} (the default behavior) will reject the current (or next) iteration regardless of the state of the
   * underyling operation.
   *
   * @param reason the reason provided to {@link cancel}
   */
  onCancel(reason) {
    throw reason;
  }
  static is(value) {
    return typeof value === "object" && value !== null && Symbol.asyncIterator in value && typeof value[Symbol.asyncIterator] === "function" && "cancel" in value && typeof value["cancel"] === "function";
  }
}
function Cancelable(executor) {
  return function cancelable(...args) {
    let delegates;
    return new CancelablePromise(
      (resolve, reject) => {
        try {
          const result = executor.call(this, cancelable2, ...args);
          if (import_Promises.MaybePromise.is(result)) {
            result.then(resolve, reject);
            return;
          }
          resolve(result);
        } catch (e) {
          reject(e);
        }
        function cancelable2(value) {
          if (CancelablePromise.is(value)) {
            const undelegate = addDelegate((reason) => value.cancel(reason));
            return value.finally(undelegate);
          }
          if (CancelableAsyncIterator.is(value)) {
            const undelegate = addDelegate((reason) => value.cancel(reason));
            const next = value.next.bind(value);
            value.next = () => {
              return next().then(
                (result) => {
                  if (result.done) {
                    undelegate();
                  }
                  return result;
                },
                (reason) => {
                  undelegate();
                  throw reason;
                }
              );
            };
            return value;
          }
          if (import_Promises.MaybePromise.is(value)) {
            const { promise, rejecter } = (0, import_Promises.createPromise)();
            const undelegate = addDelegate((reason) => rejecter(reason));
            return Promise.race([promise, value]).finally(() => undelegate);
          }
          return value;
        }
      },
      // Our "onCancel" that delegates to any registered delegators or simply rethrows if no delegation is active
      (reason) => {
        if (!delegates?.size) {
          throw reason;
        }
        for (const delegate of delegates) {
          delegate(reason);
        }
      }
    );
    function addDelegate(delegate) {
      if (!delegates) {
        delegates = /* @__PURE__ */ new Set();
      }
      delegates.add(delegate);
      return () => {
        delegates?.delete(delegate);
      };
    }
  };
}
//# sourceMappingURL=Cancelable.js.map
