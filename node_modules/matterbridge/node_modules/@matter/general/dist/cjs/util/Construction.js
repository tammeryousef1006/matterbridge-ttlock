"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Construction_exports = {};
__export(Construction_exports, {
  Construction: () => Construction,
  asyncNew: () => asyncNew
});
module.exports = __toCommonJS(Construction_exports);
var import_Logger = require("../log/Logger.js");
var import_MatterError = require("../MatterError.js");
var import_Error = require("./Error.js");
var import_Lifecycle = require("./Lifecycle.js");
var import_Observable = require("./Observable.js");
var import_Promises = require("./Promises.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
async function asyncNew(constructor, ...args) {
  const subject = new constructor(...args);
  if (subject.construction.status === import_Lifecycle.Lifecycle.Status.Inactive) {
    throw new import_MatterError.ImplementationError(
      `You cannot use asyncNew on ${constructor.name} because its construction is controlled by another component`
    );
  }
  await subject.construction.ready;
  return subject;
}
function Construction(subject, initializer) {
  if (!initializer) {
    assertDeferred(subject);
  }
  let initializerPromise;
  let awaiterPromise;
  let awaiterResolve;
  let awaiterReject;
  let closedPromise;
  let closedResolve;
  let closedReject;
  let error;
  let errorForDependencies;
  let primaryCauseHandled = false;
  let status = import_Lifecycle.Lifecycle.Status.Inactive;
  let change;
  const self = {
    [Symbol.toStringTag]: "Construction",
    get error() {
      return error;
    },
    get status() {
      return status;
    },
    get change() {
      if (change === void 0) {
        change = (0, import_Observable.Observable)();
      }
      return change;
    },
    get isErrorHandled() {
      return primaryCauseHandled;
    },
    start(...args) {
      if (status !== import_Lifecycle.Lifecycle.Status.Inactive) {
        throw new import_MatterError.ImplementationError(`Cannot initialize ${subject} because it is already active`);
      }
      assertDeferred(subject);
      status = import_Lifecycle.Lifecycle.Status.Initializing;
      try {
        const initializeDeferred = () => subject[Construction.construct](...args);
        invokeInitializer(initializeDeferred);
      } catch (e) {
        rejected(e);
        return;
      }
    },
    assert(description, dependency) {
      import_Lifecycle.Lifecycle.assertActive(status, description ?? subject.constructor.name);
      if (arguments.length < 2) {
        return;
      }
      try {
        if (dependency === void 0) {
          throw new import_MatterError.ImplementationError(`Property is undefined`);
        }
      } catch (e) {
        let error2;
        if (e instanceof Error) {
          error2 = e;
        } else {
          error2 = new import_MatterError.ImplementationError(e?.toString() ?? "(unknown error)");
        }
        error2.message = `Cannot access ${description}: ${error2.message}`;
        throw error2;
      }
      return dependency;
    },
    then(onfulfilled, onrejected) {
      const handleRejection = onrejected ? () => onrejected?.(crashedError()) : void 0;
      if (status === import_Lifecycle.Lifecycle.Status.Inactive || status === import_Lifecycle.Lifecycle.Status.Initializing) {
        if (!awaiterPromise) {
          awaiterPromise = new Promise((resolve, reject) => {
            awaiterResolve = resolve;
            awaiterReject = reject;
          });
        }
        return awaiterPromise.then(onfulfilled, handleRejection);
      }
      const promise = error ? Promise.reject(crashedError()) : Promise.resolve(subject);
      return promise.then(onfulfilled, handleRejection);
    },
    catch(onrejected) {
      return this.then(void 0, onrejected);
    },
    onSuccess(actor) {
      const onSuccess = () => {
        const errorHandler = createErrorHandler("onSuccess");
        try {
          const result = actor();
          if (import_Promises.MaybePromise.is(result)) {
            return Promise.resolve(result).catch(errorHandler);
          }
        } catch (e) {
          errorHandler(e);
        }
      };
      this.then(onSuccess).catch((e) => {
        import_Lifecycle.CrashedDependencyError.accept(e);
      });
    },
    onError(actor) {
      const onError = (error2) => {
        const errorHandler = createErrorHandler("onError");
        try {
          const result = actor((0, import_Error.errorOf)(error2));
          if (import_Promises.MaybePromise.is(result)) {
            return result.then(void 0, errorHandler);
          }
        } catch (e) {
          errorHandler(e);
        }
      };
      this.ready.catch(onError);
    },
    onCompletion(actor) {
      const onCompletion = () => {
        const errorHandler = createErrorHandler("onCompletion");
        try {
          actor();
        } catch (e) {
          errorHandler(e);
        }
      };
      this.then(onCompletion, onCompletion);
    },
    close(destructor) {
      const destructorError = createErrorHandler("destructor");
      function destroyed() {
        setStatus(import_Lifecycle.Lifecycle.Status.Destroyed);
        if (closedResolve) {
          closedResolve();
          closedResolve = closedReject = void 0;
        }
      }
      const destruct = subject[Construction.destruct];
      const invokeDestruct = destruct ? function invokeDestruct2() {
        try {
          const promise = destruct.bind(subject)();
          if (promise) {
            return promise.then(void 0, destructorError).then(destroyed);
          }
        } catch (e) {
          destructorError(e);
        }
        destroyed();
      } : destroyed;
      const invokeDestructor = destructor ? function invokeDestructor2() {
        try {
          const promise = destructor();
          if (promise) {
            return promise.then(void 0, destructorError).then(invokeDestruct);
          }
        } catch (e) {
          destructorError(e);
        }
        invokeDestruct();
      } : invokeDestruct;
      function beginDestruction() {
        if (status === import_Lifecycle.Lifecycle.Status.Destroying || status === import_Lifecycle.Lifecycle.Status.Destroyed) {
          return self.closed;
        }
        setStatus(import_Lifecycle.Lifecycle.Status.Destroying);
        return invokeDestructor();
      }
      if (status === import_Lifecycle.Lifecycle.Status.Initializing) {
        return this.then(beginDestruction, beginDestruction);
      }
      return beginDestruction();
    },
    finally(onfinally) {
      return Promise.prototype.finally.call(this, onfinally);
    },
    setStatus(newStatus) {
      if (this.status === newStatus) {
        return;
      }
      switch (status) {
        case newStatus:
          return;
        case import_Lifecycle.Lifecycle.Status.Destroying:
          if (newStatus !== import_Lifecycle.Lifecycle.Status.Destroyed) {
            throw new import_MatterError.ImplementationError("Cannot change status because destruction is ongoing");
          }
          break;
        case import_Lifecycle.Lifecycle.Status.Destroyed:
          throw new import_MatterError.ImplementationError("Cannot change status because destruction is final");
        case import_Lifecycle.Lifecycle.Status.Initializing:
          throw new import_MatterError.ImplementationError("Cannot change status because initialization is ongoing");
      }
      switch (newStatus) {
        case import_Lifecycle.Lifecycle.Status.Inactive:
          awaiterPromise = closedPromise = void 0;
          primaryCauseHandled = false;
          error = errorForDependencies = void 0;
          break;
        case import_Lifecycle.Lifecycle.Status.Active:
          awaiterPromise = closedPromise = void 0;
          error = errorForDependencies = void 0;
          break;
        default:
          break;
      }
      setStatus(newStatus);
    },
    crash(newError) {
      error = newError;
      setStatus(import_Lifecycle.Lifecycle.Status.Crashed);
    },
    get ready() {
      return {
        [Symbol.toStringTag]: "AsyncConstruction#primary",
        then(onfulfilled, onrejected) {
          let rejectionHandler;
          if (onrejected) {
            primaryCauseHandled = true;
            rejectionHandler = () => onrejected((0, import_Error.errorOf)(error));
          }
          return self.then(onfulfilled, rejectionHandler);
        },
        catch(onrejected) {
          return this.then(void 0, onrejected);
        },
        finally(onfinally) {
          return Promise.prototype.finally.call(this, onfinally);
        }
      };
    },
    get closed() {
      if (closedPromise === void 0) {
        closedPromise = new Promise((resolve, reject) => {
          closedResolve = resolve;
          closedReject = reject;
        });
      }
      return {
        [Symbol.toStringTag]: "AsyncConstruction#primary",
        then(onfulfilled, onrejected) {
          let rejectionHandler;
          if (onrejected) {
            primaryCauseHandled = true;
            rejectionHandler = () => onrejected((0, import_Error.errorOf)(error));
          }
          return closedPromise.then(onfulfilled, rejectionHandler);
        },
        catch(onrejected) {
          return this.then(void 0, onrejected);
        },
        finally(onfinally) {
          return Promise.prototype.finally.call(this, onfinally);
        }
      };
    }
  };
  if (initializer) {
    invokeInitializer(initializer);
  }
  return self;
  function invokeInitializer(initializer2) {
    status = import_Lifecycle.Lifecycle.Status.Initializing;
    initializerPromise = initializer2();
    if (import_Promises.MaybePromise.is(initializerPromise)) {
      initializerPromise.then(resolved, rejected);
    } else {
      resolved();
    }
  }
  function crashedError() {
    if (!primaryCauseHandled && error) {
      primaryCauseHandled = true;
      return error;
    }
    if (errorForDependencies) {
      return errorForDependencies;
    }
    let what;
    if (subject.toString === Object.prototype.toString) {
      what = subject.constructor.name;
    } else {
      what = subject.toString();
    }
    errorForDependencies = new import_Lifecycle.CrashedDependencyError(what, "unavailable due to initialization error");
    errorForDependencies.subject = subject;
    errorForDependencies.cause = error;
    return errorForDependencies;
  }
  function setStatus(newStatus) {
    if (status === newStatus) {
      return;
    }
    status = newStatus;
    if (change) {
      change.emit(status, subject);
    }
  }
  function resolved() {
    if (status === import_Lifecycle.Lifecycle.Status.Initializing) {
      setStatus(import_Lifecycle.Lifecycle.Status.Active);
    }
    if (awaiterResolve) {
      const resolve = awaiterResolve;
      awaiterResolve = awaiterReject = void 0;
      resolve(subject);
    }
  }
  function rejected(cause) {
    if (status !== import_Lifecycle.Lifecycle.Status.Destroying && status !== import_Lifecycle.Lifecycle.Status.Destroyed) {
      error = cause;
      setStatus(import_Lifecycle.Lifecycle.Status.Crashed);
    }
    if (awaiterReject) {
      const reject = awaiterReject;
      awaiterResolve = awaiterReject = void 0;
      reject(crashedError());
    }
    if (closedReject) {
      primaryCauseHandled = true;
      const reject = closedReject;
      closedResolve = closedReject = void 0;
      reject(cause);
    }
    if (!primaryCauseHandled) {
      unhandledError(cause);
    }
  }
  function unhandledError(...args) {
    const logger = import_Logger.Logger.get(subject.constructor.name);
    logger.error(...args);
  }
  function createErrorHandler(name) {
    return (e) => {
      unhandledError(`Unhandled error in ${subject} ${name}:`, e);
    };
  }
}
((Construction2) => {
  function all(subjects, onError) {
    if (onError === void 0) {
      onError = (errors) => new import_Lifecycle.CrashedDependenciesError(errors);
    }
    const subjectArray = [...subjects];
    const uninitialized = subjectArray.filter(
      (subject) => subject.construction.status === import_Lifecycle.Lifecycle.Status.Initializing
    );
    if (uninitialized.length) {
      return Promise.allSettled(uninitialized.map((backing) => backing.construction)).then(
        () => (
          // Recurse to ensure subjects added subsequent to initial "all" settle
          all(subjects, onError)
        )
      );
    }
    const crashed = Object.values(subjectArray).filter(
      (subject) => subject.construction.status === import_Lifecycle.Lifecycle.Status.Crashed
    );
    if (crashed.length) {
      let error;
      try {
        error = onError(crashed);
      } catch (e) {
        error = (0, import_Error.asError)(e);
      }
      if (error) {
        return Promise.reject(error);
      }
    }
  }
  Construction2.all = all;
  Construction2.construct = Symbol("construct");
  Construction2.destruct = Symbol("destruct");
})(Construction || (Construction = {}));
function assertDeferred(subject) {
  if (typeof subject?.[Construction.construct] !== "function") {
    throw new import_MatterError.ImplementationError(`No initializer defined for ${subject}`);
  }
}
//# sourceMappingURL=Construction.js.map
