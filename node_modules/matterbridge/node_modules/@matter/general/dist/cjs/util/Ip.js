"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Ip_exports = {};
__export(Ip_exports, {
  ipv4ToBytes: () => ipv4ToBytes,
  ipv4ToNumber: () => ipv4ToNumber,
  ipv6ToArray: () => ipv6ToArray,
  ipv6ToBytes: () => ipv6ToBytes,
  isIPv4: () => isIPv4,
  isIPv6: () => isIPv6,
  onSameNetwork: () => onSameNetwork
});
module.exports = __toCommonJS(Ip_exports);
var import_Bytes = require("./Bytes.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
function isIPv4(ip) {
  return ip.includes(".");
}
function isIPv6(ip) {
  return ip.includes(":");
}
function ipv4ToNumber(ip) {
  const dataView = import_Bytes.Bytes.dataViewOf(ipv4ToBytes(ip));
  return dataView.getUint32(0);
}
function ipv4ToBytes(ip) {
  const array = new Uint8Array(4);
  const ipParts = ip.split(".");
  for (let i = 0; i < 4; i++) {
    array[i] = parseInt(ipParts[i]);
  }
  return array;
}
function ipv6ToArray(ip) {
  const array = new Uint16Array(8);
  let ipParts = ip.split(":");
  const valueCount = ipParts.filter((value) => value !== "").length;
  if (valueCount !== 8) {
    ipParts = ip.replace("::", ":".padEnd((8 - valueCount) * 2 + 1, "0:")).split(":");
  }
  let index = 0;
  ipParts.forEach((part) => {
    if (part === "") return;
    array[index++] = parseInt(part, 16);
  });
  return array;
}
function ipv6ToBytes(ip) {
  return Uint8Array.from(Array.from(ipv6ToArray(ip)).flatMap((value) => [value >> 8, value & 255]));
}
function onSameNetwork(ip1, ip2, mask) {
  if (isIPv4(ip1)) {
    if (!isIPv4(ip2) || !isIPv4(mask)) return false;
    const ip1Number = ipv4ToNumber(ip1);
    const ip2Number = ipv4ToNumber(ip2);
    const maskNumber = ipv4ToNumber(mask);
    return (ip1Number & maskNumber) === (ip2Number & maskNumber);
  } else {
    if (isIPv4(ip2) || isIPv4(mask)) return false;
    const ip1Array = ipv6ToArray(ip1);
    const ip2Array = ipv6ToArray(ip2);
    const maskArray = ipv6ToArray(mask);
    for (let i = 0; i < 16; i++) {
      const mask2 = maskArray[i];
      if (mask2 === 0) return true;
      if ((ip1Array[i] & mask2) !== (ip2Array[i] & mask2)) return false;
    }
  }
}
//# sourceMappingURL=Ip.js.map
