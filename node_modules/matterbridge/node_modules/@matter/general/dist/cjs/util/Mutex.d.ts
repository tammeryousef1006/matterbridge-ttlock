/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * A mutex is a task queue where at most one task is active at a time.
 */
export declare class Mutex implements PromiseLike<unknown> {
    #private;
    constructor(owner: {}, initial?: PromiseLike<unknown>);
    /**
     * As a PromiseLike, you can await the Mutex.  This promise resolves when current activity completes but the mutex
     * may engage in another activity immediately thereafter.  So the mutex is not guaranteed to be available after an
     * await.
     */
    then<TResult1 = void, TResult2 = never>(onfulfilled?: ((value: unknown) => TResult1 | PromiseLike<TResult1>) | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null): PromiseLike<TResult1 | TResult2>;
    /**
     * Enqueue additional work.
     *
     * If {@link task} is a function it runs when current activity completes.  If it is a promise then the mutex will
     * not clear until {@link task} resolves.
     */
    run(task: PromiseLike<unknown> | (() => PromiseLike<unknown>), cancel?: () => void): void;
    /**
     * Enqueue work with an awaitable result.
     */
    produce<T>(task: () => PromiseLike<T>, cancel?: () => void): Promise<T>;
    /**
     * Cancel remaining work and perform one last task with the Mutex held.
     */
    terminate(cleanup?: () => PromiseLike<void>): void;
    /**
     * Activate a task.
     */
    protected initiateTask(task: PromiseLike<unknown> | (() => PromiseLike<unknown>)): Promise<unknown>;
}
//# sourceMappingURL=Mutex.d.ts.map