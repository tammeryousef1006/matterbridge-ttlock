"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Mutex_exports = {};
__export(Mutex_exports, {
  Mutex: () => Mutex
});
module.exports = __toCommonJS(Mutex_exports);
var import_Logger = require("../log/Logger.js");
var import_Error = require("./Error.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_Logger.Logger.get("Mutex");
class Mutex {
  #owner;
  #cancel;
  #canceled = false;
  #promise;
  constructor(owner, initial) {
    this.#owner = owner;
    if (initial) {
      this.run(() => initial);
    }
  }
  /**
   * As a PromiseLike, you can await the Mutex.  This promise resolves when current activity completes but the mutex
   * may engage in another activity immediately thereafter.  So the mutex is not guaranteed to be available after an
   * await.
   */
  then(onfulfilled, onrejected) {
    return (this.#promise || Promise.resolve()).then(onfulfilled, onrejected);
  }
  /**
   * Enqueue additional work.
   *
   * If {@link task} is a function it runs when current activity completes.  If it is a promise then the mutex will
   * not clear until {@link task} resolves.
   */
  run(task, cancel) {
    if (this.#canceled) {
      cancel?.();
      return;
    }
    if (!this.#promise) {
      this.#promise = this.initiateTask(task);
    } else {
      this.#promise = this.#promise.then(() => {
        if (this.#canceled) {
          cancel?.();
          return;
        }
        this.#cancel = cancel;
        return this.initiateTask(task).finally(() => {
          this.#cancel = void 0;
        });
      });
    }
  }
  /**
   * Enqueue work with an awaitable result.
   */
  produce(task, cancel) {
    return new Promise((resolve, reject) => {
      this.run(async () => {
        try {
          resolve(await task());
        } catch (e) {
          reject((0, import_Error.asError)(e));
        }
      }, cancel);
    });
  }
  /**
   * Cancel remaining work and perform one last task with the Mutex held.
   */
  terminate(cleanup) {
    if (this.#canceled) {
      return;
    }
    this.#canceled = true;
    if (this.#cancel) {
      this.#cancel();
    }
    if (cleanup) {
      if (!this.#promise) {
        this.#promise = this.initiateTask(cleanup);
      } else {
        this.#promise = this.#promise.then(() => this.initiateTask(cleanup));
      }
    }
  }
  /**
   * Activate a task.
   */
  async initiateTask(task) {
    if (typeof task === "function") {
      task = task();
    }
    return Promise.resolve(task).catch((cause) => logger.error(`Unhandled error in ${this.#owner} worker:`, cause));
  }
}
//# sourceMappingURL=Mutex.js.map
