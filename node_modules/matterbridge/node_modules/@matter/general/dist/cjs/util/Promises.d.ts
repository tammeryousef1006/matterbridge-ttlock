/**
 * Utils for promises.
 *
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { MatterError } from "../MatterError.js";
/**
 * Obtain a promise with functions to resolve and reject.
 */
export declare function createPromise<T>(): {
    promise: Promise<T>;
    resolver: (value: T) => void;
    rejecter: (reason?: any) => void;
};
/**
 * Use all promises or promise returning methods and return the first resolved promise or reject when all promises
 * rejected
 */
export declare function anyPromise<T>(promises: ((() => Promise<T>) | Promise<T>)[]): Promise<T>;
/**
 * Thrown when a timed promise times out.
 */
export declare class PromiseTimeoutError extends MatterError {
    constructor(message?: string);
}
/**
 * Create a promise with a timeout.
 *
 * By default, rejects with {@link PromiseTimeoutError} on timeout but you can override by supplying {@link cancel}.
 *
 * @param timeoutMs the timeout in milliseconds
 * @param promise a promise that resolves or rejects when the timed task completes
 * @param cancel invoked on timeout (default implementation throws {@link PromiseTimeoutError})
 */
export declare function withTimeout<T>(timeoutMs: number, promise: Promise<T>, cancel?: AbortController | (() => void)): Promise<T>;
/**
 * Return type for functions that are optionally asynchronous.
 *
 * TODO - as currently defined MaybePromise of a Promise incorrectly wraps as a Promise of a Promise
 */
export type MaybePromise<T = void> = T | PromiseLike<T>;
/**
 * Promise-like version of above.
 */
export type MaybePromiseLike<T = void> = T | PromiseLike<T>;
export declare const MaybePromise: {
    /**
     * Determine whether a {@link MaybePromiseLike} is a {@link Promise}.
     */
    is<T>(value: MaybePromise<T>): value is PromiseLike<T>;
    /**
     * Chained MaybePromise.  Invokes the resolve function immediately if the {@link MaybePromise} is not a
     * {@link Promise}, otherwise the same as a normal {@link Promise.then}.
     */
    then<I, O1 = never, O2 = never>(producer: MaybePromise<I> | (() => MaybePromise<I>), resolve?: ((input: I) => MaybePromise<O1>) | null, reject?: ((error: any) => MaybePromise<O2>) | null): MaybePromise<O1 | O2>;
    /**
     * Equivalent of {@link Promise.catch}.
     */
    catch<T, TResult = never>(producer: MaybePromise<T> | (() => MaybePromise<T>), onrejected?: ((reason: any) => MaybePromise<TResult>) | null): MaybePromise<TResult>;
    /**
     * Equivalent of {@link Promise.finally}.
     */
    finally<T>(producer: MaybePromise<T> | (() => MaybePromise<T>), onfinally?: (() => MaybePromise<void>) | null): MaybePromise<T>;
    [Symbol.toStringTag]: string;
};
//# sourceMappingURL=Promises.d.ts.map