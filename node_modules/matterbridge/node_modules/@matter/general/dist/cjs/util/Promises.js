"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Promises_exports = {};
__export(Promises_exports, {
  MaybePromise: () => MaybePromise,
  PromiseTimeoutError: () => PromiseTimeoutError,
  anyPromise: () => anyPromise,
  createPromise: () => createPromise,
  withTimeout: () => withTimeout
});
module.exports = __toCommonJS(Promises_exports);
var import_Error = require("#util/Error.js");
var import_MatterError = require("../MatterError.js");
var import_Time = require("../time/Time.js");
/**
 * Utils for promises.
 *
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
function createPromise() {
  let resolver, rejecter;
  const promise = new Promise((resolve, reject) => {
    resolver = resolve;
    rejecter = reject;
  });
  if (!resolver || !rejecter) {
    throw new import_MatterError.InternalError("Failed to extract resolve/reject from Promise context");
  }
  return {
    promise,
    resolver,
    rejecter
  };
}
function anyPromise(promises) {
  return new Promise((resolve, reject) => {
    let numberRejected = 0;
    let wasResolved = false;
    for (const entry of promises) {
      const promise = typeof entry === "function" ? entry() : entry;
      promise.then((value) => {
        if (!wasResolved) {
          wasResolved = true;
          resolve(value);
        }
      }).catch((reason) => {
        numberRejected++;
        if (!wasResolved && numberRejected === promises.length) {
          reject(reason);
        }
      });
    }
  });
}
class PromiseTimeoutError extends import_MatterError.MatterError {
  constructor(message = "Operation timed out") {
    super(message);
  }
}
async function withTimeout(timeoutMs, promise, cancel) {
  let cancelFn;
  if (typeof cancel === "function") {
    cancelFn = cancel;
  } else if (typeof cancel?.abort === "function") {
    cancelFn = () => cancel.abort();
  } else {
    cancelFn = () => {
      throw new PromiseTimeoutError();
    };
  }
  let cancelTimer;
  const timeout = new Promise((resolve, reject) => {
    const timer = import_Time.Time.getTimer("promise-timeout", timeoutMs, () => {
      try {
        cancelFn();
      } catch (e) {
        reject((0, import_Error.asError)(e));
        return;
      }
      reject(new Error("Timer canceled promise, but no error was thrown"));
    });
    cancelTimer = () => {
      timer.stop();
      resolve();
    };
    timer.start();
  });
  let result;
  const producer = promise.then(
    (r) => {
      cancelTimer?.();
      result = r;
    },
    (e) => {
      cancelTimer?.();
      throw e;
    }
  );
  await Promise.all([timeout, producer]);
  return result;
}
const MaybePromise = {
  /**
   * Determine whether a {@link MaybePromiseLike} is a {@link Promise}.
   */
  is(value) {
    return typeof value === "object" && value !== null && typeof value.then === "function" && value !== this;
  },
  /**
   * Chained MaybePromise.  Invokes the resolve function immediately if the {@link MaybePromise} is not a
   * {@link Promise}, otherwise the same as a normal {@link Promise.then}.
   */
  then(producer, resolve, reject) {
    let rejected = false;
    try {
      let value;
      if (producer instanceof Function) {
        value = producer();
      } else {
        value = producer;
      }
      if (MaybePromise.is(value)) {
        return value.then(
          resolve,
          reject ? (error) => {
            rejected = true;
            return reject?.(error);
          } : void 0
        );
      }
      if (resolve) {
        return resolve(value);
      }
    } catch (e) {
      if (reject && !rejected) {
        return reject(e);
      }
      throw e;
    }
    return void 0;
  },
  /**
   * Equivalent of {@link Promise.catch}.
   */
  catch(producer, onrejected) {
    return this.then(producer, void 0, onrejected);
  },
  /**
   * Equivalent of {@link Promise.finally}.
   */
  finally(producer, onfinally) {
    let result;
    try {
      if (typeof producer === "function") {
        result = producer();
      } else {
        result = producer;
      }
    } finally {
      if (MaybePromise.is(result)) {
        if (typeof result.finally === "function") {
          result = result.finally(onfinally);
        } else {
          result = result.then(
            (value) => MaybePromise.then(
              () => onfinally?.(),
              () => value
            ),
            (error) => MaybePromise.then(
              () => onfinally?.(),
              () => {
                throw error;
              }
            )
          );
        }
      } else {
        const finallyResult = onfinally?.();
        if (MaybePromise.is(finallyResult)) {
          const actualResult = result;
          result = finallyResult.then(() => actualResult);
        }
      }
    }
    return result;
  },
  [Symbol.toStringTag]: "MaybePromise"
};
MaybePromise.toString = () => "MaybePromise";
//# sourceMappingURL=Promises.js.map
