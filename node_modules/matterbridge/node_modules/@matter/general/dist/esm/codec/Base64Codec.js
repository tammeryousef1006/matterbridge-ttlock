/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
function cp(text) {
  return text.codePointAt(0) ?? 0;
}
const A2B = [];
const B2A = new Uint8Array(64);
const B2A_URL = new Uint8Array(64);
const PAD = cp("=");
{
  let addRange = function(start, stop) {
    const end = cp(stop) + 1;
    for (let i = cp(start); i < end; i++) {
      A2B[i] = pos;
      B2A[pos++] = i;
    }
  };
  var addRange2 = addRange;
  let pos = 0;
  addRange("A", "Z");
  addRange("a", "z");
  addRange("0", "9");
  addRange("+", "+");
  addRange("/", "/");
  const slashValue = A2B[cp("/")];
  const plusValue = A2B[cp("+")];
  A2B[cp("_")] = slashValue;
  A2B[cp("-")] = plusValue;
  B2A_URL.set(B2A);
  B2A_URL[slashValue] = cp("_");
  B2A_URL[plusValue] = cp("-");
}
var Base64;
((Base642) => {
  function encode(input, url = false) {
    const dict = url ? B2A_URL : B2A;
    let outLength = Math.trunc(input.length / 3) * 4;
    if (url) {
      const partial = input.length % 3;
      if (partial) outLength += partial + 1;
    } else {
      outLength += input.length % 3 ? 4 : 0;
    }
    const out = new Uint8Array(outLength);
    for (let inPos = 0, outPos = 0; outPos < outLength; ) {
      const n = (input[inPos++] << 16) + ((input[inPos++] ?? 0) << 8) + (input[inPos++] ?? 0);
      out[outPos++] = dict[n >>> 18];
      out[outPos++] = dict[n >>> 12 & 63];
      if (inPos - input.length === 2) {
        if (!url) out[outPos++] = PAD;
      } else {
        out[outPos++] = dict[n >>> 6 & 63];
      }
      if (inPos > input.length) {
        if (!url) out[outPos++] = PAD;
      } else {
        out[outPos++] = dict[n & 63];
      }
    }
    return new TextDecoder().decode(out);
  }
  Base642.encode = encode;
  function decode(input) {
    if (!input.length) {
      return new Uint8Array();
    }
    let inputLength = input.length;
    while (input.codePointAt(inputLength - 1) === PAD) inputLength--;
    let outLength = Math.trunc(inputLength / 4) * 3;
    switch (inputLength % 4) {
      case 3:
        outLength += 2;
        break;
      case 2:
        outLength += 1;
        break;
      case 1:
        throw new Error("Invalid base-64 encoding");
    }
    const out = new Uint8Array(outLength);
    for (let inPos = 0, outPos = 0; ; ) {
      let lookup2 = function() {
        if (inPos >= inputLength) return 0;
        const v = A2B[input.codePointAt(inPos++) ?? -1];
        if (v === void 0) {
          throw new Error("Invalid base-64 encoding");
        }
        return v;
      };
      var lookup = lookup2;
      const n = (lookup2() << 18) + (lookup2() << 12) + (lookup2() << 6) + lookup2();
      out[outPos++] = n >>> 16;
      if (outPos < outLength) {
        out[outPos++] = n >>> 8 & 255;
      } else {
        break;
      }
      if (outPos < outLength) {
        out[outPos++] = n & 255;
      } else {
        break;
      }
    }
    return out;
  }
  Base642.decode = decode;
})(Base64 || (Base64 = {}));
export {
  Base64
};
//# sourceMappingURL=Base64Codec.js.map
