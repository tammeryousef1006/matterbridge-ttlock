/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { UnexpectedDataError } from "../MatterError.js";
import { Bytes, Endian } from "../util/Bytes.js";
import { DataReader } from "../util/DataReader.js";
import { toHex } from "../util/Number.js";
import { isObject } from "../util/Type.js";
var DerKey = /* @__PURE__ */ ((DerKey2) => {
  DerKey2["ObjectId"] = "_objectId";
  DerKey2["TagId"] = "_tag";
  DerKey2["Bytes"] = "_bytes";
  DerKey2["Elements"] = "_elements";
  DerKey2["BitsPadding"] = "_padding";
  DerKey2["TypeOverride"] = "_type";
  DerKey2["RawData"] = "_raw";
  return DerKey2;
})(DerKey || {});
class DerError extends UnexpectedDataError {
}
var DerType = /* @__PURE__ */ ((DerType2) => {
  DerType2[DerType2["Boolean"] = 1] = "Boolean";
  DerType2[DerType2["Integer"] = 2] = "Integer";
  DerType2[DerType2["BitString"] = 3] = "BitString";
  DerType2[DerType2["OctetString"] = 4] = "OctetString";
  DerType2[DerType2["Null"] = 5] = "Null";
  DerType2[DerType2["ObjectIdentifier"] = 6] = "ObjectIdentifier";
  DerType2[DerType2["UTF8String"] = 12] = "UTF8String";
  DerType2[DerType2["Sequence"] = 16] = "Sequence";
  DerType2[DerType2["Set"] = 17] = "Set";
  DerType2[DerType2["PrintableString"] = 19] = "PrintableString";
  DerType2[DerType2["T16String"] = 20] = "T16String";
  DerType2[DerType2["IA5String"] = 22] = "IA5String";
  DerType2[DerType2["UtcDate"] = 23] = "UtcDate";
  DerType2[DerType2["GeneralizedTime"] = 24] = "GeneralizedTime";
  return DerType2;
})(DerType || {});
const CONSTRUCTED = 32;
var DerClass = /* @__PURE__ */ ((DerClass2) => {
  DerClass2[DerClass2["Universal"] = 0] = "Universal";
  DerClass2[DerClass2["Application"] = 64] = "Application";
  DerClass2[DerClass2["ContextSpecific"] = 128] = "ContextSpecific";
  DerClass2[DerClass2["Private"] = 192] = "Private";
  return DerClass2;
})(DerClass || {});
const ObjectId = (objectId) => ({
  ["_tag" /* TagId */]: 6 /* ObjectIdentifier */,
  ["_bytes" /* Bytes */]: Bytes.fromHex(objectId)
});
const DerObject = (objectId, content = {}) => ({
  ["_objectId" /* ObjectId */]: ObjectId(objectId),
  ...content
});
const BitByteArray = (data, padding = 0) => ({
  ["_tag" /* TagId */]: 3 /* BitString */,
  ["_bytes" /* Bytes */]: data,
  ["_padding" /* BitsPadding */]: padding
});
const ContextTagged = (tagId, value) => ({
  ["_tag" /* TagId */]: tagId | 128 /* ContextSpecific */ | CONSTRUCTED,
  ["_bytes" /* Bytes */]: value === void 0 ? new Uint8Array(0) : DerCodec.encode(value)
});
const ContextTaggedBytes = (tagId, value) => ({
  ["_tag" /* TagId */]: tagId | 128 /* ContextSpecific */,
  ["_bytes" /* Bytes */]: value
});
const DatatypeOverride = (type, value) => ({
  ["_type" /* TypeOverride */]: type,
  ["_raw" /* RawData */]: value
});
const RawBytes = (bytes) => ({
  ["_bytes" /* Bytes */]: bytes
});
class DerCodec {
  static encode(value) {
    if (Array.isArray(value)) {
      return this.encodeArray(value);
    } else if (value instanceof Uint8Array) {
      return this.encodeOctetString(value);
    } else if (value instanceof Date) {
      return this.encodeDate(value);
    } else if (typeof value === "string") {
      return this.encodeString(value);
    } else if (typeof value === "number" || typeof value === "bigint") {
      return this.encodeInteger(value);
    } else if (typeof value === "boolean") {
      return this.encodeBoolean(value);
    } else if (value === void 0) {
      return new Uint8Array(0);
    } else if (isObject(value)) {
      if (value["_tag" /* TagId */] !== void 0) {
        const { ["_tag" /* TagId */]: tagId, ["_padding" /* BitsPadding */]: bitsPadding, ["_bytes" /* Bytes */]: bytes } = value;
        if (typeof tagId !== "number") {
          throw new DerError("Tag ID is non-numeric");
        }
        if (bitsPadding !== void 0 && typeof bitsPadding !== "number") {
          throw new DerError("Bits padding is not a numeric byte value");
        }
        if (bytes === void 0 || !ArrayBuffer.isView(bytes)) {
          throw new DerError("DER bytes is not a byte array");
        }
        return this.encodeAsn1(
          tagId,
          bitsPadding === void 0 ? bytes : Bytes.concat(Uint8Array.of(bitsPadding), bytes)
        );
      } else if (value["_type" /* TypeOverride */] !== void 0 && value["_raw" /* RawData */] !== void 0) {
        if (value["_type" /* TypeOverride */] === 2 /* Integer */ && value["_raw" /* RawData */] instanceof Uint8Array) {
          return this.encodeInteger(value["_raw" /* RawData */]);
        } else if (value["_type" /* TypeOverride */] === 3 /* BitString */ && typeof value["_raw" /* RawData */] === "number") {
          return this.encodeBitString(value["_raw" /* RawData */]);
        } else if (value["_type" /* TypeOverride */] === 19 /* PrintableString */ && typeof value["_raw" /* RawData */] === "string") {
          return this.encodePrintableString(value["_raw" /* RawData */]);
        } else if (value["_type" /* TypeOverride */] === 22 /* IA5String */ && typeof value["_raw" /* RawData */] === "string") {
          return this.encodeIA5String(value["_raw" /* RawData */]);
        } else {
          throw new UnexpectedDataError(`Unsupported override type ${value["_type" /* TypeOverride */]}`);
        }
      } else if (value["_bytes" /* Bytes */] !== void 0 && value["_bytes" /* Bytes */] instanceof Uint8Array && Object.keys(value).length === 1) {
        return value["_bytes" /* Bytes */];
      } else if (value["_type" /* TypeOverride */] === void 0 && value["_bytes" /* Bytes */] === void 0) {
        return this.encodeObject(value);
      } else {
        throw new UnexpectedDataError(`Unsupported object type ${typeof value}`);
      }
    } else {
      throw new UnexpectedDataError(`Unsupported type ${typeof value}`);
    }
  }
  static encodeDate(date) {
    if (date.getFullYear() > 2049) {
      return this.encodeAsn1(
        24 /* GeneralizedTime */,
        Bytes.fromString(
          date.toISOString().replace(/[-:.T]/g, "").slice(0, 14) + "Z"
        )
      );
    } else
      return this.encodeAsn1(
        23 /* UtcDate */,
        Bytes.fromString(
          date.toISOString().replace(/[-:.T]/g, "").slice(2, 14) + "Z"
        )
      );
  }
  static encodeBoolean(bool) {
    return this.encodeAsn1(1 /* Boolean */, Uint8Array.of(bool ? 255 : 0));
  }
  static encodeArray(array) {
    return this.encodeAsn1(17 /* Set */ | CONSTRUCTED, Bytes.concat(...array.map((element) => this.encode(element))));
  }
  static encodeOctetString(value) {
    return this.encodeAsn1(4 /* OctetString */, value);
  }
  static encodeObject(object) {
    const attributes = new Array();
    for (const key in object) {
      attributes.push(this.encode(object[key]));
    }
    return this.encodeAsn1(16 /* Sequence */ | CONSTRUCTED, Bytes.concat(...attributes));
  }
  static encodeString(value) {
    return this.encodeAsn1(12 /* UTF8String */, Bytes.fromString(value));
  }
  static encodePrintableString(value) {
    if (!/^[a-z0-9 '()+,\-./:=?]*$/i.test(value)) {
      throw new UnexpectedDataError(`String ${value} is not a printable string.`);
    }
    return this.encodeAsn1(19 /* PrintableString */, Bytes.fromString(value));
  }
  static encodeIA5String(value) {
    if (!/^[\x00-\x7F]*$/.test(value)) {
      throw new UnexpectedDataError(`String ${value} is not an IA5 string.`);
    }
    return this.encodeAsn1(22 /* IA5String */, Bytes.fromString(value));
  }
  static encodeInteger(value) {
    const isByteArray = ArrayBuffer.isView(value);
    let valueBytes;
    if (isByteArray) {
      valueBytes = value;
    } else {
      valueBytes = Bytes.fromHex(toHex(value));
    }
    const byteArray = Bytes.concat(new Uint8Array(1), valueBytes);
    const dataView = Bytes.dataViewOf(byteArray);
    let start = 0;
    while (true) {
      if (dataView.getUint8(start) !== 0) break;
      if (dataView.getUint8(start + 1) >= 128) break;
      start++;
      if (start === byteArray.length - 1) break;
    }
    return this.encodeAsn1(2 /* Integer */, byteArray.slice(start));
  }
  static encodeBitString(value) {
    const reversedBits = value.toString(2).padStart(8, "0");
    const unusedBits = reversedBits.indexOf("1");
    const bitByteArray = Uint8Array.of(parseInt(reversedBits.split("").reverse().join(""), 2));
    return this.encode(BitByteArray(bitByteArray, unusedBits === -1 ? 8 : unusedBits));
  }
  static encodeLengthBytes(value) {
    const byteArray = new Uint8Array(5);
    const dataView = Bytes.dataViewOf(byteArray);
    dataView.setUint32(1, value);
    let start = 0;
    while (true) {
      if (dataView.getUint8(start) !== 0) break;
      start++;
      if (start === 4) break;
    }
    const lengthLength = byteArray.length - start;
    if (lengthLength > 1 || dataView.getUint8(start) >= 128) {
      start--;
      dataView.setUint8(start, 128 + lengthLength);
    }
    return byteArray.slice(start);
  }
  static encodeAsn1(tag, data) {
    return Bytes.concat(Uint8Array.of(tag), this.encodeLengthBytes(data.length), data);
  }
  static decode(data) {
    return this.decodeRec(new DataReader(data, Endian.Big));
  }
  static decodeRec(reader) {
    const { tag, bytes } = this.decodeAsn1(reader);
    if (tag === 3 /* BitString */)
      return { ["_tag" /* TagId */]: tag, ["_bytes" /* Bytes */]: bytes.slice(1), ["_padding" /* BitsPadding */]: bytes[0] };
    if ((tag & CONSTRUCTED) === 0) return { ["_tag" /* TagId */]: tag, ["_bytes" /* Bytes */]: bytes };
    const elementsReader = new DataReader(bytes, Endian.Big);
    const elements = [];
    while (elementsReader.remainingBytesCount > 0) {
      elements.push(this.decodeRec(elementsReader));
    }
    return { ["_tag" /* TagId */]: tag, ["_bytes" /* Bytes */]: bytes, ["_elements" /* Elements */]: elements };
  }
  static decodeAsn1(reader) {
    const tag = reader.readUInt8();
    let length = reader.readUInt8();
    if ((length & 128) !== 0) {
      let lengthLength = length & 127;
      length = 0;
      while (lengthLength > 0) {
        length = (length << 8) + reader.readUInt8();
        lengthLength--;
      }
    }
    const bytes = reader.readByteArray(length);
    return { tag, bytes };
  }
}
export {
  BitByteArray,
  ContextTagged,
  ContextTaggedBytes,
  DatatypeOverride,
  DerCodec,
  DerError,
  DerKey,
  DerObject,
  DerType,
  ObjectId,
  RawBytes
};
//# sourceMappingURL=DerCodec.js.map
