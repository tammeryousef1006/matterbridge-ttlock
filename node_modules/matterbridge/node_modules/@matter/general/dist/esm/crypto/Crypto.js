/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Boot } from "#util/Boot.js";
import * as mod from "@noble/curves/abstract/modular";
import * as utils from "@noble/curves/abstract/utils";
import { p256 } from "@noble/curves/p256";
import { MatterError, NoProviderError } from "../MatterError.js";
import { Endian } from "../util/Bytes.js";
import { DataReader } from "../util/DataReader.js";
const ec = {
  p256,
  ...utils,
  ...mod
};
const CRYPTO_RANDOM_LENGTH = 32;
const CRYPTO_ENCRYPT_ALGORITHM = "aes-128-ccm";
const CRYPTO_HASH_ALGORITHM = "sha256";
const CRYPTO_EC_CURVE = "prime256v1";
const CRYPTO_EC_KEY_BYTES = 32;
const CRYPTO_AUTH_TAG_LENGTH = 16;
const CRYPTO_SYMMETRIC_KEY_LENGTH = 16;
class CryptoVerifyError extends MatterError {
}
class Crypto {
  static get;
  static encrypt = (key, data, nonce, aad) => Crypto.get().encrypt(key, data, nonce, aad);
  static decrypt = (key, data, nonce, aad) => Crypto.get().decrypt(key, data, nonce, aad);
  static getRandomData = (length) => Crypto.get().getRandomData(length);
  static getRandom = () => Crypto.get().getRandomData(CRYPTO_RANDOM_LENGTH);
  static getRandomUInt16 = () => new DataReader(Crypto.get().getRandomData(2), Endian.Little).readUInt16();
  static getRandomUInt32 = () => new DataReader(Crypto.get().getRandomData(4), Endian.Little).readUInt32();
  static getRandomBigUInt64 = () => new DataReader(Crypto.get().getRandomData(8), Endian.Little).readUInt64();
  static getRandomBigInt = (size, maxValue) => {
    const { bytesToNumberBE } = ec;
    if (maxValue === void 0) {
      return bytesToNumberBE(Crypto.getRandomData(size));
    }
    while (true) {
      const random = bytesToNumberBE(Crypto.getRandomData(size));
      if (random < maxValue) return random;
    }
  };
  static ecdhGeneratePublicKey = () => Crypto.get().ecdhGeneratePublicKey();
  static ecdhGeneratePublicKeyAndSecret = (peerPublicKey) => Crypto.get().ecdhGeneratePublicKeyAndSecret(peerPublicKey);
  static ecdhGenerateSecret = (peerPublicKey, ecdh) => Crypto.get().ecdhGenerateSecret(peerPublicKey, ecdh);
  static hash = (data) => Crypto.get().hash(data);
  static pbkdf2 = (secret, salt, iteration, keyLength) => Crypto.get().pbkdf2(secret, salt, iteration, keyLength);
  static hkdf = (secret, salt, info, length) => Crypto.get().hkdf(secret, salt, info, length);
  static hmac = (key, data) => Crypto.get().hmac(key, data);
  static sign = (privateKey, data, dsaEncoding) => Crypto.get().sign(privateKey, data, dsaEncoding);
  static verify = (publicKey, data, signature, dsaEncoding) => Crypto.get().verify(publicKey, data, signature, dsaEncoding);
  static createKeyPair = () => Crypto.get().createKeyPair();
}
Boot.init(() => {
  Crypto.get = () => {
    throw new NoProviderError("No provider configured");
  };
  if (typeof MatterHooks !== "undefined") {
    MatterHooks.cryptoSetup?.(Crypto);
  }
});
export {
  CRYPTO_AUTH_TAG_LENGTH,
  CRYPTO_EC_CURVE,
  CRYPTO_EC_KEY_BYTES,
  CRYPTO_ENCRYPT_ALGORITHM,
  CRYPTO_HASH_ALGORITHM,
  CRYPTO_RANDOM_LENGTH,
  CRYPTO_SYMMETRIC_KEY_LENGTH,
  Crypto,
  CryptoVerifyError,
  ec
};
//# sourceMappingURL=Crypto.js.map
