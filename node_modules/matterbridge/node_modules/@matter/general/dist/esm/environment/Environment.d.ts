/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { MaybePromise } from "#util/Promises.js";
import "../polyfills/disposable.js";
import { Observable } from "../util/Observable.js";
import { Environmental } from "./Environmental.js";
import { RuntimeService } from "./RuntimeService.js";
import { VariableService } from "./VariableService.js";
/**
 * Access to general platform-dependent features.
 *
 * The following variables are defined by this class:
 * * `log.level` - Log level to use {@link Logger.LEVEL}
 * * `log.format` - Log format to use {@link Logger.FORMAT}
 * * `log.stack.limit` - Stack trace limit, see https://nodejs.org/api/errors.html#errorstacktracelimit
 * * `mdns.networkInterface` - Network interface to use for MDNS broadcasts and scanning, default are all available interfaces
 * * `mdns.ipv4` - Also announce/scan on IPv4 interfaces
 * * `network.interface` - Map of interface names to types, expected to be defined as object with name as key and of `{type: string|number}` objects with types: 1=Wifi, 2=Ethernet, 3=Cellular, 4=Thread (strings or numbers can be used). Can also be provided via env or cli like `MATTER_NETWORK_INTERFACE_ETH0_TYPE=Ethernet`
 *
 * TODO - could remove global singletons by moving here
 */
export declare class Environment {
    #private;
    constructor(name: string, parent?: Environment);
    /**
     * Determine if an environmental service is available.
     */
    has(type: abstract new (...args: any[]) => any): boolean;
    /**
     * Access an environmental service.
     */
    get<T extends object>(type: abstract new (...args: any[]) => T): T;
    /**
     * Access an environmental service that may not exist.
     */
    maybeGet<T extends object>(type: abstract new (...args: any[]) => T): T | undefined;
    /**
     * Remove an environmental service.
     *
     * @param type the class of the service to remove
     * @param instance optional instance expected, if existing instance does not match it is not deleted
     */
    delete(type: abstract new (...args: any[]) => any, instance?: any): void;
    /**
     * Remove and close an environmental service.
     */
    close<T extends object>(type: abstract new (...args: any[]) => T): T extends {
        close: () => MaybePromise<void>;
    } ? MaybePromise<void> : void;
    /**
     * Access an environmental service, waiting for any async initialization to complete.
     */
    load<T extends Environmental.Service>(type: Environmental.Factory<T>): Promise<T>;
    /**
     * Install a preinitialized version of an environmental service.
     */
    set<T extends {}>(type: abstract new (...args: any[]) => T, instance: T): void;
    /**
     * Name of the environment.
     */
    get name(): string;
    get root(): Environment;
    /**
     * Emits on service add.
     *
     * Currently only emits for services owned directly by this environment.
     */
    get added(): Observable<[type: abstract new (...args: any[]) => {}, instance: {}], void>;
    /**
     * Emits on service delete.
     *
     * Currently only emits for services owned directly by this environment.
     */
    get deleted(): Observable<[type: abstract new (...args: any[]) => {}, instance: {}], void>;
    /**
     * Obtain an object with events that trigger when a specific service is added or deleted.
     *
     * This is a more convenient way to observe a specific service than {@link added} and {@link deleted}.
     */
    eventsFor<T extends Environmental.Factory<any>>(type: T): Environmental.ServiceEvents<T>;
    /**
     * The default environment.
     *
     * Currently only emits for services owned directly by this environment.
     */
    static get default(): Environment;
    /**
     * Set the default environment.
     */
    static set default(env: Environment);
    /**
     * Shortcut for accessing {@link VariableService.vars}.
     */
    get vars(): VariableService;
    /**
     * Shortcut for accessing {@link RuntimeService}.
     */
    get runtime(): RuntimeService;
    /**
     * Display tasks that supply diagnostics.
     */
    diagnose(): void;
    protected loadVariables(): Record<string, any>;
}
//# sourceMappingURL=Environment.d.ts.map