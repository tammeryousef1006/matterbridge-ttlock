/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Diagnostic } from "../log/Diagnostic.js";
import { DiagnosticSource } from "../log/DiagnosticSource.js";
import { Logger } from "../log/Logger.js";
import { Lifecycle } from "../util/Lifecycle.js";
import { Observable } from "../util/Observable.js";
import { Environmental } from "./Environmental.js";
const logger = Logger.get("Runtime");
class RuntimeService {
  #env;
  #workers = /* @__PURE__ */ new Set();
  #cancelled = /* @__PURE__ */ new Set();
  #workerDeleted = Observable();
  #canceled = false;
  #started = Observable();
  #stopped = Observable();
  #crashed = Observable();
  constructor(environment) {
    this.#env = environment;
    environment.set(RuntimeService, this);
    DiagnosticSource.add(this);
  }
  /**
   * Add a {@link Worker}.
   *
   * The runtime considers itself "active" if there are one or more workers installed.
   *
   * A worker must either be {@link PromiseLike} or {@link Constructable} for the runtime to detect completion. On
   * completion the worker is removed and destroyed if the worker is {@link Destructable}.
   *
   * Once added, the {@link worker} is owned by the RuntimeService until closed, resolved or removed via
   * {@link delete}.
   */
  add(worker) {
    if (!worker) {
      return;
    }
    if (this.#workers.has(worker)) {
      return;
    }
    this.#workers.add(worker);
    if (this.#workers.size === 1) {
      this.#started.emit();
    }
    if (worker.then) {
      Promise.resolve(worker).catch((error) => this.#crash(error)).finally(() => this.delete(worker));
      return;
    }
    if (worker.construction?.change) {
      worker.construction.change.on((status) => {
        switch (status) {
          case Lifecycle.Status.Crashed:
            this.#crash();
            break;
          case Lifecycle.Status.Destroyed:
            this.delete(worker);
            break;
        }
      });
    }
  }
  /**
   * Remove a worker.
   */
  delete(worker) {
    if (!this.#workers.has(worker)) {
      return;
    }
    this.#workers.delete(worker);
    this.#cancelled.delete(worker);
    this.#workerDeleted.emit();
    if (this.#workers.size) {
      return;
    }
    this.cancel();
    void this.inactive.finally(() => this.#stopped.emit());
  }
  /**
   * Emits when a worker is added when previously there were none.
   */
  get started() {
    return this.#started;
  }
  /**
   * Emits when the last worker departs.
   */
  get stopped() {
    return this.#stopped;
  }
  /**
   * Emits when a worker experiences an unhandled error.
   */
  get crashed() {
    return this.#crashed;
  }
  static [Environmental.create](environment) {
    return new this(environment);
  }
  /**
   * Cancel execution.
   *
   * On cancel the runtime destroys all workers.
   */
  cancel() {
    if (this.#canceled) {
      return;
    }
    this.#canceled = true;
    logger.notice("Shutting down");
    for (const worker of this.#workers) {
      const disposal = this.#cancelWorker(worker);
      if (disposal) {
        this.add(disposal);
      }
    }
  }
  /**
   * Interrupt handler.  Triggered by e.g. on SIGINT on unixish systems.
   *
   * The default implementation cancels the runtime.
   *
   * @returns a boolean indicating whether to continue trapping interrupts
   */
  interrupt() {
    this.cancel();
    return false;
  }
  /**
   * Resolves when no workers are active.
   */
  get inactive() {
    if (!this.#workers.size) {
      return Promise.resolve();
    }
    return new Promise((resolve) => {
      const listener = () => {
        if (!this.#workers.size) {
          this.#workerDeleted.off(listener);
          resolve();
        }
      };
      this.#workerDeleted.on(listener);
    });
  }
  async close() {
    this.cancel();
    await this.inactive;
    this.#env.delete(RuntimeService, this);
    DiagnosticSource.delete(this);
  }
  [Symbol.asyncDispose]() {
    return this.close();
  }
  get [Diagnostic.value]() {
    return Diagnostic.node("\u{1F6E0}", "Workers", {
      children: [...this.#workers].map((worker) => {
        let diagnostic = worker[RuntimeService.label];
        if (diagnostic === void 0) {
          diagnostic = worker[Diagnostic.value];
          if (diagnostic === void 0) {
            diagnostic = worker.toString();
          }
        }
        return diagnostic;
      })
    });
  }
  #cancelWorker(worker) {
    if (this.#cancelled.has(worker)) {
      return;
    }
    const cancel = () => {
      this.#cancelled.add(worker);
      if (worker.close) {
        this.#cancelled.add(worker);
        return Promise.resolve(worker.close()).finally(() => this.delete(worker));
      }
      if (worker[Symbol.asyncDispose]) {
        this.#cancelled.add(worker);
        return Promise.resolve(worker[Symbol.asyncDispose]?.()).finally(() => this.delete(worker));
      }
      if (worker[Symbol.dispose]) {
        worker[Symbol.dispose]?.();
        this.delete(worker);
        return;
      }
    };
    if (worker.construction) {
      worker.construction.onSuccess(cancel);
      return;
    }
    return cancel();
  }
  #crash(cause) {
    if (cause) {
      logger.error(cause);
    }
    this.crashed.emit(cause);
    this.cancel();
  }
}
((RuntimeService2) => {
  RuntimeService2.label = Symbol("label");
})(RuntimeService || (RuntimeService = {}));
export {
  RuntimeService
};
//# sourceMappingURL=RuntimeService.js.map
