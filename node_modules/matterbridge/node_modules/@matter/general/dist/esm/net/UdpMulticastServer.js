/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { MatterAggregateError } from "#MatterError.js";
import { Logger } from "../log/Logger.js";
import { Cache } from "../util/Cache.js";
import { asError } from "../util/Error.js";
import { isIPv4 } from "../util/Ip.js";
import { NoAddressAvailableError } from "./Network.js";
const logger = Logger.get("UdpMulticastServer");
class UdpMulticastServer {
  constructor(network, broadcastAddressIpv4, broadcastAddressIpv6, broadcastPort, serverIpv4, serverIpv6, netInterface) {
    this.network = network;
    this.broadcastAddressIpv4 = broadcastAddressIpv4;
    this.broadcastAddressIpv6 = broadcastAddressIpv6;
    this.broadcastPort = broadcastPort;
    this.serverIpv4 = serverIpv4;
    this.serverIpv6 = serverIpv6;
    this.netInterface = netInterface;
  }
  static async create({
    netInterface,
    broadcastAddressIpv4,
    broadcastAddressIpv6,
    listeningPort,
    network
  }) {
    let ipv4UdpChannel = void 0;
    if (broadcastAddressIpv4 !== void 0) {
      try {
        ipv4UdpChannel = await network.createUdpChannel({
          type: "udp4",
          netInterface,
          listeningPort,
          membershipAddresses: [broadcastAddressIpv4]
        });
      } catch (error) {
        NoAddressAvailableError.accept(error);
        logger.info(`IPv4 UDP channel not created because IPv4 is not available: ${asError(error).message}`);
      }
    }
    try {
      return new UdpMulticastServer(
        network,
        broadcastAddressIpv4,
        broadcastAddressIpv6,
        listeningPort,
        ipv4UdpChannel,
        await network.createUdpChannel({
          type: "udp6",
          netInterface,
          listeningPort,
          membershipAddresses: [broadcastAddressIpv6]
        }),
        netInterface
      );
    } catch (error) {
      NoAddressAvailableError.accept(error);
      logger.info(`IPv6 UDP interface not created because IPv6 is not available, but required my Matter.`);
      throw error;
    }
  }
  broadcastChannels = new Cache(
    "UDP broadcast channel",
    (netInterface, iPv4) => this.createBroadcastChannel(netInterface, iPv4),
    5 * 60 * 1e3,
    async (_netInterface, channel) => (await channel).close()
  );
  onMessage(listener) {
    this.serverIpv4?.onData((netInterface, peerAddress, _port, message) => {
      if (netInterface === void 0) {
        return;
      }
      listener(message, peerAddress, netInterface);
    });
    this.serverIpv6.onData((netInterface, peerAddress, _port, message) => {
      if (netInterface === void 0) {
        return;
      }
      listener(message, peerAddress, netInterface);
    });
  }
  async send(message, netInterface, uniCastTarget) {
    netInterface = netInterface ?? this.netInterface;
    if (uniCastTarget !== void 0 && netInterface !== void 0) {
      try {
        await (await this.broadcastChannels.get(netInterface, isIPv4(uniCastTarget))).send(uniCastTarget, this.broadcastPort, message);
      } catch (error) {
        logger.info(`${netInterface} ${uniCastTarget}: ${asError(error).message}`);
      }
    } else {
      const netInterfaces = netInterface !== void 0 ? [{ name: netInterface }] : await this.network.getNetInterfaces();
      await MatterAggregateError.allSettled(
        netInterfaces.map(async ({ name: netInterface2 }) => {
          const { ipV4, ipV6 } = await this.network.getIpMac(netInterface2) ?? {
            mac: "",
            ipV4: [],
            ipV6: []
          };
          const ips = [...ipV4, ...ipV6];
          await MatterAggregateError.allSettled(
            ips.map(async (ip) => {
              const iPv4 = ipV4.includes(ip);
              const broadcastTarget = iPv4 ? this.broadcastAddressIpv4 : this.broadcastAddressIpv6;
              if (broadcastTarget == void 0) {
                return;
              }
              try {
                await (await this.broadcastChannels.get(netInterface2, iPv4)).send(broadcastTarget, this.broadcastPort, message);
              } catch (error) {
                logger.info(`${netInterface2}: ${asError(error).message}`);
              }
            }),
            `Error sending UDP Multicast message on interface ${netInterface2}`
          );
        }),
        "Error sending UDP Multicast message"
      );
    }
  }
  async createBroadcastChannel(netInterface, iPv4) {
    return await this.network.createUdpChannel({
      type: iPv4 ? "udp4" : "udp6",
      listeningPort: this.broadcastPort,
      netInterface
    });
  }
  async close() {
    await this.serverIpv4?.close();
    await this.serverIpv6.close();
    await this.broadcastChannels.close();
  }
}
export {
  UdpMulticastServer
};
//# sourceMappingURL=UdpMulticastServer.js.map
