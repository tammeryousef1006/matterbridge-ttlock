/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { deepCopy } from "#util/DeepCopy.js";
import { StorageError, SyncStorage } from "./Storage.js";
class StorageBackendMemory extends SyncStorage {
  constructor(store = {}) {
    super();
    this.store = store;
  }
  isInitialized = false;
  get initialized() {
    return this.isInitialized;
  }
  static async create(store = {}) {
    const storage = new StorageBackendMemory(store);
    storage.initialize();
    return storage;
  }
  createContextKey(contexts) {
    const key = contexts.join(".");
    if (!key.length || key.includes("..") || key.startsWith(".") || key.endsWith("."))
      throw new StorageError("Context must not be an empty string.");
    return key;
  }
  initialize() {
    if (this.initialized) throw new StorageError("Storage already initialized!");
    this.isInitialized = true;
  }
  clone() {
    const clone = new StorageBackendMemory(deepCopy(this.store));
    clone.initialize();
    return clone;
  }
  async close() {
    this.isInitialized = false;
  }
  clear() {
    this.store = {};
  }
  get data() {
    return this.store;
  }
  get(contexts, key) {
    if (!this.initialized) throw new StorageError("Storage is not initialized");
    if (!contexts.length || !key.length) throw new StorageError("Context and key must not be empty.");
    return this.store[this.createContextKey(contexts)]?.[key];
  }
  #setKey(contexts, key, value) {
    if (!contexts.length || !key.length) throw new StorageError("Context and key must not be empty.");
    const contextKey = this.createContextKey(contexts);
    if (this.store[contextKey] === void 0) {
      this.store[contextKey] = {};
    }
    this.store[contextKey][key] = value;
  }
  set(contexts, keyOrValues, value) {
    if (!this.initialized) throw new StorageError("Storage is not initialized");
    if (typeof keyOrValues === "string") {
      this.#setKey(contexts, keyOrValues, value);
    } else {
      Object.entries(keyOrValues).forEach(([key, value2]) => {
        this.#setKey(contexts, key, value2);
      });
    }
  }
  delete(contexts, key) {
    if (!this.initialized) throw new StorageError("Storage is not initialized");
    if (!contexts.length || !key.length) throw new StorageError("Context and key must not be empty.");
    delete this.store[this.createContextKey(contexts)]?.[key];
  }
  keys(contexts) {
    if (!this.initialized) throw new StorageError("Storage is not initialized");
    if (!contexts.length) throw new StorageError("Context must not be empty!");
    return Object.keys(this.store[this.createContextKey(contexts)] ?? {});
  }
  values(contexts) {
    const values = {};
    for (const key of this.keys(contexts)) {
      values[key] = this.get(contexts, key);
    }
    return values;
  }
  contexts(contexts) {
    if (!this.initialized) throw new StorageError("Storage is not initialized");
    const contextKey = contexts.length ? this.createContextKey(contexts) : "";
    const startContextKey = contextKey.length ? `${contextKey}.` : "";
    const foundContexts = new Array();
    Object.keys(this.store).forEach((key) => {
      if (key.startsWith(startContextKey)) {
        const subKeys = key.substring(startContextKey.length).split(".");
        if (subKeys.length < 1) return;
        const context = subKeys[0];
        if (!foundContexts.includes(context)) {
          foundContexts.push(context);
        }
      }
    });
    return foundContexts;
  }
  clearAll(contexts) {
    if (!this.initialized) throw new StorageError("Storage is not initialized");
    const contextKey = this.createContextKey(contexts);
    if (contextKey.length) {
      delete this.store[contextKey];
    }
    const startContextKey = contextKey.length ? `${contextKey}.` : "";
    Object.keys(this.store).forEach((key) => {
      if (key.startsWith(startContextKey)) {
        delete this.store[key];
      }
    });
  }
}
export {
  StorageBackendMemory
};
//# sourceMappingURL=StorageBackendMemory.js.map
