/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Diagnostic } from "#log/Diagnostic.js";
import { Logger } from "#log/Logger.js";
import { ImplementationError, ReadOnlyError } from "#MatterError.js";
import { Time } from "#time/Time.js";
import { Observable } from "#util/Observable.js";
import { MaybePromise } from "#util/Promises.js";
import { describeList } from "#util/String.js";
import { FinalizationError, TransactionDestroyedError, TransactionFlowError, UnsettledStateError } from "./errors.js";
import { ResourceSet } from "./ResourceSet.js";
import { Status } from "./Status.js";
const logger = Logger.get("Transaction");
const MAX_PRECOMMIT_CYCLES = 5;
const MAX_CHAINED_COMMITS = 5;
function act(via, actor) {
  const tx = new Tx(via);
  let commits = 0;
  function commitTransaction(finalResult) {
    commits++;
    if (commits > MAX_CHAINED_COMMITS) {
      throw new TransactionFlowError(
        `Transaction commits have cascaded ${MAX_CHAINED_COMMITS} times which likely indicates an infinite loop`
      );
    }
    const result = tx.commit();
    if (MaybePromise.is(result)) {
      return result.then(() => {
        if (tx.status === Status.Exclusive) {
          return commitTransaction(finalResult);
        }
        return finalResult;
      });
    } else if (tx.status === Status.Exclusive) {
      return commitTransaction(finalResult);
    }
    return finalResult;
  }
  const handleTransactionError = (error) => {
    if (commits) {
      throw error;
    }
    logger.error("Rolling back", tx.via, "due to error:", Diagnostic.weak(error?.message || `${error}`));
    try {
      const result = tx.rollback();
      if (MaybePromise.is(result)) {
        return Promise.resolve(result).catch((error2) => {
          if (error2 !== error) {
            logger.error("Secondary error in", tx.via, "rollback:", error2);
          }
          throw error;
        });
      }
    } catch (error2) {
      if (error2 !== error) {
        logger.error("Secondary error in", tx.via, "rollback:", error2);
      }
    }
    throw error;
  };
  const closeTransaction = tx.close.bind(tx);
  let isAsync = false;
  try {
    const actorResult = actor(tx);
    if (MaybePromise.is(actorResult)) {
      isAsync = tx.isAsync = true;
      return Promise.resolve(actorResult).then(commitTransaction, handleTransactionError).finally(closeTransaction);
    }
    const commitResult = commitTransaction(actorResult);
    if (MaybePromise.is(commitResult)) {
      isAsync = true;
      return Promise.resolve(commitResult).catch(handleTransactionError).finally(closeTransaction);
    }
    return commitResult;
  } catch (e) {
    const result = handleTransactionError(e);
    isAsync = true;
    return Promise.resolve(result).finally(closeTransaction);
  } finally {
    if (!isAsync) {
      tx.close();
    }
  }
}
class Tx {
  #participants = /* @__PURE__ */ new Set();
  #roles = /* @__PURE__ */ new Map();
  #resources = /* @__PURE__ */ new Set();
  #status;
  #waitingOn;
  #via;
  #shared;
  #closed;
  #isAsync = false;
  #reportingLocks = false;
  constructor(via, readonly = false) {
    this.#via = Diagnostic.via(via);
    if (readonly) {
      this.#status = Status.ReadOnly;
    } else {
      this.#status = Status.Shared;
    }
  }
  close() {
    Monitor.delete(this);
    this.#status = Status.Destroyed;
    this.#resources.clear();
    this.#roles.clear();
    this.#participants.clear();
    this.#closed?.emit();
  }
  get via() {
    return this.#via;
  }
  get status() {
    return this.#status;
  }
  get participants() {
    return this.#participants;
  }
  get resources() {
    return this.#resources;
  }
  get waitingOn() {
    return this.#waitingOn;
  }
  get isAsync() {
    return this.#isAsync;
  }
  set isAsync(isAsync) {
    if (!this.#isAsync) {
      this.#locksChanged(this.#resources);
    }
    this.#isAsync = isAsync;
  }
  onShared(listener, once) {
    if (this.status === Status.ReadOnly) {
      return;
    }
    if (this.#shared === void 0) {
      this.#shared = Observable();
    }
    this.#shared[once ? "once" : "on"](listener);
  }
  onClose(listener) {
    if (this.status === Status.ReadOnly) {
      return;
    }
    if (this.status === Status.Destroyed) {
      listener();
    }
    if (this.#closed === void 0) {
      this.#closed = Observable();
    }
    this.#closed.once(listener);
  }
  async addResources(...resources) {
    this.#assertAvailable();
    if (this.#status === Status.Exclusive) {
      const set = new ResourceSet(this, resources);
      const locked = await set.acquireLocks();
      this.#locksChanged(locked);
    }
    this.addResourcesSync(...resources);
  }
  addResourcesSync(...resources) {
    this.#assertAvailable();
    if (this.#status === Status.Exclusive) {
      const set = new ResourceSet(this, resources);
      const locked = set.acquireLocksSync();
      this.#locksChanged(locked);
    } else if (this.#status !== Status.Shared) {
      throw new TransactionFlowError(`Cannot add resources to transaction that is ${this.status}`);
    }
    for (const resource of resources) {
      this.#resources.add(resource);
    }
  }
  async begin() {
    this.#assertAvailable();
    if (this.status === Status.Exclusive) {
      return;
    }
    if (this.status !== Status.Shared) {
      throw new TransactionFlowError(`Cannot begin write transaction because transaction is ${this.#status}`);
    }
    this.#status = Status.Waiting;
    try {
      const resources = new ResourceSet(this, this.#resources);
      const locked = await resources.acquireLocks();
      this.#locksChanged(locked);
      this.#status = Status.Exclusive;
    } catch (e) {
      this.#status = Status.Shared;
      throw e;
    }
  }
  beginSync() {
    this.#assertAvailable();
    if (this.status === Status.Exclusive) {
      return;
    }
    if (this.status !== Status.Shared) {
      throw new TransactionFlowError(`Cannot begin write transaction because transaction is ${this.#status}`);
    }
    this.#status = Status.Exclusive;
    try {
      const resources = new ResourceSet(this, this.#resources);
      const locked = resources.acquireLocksSync();
      this.#locksChanged(locked);
    } catch (e) {
      this.#status = Status.Shared;
      throw e;
    }
  }
  addParticipants(...participants) {
    this.#assertAvailable();
    for (const participant of participants) {
      if (this.#participants.has(participant)) {
        continue;
      }
      if ([...this.#participants].findIndex((p) => p.toString() === participant.toString()) !== -1) {
        throw new ImplementationError(`Participant ${participant} identity is not unique`);
      }
      this.#participants.add(participant);
      if (participant.role !== void 0) {
        if (this.#roles.has(participant.role)) {
          throw new TransactionFlowError(`A participant is already registered for role ${participant.role}`);
        }
        this.#roles.set(participant.role, participant);
      }
    }
  }
  getParticipant(role) {
    this.#assertAvailable();
    return this.#roles.get(role);
  }
  commit() {
    this.#assertAvailable();
    if (this.#status === Status.Shared) {
      return this.rollback();
    }
    const performCommit = () => {
      const participants = [...this.#participants];
      const result2 = this.#finalize(Status.CommittingPhaseOne, "committed", this.#executeCommit.bind(this));
      if (MaybePromise.is(result2)) {
        return result2.then(() => this.#executePostCommit(participants));
      }
      return this.#executePostCommit(participants);
    };
    const result = this.#executePreCommit();
    if (MaybePromise.is(result)) {
      return result.then(performCommit);
    }
    return performCommit();
  }
  rollback() {
    this.#assertAvailable();
    return this.#finalize(Status.RollingBack, "rolled back", () => this.#executeRollback());
  }
  waitFor(others) {
    this.#assertAvailable();
    if (this.waitingOn) {
      throw new TransactionFlowError("Attempted wait on a transaction that is already waiting");
    }
    logger.log(
      Status.slowLogLevel,
      "Tx",
      this.via,
      "waiting on",
      describeList("and", ...[...others].map((other) => other.via))
    );
    this.#waitingOn = others;
    return new Promise((resolve) => {
      for (const other of others) {
        other.onShared(() => {
          others.delete(other);
          if (!others.size) {
            this.#waitingOn = void 0;
            resolve();
          }
        }, true);
      }
    }).finally(() => this.#waitingOn = void 0);
  }
  toString() {
    return `transaction<${this.via}>`;
  }
  treatAsSlow() {
    Monitor.delete(this);
    if (this.#reportingLocks) {
      return;
    }
    this.#reportingLocks = true;
    this.#locksChanged(this.#resources);
  }
  /**
   * Shared implementation for commit and rollback.
   */
  #finalize(status, why, finalizer) {
    if (this.status !== Status.Shared && this.status !== Status.Exclusive) {
      throw new TransactionFlowError(
        `Illegal attempt to enter status ${status} when transaction is ${this.#status}`
      );
    }
    const cleanup = () => {
      const set = new ResourceSet(this, this.#resources);
      const unlocked = set.releaseLocks();
      this.#locksChanged(unlocked, `${why} and unlocked`);
      Monitor.delete(this);
      this.#reportingLocks = false;
      this.#participants.clear();
      this.#status = Status.Shared;
      this.#shared?.emit();
    };
    let isAsync = false;
    try {
      this.#status = status;
      const result = finalizer();
      if (MaybePromise.is(result)) {
        isAsync = true;
        return Promise.resolve(result).finally(cleanup);
      }
    } finally {
      if (!isAsync) {
        cleanup();
      }
    }
  }
  /**
   * Iteratively execute pre-commit until all participants "settle" and report no possible mutation.
   */
  #executePreCommit() {
    let mayHaveMutated = false;
    let abortedDueToError = false;
    let iterator = this.participants[Symbol.iterator]();
    let cycles = 1;
    const errorRollback = (error) => {
      logger.error(
        "Rolling back",
        this.via,
        "due to pre-commit error:",
        Diagnostic.weak(error?.message || `${error}`)
      );
      const result = this.#finalize(Status.RollingBack, "rolled back", () => this.#executeRollback());
      if (MaybePromise.is(result)) {
        return result.then(() => {
          throw error;
        });
      }
      throw error;
    };
    const nextCycle = () => {
      cycles++;
      if (cycles > MAX_PRECOMMIT_CYCLES) {
        return errorRollback(
          new UnsettledStateError(
            `State has not settled after ${MAX_PRECOMMIT_CYCLES} pre-commit cycles which likely indicates an infinite loop`
          )
        );
      }
      mayHaveMutated = false;
      iterator = this.participants[Symbol.iterator]();
    };
    const nextPreCommit = (previousResult) => {
      if (abortedDueToError) {
        return;
      }
      if (previousResult) {
        mayHaveMutated = true;
      }
      while (true) {
        const n = iterator.next();
        if (n.done) {
          if (mayHaveMutated) {
            const result = nextCycle();
            if (MaybePromise.is(result)) {
              return result;
            }
            continue;
          }
          break;
        }
        const participant = n.value;
        const handleError = (error) => {
          abortedDueToError = true;
          return errorRollback(error);
        };
        try {
          const result = participant.preCommit?.();
          if (MaybePromise.is(result)) {
            return Promise.resolve(result).catch(handleError).then(nextPreCommit);
          }
          if (result) {
            mayHaveMutated = true;
          }
        } catch (e) {
          return handleError(e);
        }
      }
    };
    return nextPreCommit();
  }
  /**
   * Commit logic passed to #finalize.
   */
  #executeCommit() {
    const result = this.#executeCommit1();
    if (MaybePromise.is(result)) {
      return Promise.resolve(result).then(this.#executeCommit2.bind(this));
    }
    return this.#executeCommit2();
  }
  #executeCommit1() {
    let needRollback = false;
    let asyncCommits;
    for (const participant of this.participants) {
      const handleParticipantError = (error) => {
        logger.error(`Error committing ${participant} (phase one):`, error);
        needRollback = true;
      };
      try {
        const result = participant.commit1?.();
        if (MaybePromise.is(result)) {
          if (!asyncCommits) {
            asyncCommits = [];
          }
          asyncCommits.push(Promise.resolve(result).catch(handleParticipantError));
        }
      } catch (e) {
        handleParticipantError(e);
        break;
      }
    }
    const abortIfFailed = () => {
      if (needRollback) {
        const result = this.#executeRollback();
        if (MaybePromise.is(result)) {
          return result.then(() => {
            throw new FinalizationError("Rolled back due to commit phase one error");
          });
        }
        throw new FinalizationError("Rolled back due to commit phase one error");
      }
    };
    if (asyncCommits) {
      return Promise.allSettled(asyncCommits).then(abortIfFailed);
    }
    return abortIfFailed();
  }
  #executeCommit2() {
    this.#status = Status.CommittingPhaseTwo;
    let errored;
    let ongoing;
    for (const participant of this.participants) {
      const promise = MaybePromise.then(
        () => participant.commit2?.(),
        void 0,
        (error) => {
          logger.error(`Error committing (phase two) ${participant}, state inconsistency possible:`, error);
          if (errored) {
            errored.push(participant);
          } else {
            errored = [participant];
          }
        }
      );
      if (MaybePromise.is(promise)) {
        if (ongoing) {
          ongoing.push(promise);
        } else {
          ongoing = [promise];
        }
      }
    }
    if (ongoing) {
      return Promise.allSettled(ongoing).then(() => throwIfErrored(errored, "in commit phase 2"));
    } else {
      throwIfErrored(errored, "in commit phase 2");
    }
  }
  #executePostCommit(participants) {
    const participantIterator = participants[Symbol.iterator]();
    const postCommitNextParticipant = () => {
      const next = participantIterator.next();
      if (next.done) {
        return;
      }
      const participant = next.value;
      return MaybePromise.then(
        () => participant.postCommit?.(),
        () => postCommitNextParticipant(),
        (error) => {
          logger.error(`Error post-commit of ${participant}:`, error);
        }
      );
    };
    return postCommitNextParticipant();
  }
  /**
   * Rollback logic passed to #finish.
   */
  #executeRollback() {
    this.#status = Status.RollingBack;
    let errored;
    let ongoing;
    for (const participant of this.participants) {
      const promise = MaybePromise.then(
        () => participant.rollback?.(),
        void 0,
        (error) => {
          logger.error(`Error rolling back ${participant}, state inconsistency possible:`, error);
          if (errored) {
            errored.push(participant);
          } else {
            errored = [participant];
          }
        }
      );
      if (MaybePromise.is(promise)) {
        if (ongoing) {
          ongoing.push(promise);
        } else {
          ongoing = [promise];
        }
      }
    }
    const finished = () => {
      this.#status = Status.Shared;
      throwIfErrored(errored, "in commit phase 2");
    };
    if (ongoing) {
      return Promise.allSettled(ongoing).then(finished);
    } else {
      finished();
    }
  }
  #locksChanged(resources, how = "locked") {
    if (!resources.size || !this.isAsync) {
      return;
    }
    if (!this.#reportingLocks) {
      Monitor.add(this);
      return;
    }
    let resourceDescription;
    if (how === "locked") {
      resourceDescription = Diagnostic.strong(describeList("and", ...[...resources].map((r) => r.toString())));
    } else {
      resourceDescription = `${resources.size} resource${resources.size === 1 ? "" : "s"}`;
    }
    logger.log(Status.slowLogLevel, this.via, how, resourceDescription);
  }
  #assertAvailable() {
    if (this.#status === Status.Destroyed) {
      logger.warn(
        "You have accessed transaction",
        this.via,
        "outside of the context in which it was active.  Open a new context or ensure your operation completes before the context exits"
      );
      throw new TransactionDestroyedError(`Transaction ${this.#via} is destroyed`);
    }
    if (this.#status === Status.ReadOnly) {
      throw new ReadOnlyError();
    }
  }
}
const ReadOnlyTransaction = new Tx("readonly", true);
function throwIfErrored(errored, when) {
  if (!errored?.length) {
    return;
  }
  const suffix = errored.length > 1 ? "s" : "";
  throw new FinalizationError(
    `Unhandled error${suffix} ${when} participant${suffix} ${describeList(
      "and",
      ...errored.map((p) => p.toString())
    )}`
  );
}
const Monitor = /* @__PURE__ */ function() {
  const monitored = /* @__PURE__ */ new Map();
  let monitor;
  function check() {
    const now = Time.nowMs();
    for (const [tx, slowAt] of monitored) {
      if (now > slowAt) {
        tx.treatAsSlow();
      }
    }
  }
  return {
    add(tx) {
      const { slowTransactionMs } = Status;
      if (slowTransactionMs < 0) {
        return;
      }
      if (!slowTransactionMs) {
        tx.treatAsSlow();
        return;
      }
      if (monitored.has(tx)) {
        return;
      }
      monitored.set(tx, Time.nowMs() + slowTransactionMs);
      if (monitor === void 0) {
        monitor = Time.getPeriodicTimer("tx-lock-monitor", slowTransactionMs / 10, check);
        monitor.start();
      }
    },
    delete(tx) {
      monitored.delete(tx);
      if (!monitored.size && monitor) {
        monitor.stop();
        monitor = void 0;
      }
    }
  };
}();
export {
  ReadOnlyTransaction,
  act
};
//# sourceMappingURL=Tx.js.map
