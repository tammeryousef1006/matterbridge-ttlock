/**
 * Cache computed values or resources for a specified duration to improve performances.
 *
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Diagnostic } from "../log/Diagnostic.js";
import { Time } from "../time/Time.js";
class GenericCache {
  constructor(name, expirationMs, expireCallback) {
    this.expirationMs = expirationMs;
    this.expireCallback = expireCallback;
    this.periodicTimer = Time.getPeriodicTimer(
      Diagnostic.upgrade(`${name} cache expiration`, [Diagnostic.strong(name), "cache expiration"]),
      expirationMs,
      () => this.expire()
    ).start();
    this.periodicTimer.utility = true;
  }
  knownKeys = /* @__PURE__ */ new Set();
  values = /* @__PURE__ */ new Map();
  timestamps = /* @__PURE__ */ new Map();
  periodicTimer;
  keys() {
    return Array.from(this.knownKeys.values());
  }
  async deleteEntry(key) {
    const value = this.values.get(key);
    if (this.expireCallback !== void 0 && value !== void 0) {
      await this.expireCallback(key, value);
    }
    this.values.delete(key);
    this.timestamps.delete(key);
  }
  async clear() {
    for (const key of this.values.keys()) {
      await this.deleteEntry(key);
    }
    this.values.clear();
    this.timestamps.clear();
  }
  async close() {
    await this.clear();
    this.knownKeys.clear();
    this.periodicTimer.stop();
  }
  async expire() {
    const now = Time.nowMs();
    for (const [key, timestamp] of this.timestamps.entries()) {
      if (now - timestamp < this.expirationMs) continue;
      await this.deleteEntry(key);
    }
  }
}
class Cache extends GenericCache {
  constructor(name, generator, expirationMs, expireCallback) {
    super(name, expirationMs, expireCallback);
    this.generator = generator;
  }
  get(...params) {
    const key = params.join(",");
    let value = this.values.get(key);
    if (value === void 0) {
      value = this.generator(...params);
      this.values.set(key, value);
      this.knownKeys.add(key);
    }
    this.timestamps.set(key, Time.nowMs());
    return value;
  }
}
class AsyncCache extends GenericCache {
  constructor(name, generator, expirationMs, expireCallback) {
    super(name, expirationMs, expireCallback);
    this.generator = generator;
  }
  async get(...params) {
    const key = params.join(",");
    let value = this.values.get(key);
    if (value === void 0) {
      value = await this.generator(...params);
      this.values.set(key, value);
      this.knownKeys.add(key);
    }
    this.timestamps.set(key, Time.nowMs());
    return value;
  }
}
export {
  AsyncCache,
  Cache
};
//# sourceMappingURL=Cache.js.map
