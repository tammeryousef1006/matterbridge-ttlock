/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Logger } from "../log/Logger.js";
import { ImplementationError } from "../MatterError.js";
import { asError, errorOf } from "./Error.js";
import { CrashedDependenciesError, CrashedDependencyError, Lifecycle } from "./Lifecycle.js";
import { Observable } from "./Observable.js";
import { MaybePromise } from "./Promises.js";
async function asyncNew(constructor, ...args) {
  const subject = new constructor(...args);
  if (subject.construction.status === Lifecycle.Status.Inactive) {
    throw new ImplementationError(
      `You cannot use asyncNew on ${constructor.name} because its construction is controlled by another component`
    );
  }
  await subject.construction.ready;
  return subject;
}
function Construction(subject, initializer) {
  if (!initializer) {
    assertDeferred(subject);
  }
  let initializerPromise;
  let awaiterPromise;
  let awaiterResolve;
  let awaiterReject;
  let closedPromise;
  let closedResolve;
  let closedReject;
  let error;
  let errorForDependencies;
  let primaryCauseHandled = false;
  let status = Lifecycle.Status.Inactive;
  let change;
  const self = {
    [Symbol.toStringTag]: "Construction",
    get error() {
      return error;
    },
    get status() {
      return status;
    },
    get change() {
      if (change === void 0) {
        change = Observable();
      }
      return change;
    },
    get isErrorHandled() {
      return primaryCauseHandled;
    },
    start(...args) {
      if (status !== Lifecycle.Status.Inactive) {
        throw new ImplementationError(`Cannot initialize ${subject} because it is already active`);
      }
      assertDeferred(subject);
      status = Lifecycle.Status.Initializing;
      try {
        const initializeDeferred = () => subject[Construction.construct](...args);
        invokeInitializer(initializeDeferred);
      } catch (e) {
        rejected(e);
        return;
      }
    },
    assert(description, dependency) {
      Lifecycle.assertActive(status, description ?? subject.constructor.name);
      if (arguments.length < 2) {
        return;
      }
      try {
        if (dependency === void 0) {
          throw new ImplementationError(`Property is undefined`);
        }
      } catch (e) {
        let error2;
        if (e instanceof Error) {
          error2 = e;
        } else {
          error2 = new ImplementationError(e?.toString() ?? "(unknown error)");
        }
        error2.message = `Cannot access ${description}: ${error2.message}`;
        throw error2;
      }
      return dependency;
    },
    then(onfulfilled, onrejected) {
      const handleRejection = onrejected ? () => onrejected?.(crashedError()) : void 0;
      if (status === Lifecycle.Status.Inactive || status === Lifecycle.Status.Initializing) {
        if (!awaiterPromise) {
          awaiterPromise = new Promise((resolve, reject) => {
            awaiterResolve = resolve;
            awaiterReject = reject;
          });
        }
        return awaiterPromise.then(onfulfilled, handleRejection);
      }
      const promise = error ? Promise.reject(crashedError()) : Promise.resolve(subject);
      return promise.then(onfulfilled, handleRejection);
    },
    catch(onrejected) {
      return this.then(void 0, onrejected);
    },
    onSuccess(actor) {
      const onSuccess = () => {
        const errorHandler = createErrorHandler("onSuccess");
        try {
          const result = actor();
          if (MaybePromise.is(result)) {
            return Promise.resolve(result).catch(errorHandler);
          }
        } catch (e) {
          errorHandler(e);
        }
      };
      this.then(onSuccess).catch((e) => {
        CrashedDependencyError.accept(e);
      });
    },
    onError(actor) {
      const onError = (error2) => {
        const errorHandler = createErrorHandler("onError");
        try {
          const result = actor(errorOf(error2));
          if (MaybePromise.is(result)) {
            return result.then(void 0, errorHandler);
          }
        } catch (e) {
          errorHandler(e);
        }
      };
      this.ready.catch(onError);
    },
    onCompletion(actor) {
      const onCompletion = () => {
        const errorHandler = createErrorHandler("onCompletion");
        try {
          actor();
        } catch (e) {
          errorHandler(e);
        }
      };
      this.then(onCompletion, onCompletion);
    },
    close(destructor) {
      const destructorError = createErrorHandler("destructor");
      function destroyed() {
        setStatus(Lifecycle.Status.Destroyed);
        if (closedResolve) {
          closedResolve();
          closedResolve = closedReject = void 0;
        }
      }
      const destruct = subject[Construction.destruct];
      const invokeDestruct = destruct ? function invokeDestruct2() {
        try {
          const promise = destruct.bind(subject)();
          if (promise) {
            return promise.then(void 0, destructorError).then(destroyed);
          }
        } catch (e) {
          destructorError(e);
        }
        destroyed();
      } : destroyed;
      const invokeDestructor = destructor ? function invokeDestructor2() {
        try {
          const promise = destructor();
          if (promise) {
            return promise.then(void 0, destructorError).then(invokeDestruct);
          }
        } catch (e) {
          destructorError(e);
        }
        invokeDestruct();
      } : invokeDestruct;
      function beginDestruction() {
        if (status === Lifecycle.Status.Destroying || status === Lifecycle.Status.Destroyed) {
          return self.closed;
        }
        setStatus(Lifecycle.Status.Destroying);
        return invokeDestructor();
      }
      if (status === Lifecycle.Status.Initializing) {
        return this.then(beginDestruction, beginDestruction);
      }
      return beginDestruction();
    },
    finally(onfinally) {
      return Promise.prototype.finally.call(this, onfinally);
    },
    setStatus(newStatus) {
      if (this.status === newStatus) {
        return;
      }
      switch (status) {
        case newStatus:
          return;
        case Lifecycle.Status.Destroying:
          if (newStatus !== Lifecycle.Status.Destroyed) {
            throw new ImplementationError("Cannot change status because destruction is ongoing");
          }
          break;
        case Lifecycle.Status.Destroyed:
          throw new ImplementationError("Cannot change status because destruction is final");
        case Lifecycle.Status.Initializing:
          throw new ImplementationError("Cannot change status because initialization is ongoing");
      }
      switch (newStatus) {
        case Lifecycle.Status.Inactive:
          awaiterPromise = closedPromise = void 0;
          primaryCauseHandled = false;
          error = errorForDependencies = void 0;
          break;
        case Lifecycle.Status.Active:
          awaiterPromise = closedPromise = void 0;
          error = errorForDependencies = void 0;
          break;
        default:
          break;
      }
      setStatus(newStatus);
    },
    crash(newError) {
      error = newError;
      setStatus(Lifecycle.Status.Crashed);
    },
    get ready() {
      return {
        [Symbol.toStringTag]: "AsyncConstruction#primary",
        then(onfulfilled, onrejected) {
          let rejectionHandler;
          if (onrejected) {
            primaryCauseHandled = true;
            rejectionHandler = () => onrejected(errorOf(error));
          }
          return self.then(onfulfilled, rejectionHandler);
        },
        catch(onrejected) {
          return this.then(void 0, onrejected);
        },
        finally(onfinally) {
          return Promise.prototype.finally.call(this, onfinally);
        }
      };
    },
    get closed() {
      if (closedPromise === void 0) {
        closedPromise = new Promise((resolve, reject) => {
          closedResolve = resolve;
          closedReject = reject;
        });
      }
      return {
        [Symbol.toStringTag]: "AsyncConstruction#primary",
        then(onfulfilled, onrejected) {
          let rejectionHandler;
          if (onrejected) {
            primaryCauseHandled = true;
            rejectionHandler = () => onrejected(errorOf(error));
          }
          return closedPromise.then(onfulfilled, rejectionHandler);
        },
        catch(onrejected) {
          return this.then(void 0, onrejected);
        },
        finally(onfinally) {
          return Promise.prototype.finally.call(this, onfinally);
        }
      };
    }
  };
  if (initializer) {
    invokeInitializer(initializer);
  }
  return self;
  function invokeInitializer(initializer2) {
    status = Lifecycle.Status.Initializing;
    initializerPromise = initializer2();
    if (MaybePromise.is(initializerPromise)) {
      initializerPromise.then(resolved, rejected);
    } else {
      resolved();
    }
  }
  function crashedError() {
    if (!primaryCauseHandled && error) {
      primaryCauseHandled = true;
      return error;
    }
    if (errorForDependencies) {
      return errorForDependencies;
    }
    let what;
    if (subject.toString === Object.prototype.toString) {
      what = subject.constructor.name;
    } else {
      what = subject.toString();
    }
    errorForDependencies = new CrashedDependencyError(what, "unavailable due to initialization error");
    errorForDependencies.subject = subject;
    errorForDependencies.cause = error;
    return errorForDependencies;
  }
  function setStatus(newStatus) {
    if (status === newStatus) {
      return;
    }
    status = newStatus;
    if (change) {
      change.emit(status, subject);
    }
  }
  function resolved() {
    if (status === Lifecycle.Status.Initializing) {
      setStatus(Lifecycle.Status.Active);
    }
    if (awaiterResolve) {
      const resolve = awaiterResolve;
      awaiterResolve = awaiterReject = void 0;
      resolve(subject);
    }
  }
  function rejected(cause) {
    if (status !== Lifecycle.Status.Destroying && status !== Lifecycle.Status.Destroyed) {
      error = cause;
      setStatus(Lifecycle.Status.Crashed);
    }
    if (awaiterReject) {
      const reject = awaiterReject;
      awaiterResolve = awaiterReject = void 0;
      reject(crashedError());
    }
    if (closedReject) {
      primaryCauseHandled = true;
      const reject = closedReject;
      closedResolve = closedReject = void 0;
      reject(cause);
    }
    if (!primaryCauseHandled) {
      unhandledError(cause);
    }
  }
  function unhandledError(...args) {
    const logger = Logger.get(subject.constructor.name);
    logger.error(...args);
  }
  function createErrorHandler(name) {
    return (e) => {
      unhandledError(`Unhandled error in ${subject} ${name}:`, e);
    };
  }
}
((Construction2) => {
  function all(subjects, onError) {
    if (onError === void 0) {
      onError = (errors) => new CrashedDependenciesError(errors);
    }
    const subjectArray = [...subjects];
    const uninitialized = subjectArray.filter(
      (subject) => subject.construction.status === Lifecycle.Status.Initializing
    );
    if (uninitialized.length) {
      return Promise.allSettled(uninitialized.map((backing) => backing.construction)).then(
        () => (
          // Recurse to ensure subjects added subsequent to initial "all" settle
          all(subjects, onError)
        )
      );
    }
    const crashed = Object.values(subjectArray).filter(
      (subject) => subject.construction.status === Lifecycle.Status.Crashed
    );
    if (crashed.length) {
      let error;
      try {
        error = onError(crashed);
      } catch (e) {
        error = asError(e);
      }
      if (error) {
        return Promise.reject(error);
      }
    }
  }
  Construction2.all = all;
  Construction2.construct = Symbol("construct");
  Construction2.destruct = Symbol("destruct");
})(Construction || (Construction = {}));
function assertDeferred(subject) {
  if (typeof subject?.[Construction.construct] !== "function") {
    throw new ImplementationError(`No initializer defined for ${subject}`);
  }
}
export {
  Construction,
  asyncNew
};
//# sourceMappingURL=Construction.js.map
