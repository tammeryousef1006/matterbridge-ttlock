/**
 * Promise-based blocking queue.
 *
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { MatterFlowError } from "../MatterError.js";
import { Time } from "../time/Time.js";
import { createPromise } from "./Promises.js";
import { EndOfStreamError, NoResponseTimeoutError } from "./Stream.js";
class DataReadQueue {
  #queue = new Array();
  #pendingRead;
  #closed = false;
  async read(timeoutMs = 6e4) {
    const { promise, resolver, rejecter } = createPromise();
    if (this.#closed) throw new EndOfStreamError();
    const data = this.#queue.shift();
    if (data !== void 0) {
      return data;
    }
    if (this.#pendingRead !== void 0) throw new MatterFlowError("Only one pending read is supported");
    this.#pendingRead = {
      resolver,
      rejecter,
      timeoutTimer: Time.getTimer(
        "Queue timeout",
        timeoutMs,
        () => rejecter(new NoResponseTimeoutError(`Expected response data missing within timeout of ${timeoutMs}ms`))
      ).start()
    };
    return promise;
  }
  async write(data) {
    this.push(data);
  }
  /**
   * Same as write but doesn't require the await required to satisfy {@link Stream#write}.
   */
  push(data) {
    if (this.#closed) throw new EndOfStreamError();
    if (this.#pendingRead !== void 0) {
      this.#pendingRead.timeoutTimer?.stop();
      this.#pendingRead.resolver(data);
      this.#pendingRead = void 0;
      return;
    }
    this.#queue.push(data);
  }
  close() {
    if (this.#closed) return;
    this.#closed = true;
    if (this.#pendingRead === void 0) return;
    this.#pendingRead.timeoutTimer?.stop();
    this.#pendingRead.rejecter(new EndOfStreamError());
  }
}
export {
  DataReadQueue
};
//# sourceMappingURL=DataReadQueue.js.map
