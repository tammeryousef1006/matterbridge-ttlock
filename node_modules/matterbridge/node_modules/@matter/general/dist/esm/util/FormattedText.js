/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const LIST_INDENT = 2;
import { camelize, describeList, serialize } from "./String.js";
function FormattedText(text, width = 120) {
  const structure = detectStructure(text);
  return formatStructure(structure, width);
}
var ListType = /* @__PURE__ */ ((ListType2) => {
  ListType2["Bullet1"] = "\u2022";
  ListType2["Bullet2"] = "\u25E6";
  ListType2["Bullet3"] = "\u25AA";
  ListType2["Bullet4"] = "\u25CB";
  ListType2["Bullet5"] = "\u25CF";
  ListType2["Bullet6"] = "\u2023";
  ListType2["Bullet7"] = "\u2043";
  ListType2["Bullet8"] = "\u25D8";
  ListType2["Number"] = "number";
  ListType2["LowerAlpha"] = "alpha";
  ListType2["UpperAlpha"] = "ALPHA";
  ListType2["LowerRoman"] = "roman";
  ListType2["UpperRoman"] = "ROMAN";
  return ListType2;
})(ListType || {});
function detectList(text, listState) {
  function enterList(listType) {
    const existing = listState.indexOf(listType);
    if (existing == -1) {
      listState.push(listType);
    } else {
      listState.length = existing + 1;
    }
  }
  for (const value of Object.values(ListType)) {
    if (text[0] === value && text[1] === " ") {
      enterList(text[0]);
      return;
    }
  }
  function detectEnumeration(test, listType, first) {
    if (!text.match(test)) {
      return false;
    }
    if (listState.indexOf(listType) != -1 || text.startsWith(`${first}.`)) {
      enterList(listType);
      return true;
    }
    return false;
  }
  if (detectEnumeration(/^\d+\./, "number" /* Number */, "1")) return;
  if (detectEnumeration(/^[ivx]+\./, "roman" /* LowerRoman */, "i")) return;
  if (detectEnumeration(/^[IVX]+\./, "ROMAN" /* UpperRoman */, "I")) return;
  if (detectEnumeration(/^[a-z]+\./, "alpha" /* LowerAlpha */, "a")) return;
  if (detectEnumeration(/^[A-Z]+\./, "ALPHA" /* UpperAlpha */, "A")) return;
  listState.length = 0;
}
function extractPrefix(text) {
  const match = text.match(/^(\S+)\s+($|\S.*$)/);
  if (match) {
    return { prefix: match[1], text: match[2] };
  }
  return { prefix: text, text: "" };
}
function detectStructure(text) {
  if (text == "") {
    return { prefixWidth: 0, entries: [] };
  }
  const paragraphs = text.split(/\n+/).map((paragraph) => paragraph.trim().replace(/\s+/g, " "));
  if (!paragraphs.length) {
    return { prefixWidth: 0, entries: [] };
  }
  const listState = Array();
  let index = 0;
  function processLevel() {
    const level = listState.length;
    const structure = {
      prefixWidth: 0,
      entries: []
    };
    while (index < paragraphs.length) {
      detectList(paragraphs[index], listState);
      if (listState.length < level) {
        break;
      }
      if (listState.length > level) {
        structure.entries.push(processLevel());
        if (listState.length < level || index >= paragraphs.length) {
          break;
        }
      }
      structure.entries.push(paragraphs[index]);
      if (level) {
        const { prefix } = extractPrefix(paragraphs[index]);
        if (prefix.length > structure.prefixWidth) {
          structure.prefixWidth = prefix.length;
        }
      }
      index++;
    }
    return structure;
  }
  return processLevel();
}
function wrapParagraph(input, into, wrapWidth, padding, prefixWidth) {
  const segments = input.split(/\s+/);
  if (!segments) {
    return;
  }
  for (let i = 0; i < segments?.length; i++) {
    if (!segments[i].includes("{@")) {
      continue;
    }
    for (let j = i; j < segments.length; j++) {
      if (segments[j].includes("}")) {
        segments.splice(i, j - i + 1, segments.slice(i, j + 1).join(" "));
        break;
      }
    }
  }
  let wrapPrefix;
  if (prefixWidth) {
    wrapPrefix = "".padStart(prefixWidth + 1, " ");
  } else {
    wrapPrefix = "";
  }
  const line = Array();
  let length = 0;
  let pushedOne = false;
  let needWrapPrefix = false;
  for (const s of segments) {
    const segmentLength = visibleLengthOf(s);
    if (length && length + segmentLength > wrapWidth) {
      addLine();
      line.length = length = 0;
      needWrapPrefix = true;
    }
    if (!line.length && padding) {
      line.push("".padStart(padding, " "));
      length += padding;
    }
    if (needWrapPrefix) {
      needWrapPrefix = false;
      line.push(wrapPrefix);
      length += wrapPrefix.length;
    }
    line.push(s);
    line.push(" ");
    length += segmentLength + 1;
  }
  line.length = line.length - 1;
  if (line.length) {
    addLine();
  }
  function addLine() {
    if (!pushedOne) {
      if (into.length) {
        into.push("");
      }
      pushedOne = true;
    }
    into.push(line.join(""));
  }
}
function formatStructure(structure, width) {
  const lines = Array();
  function formatLevel(structure2, padding) {
    for (const entry of structure2.entries) {
      if (typeof entry == "string") {
        wrapParagraph(entry, lines, width, padding, structure2.prefixWidth);
      } else {
        formatLevel(entry, padding + LIST_INDENT);
      }
    }
  }
  formatLevel(structure, 0);
  return lines;
}
function visibleLengthOf(text) {
  let length = 0;
  for (let i = 0; i < text.length; ) {
    switch (text[i]) {
      case `\x1B`:
        i++;
        const code = text[i];
        if (code >= "@" && code <= "Z" || code === "-" || code === "_") {
          i++;
          break;
        }
        if (code === "[") {
          i++;
          while (text[i] >= "0" && text[i] <= "?") {
            i++;
          }
          while (text[i] >= " " && text[i] <= "/") {
            i++;
          }
          if (text[i] >= "@" && text[i] <= "~") {
            i++;
            break;
          }
        }
        break;
      case `\u200B`:
        i++;
        break;
      default:
        i++;
        length++;
        break;
    }
  }
  return length;
}
export {
  FormattedText,
  camelize,
  describeList,
  serialize
};
//# sourceMappingURL=FormattedText.js.map
