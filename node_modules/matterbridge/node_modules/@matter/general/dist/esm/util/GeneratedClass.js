/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { InternalError } from "../MatterError.js";
function GeneratedClass(options) {
  const { base: base2, name: name2, args: args2, mixins: mixins2 } = options;
  const allMixins = mixins2 ? [...mixins2, options] : [options];
  const type = createConstructor({
    name: name2 ?? (base2 ? `${base2.name}$` : "GeneratedClass"),
    base: base2,
    args: args2,
    mixins: allMixins
  });
  for (const mixin of allMixins) {
    applyMixin(type, mixin);
  }
  return type;
}
function applyMixin(constructor, { staticProperties, staticDescriptors, instanceDescriptors }) {
  if (staticProperties) {
    Object.assign(constructor, staticProperties);
  }
  if (staticDescriptors) {
    Object.defineProperties(constructor, staticDescriptors);
  }
  if (instanceDescriptors) {
    Object.defineProperties(constructor.prototype, instanceDescriptors);
  }
}
function createConstructor({ name, base, args, mixins }) {
  const _InternalError = InternalError;
  if (!name.match(/^[\p{L}0-9$_]+$/u)) {
    throw new InternalError("Refusing to generate class with untrustworthy name");
  }
  let ext;
  if (base) {
    ext = `extends base `;
  } else {
    ext = "";
  }
  const code = [`class ${name} ${ext}{`];
  let initialize;
  let instanceProperties;
  for (const mixin of mixins) {
    const mixinInitialize = mixin.initialize;
    if (mixinInitialize) {
      if (initialize) {
        const baseInitialize = initialize;
        initialize = function(...args2) {
          baseInitialize.call(this, ...args2);
          mixinInitialize.call(this, ...args2);
        };
      } else {
        initialize = mixinInitialize;
      }
    }
    if (mixin.instanceProperties) {
      if (instanceProperties) {
        instanceProperties = {
          ...instanceProperties,
          ...mixin.instanceProperties
        };
      } else {
        instanceProperties = mixin.instanceProperties;
      }
    }
  }
  if (args || initialize || instanceProperties) {
    code.push("constructor() {");
    let argsName;
    if (args) {
      argsName = "a";
      code.push(`const a = args(...arguments)`);
    } else {
      argsName = "arguments";
    }
    if (base) {
      code.push(`super(...${argsName})`);
    }
    if (instanceProperties) {
      code.push(`for (const k in instanceProperties) this[k] = instanceProperties[k]`);
    }
    if (initialize) {
      code.push(`initialize.apply(this, ${argsName})`);
    }
    code.push("}");
  }
  code.push("}", name);
  return eval(code.join("\n"));
}
export {
  GeneratedClass
};
//# sourceMappingURL=GeneratedClass.js.map
