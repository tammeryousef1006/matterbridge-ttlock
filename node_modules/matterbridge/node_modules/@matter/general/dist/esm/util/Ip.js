/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Bytes } from "./Bytes.js";
function isIPv4(ip) {
  return ip.includes(".");
}
function isIPv6(ip) {
  return ip.includes(":");
}
function ipv4ToNumber(ip) {
  const dataView = Bytes.dataViewOf(ipv4ToBytes(ip));
  return dataView.getUint32(0);
}
function ipv4ToBytes(ip) {
  const array = new Uint8Array(4);
  const ipParts = ip.split(".");
  for (let i = 0; i < 4; i++) {
    array[i] = parseInt(ipParts[i]);
  }
  return array;
}
function ipv6ToArray(ip) {
  const array = new Uint16Array(8);
  let ipParts = ip.split(":");
  const valueCount = ipParts.filter((value) => value !== "").length;
  if (valueCount !== 8) {
    ipParts = ip.replace("::", ":".padEnd((8 - valueCount) * 2 + 1, "0:")).split(":");
  }
  let index = 0;
  ipParts.forEach((part) => {
    if (part === "") return;
    array[index++] = parseInt(part, 16);
  });
  return array;
}
function ipv6ToBytes(ip) {
  return Uint8Array.from(Array.from(ipv6ToArray(ip)).flatMap((value) => [value >> 8, value & 255]));
}
function onSameNetwork(ip1, ip2, mask) {
  if (isIPv4(ip1)) {
    if (!isIPv4(ip2) || !isIPv4(mask)) return false;
    const ip1Number = ipv4ToNumber(ip1);
    const ip2Number = ipv4ToNumber(ip2);
    const maskNumber = ipv4ToNumber(mask);
    return (ip1Number & maskNumber) === (ip2Number & maskNumber);
  } else {
    if (isIPv4(ip2) || isIPv4(mask)) return false;
    const ip1Array = ipv6ToArray(ip1);
    const ip2Array = ipv6ToArray(ip2);
    const maskArray = ipv6ToArray(mask);
    for (let i = 0; i < 16; i++) {
      const mask2 = maskArray[i];
      if (mask2 === 0) return true;
      if ((ip1Array[i] & mask2) !== (ip2Array[i] & mask2)) return false;
    }
  }
}
export {
  ipv4ToBytes,
  ipv4ToNumber,
  ipv6ToArray,
  ipv6ToBytes,
  isIPv4,
  isIPv6,
  onSameNetwork
};
//# sourceMappingURL=Ip.js.map
