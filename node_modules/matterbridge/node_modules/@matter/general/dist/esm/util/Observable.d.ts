/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import "../polyfills/disposable.js";
import { MaybePromise } from "./Promises.js";
/**
 * A callback function for observables.
 *
 * The observer return value effects how an {@link Observable} emits:
 *
 *   - If an observer returns undefined the {@link Observable} invokes the next observer immediately.
 *
 *   - If an observer returns a {@link Promise}, the {@link Observable} awaits the return value then continues as
 *     described here.  The emitter must then await the {@link Promise} returned by {@link Observable.emit}.
 *
 *   - Any other return value is returned by {@link Observable.emit} and subsequent observers do not see emission.
 *
 * @param payload a list of arguments to be emitted
 */
export interface Observer<T extends any[] = any[], R = void> {
    (...payload: T): MaybePromise<R | undefined>;
    [observant]?: boolean;
}
/**
 * A discrete event that may be monitored via callback.  Could call it "event" but that could be confused with Matter
 * cluster events and/or DOM events.
 *
 * @param T arguments, should be a named tuple
 */
export interface Observable<T extends any[] = any[], R = void> extends AsyncIterable<T>, PromiseLike<T> {
    /**
     * Notify observers.
     */
    emit(...args: T): R | undefined;
    /**
     * Add an observer.
     */
    on(observer: Observer<T, R>): void;
    /**
     * Remove an observer.
     */
    off(observer: Observer<T, R>): void;
    /**
     * Add an observer that emits once then is unregistered.
     */
    once(observer: Observer<T, R>): void;
    /**
     * True if there is at least one observer registered.
     */
    isObserved: boolean;
    /**
     * Determine whether an observer is registered.
     */
    isObservedBy(observer: Observer<T, R>): boolean;
    /**
     * Errors throw by observers will interrupt emitters unless an error handler is installed here and the handler does
     * not rethrow.
     *
     * The only exception to this is if {@link handlePromise} is false and an observer is asynchronous.  In this case
     * the emitter cannot be made aware of the exception.
     */
    handleError: ObserverErrorHandler;
    /**
     * We allow emitters to be async, but we do not want to overburden either the emitter or the observer with promise
     * tracking if the lifetime of the observer is not relevant to the emitter.
     *
     * To facilitate this we allow observables to be configured in one of three promise handling modes:
     *
     * * If you set handlePromise, isAsync is true; the handler is invoked for any observer promise
     *
     * * If isAsync is true but you do not set handlePromise, any observer promise is returned to the emitter which must
     *   handle the promise
     *
     * * If isAsync is false, we log observer promise errors but the promise is otherwise untracked
     *
     * If the promiseHandler returns a promise or is true and the emitter returns a promise, the observable will emit to
     * successive observers only after the promise resolves.
     */
    isAsync: boolean;
    /**
     * A promise handler.
     *
     * If you set {@link isAsync} (either true or false) the promise handler is set by the Observable.
     */
    handlePromise: ObserverPromiseHandler | boolean;
    /**
     * Observable supports standard "for await (const value of observable").
     *
     * Using an observer in this manner limits your listener to the first parameter normally emitted and your observer
     * cannot return a value.
     */
    [Symbol.asyncIterator](): AsyncIterator<T[0]>;
    /**
     * Release resources associated with the observable.
     */
    [Symbol.dispose](): void;
}
/**
 * An observer may designate itself as "not observant" for the purposes of {@link Observable.isObserved} by returning
 * false from this field.
 */
export declare const observant: unique symbol;
/**
 * An {@link Observable} that explicitly supports asynchronous observers.
 */
export interface AsyncObservable<T extends any[] = any[], R = void> extends Observable<T, MaybePromise<R>> {
}
export type ObserverErrorHandler = (error: Error, observer: Observer<any[], any>) => void;
export type ObserverPromiseHandler = (promise: Promise<unknown>, observer: Observer<any[], any>) => unknown;
/**
 * A concrete {@link Observable} implementation.
 */
export declare class BasicObservable<T extends any[] = any[], R = void> implements Observable<T, R> {
    #private;
    constructor(handleError?: ObserverErrorHandler, asyncConfig?: ObserverPromiseHandler | boolean);
    [Symbol.dispose](): void;
    set handleError(handleError: ObserverErrorHandler);
    get handleError(): ObserverErrorHandler;
    set isAsync(isAsync: boolean);
    get isAsync(): boolean;
    set handlePromise(handlePromise: ObserverPromiseHandler);
    get handlePromise(): ObserverPromiseHandler;
    get isObserved(): boolean;
    isObservedBy(observer: Observer<T, R>): boolean;
    emit(...payload: T): R | undefined;
    on(observer: Observer<T, R>): void;
    off(observer: Observer<T, R>): void;
    once(observer: Observer<T, R>): void;
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null): PromiseLike<TResult1 | TResult2>;
    [Symbol.asyncIterator](): AsyncIterator<T[0]>;
}
/**
 * Create an {@link Observable}.
 */
export declare const Observable: {
    new <T extends any[], R = void>(errorHandler?: ObserverErrorHandler): Observable<T, R>;
    <T extends any[], R = void>(errorHandler?: ObserverErrorHandler): Observable<T, R>;
};
/**
 * Create an {@link AsyncObservable} that explicitly supports asynchronous results
 */
export declare const AsyncObservable: {
    new <T extends any[], R = void>(handleError?: ObserverErrorHandler): AsyncObservable<T, R>;
    <T extends any[], R = void>(handleError?: ObserverErrorHandler): AsyncObservable<T, R>;
};
/**
 * A set of observables.  You can bind events using individual observables or the methods emulating a subset Node's
 * EventEmitter.
 *
 * To maintain type safety, implementers define events as observable child properties.
 */
export declare class EventEmitter {
    private events?;
    emit<This, N extends EventEmitter.NamesOf<This>>(this: This, name: N, ...payload: EventEmitter.PayloadOf<This, N>): void;
    addListener<This, N extends EventEmitter.NamesOf<This>>(this: This, name: N, handler: EventEmitter.ObserverOf<This, N>): void;
    removeListener<This, N extends EventEmitter.NamesOf<This>>(this: This, name: N, handler: EventEmitter.ObserverOf<This, N>): void;
    addEvent(name: string, event?: Observable): void;
    getEvent(name: string): Observable<any[], void>;
    hasEvent(name: string, onlyIfInitialized?: boolean): boolean | Observable<any[], void> | undefined;
    get eventNames(): string[];
    [Symbol.dispose](): void;
}
export declare namespace EventEmitter {
    /**
     * Legal event names.  If there are no events defined, assume this is an
     * untyped instance and allow any argument.
     */
    type NamesOf<This> = [EventNames<This>] extends [never] ? string : EventNames<This>;
    type EventNames<This> = string & keyof {
        [K in keyof This as This[K] extends Observable ? K : never]: true;
    };
    /**
     * Arguments for an event.  If there are no events defined, assume this is
     * an untyped emitter and allow any argument.
     */
    type PayloadOf<This, E extends string> = [EventPayload<This, E>] extends [never] ? any[] : EventPayload<This, E>;
    type EventPayload<This, E extends string> = This extends {
        [K in E]: Observable<infer T extends any[]>;
    } ? T : never;
    type ObserverOf<This, E extends string> = Observable<PayloadOf<This, E>>;
}
/**
 * An {@link Observable} that proxies to another {@link Observable}.
 *
 * Events emitted here instead emit on the target {@link Observable}.  Events emitted on the target emit locally via
 * a listener installed by the proxy.
 *
 * This is useful for managing a subset of {@link Observer}s for an {@link Observable}.
 *
 * Note that this "proxy" acts as a proxy but is not a JS {@link Proxy}.
 */
export declare class ObservableProxy extends BasicObservable {
    #private;
    constructor(target: Observable);
    [Symbol.dispose](): void;
    get isObserved(): boolean;
    emit: (...payload: any) => any | undefined;
    protected get target(): Observable<any[], void>;
}
/**
 * A collection of observers managed as a unit.  This makes it convenient to deregister multiple observers when an
 * object closes.
 */
export declare class ObserverGroup {
    #private;
    constructor(target?: {});
    /**
     * Add an observer.
     *
     * @param observable the observable to observe
     * @param observer the observer function
     * @param target optional "this" to bind the observer
     */
    on<T extends any[], R>(observable: Observable<T, R> | AsyncObservable<T, R>, observer: Observer<ObserverGroup.VarArgs<NoInfer<T>>, NoInfer<R>>, target?: {} | undefined): void;
    /**
     * Remove a single observer.
     *
     * @param observable the observable to observe
     * @param observer the observer function
     * @param target if the observer was bound in {@link on} this must match the bound target
     */
    off<T extends any[]>(observable: Observable<T> | AsyncObservable<T>, observer: Observer<NoInfer<T>>, target?: {} | undefined): void;
    /**
     * Remove all observers.
     */
    close(): void;
}
export declare namespace ObserverGroup {
    /**
     * This is a workaround for a TS bug, without this the observer must provide a full argument set even if it does not
     * use all arguments.
     */
    type VarArgs<T extends any[]> = T extends [...infer R, infer A] ? [...R, A] : T extends [infer A] ? A : [];
}
/**
 * An {@link Observable} that emits an algorithmically-reduced number of events.
 */
export declare class QuietObservable<T extends any[] = any[]> extends BasicObservable<T> implements QuietObservable.State<T> {
    #private;
    constructor(config?: QuietObservable.Configuration<T>);
    get config(): QuietObservable.Configuration<T>;
    set config(config: QuietObservable.Configuration<T>);
    get emitAutomatically(): boolean;
    set emitAutomatically(value: boolean);
    get suppressionEnabled(): boolean;
    set suppressionEnabled(value: boolean);
    get minimumEmitIntervalMs(): number;
    set minimumEmitIntervalMs(value: number);
    get source(): Observable<T> | undefined;
    set source(source: Observable<T> | undefined);
    get sink(): Observable<T> | undefined;
    set sink(sink: Observable<T> | undefined);
    get shouldEmit(): QuietObservable.EmitPredicate<T> | undefined;
    set shouldEmit(shouldEmit: QuietObservable.EmitPredicate<T> | undefined);
    get isObserved(): boolean;
    isObservedBy(observer: Observer<T>): boolean;
    emit(...payload: T): void;
    /**
     * Emit immediately, regardless of suppression configuration.
     */
    emitNow(): void;
    /**
     * Emit as soon as allowed by suppression.
     */
    emitSoon(): void;
    [Symbol.dispose](): void;
}
export declare namespace QuietObservable {
    interface State<T extends any[] = any[]> {
        /**
         * If true this observable will emit within the suppression constraints.  If false it will only emit after calls
         * to {@link emitSoon} or {@link emitNow}.
         */
        emitAutomatically: boolean;
        /**
         * If true then emit rate is constrained.  If false emits will occur immediately.
         */
        suppressionEnabled: boolean;
        /**
         * The minimum time between emits in milliseconds.
         */
        minimumEmitIntervalMs: number;
        /**
         * An input observable this observable will automatically observe to produce events.
         */
        source?: Observable<T>;
        /**
         * An output observable this observable will automatically emit to whenever it emits.
         */
        sink?: Observable<T>;
        /**
         * A predicate that determine whether a payload should emit.
         */
        shouldEmit?: EmitPredicate<T>;
        /**
         * Handler for errors returned by observers.
         */
        handleError?: ObserverErrorHandler;
        /**
         * Designates async support (overridden if you supply {@link handlePromise}).
         */
        isAsync?: boolean;
        /**
         * Handler for promises returned by observers.
         */
        handlePromise?: ObserverPromiseHandler;
    }
    /**
     * An emit predicate may emit this value to force immediate emit.
     */
    const now = "now";
    /**
     * The return value of an emit predicate.  "true" allows the event to emit as normal, "false" prevents the event
     * from emitting, and {@link now} forces immediate emit regardless of interval configuration.
     */
    type EmitDirective = true | false | typeof now;
    /**
     * A predicate that may filter emits manually.
     */
    interface EmitPredicate<T extends any[] = any[]> {
        (...payload: T): EmitDirective;
    }
    interface Configuration<T extends any[] = any[]> extends Partial<State<T>> {
    }
    const defaults: State;
}
//# sourceMappingURL=Observable.d.ts.map