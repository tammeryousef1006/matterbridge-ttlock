/**
 * Utils for promises.
 *
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { asError } from "#util/Error.js";
import { InternalError, MatterError } from "../MatterError.js";
import { Time } from "../time/Time.js";
function createPromise() {
  let resolver, rejecter;
  const promise = new Promise((resolve, reject) => {
    resolver = resolve;
    rejecter = reject;
  });
  if (!resolver || !rejecter) {
    throw new InternalError("Failed to extract resolve/reject from Promise context");
  }
  return {
    promise,
    resolver,
    rejecter
  };
}
function anyPromise(promises) {
  return new Promise((resolve, reject) => {
    let numberRejected = 0;
    let wasResolved = false;
    for (const entry of promises) {
      const promise = typeof entry === "function" ? entry() : entry;
      promise.then((value) => {
        if (!wasResolved) {
          wasResolved = true;
          resolve(value);
        }
      }).catch((reason) => {
        numberRejected++;
        if (!wasResolved && numberRejected === promises.length) {
          reject(reason);
        }
      });
    }
  });
}
class PromiseTimeoutError extends MatterError {
  constructor(message = "Operation timed out") {
    super(message);
  }
}
async function withTimeout(timeoutMs, promise, cancel) {
  let cancelFn;
  if (typeof cancel === "function") {
    cancelFn = cancel;
  } else if (typeof cancel?.abort === "function") {
    cancelFn = () => cancel.abort();
  } else {
    cancelFn = () => {
      throw new PromiseTimeoutError();
    };
  }
  let cancelTimer;
  const timeout = new Promise((resolve, reject) => {
    const timer = Time.getTimer("promise-timeout", timeoutMs, () => {
      try {
        cancelFn();
      } catch (e) {
        reject(asError(e));
        return;
      }
      reject(new Error("Timer canceled promise, but no error was thrown"));
    });
    cancelTimer = () => {
      timer.stop();
      resolve();
    };
    timer.start();
  });
  let result;
  const producer = promise.then(
    (r) => {
      cancelTimer?.();
      result = r;
    },
    (e) => {
      cancelTimer?.();
      throw e;
    }
  );
  await Promise.all([timeout, producer]);
  return result;
}
const MaybePromise = {
  /**
   * Determine whether a {@link MaybePromiseLike} is a {@link Promise}.
   */
  is(value) {
    return typeof value === "object" && value !== null && typeof value.then === "function" && value !== this;
  },
  /**
   * Chained MaybePromise.  Invokes the resolve function immediately if the {@link MaybePromise} is not a
   * {@link Promise}, otherwise the same as a normal {@link Promise.then}.
   */
  then(producer, resolve, reject) {
    let rejected = false;
    try {
      let value;
      if (producer instanceof Function) {
        value = producer();
      } else {
        value = producer;
      }
      if (MaybePromise.is(value)) {
        return value.then(
          resolve,
          reject ? (error) => {
            rejected = true;
            return reject?.(error);
          } : void 0
        );
      }
      if (resolve) {
        return resolve(value);
      }
    } catch (e) {
      if (reject && !rejected) {
        return reject(e);
      }
      throw e;
    }
    return void 0;
  },
  /**
   * Equivalent of {@link Promise.catch}.
   */
  catch(producer, onrejected) {
    return this.then(producer, void 0, onrejected);
  },
  /**
   * Equivalent of {@link Promise.finally}.
   */
  finally(producer, onfinally) {
    let result;
    try {
      if (typeof producer === "function") {
        result = producer();
      } else {
        result = producer;
      }
    } finally {
      if (MaybePromise.is(result)) {
        if (typeof result.finally === "function") {
          result = result.finally(onfinally);
        } else {
          result = result.then(
            (value) => MaybePromise.then(
              () => onfinally?.(),
              () => value
            ),
            (error) => MaybePromise.then(
              () => onfinally?.(),
              () => {
                throw error;
              }
            )
          );
        }
      } else {
        const finallyResult = onfinally?.();
        if (MaybePromise.is(finallyResult)) {
          const actualResult = result;
          result = finallyResult.then(() => actualResult);
        }
      }
    }
    return result;
  },
  [Symbol.toStringTag]: "MaybePromise"
};
MaybePromise.toString = () => "MaybePromise";
export {
  MaybePromise,
  PromiseTimeoutError,
  anyPromise,
  createPromise,
  withTimeout
};
//# sourceMappingURL=Promises.js.map
