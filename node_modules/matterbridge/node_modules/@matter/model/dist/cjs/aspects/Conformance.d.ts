/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { type Model } from "#models/Model.js";
import { FieldValue } from "../common/index.js";
import { Aspect } from "./Aspect.js";
/**
 * An operational view of conformance as defined by the Matter Specification.
 *
 * We extend the specification's syntax to add ">", "<", ">=" and "<=".  These are required to encode some portions of
 * the specification that are described in prose.
 *
 * "Conformance" controls when a data field or cluster element is allowed or required.
 */
export declare class Conformance extends Aspect<Conformance.Definition> {
    ast: Conformance.Ast;
    get type(): Conformance.Special | Conformance.Flag | Conformance.Operator.NOT | Conformance.Operator.EQ | Conformance.Operator.NE | Conformance.Operator.OR | Conformance.Operator.XOR | Conformance.Operator.AND | Conformance.Operator.GT | Conformance.Operator.LT | Conformance.Operator.GTE | Conformance.Operator.LTE;
    get empty(): boolean;
    /**
     * Initialize from a Conformance.Definition or the conformance DSL defined by the Matter Specification.
     */
    constructor(definition: Conformance.Definition);
    validateReferences(errorTarget: Conformance.ErrorTarget, lookup: Conformance.ReferenceResolver): void;
    /**
     * Is the associated element mandatory?
     *
     * This supports a limited subset of conformance and is only appropriate for field and requirement conformance.
     */
    get isMandatory(): boolean;
    /**
     * Perform limited conformance evaluation to determine whether this conformance is applicable given a feature
     * combination.
     *
     * This is useful for filtering elements at compile time.  For complete accuracy you then need to filter at runtime
     * once field values are known.
     */
    applicabilityOf(features: Iterable<string>, supportedFeatures: Iterable<string>): Conformance.Applicability;
    toString(): string;
    protected freeze(): void;
}
export declare namespace Conformance {
    enum Applicability {
        None = 0,
        Unconditional = 1,
        Conditional = 2
    }
    type AstParam = Ast.Name | Ast.Value | Ast.Option | Ast.UnaryOperand | Ast.BinaryOperands | Ast.Group | Ast.Choice;
    type Ast = {
        type: Special.Empty | Special.Desc | Flag;
    } | {
        type: Special.Name;
        param: Ast.Name;
    } | {
        type: Special.Value;
        param: Ast.Value;
    } | {
        type: Special.Choice;
        param: Ast.Choice;
    } | {
        type: Special.Group;
        param: Ast.Group;
    } | {
        type: Special.OptionalIf;
        param: Ast.Option;
    } | {
        type: Operator.AND | Operator.OR | Operator.XOR | Operator.EQ | Operator.NE | Operator.LT | Operator.GT | Operator.LTE | Operator.GTE;
        param: Ast.BinaryOperands;
    } | {
        type: Operator.NOT;
        param: Ast.UnaryOperand;
    };
    namespace Ast {
        type Name = string;
        type Value = FieldValue;
        type Option = Ast;
        type UnaryOperand = Ast;
        type BinaryOperands = {
            lhs: Ast;
            rhs: Ast;
        };
        type Group = Ast[];
        type Choice = {
            name: ChoiceName;
            num: number;
            orMore?: boolean;
            orLess?: boolean;
            expr: Ast;
        };
    }
    enum Special {
        Empty = "empty",
        Desc = "desc",
        Name = "name",
        Value = "value",
        Choice = "choice",
        Group = "group",
        OptionalIf = "optionalIf"
    }
    enum Flag {
        Mandatory = "M",
        Optional = "O",
        Provisional = "P",
        Deprecated = "D",
        Disallowed = "X"
    }
    enum Operator {
        NOT = "!",
        EQ = "==",
        NE = "!=",
        OR = "|",
        XOR = "^",
        AND = "&",
        DOT = ".",
        GT = ">",
        LT = "<",
        GTE = ">=",
        LTE = "<="
    }
    const M = Flag.Mandatory;
    const O = Flag.Optional;
    const P = Flag.Provisional;
    const D = Flag.Deprecated;
    const X = Flag.Disallowed;
    const EQ = Operator.EQ;
    const NE = Operator.NE;
    const OR = Operator.OR;
    const XOR = Operator.XOR;
    const AND = Operator.AND;
    const DOT = Operator.DOT;
    const GT = Operator.GT;
    const LT = Operator.LT;
    const GTE = Operator.GTE;
    const LTE = Operator.LTE;
    type Name = string;
    type Number = number;
    type ChoiceName = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z";
    type ReferenceResolver = (name: string) => Model | undefined;
    type ErrorTarget = {
        error(code: string, message: string): void;
    };
    /**
     * Supported ways of expressing conformance (conceptually union should include Flag but that is covered by string).
     */
    type Definition = string | string[] | {
        ast: Conformance.Ast;
    } | undefined;
    function validateReferences(conformance: Conformance, ast: Ast, errorTarget: ErrorTarget, resolver: ReferenceResolver): void;
    function serialize(ast: Ast): string;
    function isBinaryOperator(type: Ast["type"] | Operator): type is Operator;
    function precedenceOf(operator: Ast["type"] | Operator): number | undefined;
    function isHigherPrecedence(operator: Ast["type"] | Operator, other: Ast["type"] | Operator): boolean;
}
//# sourceMappingURL=Conformance.d.ts.map