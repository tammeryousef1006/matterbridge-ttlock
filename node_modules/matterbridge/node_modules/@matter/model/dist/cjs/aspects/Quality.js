"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Quality_exports = {};
__export(Quality_exports, {
  Quality: () => Quality
});
module.exports = __toCommonJS(Quality_exports);
var import_Aspect = require("./Aspect.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
class Quality extends import_Aspect.Aspect {
  /**
   * Initialize from a Quality.All definition or a string conforming to the
   * "other quality" DSL defined in the Matter specification.
   */
  constructor(definition) {
    super(definition);
    if (typeof definition === "string") {
      this.parse(this, definition);
    } else if (Array.isArray(definition)) {
      definition.map((f) => this.parse(this, f));
    } else {
      Object.assign(this, definition);
    }
    this.freeze();
  }
  parse(quality, definition) {
    const text = definition.toUpperCase();
    if (text === "DERIVED") {
      return;
    }
    let disallow = false;
    for (const char of text) {
      if (char === " " || char === "	") {
        continue;
      }
      if (char === "!") {
        disallow = true;
        continue;
      }
      const field = Quality.Flag[char];
      if (field) {
        if (this.disallowed?.[field]) {
          continue;
        }
        if (disallow) {
          delete this[field];
          if (!this.disallowed) {
            this.disallowed = {};
          }
          this.disallowed[field] = true;
          disallow = false;
        } else {
          this[field] = true;
        }
      } else {
        quality.error("UNKNOWN_QUALITY_FLAG", `Unknown flag "${char}"`);
      }
    }
  }
  /**
   * Display quality using standard Matter syntax.
   */
  toString() {
    const flags = [];
    for (const f of Quality.FlagNames) {
      const field = Quality.Flag[f];
      if (this[field] && !this.disallowed?.[field]) {
        flags.push(f);
      }
    }
    return flags.join(" ");
  }
}
((Quality2) => {
  let Field;
  ((Field2) => {
    Field2["nullable"] = "X";
    Field2["nonvolatile"] = "N";
    Field2["fixed"] = "F";
    Field2["scene"] = "S";
    Field2["reportable"] = "P";
    Field2["changesOmitted"] = "C";
    Field2["singleton"] = "I";
    Field2["quieter"] = "Q";
    Field2["largeMessage"] = "L";
    Field2["diagnostics"] = "K";
    Field2["atomic"] = "T";
  })(Field = Quality2.Field || (Quality2.Field = {}));
  let Flag;
  ((Flag2) => {
    Flag2["X"] = "nullable";
    Flag2["N"] = "nonvolatile";
    Flag2["F"] = "fixed";
    Flag2["S"] = "scene";
    Flag2["P"] = "reportable";
    Flag2["C"] = "changesOmitted";
    Flag2["I"] = "singleton";
    Flag2["Q"] = "quieter";
    Flag2["L"] = "largeMessage";
    Flag2["K"] = "diagnostics";
    Flag2["T"] = "atomic";
  })(Flag = Quality2.Flag || (Quality2.Flag = {}));
  Quality2.FlagNames = ["X", "N", "F", "S", "P", "C", "I", "Q", "L", "K", "T"];
})(Quality || (Quality = {}));
//# sourceMappingURL=Quality.js.map
