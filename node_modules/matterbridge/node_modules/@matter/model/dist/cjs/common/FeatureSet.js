"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var FeatureSet_exports = {};
__export(FeatureSet_exports, {
  FeatureSet: () => FeatureSet
});
module.exports = __toCommonJS(FeatureSet_exports);
var import_general = require("@matter/general");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
class FeatureSet extends Set {
  /**
   * Create a new feature set from an iterable that returns active names or from an object of the form { [featureName:
   * string]: true }
   */
  constructor(definition) {
    if (typeof definition === "string") {
      super([definition]);
      return;
    }
    if (definition && typeof definition[Symbol.iterator] !== "function") {
      definition = Object.entries(definition).filter(([_k, v]) => v).map(([k]) => k);
    }
    super(definition);
  }
  /**
   * Access features as an array of feature names.
   */
  get array() {
    return Array.from(this);
  }
  /**
   * Access features as an object mapping feature name -> true.
   */
  get record() {
    return Object.fromEntries(this.map((f) => [f, true]));
  }
  /**
   * Determine if I am identical to another set.
   */
  is(other) {
    return (0, import_general.isDeepEqual)([...this].sort(), other ? [...other].sort() : []);
  }
  map(fn) {
    return this.array.map(fn);
  }
}
((FeatureSet2) => {
  function normalize(featureMap, supportedFeatures) {
    const featuresAvailable = new FeatureSet2();
    const featuresSupported = new FeatureSet2();
    const supported = supportedFeatures ? new Set([...supportedFeatures].map((f) => f.toLowerCase())) : void 0;
    for (const feature of featureMap.children) {
      featuresAvailable.add(feature.name);
      if (supported?.has(feature.name.toLowerCase()) || feature.description && supported?.has(feature.description.toLowerCase())) {
        featuresSupported.add(feature.name);
      }
    }
    return {
      featuresAvailable,
      featuresSupported
    };
  }
  FeatureSet2.normalize = normalize;
})(FeatureSet || (FeatureSet = {}));
//# sourceMappingURL=FeatureSet.js.map
