/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import type { Metatype } from "./Metatype.js";
/**
 * A FieldValue represents a concrete value for a datatype.  Most values are primitives but some values we encode with
 * specialized typed objects so we can capture the original semantic meaning.
 */
export type FieldValue = null | string | number | bigint | boolean | Date | FieldValue[] | FieldValue.Properties | FieldValue.Reference | FieldValue.Percent | FieldValue.Celsius | FieldValue.Bytes | FieldValue.None;
/**
 * Create a FieldValue (or undefined) from a naked JavaScript value.
 *
 * Assumes that objects and arrays already contain valid FieldValues.
 */
export declare function FieldValue(value: unknown): FieldValue | undefined;
export declare namespace FieldValue {
    const percent = "percent";
    type percent = typeof percent;
    const celsius = "celsius";
    type celsius = typeof celsius;
    const reference = "reference";
    type reference = typeof reference;
    const properties = "properties";
    type properties = typeof properties;
    const bytes = "bytes";
    type bytes = typeof bytes;
    const none = "none";
    type none = typeof none;
    /**
     * A field value that allows type extension.
     */
    type Open = FieldValue | {
        type: string;
    };
    /**
     * If a field value isn't a primitive type, it's an object with a type field indicating one of these types.
     */
    type Type = percent | celsius | reference | properties | bytes | none;
    /**
     * Test for one of the special placeholder types.
     */
    function is(value: Open | undefined, type: Type): boolean | "" | 0 | 0n | null | undefined;
    /**
     * Flag for an invalid value.  Not part of the FieldValue union but returned when casting to a field value if the
     * cast is impossible
     */
    const Invalid: unique symbol;
    type Invalid = typeof Invalid;
    /**
     * Flag for an "Undefined"/No value. Can be used in overrides to reset fields
     */
    type None = {
        type: none;
    };
    const None: None;
    /**
     * Reference to a named field
     */
    type Reference = {
        type: reference;
        name: string;
    };
    function Reference(name: string): Reference;
    /**
     * Celsius value, typically .1°C or .01°C
     */
    type Celsius = {
        type: celsius;
        value: number;
    };
    function Celsius(value: number): Celsius;
    /**
     * Percent value, units of either 1% (.01) or .01% (.0001)
     */
    type Percent = {
        type: percent;
        value: number;
    };
    function Percent(value: number): Percent;
    /**
     * A set of struct property values keyed by name.
     */
    type Properties = {
        type: properties;
        properties: {
            [name: string]: FieldValue;
        };
    };
    /**
     * Byte value, encoded as hex string.
     */
    type Bytes = {
        type: bytes;
        value: string;
    };
    function Bytes(value: Uint8Array | string): Bytes;
    /**
     * Convert the field value to a "defacto-standard" form.
     */
    function serialize(value: FieldValue): string;
    /**
     * Given a type name as a hint, do our best to convert a field value to a number.
     */
    function numericValue(value: Open | undefined, typeName?: string): number | undefined;
    /**
     * Extract object properties from the value.
     */
    function objectValue(value: FieldValue | undefined): {
        [name: string]: FieldValue;
    } | undefined;
    /**
     * Unwrap wrapped values, leave others as-is.
     */
    function unwrap(value: FieldValue | undefined, typeName?: string): string | number | bigint | boolean | Date | FieldValue[] | {
        [name: string]: FieldValue;
    } | null | undefined;
    /**
     * Get the referenced name if the FieldValue is a reference.
     */
    function referenced(value: Open | undefined): string | undefined;
    /**
     * Convert an arbitrary value to a proper FieldValue.
     *
     * @param type casts to a native equivalent of this type
     * @param value value to cast
     *
     * @returns the cast value or FieldValue.Invalid if cast is not possible
     */
    function cast<const T extends Metatype>(type: T, value: any): FieldValue | FieldValue.Invalid | undefined;
}
//# sourceMappingURL=FieldValue.d.ts.map