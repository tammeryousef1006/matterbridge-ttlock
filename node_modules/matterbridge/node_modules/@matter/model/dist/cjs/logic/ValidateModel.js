"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ValidateModel_exports = {};
__export(ValidateModel_exports, {
  ValidateModel: () => ValidateModel
});
module.exports = __toCommonJS(ValidateModel_exports);
var import_general = require("@matter/general");
var import_ModelTraversal = require("./ModelTraversal.js");
var import_ModelValidator = require("./definition-validation/ModelValidator.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("ValidateModel");
function ValidateModel(model) {
  const result = new ValidateModel.Result(model);
  function validate(model2) {
    const Validator = import_ModelValidator.ModelValidator.validators[model2.tag];
    if (!Validator) {
      model2.error("UNKNOWN_MODEL_TYPE", `No validator for ${model2.tag}`);
      return;
    }
    try {
      new Validator(model2).validate();
    } catch (e) {
      console.error(`Error validating ${model2.path}`);
      throw e;
    }
    result.elementCount++;
    if (!model2.valid) {
      result.invalidElementCount++;
      if (model2.errors) {
        for (const error of model2.errors) {
          if (result.errorCounts[error.code]) {
            result.errorCounts[error.code]++;
          } else {
            result.errorCounts[error.code] = 1;
          }
          result.errors.push(error);
        }
      }
    }
    import_general.Logger.nest(() => {
      model2.children.forEach(validate);
    });
  }
  logger.info("Validating matter model");
  import_ModelTraversal.ModelTraversal.memoize(() => validate(model));
  return result;
}
((ValidateModel2) => {
  class Result {
    constructor(model) {
      this.model = model;
    }
    elementCount = 0;
    invalidElementCount = 0;
    errorCounts = {};
    errors = Array();
    get invalidElementPercent() {
      return (this.invalidElementCount / this.elementCount * 100).toPrecision(2);
    }
    report() {
      if (this.errors.length) {
        logger.error("*** Validation error summary ***");
        this.errors.forEach(
          (error) => logger.error(
            error.message,
            import_general.Diagnostic.dict({ code: error.code, xref: error.xref, src: error.source })
          )
        );
        logger.error("Error counts by code:");
        import_general.Logger.nest(() => {
          const codes = Object.keys(this.errorCounts).sort(
            (a, b) => a.localeCompare(b, void 0, { sensitivity: "base" })
          );
          for (const code of codes) {
            logger.error(`${code}: ${this.errorCounts[code]}`);
          }
        });
        logger.error(
          `*** Total ${this.errors.length} validation error${this.errors.length === 1 ? "" : "s"} ***`
        );
        logger.error(
          `*** Total ${this.invalidElementCount} invalid element${this.invalidElementCount === 1 ? "" : "s"} (${this.invalidElementPercent}%) ***`
        );
      } else {
        logger.info(`*** Validation successful ***`);
      }
      logger.debug(`*** Total ${this.elementCount} element${this.elementCount === 1 ? "" : "s"} ***`);
    }
  }
  ValidateModel2.Result = Result;
})(ValidateModel || (ValidateModel = {}));
//# sourceMappingURL=ValidateModel.js.map
