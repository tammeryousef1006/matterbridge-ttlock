"use strict";
var import_common = require("../../common/index.js");
var import_elements = require("../../elements/index.js");
var import_models = require("../../models/index.js");
var import_ModelValidator = require("./ModelValidator.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import_ModelValidator.ModelValidator.validators[import_elements.RequirementElement.Tag] = class RequirementValidator extends import_ModelValidator.ModelValidator {
  validate() {
    this.validateStructure(false, import_models.RequirementModel, import_models.RequirementModel, import_models.FieldModel);
    this.validateProperty({
      name: "element",
      type: import_elements.RequirementElement.ElementType,
      required: true
    });
    const parentTag = this.model.parent?.tag;
    if (parentTag) {
      switch (this.model.element) {
        case import_elements.RequirementElement.ElementType.ClientCluster:
        case import_elements.RequirementElement.ElementType.ServerCluster:
          if (parentTag !== import_common.ElementTag.DeviceType) {
            this.error(
              "ILLEGAL_REQUIREMENT_PARENT",
              `Requirement type ${this.model.type} must be parented by device type`
            );
          }
          break;
        case import_elements.RequirementElement.ElementType.Feature:
        case import_elements.RequirementElement.ElementType.Attribute:
        case import_elements.RequirementElement.ElementType.Command:
        case import_elements.RequirementElement.ElementType.Event:
          if (parentTag !== import_common.ElementTag.Requirement) {
            this.error(
              "ILLEGAL_REQUIREMENT_PARENT",
              `Requirement type ${this.model.type} must be parented by cluster requirement`
            );
          }
          break;
      }
    }
    super.validate();
  }
};
//# sourceMappingURL=RequirementValidator.js.map
