"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Aspects_exports = {};
__export(Aspects_exports, {
  Aspects: () => Aspects
});
module.exports = __toCommonJS(Aspects_exports);
var import_ModelTraversal = require("../logic/ModelTraversal.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const aspectCache = {
  Access: {},
  Conformance: {},
  Constraint: {},
  Quality: {}
};
const emptyAspects = {};
var Aspects;
((Aspects2) => {
  function getAspect(model, symbol, constructor) {
    const aspect = model[symbol] ?? emptyAspects[constructor.name];
    if (aspect) {
      return aspect;
    }
    return emptyAspects[constructor.name] = new constructor(void 0);
  }
  Aspects2.getAspect = getAspect;
  function setAspect(model, symbol, constructor, value) {
    if (value instanceof constructor) {
      model[symbol] = value;
    } else {
      const cacheKey = typeof value === "string" ? value : JSON.stringify(value);
      let aspect = aspectCache[constructor.name][value];
      if (!aspect) {
        aspect = aspectCache[constructor.name][cacheKey] = new constructor(value);
      }
      model[symbol] = aspect;
    }
  }
  Aspects2.setAspect = setAspect;
  function cloneAspects(source, dest, ...symbols) {
    for (const symbol of symbols) {
      const aspect = source[symbol];
      if (aspect !== void 0) {
        dest[symbol] = aspect;
      }
    }
  }
  Aspects2.cloneAspects = cloneAspects;
  function getEffectiveAspect(model, symbol, constructor) {
    const aspect = new import_ModelTraversal.ModelTraversal().findAspect(model, symbol);
    if (aspect) {
      return aspect;
    }
    return getAspect(model, symbol, constructor);
  }
  Aspects2.getEffectiveAspect = getEffectiveAspect;
})(Aspects || (Aspects = {}));
//# sourceMappingURL=Aspects.js.map
