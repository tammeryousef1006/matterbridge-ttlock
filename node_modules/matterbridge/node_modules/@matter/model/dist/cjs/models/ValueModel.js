"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ValueModel_exports = {};
__export(ValueModel_exports, {
  ValueModel: () => ValueModel
});
module.exports = __toCommonJS(ValueModel_exports);
var import_aspects = require("../aspects/index.js");
var import_common = require("../common/index.js");
var import_ModelTraversal = require("../logic/ModelTraversal.js");
var import_Aspects = require("./Aspects.js");
var import_Model = require("./Model.js");
var import_Scope = require("#logic/Scope.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const CONSTRAINT = Symbol("constraint");
const CONFORMANCE = Symbol("conformance");
const ACCESS = Symbol("access");
const QUALITY = Symbol("quality");
class ValueModel extends import_Model.Model {
  isType = true;
  get children() {
    return super.children;
  }
  set children(children) {
    super.children = children;
  }
  get constraint() {
    return import_Aspects.Aspects.getAspect(this, CONSTRAINT, import_aspects.Constraint);
  }
  set constraint(definition) {
    import_Aspects.Aspects.setAspect(this, CONSTRAINT, import_aspects.Constraint, definition);
  }
  get effectiveConstraint() {
    return new import_ModelTraversal.ModelTraversal().findConstraint(this, CONSTRAINT) || this.constraint;
  }
  get conformance() {
    return import_Aspects.Aspects.getAspect(this, CONFORMANCE, import_aspects.Conformance);
  }
  set conformance(definition) {
    import_Aspects.Aspects.setAspect(this, CONFORMANCE, import_aspects.Conformance, definition);
  }
  get effectiveConformance() {
    return import_Aspects.Aspects.getEffectiveAspect(this, CONFORMANCE, import_aspects.Conformance);
  }
  get access() {
    return import_Aspects.Aspects.getAspect(this, ACCESS, import_aspects.Access);
  }
  set access(definition) {
    import_Aspects.Aspects.setAspect(this, ACCESS, import_aspects.Access, definition);
  }
  get effectiveAccess() {
    return new import_ModelTraversal.ModelTraversal().findAccess(this, ACCESS, ValueModel);
  }
  get quality() {
    return import_Aspects.Aspects.getAspect(this, QUALITY, import_aspects.Quality);
  }
  set quality(definition) {
    import_Aspects.Aspects.setAspect(this, QUALITY, import_aspects.Quality, definition);
  }
  get effectiveQuality() {
    return import_Aspects.Aspects.getEffectiveAspect(this, QUALITY, import_aspects.Quality);
  }
  /**
   * Metatype is only present on global types with specific semantic meaning. This model is significant because it
   * gives us information about how to manipulate the data.  This accessor retrieves this model.
   */
  get metabase() {
    return new import_ModelTraversal.ModelTraversal().findMetabase(this);
  }
  /**
   * Get the primitive type for this value model.  This is an integer type for enums and bitmaps.  Otherwise it's the
   * metabase.
   */
  get primitiveBase() {
    const metabase = this.metabase;
    if (!metabase) {
      return;
    }
    if (metabase.metatype === import_common.Metatype.enum) {
      return metabase.base;
    }
    if (metabase.metatype === import_common.Metatype.bitmap) {
      const primitiveName = metabase.name.replace("map", "uint");
      return metabase.parent?.children.find((c) => c.name === primitiveName);
    }
    return metabase;
  }
  /**
   * The "effective type" may be inferred from context.
   */
  get effectiveType() {
    const type = super.effectiveType;
    if (type) {
      return type;
    }
    return new import_ModelTraversal.ModelTraversal().getTypeName(this);
  }
  /**
   * The working metatype for this object.
   */
  get effectiveMetatype() {
    const metaBase = this.metabase;
    if (metaBase) {
      return metaBase.metatype;
    }
  }
  /**
   * Get the first derived ancestor with children, if any.
   */
  get definingModel() {
    return new import_ModelTraversal.ModelTraversal().findDefiningModel(this);
  }
  /**
   * Get the entry type for lists, if any.
   */
  get listEntry() {
    return this.member("entry", [import_common.ElementTag.Field]);
  }
  /**
   * ValueModels may only derive from ValueModels.
   */
  get base() {
    return super.base;
  }
  /**
   * ValueModels may derive from models of the same type or from generic Datatype models.
   */
  get allowedBaseTags() {
    if (this.tag === import_common.ElementTag.Field) {
      return [import_common.ElementTag.Field, import_common.ElementTag.Datatype, import_common.ElementTag.Attribute];
    }
    return [this.tag, import_common.ElementTag.Datatype];
  }
  /**
   * All {@link FieldModel} children in the context of the model's containing scope.
   */
  get members() {
    return (0, import_Scope.Scope)(this).membersOf(this);
  }
  /**
   * Collect constraints and conformance for this type and all base types.
   */
  get validationAspects() {
    const aspects = Array();
    new import_ModelTraversal.ModelTraversal().visitInheritance(this, (model) => {
      if (model instanceof ValueModel) {
        if (!model.conformance.empty && model.conformance.type !== import_aspects.Conformance.Special.Desc) {
          aspects.push(model.conformance);
        }
        if (!model.constraint.empty && !model.constraint.desc) {
          aspects.push(model.constraint);
        }
        if (model.quality.nullable === false) {
          aspects.push(model.quality);
        }
      }
    });
    return aspects;
  }
  /**
   * Is this model deprecated?
   */
  get isDeprecated() {
    return this.effectiveConformance.type === import_aspects.Conformance.Flag.Deprecated;
  }
  /**
   * Is this model disallowed?
   */
  get isDisallowed() {
    return this.effectiveConformance.type === import_aspects.Conformance.Flag.Disallowed;
  }
  /**
   * Can this model be omitted?
   */
  get nullable() {
    return !!this.effectiveQuality.nullable;
  }
  /**
   * Is the model mandatory?
   */
  get mandatory() {
    return this.effectiveConformance.isMandatory;
  }
  /**
   * Determine whether this element overrides key properties of its shadow.
   */
  get overridesShadow() {
    const shadow = this.shadow;
    if (!shadow || !(shadow instanceof ValueModel)) {
      return;
    }
    if (this.type && this.type !== shadow.type) {
      return true;
    }
    if (!this.conformance.empty && !this.conformance.equals(shadow.conformance)) {
      return true;
    }
    if (!this.quality.empty && !this.quality.equals(shadow.quality)) {
      return true;
    }
    if (!this.constraint.empty && !this.constraint.equals(shadow.constraint)) {
      return true;
    }
    if (!this.access.empty && !this.access.equals(shadow.access)) {
      return true;
    }
  }
  /**
   * Search the inheritance chain for a bitmap field defining a specific bit.
   */
  bitDefinition(bit) {
    return new import_ModelTraversal.ModelTraversal().findBitDefinition(this, bit);
  }
  /**
   * Clone the model with minimum metadata required to ensure model is valid.
   */
  cloneAsReference() {
    const Type = this.constructor;
    return new Type(this.requiredFields);
  }
  get requiredFields() {
    return { name: this.name };
  }
  valueOf() {
    const result = super.valueOf();
    for (const k of ["conformance", "access", "quality", "constraint"]) {
      const v = this[k];
      if (v && !v.empty) {
        result[k] = v.valueOf();
      }
    }
    if (result.default === void 0) {
      delete result.default;
    }
    return result;
  }
  constructor(definition, ...children) {
    super(definition, ...children);
    const match = this.type?.match(/^list\[(.*)\]$/);
    if (match) {
      this.type = "list";
      this.children.push(new import_Model.Model.types.field({ name: "entry", type: match[1] }));
    }
    if (definition instanceof import_Model.Model) {
      import_Aspects.Aspects.cloneAspects(definition, this, CONSTRAINT, CONFORMANCE, ACCESS, QUALITY);
    }
  }
}
//# sourceMappingURL=ValueModel.js.map
