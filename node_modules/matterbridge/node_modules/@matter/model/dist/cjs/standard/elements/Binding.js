"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Binding_exports = {};
__export(Binding_exports, {
  Binding: () => Binding
});
module.exports = __toCommonJS(Binding_exports);
var import_MatterDefinition = require("../MatterDefinition.js");
var import_elements = require("../../elements/index.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const Binding = (0, import_elements.ClusterElement)(
  {
    name: "Binding",
    id: 30,
    classification: "endpoint",
    pics: "BIND",
    details: "NOTE\nThis scope of this document is the Binding cluster as part of the Cluster Library. The Binding cluster is meant to replace the support from the Zigbee Device Object (ZDO) for supporting the binding table.\nA binding represents a persistent relationship between an endpoint and one or more other local or remote endpoints. A binding does not require that the relationship exists. It is up to the node application to set up the relationship.\nA binding is used to inform a client endpoint of one or more targets for a potential interaction. For example: a light switch that controls one or more light bulbs, needs to be told the nodes and endpoints of the bulbs, or told a group in which the bulbs are members. For example: A client that needs to subscribe to an occupancy sensor, needs to know the node and endpoint of the sensor.\nIn such cases, a binding is used to direct a local endpoint to a target. The existence of the Binding cluster on the client endpoint, allows the creation of one or more binding entries (bindings) in the Binding cluster.\nEach binding indicates another endpoint or cluster on another endpoint. Multiple bindings are allowed, depending on the interaction.\nA binding is either a unicast binding, where the target is a single endpoint on a single node, or a groupcast binding, where the target is a group, which may indicate multiple endpoints on multiple nodes. The binding may also target a single cluster on the target endpoint(s).\nWhen a client cluster requires a target for an interaction, the Binding cluster shall exist on the same endpoint.\nOnce a binding entry is created on the Binding cluster, the client endpoint may initiate interactions to the binding target.",
    xref: { document: "core", section: "9.6" }
  },
  (0, import_elements.AttributeElement)({ name: "ClusterRevision", id: 65533, type: "ClusterRevision", default: 1 }),
  (0, import_elements.AttributeElement)(
    {
      name: "Binding",
      id: 0,
      type: "list",
      access: "RW F VM",
      conformance: "M",
      constraint: "desc",
      default: [],
      quality: "N",
      details: "Each entry shall represent a binding.",
      xref: { document: "core", section: "9.6.6.1" }
    },
    (0, import_elements.FieldElement)({ name: "entry", type: "TargetStruct" })
  ),
  (0, import_elements.DatatypeElement)(
    { name: "TargetStruct", type: "struct", xref: { document: "core", section: "9.6.5.1" } },
    (0, import_elements.FieldElement)({
      name: "Node",
      id: 1,
      type: "node-id",
      access: "F",
      conformance: "Endpoint",
      details: "This field is the remote target node ID. If the Endpoint field is present, this field shall be present.",
      xref: { document: "core", section: "9.6.5.1.1" }
    }),
    (0, import_elements.FieldElement)({
      name: "Group",
      id: 2,
      type: "group-id",
      access: "F",
      conformance: "!Endpoint",
      constraint: "min 1",
      details: "This field is the target group ID that represents remote endpoints. If the Endpoint field is present, this field shall NOT be present.",
      xref: { document: "core", section: "9.6.5.1.2" }
    }),
    (0, import_elements.FieldElement)({
      name: "Endpoint",
      id: 3,
      type: "endpoint-no",
      access: "F",
      conformance: "!Group",
      details: "This field is the remote endpoint that the local endpoint is bound to. If the Group field is present, this field shall NOT be present.",
      xref: { document: "core", section: "9.6.5.1.3" }
    }),
    (0, import_elements.FieldElement)({
      name: "Cluster",
      id: 4,
      type: "cluster-id",
      access: "F",
      conformance: "O",
      details: "This field is the cluster ID (client & server) on the local and target endpoint(s). If this field is present, the client cluster shall also exist on this endpoint (with this Binding cluster). If this field is present, the target shall be this cluster on the target endpoint(s).",
      xref: { document: "core", section: "9.6.5.1.4" }
    }),
    (0, import_elements.FieldElement)({ name: "FabricIndex", id: 254, type: "FabricIndex" })
  )
);
import_MatterDefinition.MatterDefinition.children.push(Binding);
//# sourceMappingURL=Binding.js.map
