"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var BridgedDeviceBasicInformation_exports = {};
__export(BridgedDeviceBasicInformation_exports, {
  BridgedDeviceBasicInformation: () => BridgedDeviceBasicInformation
});
module.exports = __toCommonJS(BridgedDeviceBasicInformation_exports);
var import_MatterDefinition = require("../MatterDefinition.js");
var import_elements = require("../../elements/index.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const BridgedDeviceBasicInformation = (0, import_elements.ClusterElement)(
  {
    name: "BridgedDeviceBasicInformation",
    id: 57,
    type: "BasicInformation",
    classification: "endpoint",
    pics: "BRBINFO",
    details: "This cluster is a derived cluster of the Basic Information cluster and serves two purposes towards a Node communicating with a Bridge:\n  \u2022 Indicate that the functionality on the Endpoint where it is placed (and its Parts) is bridged,     and\n  \u2022 Provide a centralized collection of attributes that the Node may collect to aid in conveying     information regarding the Bridged Device to a user, such as the vendor name, the model name, or     user-assigned name.\nThis cluster shall be exposed by a Bridge on the Endpoint representing each Bridged Device. When the functionality of a Bridged Device is represented using a set of Endpoints, this cluster shall only be exposed on the Endpoint which is at the top of the hierarchy for the functionality of that Bridged Device.\nThis cluster shall NOT be used on an endpoint that is not in the Descriptor cluster PartsList of an endpoint with an Aggregator device type.\nThis cluster has been derived from the Basic Information Cluster, and provides generic information about the Bridged Device. Not all of the attributes in the Basic Information Cluster are relevant for a Bridged Device (e.g. ProductID since it is not a Matter device). For other attributes, the information which is listed as Mandatory for the Basic Information Cluster, may not be available when the Bridged Device does not provide it to the Bridge, and the Bridge has no other means to determine it. For such cases where the information for a particular attribute is not available, the Bridge SHOULD NOT include the attribute in the cluster for this Bridged Device. See below for Conformance details.",
    xref: { document: "core", section: "9.13" }
  },
  (0, import_elements.AttributeElement)({ name: "ClusterRevision", id: 65533, type: "ClusterRevision", default: 4 }),
  (0, import_elements.AttributeElement)(
    { name: "FeatureMap", id: 65532, type: "FeatureMap", xref: { document: "core", section: "9.13.4" } },
    (0, import_elements.FieldElement)({
      name: "BIS",
      conformance: "O",
      constraint: "20",
      description: "BridgedIcdSupport",
      details: "Support bridged ICDs."
    })
  ),
  (0, import_elements.AttributeElement)({ name: "DataModelRevision", id: 0, conformance: "X", xref: { document: "core", section: "9.13.5" } }),
  (0, import_elements.AttributeElement)({ name: "VendorName", id: 1, conformance: "O", xref: { document: "core", section: "9.13.5" } }),
  (0, import_elements.AttributeElement)({ name: "VendorId", id: 2, conformance: "O", xref: { document: "core", section: "9.13.5" } }),
  (0, import_elements.AttributeElement)({ name: "ProductName", id: 3, conformance: "O", xref: { document: "core", section: "9.13.5" } }),
  (0, import_elements.AttributeElement)({ name: "ProductId", id: 4, conformance: "desc", xref: { document: "core", section: "9.13.5" } }),
  (0, import_elements.AttributeElement)({ name: "NodeLabel", id: 5, conformance: "O", xref: { document: "core", section: "9.13.5" } }),
  (0, import_elements.AttributeElement)({ name: "Location", id: 6, conformance: "X", xref: { document: "core", section: "9.13.5" } }),
  (0, import_elements.AttributeElement)({ name: "HardwareVersion", id: 7, conformance: "O", xref: { document: "core", section: "9.13.5" } }),
  (0, import_elements.AttributeElement)({ name: "HardwareVersionString", id: 8, conformance: "O", xref: { document: "core", section: "9.13.5" } }),
  (0, import_elements.AttributeElement)({ name: "SoftwareVersion", id: 9, conformance: "O", xref: { document: "core", section: "9.13.5" } }),
  (0, import_elements.AttributeElement)({ name: "SoftwareVersionString", id: 10, conformance: "O", xref: { document: "core", section: "9.13.5" } }),
  (0, import_elements.AttributeElement)({ name: "ManufacturingDate", id: 11, conformance: "O", xref: { document: "core", section: "9.13.5" } }),
  (0, import_elements.AttributeElement)({ name: "PartNumber", id: 12, conformance: "O", xref: { document: "core", section: "9.13.5" } }),
  (0, import_elements.AttributeElement)({ name: "ProductUrl", id: 13, conformance: "O", xref: { document: "core", section: "9.13.5" } }),
  (0, import_elements.AttributeElement)({ name: "ProductLabel", id: 14, conformance: "O", xref: { document: "core", section: "9.13.5" } }),
  (0, import_elements.AttributeElement)({ name: "SerialNumber", id: 15, conformance: "O", xref: { document: "core", section: "9.13.5" } }),
  (0, import_elements.AttributeElement)({ name: "LocalConfigDisabled", id: 16, conformance: "X", xref: { document: "core", section: "9.13.5" } }),
  (0, import_elements.AttributeElement)({
    name: "Reachable",
    id: 17,
    conformance: "M",
    details: "This attribute shall be used to indicate whether the bridged device is reachable by the bridge, so a Matter Node which wants to communicate with a bridged device can get an indication that this might fail (when the attribute is False). Determination of reachability might not be perfect (e.g. depending on technology employed), so the Matter Node SHOULD be aware of the risk of false positives and negatives on reachability determination. For example, a bridged device may be marked as unreachable while it could actually be reached, and vice-versa. Also, detection (and indication) that a bridged device is not longer reachable may be delayed due to the technique employed (e.g. detecting that a number of expected messages from the bridged device did not arrive). Also see event ReachableChanged below.",
    xref: { document: "core", section: "9.13.5.1" }
  }),
  (0, import_elements.AttributeElement)({
    name: "UniqueId",
    id: 18,
    conformance: "M",
    details: "This attribute shall, for a Bridged Device, be updated when the Bridge is factory reset. If the bridged device does not provide some unique id (e.g. in the case of bridging from non-Matter devices, or in case of bridging Matter devices from an earlier revision which were not required to provide a UniqueID attribute), the bridge shall generate a unique id on behalf of the bridged device.\nNOTE The UniqueID attribute was optional in cluster revisions prior to revision 4.",
    xref: { document: "core", section: "9.13.5.2" }
  }),
  (0, import_elements.AttributeElement)({ name: "CapabilityMinima", id: 19, conformance: "X", xref: { document: "core", section: "9.13.5" } }),
  (0, import_elements.AttributeElement)({ name: "ProductAppearance", id: 20, conformance: "O", xref: { document: "core", section: "9.13.5" } }),
  (0, import_elements.AttributeElement)({ name: "SpecificationVersion", id: 21, conformance: "X", xref: { document: "core", section: "9.13.5" } }),
  (0, import_elements.AttributeElement)({ name: "MaxPathsPerInvoke", id: 22, conformance: "X", xref: { document: "core", section: "9.13.5" } }),
  (0, import_elements.EventElement)({ name: "StartUp", id: 0, conformance: "O", priority: "critical", xref: { document: "core", section: "9.13.7" } }),
  (0, import_elements.EventElement)({
    name: "ShutDown",
    id: 1,
    conformance: "O",
    priority: "critical",
    xref: { document: "core", section: "9.13.7" }
  }),
  (0, import_elements.EventElement)(
    {
      name: "Leave",
      id: 2,
      conformance: "O",
      priority: "critical",
      details: "The Leave event SHOULD be generated by the bridge when it detects that the associated device has left the non-Matter network.\nNOTE\nThe FabricIndex field has the X conformance, indicating it shall NOT be present. This event, in the context of Bridged Device Basic Information cluster, has no usable fields, but the original Basic Information cluster\u2019s field definition is kept for completeness.",
      xref: { document: "core", section: "9.13.7.1" }
    },
    (0, import_elements.FieldElement)({ name: "FabricIndex", id: 0, conformance: "X" })
  ),
  (0, import_elements.EventElement)({
    name: "ReachableChanged",
    id: 3,
    conformance: "M",
    priority: "critical",
    details: "This event shall be generated when there is a change in the Reachable attribute. Its purpose is to provide an indication towards interested parties that the reachability of a bridged device has changed over its native connectivity technology, so they may take appropriate action.\nAfter (re)start of a bridge this event may be generated.",
    xref: { document: "core", section: "9.13.7.2" }
  }),
  (0, import_elements.EventElement)(
    {
      name: "ActiveChanged",
      id: 128,
      access: "V",
      conformance: "BIS",
      priority: "info",
      details: "This event (when supported) shall be generated the next time a bridged device becomes active after a KeepActive command is received.\nSee KeepActive for more details.",
      xref: { document: "core", section: "9.13.7.3" }
    },
    (0, import_elements.FieldElement)({
      name: "PromisedActiveDuration",
      id: 0,
      type: "uint32",
      conformance: "M",
      constraint: "desc",
      details: "This field shall indicate the minimum duration, in milliseconds, that the bridged device will remain active after receiving the initial request from the KeepActive processing steps.\nIf the bridged device is a Matter Intermittently Connected Device, PromisedActiveDuration shall be set to the PromisedActiveDuration value returned in the StayActiveResponse command.\nIf the bridged device is not a Matter Intermittently Connected Device, the implementation of this is best-effort since it may interact with non-native protocol.",
      xref: { document: "core", section: "9.13.7.3.1" }
    })
  ),
  (0, import_elements.CommandElement)(
    {
      name: "KeepActive",
      id: 128,
      access: "O",
      conformance: "BIS",
      direction: "request",
      response: "status",
      details: 'Upon receipt, the server shall attempt to keep the bridged device active for the duration specified by the command, when the device is next active.\nThe implementation of this is best-effort since it may interact with non-native protocols. However, several specific protocol requirements are:\n  \u2022 If the bridged device is a Matter Intermittently Connected Device, then the server shall send a     StayActiveRequest command with the StayActiveDuration field set to value of the     StayActiveDuration field in the received command to the bridged device when the bridged device     next sends a checks-in message or subscription report. See Intermittently Connected Devices     Behavior for details on ICD state management.\nWhen the bridge detects that the bridged device goes into an active state, an ActiveChanged event shall be generated.\nIn order to avoid unnecessary power consumption in the bridged device:\n  \u2022 The server shall enter a "pending active" state for the associated device when the KeepActive     command is received. The server "pending active" state shall expire after the amount of time     defined by the TimeoutMs field, in milliseconds, if no subsequent KeepActive command is     received. When a KeepActive command is received, the "pending active" state is set, the     StayActiveDuration is updated to the greater of the new value and the previously stored value,     and the TimeoutMs is updated to the greater of the new value and the remaining time until the     prior "pending active" state expires.\n  \u2022 The server shall only keep the bridged device active once for a request. (The server shall only     consider the operation performed if an associated ActiveChanged event was generated.)',
      xref: { document: "core", section: "9.13.6.1" }
    },
    (0, import_elements.FieldElement)({
      name: "StayActiveDuration",
      id: 0,
      type: "uint32",
      conformance: "M",
      details: "This field shall indicate the duration, in milliseconds, that the device is requested to remain active, once the device becomes active again.\nThe value of this field may be longer than the value supported by the bridged device and would, typically, be used by the client to request the server of the bridged device to stay active and responsive for this period to allow a sequence of message exchanges during that period.\nThe client may slightly overestimate the duration it wants the bridged device to be active for, in order to account for network delays.",
      xref: { document: "core", section: "9.13.6.1.1" }
    }),
    (0, import_elements.FieldElement)({
      name: "TimeoutMs",
      id: 1,
      type: "uint32",
      conformance: "M",
      constraint: "30000 to 3600000",
      details: 'This field shall indicate the period, in milliseconds, that the server will wait before the "pending active" state expires. See the KeepActive Command description for details.\nNOTE\nTimeoutMs is a timeout for the request, NOT the time the device will be awake for. The server will wait for up to TimeoutMs for the device. If after TimeoutMs the ICD\ndevice does NOT check-in, the server will not perform any actions.',
      xref: { document: "core", section: "9.13.6.1.2" }
    })
  )
);
import_MatterDefinition.MatterDefinition.children.push(BridgedDeviceBasicInformation);
//# sourceMappingURL=BridgedDeviceBasicInformation.js.map
