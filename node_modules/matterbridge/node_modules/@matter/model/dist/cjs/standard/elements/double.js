"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var double_exports = {};
__export(double_exports, {
  double: () => double
});
module.exports = __toCommonJS(double_exports);
var import_MatterDefinition = require("../MatterDefinition.js");
var import_elements = require("../../elements/index.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const double = (0, import_elements.DatatypeElement)({
  name: "double",
  byteSize: 8,
  description: "Double precision",
  isSeed: true,
  metatype: "float",
  details: "The double precision number format is based on the IEEE 754-2019 double precision (64-bit) format for binary floating-point arithmetic.\nThe format and interpretation of values of this data type follow the same rules as given for the single precision data type, but with wider mantissa and exponent ranges.\nSee IEEE 754-2019 for more details on the representable values.",
  xref: { document: "core", section: "7.19.1.6" }
});
import_MatterDefinition.MatterDefinition.children.push(double);
//# sourceMappingURL=double.js.map
