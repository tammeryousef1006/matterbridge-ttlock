/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { FieldValue } from "../common/index.js";
import { Aspect } from "./Aspect.js";
/**
 * An operational view of constraints as defined by the Matter specification.
 *
 * A "constraint" limits possible data values.
 */
export declare class Constraint extends Aspect<Constraint.Definition> implements Constraint.Ast {
    desc?: boolean;
    value?: Constraint.Expression;
    min?: Constraint.Expression;
    max?: Constraint.Expression;
    in?: FieldValue;
    entry?: Constraint;
    cpMax?: number;
    parts?: Constraint[];
    /**
     * Initialize from a Constraint.Definition or the constraint DSL defined by the Matter Specification.
     */
    constructor(definition: Constraint.Definition);
    /**
     * Test a value against a constraint.  Does not recurse into arrays.
     */
    test(value: FieldValue, nameResolver?: (name: string) => unknown): boolean;
    toString(): string;
    protected freeze(): void;
}
export declare namespace Constraint {
    type NumberOrIdentifier = number | string;
    /**
     * Parsed constraint.
     */
    type Ast = {
        /**
         * Indicates constraint is defined in prose and cannot be enforced automatically.
         */
        desc?: boolean;
        /**
         * Constant value.
         */
        value?: Expression;
        /**
         * Lower bound on value or sequence length.
         */
        min?: Expression;
        /**
         * Upper bound on value or sequence length.
         */
        max?: Expression;
        /**
         * Require set membership for the value.
         */
        in?: FieldValue;
        /**
         * Constraint on list child element.
         */
        entry?: Ast;
        /**
         * Constraint on codepoints in a string.
         */
        cpMax?: number;
        /**
         * List of sub-constraints in a sequence.
         */
        parts?: Ast[];
    };
    /**
     * Parsed binary operator.
     */
    interface BinaryOperator {
        type: "+" | "-";
        lhs: Expression;
        rhs: Expression;
    }
    /**
     * Parsed expression.
     */
    type Expression = FieldValue | BinaryOperator;
    /**
     * These are all ways to describe a constraint.
     */
    type Definition = (Ast & {
        definition?: Definition;
    }) | string | number | undefined;
}
//# sourceMappingURL=Constraint.d.ts.map