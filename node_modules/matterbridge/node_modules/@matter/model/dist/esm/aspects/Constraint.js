/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Lexer } from "#parser/Lexer.js";
import { TokenStream } from "#parser/TokenStream.js";
import { camelize } from "@matter/general";
import { FieldValue } from "../common/index.js";
import { Aspect } from "./Aspect.js";
class Constraint extends Aspect {
  /**
   * Initialize from a Constraint.Definition or the constraint DSL defined by the Matter Specification.
   */
  constructor(definition) {
    super(definition);
    let ast;
    switch (typeof definition) {
      case "string":
        if (
          // Mask
          definition.match(/^0b[0x ]+$/) || // Hack to identify mask without 0b prefix
          definition.startsWith("00") && definition.includes("x") && definition.match(/^[0x ]+$/)
        ) {
          break;
        }
        ast = Parser.parse(this, definition);
        break;
      case "number":
        ast = { value: definition };
        break;
      default:
        ast = definition;
        if (ast?.definition) {
          this.definition = ast.definition;
        }
        break;
    }
    if (!ast) {
      return;
    }
    if (ast.desc !== void 0) {
      this.desc = ast.desc;
    }
    if (ast.value !== void 0) {
      this.value = ast.value;
    }
    if (ast.min !== void 0) {
      this.min = ast.min;
    }
    if (ast.max !== void 0) {
      this.max = ast.max;
    }
    if (ast.in !== void 0) {
      this.in = ast.in;
    }
    if (ast.entry !== void 0) {
      this.entry = new Constraint(ast.entry);
    }
    if (ast.cpMax !== void 0) {
      this.cpMax = ast.cpMax;
    }
    if (ast.parts !== void 0) {
      this.parts = ast.parts.map((p) => new Constraint(p));
    }
    this.freeze();
  }
  /**
   * Test a value against a constraint.  Does not recurse into arrays.
   */
  test(value, nameResolver) {
    function valueOf(value2, raw = false) {
      if (!raw && (typeof value2 === "string" || Array.isArray(value2))) {
        return value2.length;
      }
      if (typeof value2 === "object" && value2 !== null && "type" in value2) {
        const { type } = value2;
        switch (type) {
          case FieldValue.reference:
            if (typeof value2.name === "string") {
              value2 = FieldValue(nameResolver?.(camelize(value2.name)));
            }
            break;
          case "+":
            {
              const lhs = valueOf(value2.lhs);
              const rhs = valueOf(value2.rhs);
              if (typeof lhs === "number" && typeof rhs === "number") {
                return lhs + rhs;
              }
              return void 0;
            }
            break;
          case "-":
            {
              const lhs = valueOf(value2.lhs);
              const rhs = valueOf(value2.rhs);
              if (typeof lhs === "number" && typeof rhs === "number") {
                return lhs - rhs;
              }
              return void 0;
            }
            break;
        }
      }
      return value2;
    }
    if (value === void 0) {
      return false;
    }
    if (this.in) {
      let set = valueOf(this.in, true);
      if (!Array.isArray(set)) {
        set = set === void 0 ? [] : [set];
      }
      return set.indexOf(value) !== -1;
    }
    const v = valueOf(this.value);
    if (v === value) {
      return true;
    }
    if (v !== void 0 || value === null) {
      return false;
    }
    if (this.min !== void 0 && this.min !== null) {
      const min = valueOf(this.min);
      if (min !== void 0 && min !== null && min > value) {
        return false;
      }
    }
    if (this.max !== void 0 && this.max !== null) {
      const max = valueOf(this.max);
      if (max !== void 0 && max !== null && max < value) {
        return false;
      }
    }
    if (this.parts?.every((part) => part.test(value, nameResolver) === false)) {
      return false;
    }
    return true;
  }
  toString() {
    if (!this.valid && this.definition) {
      return this.definition.toString();
    }
    return Serializer.serialize(this);
  }
  freeze() {
    if (this.parts) {
      Object.freeze(this.parts);
    }
    super.freeze();
  }
}
var Serializer;
((Serializer2) => {
  function serialize(ast) {
    if (ast.parts) {
      return ast.parts.map(serialize).join(", ");
    }
    if (ast.entry) {
      return `${serializeAtom(ast)}[${serialize(ast.entry)}]`;
    }
    if (ast.cpMax) {
      return `${serializeAtom(ast)}{${ast.cpMax}}`;
    }
    return serializeAtom(ast);
  }
  Serializer2.serialize = serialize;
  function serializeValue(value, inExpr = false) {
    if (typeof value !== "object" || value === null || Array.isArray(value) || value instanceof Date) {
      return FieldValue.serialize(value);
    }
    switch (value.type) {
      case "+":
      case "-":
        const sum = `${serializeValue(value.lhs, true)} ${value.type} ${serializeValue(value.rhs, true)}`;
        if (inExpr) {
          return `(${sum})`;
        }
        return sum;
      default:
        return FieldValue.serialize(value);
    }
  }
  function serializeAtom(ast) {
    if (ast.desc) {
      return "desc";
    }
    if (ast.value !== void 0 && ast.value !== null) {
      return `${serializeValue(ast.value)}`;
    }
    if (ast.min !== void 0 && ast.min !== null) {
      if (ast.max === void 0 || ast.max === null) {
        return `min ${serializeValue(ast.min)}`;
      }
      return `${serializeValue(ast.min)} to ${serializeValue(ast.max)}`;
    }
    if (ast.max !== void 0 && ast.max !== null) {
      return `max ${serializeValue(ast.max)}`;
    }
    if (ast.in !== void 0) {
      return `in ${serializeValue(ast.in)}`;
    }
    return "all";
  }
})(Serializer || (Serializer = {}));
var Parser;
((Parser2) => {
  const lexer = new Lexer(["in", "min", "max", "to", "all", "desc", "true", "false"]);
  function parse(constraint, definition) {
    const tokens = TokenStream(lexer.lex(definition, (code, message) => constraint.error(code, message)));
    const result = parseParts();
    if (tokens.token && tokens.token?.type !== ",") {
      constraint.error("UNEXPECTED_CONSTRAINT_TOKEN", `Unexpected ${tokens.description}`);
    }
    return result;
    function parseParts() {
      const parts = Array();
      while (true) {
        const part = parsePart();
        if (part !== void 0) {
          parts.push(part);
        }
        if (tokens.done) {
          break;
        }
        if (tokens.token?.type !== ",") {
          break;
        }
        tokens.next();
      }
      if (!parts.length) {
        return {};
      }
      if (parts.length === 1) {
        return parts[0];
      }
      return { parts };
    }
    function parsePart() {
      const result2 = parsePartWithoutSubconstraint();
      if (result2 === void 0) {
        return result2;
      }
      switch (tokens.token?.type) {
        case "[":
          {
            tokens.next();
            const entry = parseParts();
            if (tokens.token?.type !== "]") {
              constraint.error("MISSING_ENTRY_END", 'Entry constraint does not end with "]"');
            }
            tokens.next();
            if (entry !== void 0) {
              result2.entry = entry;
            }
          }
          break;
        case "{":
          {
            tokens.next();
            if (tokens.token?.type !== "value") {
              constraint.error(
                "MISSING_CODEPOINT_MAX",
                "Codepoint constraint does not specify maximum codepoint length"
              );
              if (tokens.peeked?.type === "}") {
                tokens.next();
              }
            } else {
              result2.cpMax = FieldValue.numericValue(
                tokens.token.value
              );
              tokens.next();
            }
            if (tokens.token?.type !== "}") {
              constraint.error("MISSING_CODEPOINT_END", 'Codepoint constraint does not end with "}"');
            }
            tokens.next();
          }
          break;
      }
      return result2;
    }
    function parsePartWithoutSubconstraint() {
      const { token } = tokens;
      if (!token) {
        return;
      }
      switch (token.type) {
        case "desc":
          tokens.next();
          return { desc: true };
        case "all":
          tokens.next();
          return {};
        case "min":
        case "max":
          tokens.next();
          return parseSingleBound(token.type);
        case "in":
          tokens.next();
          if (tokens.token?.type === "word") {
            const name = tokens.token.value;
            tokens.next();
            return { in: FieldValue.Reference(name) };
          }
          constraint.error("MISSING_IN_FIELD", 'Expected field name to follow "in"');
          break;
      }
      const value = parseExpression();
      if (value === void 0 || tokens.token?.type !== "to") {
        return { value };
      }
      tokens.next();
      const max = parseExpression();
      if (max === void 0) {
        constraint.error("MISSING_UPPER_BOUND", `"to" must be followed by upper boundary value`);
        return;
      }
      return {
        min: value,
        max
      };
    }
    function parseSingleBound(kind) {
      const bound = parseExpression();
      if (bound === void 0) {
        constraint.error("MISSING_SINGLE_BOUND", `"${kind}" must be followed by boundary value`);
        return;
      }
      return { [kind]: bound };
    }
    function parseExpression() {
      const value = parseValueExpression();
      if (value === void 0) {
        return value;
      }
      switch (tokens.token?.type) {
        case "+":
        case "-":
          const type = tokens.token.type;
          tokens.next();
          const rhs = parseValueExpression();
          if (rhs === void 0) {
            constraint.error("MISSING_RIGHT_OPERAND", `Missing operand after "${type}"`);
            return;
          }
          return {
            type,
            lhs: value,
            rhs
          };
      }
      return value;
    }
    function parseValueExpression() {
      const { token } = tokens;
      if (token === void 0) {
        return;
      }
      switch (token.type) {
        case "value":
          tokens.next();
          return token.value;
        case "true":
          tokens.next();
          return true;
        case "false":
          tokens.next();
          return false;
        case "word":
          const ref = FieldValue.Reference(camelize(token.value));
          tokens.next();
          return ref;
        case "-":
        case "+": {
          tokens.next();
          let number = tokens.token?.type === "value" ? tokens.token.value : void 0;
          if (number !== void 0) {
            tokens.next();
            if (token.type === "-") {
              if (typeof number === "number") {
                number *= -1;
              } else if (FieldValue.is(number, FieldValue.percent) || FieldValue.is(number, FieldValue.celsius)) {
                number.value *= -1;
              } else {
                number = void 0;
              }
            }
          }
          if (number === void 0) {
            constraint.error("MISSING_NUMBER", `Unary "${token.type}" not followed by numeric value`);
            return;
          }
          return number;
        }
        case "(": {
          tokens.next();
          const result2 = parseExpression();
          if (tokens.token?.type !== ")") {
            constraint.error("MISSING_GROUP_END", 'Group does not end with ")"');
          }
          tokens.next();
          return result2;
        }
      }
    }
  }
  Parser2.parse = parse;
})(Parser || (Parser = {}));
export {
  Constraint
};
//# sourceMappingURL=Constraint.js.map
