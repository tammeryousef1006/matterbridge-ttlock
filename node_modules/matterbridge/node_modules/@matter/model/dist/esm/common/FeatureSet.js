/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { isDeepEqual } from "@matter/general";
class FeatureSet extends Set {
  /**
   * Create a new feature set from an iterable that returns active names or from an object of the form { [featureName:
   * string]: true }
   */
  constructor(definition) {
    if (typeof definition === "string") {
      super([definition]);
      return;
    }
    if (definition && typeof definition[Symbol.iterator] !== "function") {
      definition = Object.entries(definition).filter(([_k, v]) => v).map(([k]) => k);
    }
    super(definition);
  }
  /**
   * Access features as an array of feature names.
   */
  get array() {
    return Array.from(this);
  }
  /**
   * Access features as an object mapping feature name -> true.
   */
  get record() {
    return Object.fromEntries(this.map((f) => [f, true]));
  }
  /**
   * Determine if I am identical to another set.
   */
  is(other) {
    return isDeepEqual([...this].sort(), other ? [...other].sort() : []);
  }
  map(fn) {
    return this.array.map(fn);
  }
}
((FeatureSet2) => {
  function normalize(featureMap, supportedFeatures) {
    const featuresAvailable = new FeatureSet2();
    const featuresSupported = new FeatureSet2();
    const supported = supportedFeatures ? new Set([...supportedFeatures].map((f) => f.toLowerCase())) : void 0;
    for (const feature of featureMap.children) {
      featuresAvailable.add(feature.name);
      if (supported?.has(feature.name.toLowerCase()) || feature.description && supported?.has(feature.description.toLowerCase())) {
        featuresSupported.add(feature.name);
      }
    }
    return {
      featuresAvailable,
      featuresSupported
    };
  }
  FeatureSet2.normalize = normalize;
})(FeatureSet || (FeatureSet = {}));
export {
  FeatureSet
};
//# sourceMappingURL=FeatureSet.js.map
