/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Bytes, camelize, NotImplementedError } from "@matter/general";
import { ElementTag, FieldValue, Metatype } from "../common/index.js";
import { Model } from "../models/Model.js";
import { FeatureMap } from "../standard/elements/FeatureMap.js";
function DefaultValue(scope, model, ifValid = false) {
  const value = castValue(model, model.default);
  if (value === void 0) {
    return buildValue(scope, model, ifValid);
  }
  return value;
}
function castValue(model, modelDefault) {
  if (modelDefault === void 0) {
    return;
  }
  if (modelDefault === null) {
    if (model.nullable) {
      return null;
    }
    return;
  }
  const metatype = model.effectiveMetatype;
  switch (metatype) {
    case void 0:
    case Metatype.any:
      return FieldValue.unwrap(modelDefault);
    case Metatype.integer:
    case Metatype.float:
      return FieldValue.numericValue(modelDefault, model.type);
    case Metatype.enum:
      let enumValueModel;
      if (typeof modelDefault === "number" || typeof modelDefault === "string") {
        enumValueModel = model.member(modelDefault);
      }
      if (enumValueModel) {
        return enumValueModel.effectiveId;
      }
      return;
    case Metatype.bitmap:
      if (typeof modelDefault === "number" || typeof modelDefault === "bigint") {
        return decodeBitmap(model, modelDefault);
      }
      return FieldValue.objectValue(modelDefault);
    case Metatype.object:
      return FieldValue.objectValue(modelDefault);
    case Metatype.string:
      return `${modelDefault}`;
    case Metatype.bytes:
      if (ArrayBuffer.isView(modelDefault)) {
        return new Uint8Array(modelDefault.buffer, modelDefault.byteOffset, modelDefault.byteLength);
      }
      if (typeof modelDefault === "string") {
        return Bytes.fromHex(modelDefault);
      }
      return;
    case Metatype.date:
      if (modelDefault instanceof Date) {
        return modelDefault;
      }
      if (typeof modelDefault === "number" || typeof modelDefault === "string") return new Date(modelDefault);
      return;
    case Metatype.array:
      if (Array.isArray(modelDefault)) {
        const entry = model.member("entry");
        if (entry?.isType) {
          return modelDefault.map((value) => castValue(entry, value));
        }
        return modelDefault;
      }
      return;
    case Metatype.boolean:
      return !!modelDefault;
    default:
      throw new NotImplementedError(`Unsupported metatype "${metatype}"`);
  }
}
function buildValue(scope, model, ifValid) {
  switch (model.effectiveMetatype) {
    case Metatype.array:
      if (!model.nullable && model.effectiveMetatype === Metatype.array && !model.constraint.min && !model.constraint.value) {
        return [];
      }
      return;
    case Metatype.object:
      return buildObject(scope, model, ifValid);
    case Metatype.bitmap:
      return buildBitmap(scope, model);
  }
}
function buildObject(scope, model, ifValid) {
  let result;
  for (const child of scope.membersOf(model, { conformance: "conformant" })) {
    const name = camelize(child.name);
    if (result && result[name] !== void 0) {
      continue;
    }
    const value = DefaultValue(scope, child);
    if (value !== void 0) {
      if (!result) {
        result = {};
      }
      result[name] = value;
      continue;
    }
    if (ifValid && !child.nullable) {
      return;
    }
  }
  return result;
}
function buildBitmap(scope, model) {
  let result;
  let fieldsDefined = 0;
  for (const m of scope.membersOf(model, { conformance: "conformant" })) {
    const defaultValue = FieldValue.numericValue(m.default);
    if (defaultValue === void 0) {
      continue;
    }
    if (result === void 0) {
      result = 0;
    }
    let minBit, maxBit;
    const constraintValue = FieldValue.numericValue(m.constraint.value);
    if (constraintValue !== void 0) {
      minBit = constraintValue;
      maxBit = constraintValue + 1;
    } else {
      minBit = FieldValue.numericValue(m.constraint.min);
      maxBit = FieldValue.numericValue(m.constraint.max);
    }
    if (minBit === void 0) {
      minBit = 0;
    }
    if (maxBit === void 0) {
      maxBit = Math.trunc(Math.log2(defaultValue)) + 1;
    }
    for (let i = 0, mask = 1 << minBit; i < maxBit - minBit; i++, mask <<= 1) {
      if (fieldsDefined & mask) {
        continue;
      }
      fieldsDefined |= mask;
      if (defaultValue & 1 << i) {
        result |= mask;
      }
    }
  }
  return result;
}
function decodeBitmap(model, value) {
  const fields = /* @__PURE__ */ new Map();
  if (value === 0) {
    return {};
  }
  for (let bit = 0; Math.pow(2, bit) <= value; bit++) {
    if (typeof value === "bigint") {
      if (!(value & 1n << BigInt(bit))) {
        continue;
      }
    } else if (!(value & 1 << bit)) {
      continue;
    }
    const definition = model.bitDefinition(bit);
    if (!definition) {
      continue;
    }
    const constraint = definition.effectiveConstraint;
    if (constraint.value !== void 0) {
      fields.set(definition, true);
    } else if (constraint.min !== void 0) {
      const fieldBit = 1 << bit - constraint.min;
      fields.set(definition, (fields.get(definition) ?? 0) | fieldBit);
    }
  }
  let nameGenerator;
  if (Model.types[ElementTag.Attribute] && model.id === FeatureMap.id) {
    nameGenerator = (model2) => model2.description === void 0 ? camelize(model2.name) : camelize(model2.description);
  } else {
    nameGenerator = (model2) => camelize(model2.name);
  }
  return Object.fromEntries([...fields.entries()].map(([k, v]) => [nameGenerator(k), v]));
}
export {
  DefaultValue
};
//# sourceMappingURL=DefaultValue.js.map
