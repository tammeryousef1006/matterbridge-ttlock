/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { MatterElement } from "../elements/index.js";
import { ModelTraversal } from "../logic/ModelTraversal.js";
import { AttributeModel } from "./AttributeModel.js";
import { ClusterModel } from "./ClusterModel.js";
import { DeviceTypeModel } from "./DeviceTypeModel.js";
import { FabricModel } from "./FabricModel.js";
import { FieldModel } from "./FieldModel.js";
import { Globals } from "./Globals.js";
import { ScopeModel } from "./ScopeModel.js";
import { SemanticNamespaceModel } from "./SemanticNamespaceModel.js";
class MatterModel extends ScopeModel {
  tag = MatterElement.Tag;
  get children() {
    return super.children;
  }
  set children(children) {
    super.children = children;
  }
  /**
   * The default instance of the canonical MatterModel (also exported directly simply as "Matter").
   */
  static standard = new MatterModel({
    name: "Matter",
    children: Object.values(Globals)
  });
  /**
   * Clusters.
   */
  get clusters() {
    return this.all(ClusterModel);
  }
  /**
   * Device types.
   */
  get deviceTypes() {
    return this.all(DeviceTypeModel);
  }
  /**
   * Semantic tag namespaces.
   */
  get semanticNamespaces() {
    return this.all(SemanticNamespaceModel);
  }
  /**
   * Global datatypes.
   */
  get datatypes() {
    return this.all(FieldModel);
  }
  /**
   * Global attributes.
   */
  get attributes() {
    return this.all(AttributeModel);
  }
  /**
   * Fabrics.
   */
  get fabrics() {
    return this.all(FabricModel);
  }
  /**
   * Create a new MatterModel.
   *
   * @param definition the MatterElement that defines the model
   */
  constructor(definition, ...children) {
    const name = definition.name ?? "Matter";
    const definitionChildren = [...definition.children || []];
    super({ ...definition, name, children: definitionChildren }, ...children);
  }
  /**
   * All sub-cluster global elements from this model.
   *
   * This is the set of utility datatypes required by cluster definitions.
   *
   * The returned elements are clones as we use this to initialize empty models for testing or diagnostic purposes.
   */
  get seedGlobals() {
    return this.children.filter((child) => child.isSeed).map((child) => child.clone());
  }
  static Tag = MatterElement.Tag;
}
MatterModel.register();
ModelTraversal.fallbackScope = MatterModel.standard;
export {
  MatterModel
};
//# sourceMappingURL=MatterModel.js.map
