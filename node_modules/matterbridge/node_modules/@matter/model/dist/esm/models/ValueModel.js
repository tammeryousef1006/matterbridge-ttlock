/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Access, Conformance, Constraint, Quality } from "../aspects/index.js";
import { ElementTag, Metatype } from "../common/index.js";
import { ModelTraversal } from "../logic/ModelTraversal.js";
import { Aspects } from "./Aspects.js";
import { Model } from "./Model.js";
import { Scope } from "#logic/Scope.js";
const CONSTRAINT = Symbol("constraint");
const CONFORMANCE = Symbol("conformance");
const ACCESS = Symbol("access");
const QUALITY = Symbol("quality");
class ValueModel extends Model {
  isType = true;
  get children() {
    return super.children;
  }
  set children(children) {
    super.children = children;
  }
  get constraint() {
    return Aspects.getAspect(this, CONSTRAINT, Constraint);
  }
  set constraint(definition) {
    Aspects.setAspect(this, CONSTRAINT, Constraint, definition);
  }
  get effectiveConstraint() {
    return new ModelTraversal().findConstraint(this, CONSTRAINT) || this.constraint;
  }
  get conformance() {
    return Aspects.getAspect(this, CONFORMANCE, Conformance);
  }
  set conformance(definition) {
    Aspects.setAspect(this, CONFORMANCE, Conformance, definition);
  }
  get effectiveConformance() {
    return Aspects.getEffectiveAspect(this, CONFORMANCE, Conformance);
  }
  get access() {
    return Aspects.getAspect(this, ACCESS, Access);
  }
  set access(definition) {
    Aspects.setAspect(this, ACCESS, Access, definition);
  }
  get effectiveAccess() {
    return new ModelTraversal().findAccess(this, ACCESS, ValueModel);
  }
  get quality() {
    return Aspects.getAspect(this, QUALITY, Quality);
  }
  set quality(definition) {
    Aspects.setAspect(this, QUALITY, Quality, definition);
  }
  get effectiveQuality() {
    return Aspects.getEffectiveAspect(this, QUALITY, Quality);
  }
  /**
   * Metatype is only present on global types with specific semantic meaning. This model is significant because it
   * gives us information about how to manipulate the data.  This accessor retrieves this model.
   */
  get metabase() {
    return new ModelTraversal().findMetabase(this);
  }
  /**
   * Get the primitive type for this value model.  This is an integer type for enums and bitmaps.  Otherwise it's the
   * metabase.
   */
  get primitiveBase() {
    const metabase = this.metabase;
    if (!metabase) {
      return;
    }
    if (metabase.metatype === Metatype.enum) {
      return metabase.base;
    }
    if (metabase.metatype === Metatype.bitmap) {
      const primitiveName = metabase.name.replace("map", "uint");
      return metabase.parent?.children.find((c) => c.name === primitiveName);
    }
    return metabase;
  }
  /**
   * The "effective type" may be inferred from context.
   */
  get effectiveType() {
    const type = super.effectiveType;
    if (type) {
      return type;
    }
    return new ModelTraversal().getTypeName(this);
  }
  /**
   * The working metatype for this object.
   */
  get effectiveMetatype() {
    const metaBase = this.metabase;
    if (metaBase) {
      return metaBase.metatype;
    }
  }
  /**
   * Get the first derived ancestor with children, if any.
   */
  get definingModel() {
    return new ModelTraversal().findDefiningModel(this);
  }
  /**
   * Get the entry type for lists, if any.
   */
  get listEntry() {
    return this.member("entry", [ElementTag.Field]);
  }
  /**
   * ValueModels may only derive from ValueModels.
   */
  get base() {
    return super.base;
  }
  /**
   * ValueModels may derive from models of the same type or from generic Datatype models.
   */
  get allowedBaseTags() {
    if (this.tag === ElementTag.Field) {
      return [ElementTag.Field, ElementTag.Datatype, ElementTag.Attribute];
    }
    return [this.tag, ElementTag.Datatype];
  }
  /**
   * All {@link FieldModel} children in the context of the model's containing scope.
   */
  get members() {
    return Scope(this).membersOf(this);
  }
  /**
   * Collect constraints and conformance for this type and all base types.
   */
  get validationAspects() {
    const aspects = Array();
    new ModelTraversal().visitInheritance(this, (model) => {
      if (model instanceof ValueModel) {
        if (!model.conformance.empty && model.conformance.type !== Conformance.Special.Desc) {
          aspects.push(model.conformance);
        }
        if (!model.constraint.empty && !model.constraint.desc) {
          aspects.push(model.constraint);
        }
        if (model.quality.nullable === false) {
          aspects.push(model.quality);
        }
      }
    });
    return aspects;
  }
  /**
   * Is this model deprecated?
   */
  get isDeprecated() {
    return this.effectiveConformance.type === Conformance.Flag.Deprecated;
  }
  /**
   * Is this model disallowed?
   */
  get isDisallowed() {
    return this.effectiveConformance.type === Conformance.Flag.Disallowed;
  }
  /**
   * Can this model be omitted?
   */
  get nullable() {
    return !!this.effectiveQuality.nullable;
  }
  /**
   * Is the model mandatory?
   */
  get mandatory() {
    return this.effectiveConformance.isMandatory;
  }
  /**
   * Determine whether this element overrides key properties of its shadow.
   */
  get overridesShadow() {
    const shadow = this.shadow;
    if (!shadow || !(shadow instanceof ValueModel)) {
      return;
    }
    if (this.type && this.type !== shadow.type) {
      return true;
    }
    if (!this.conformance.empty && !this.conformance.equals(shadow.conformance)) {
      return true;
    }
    if (!this.quality.empty && !this.quality.equals(shadow.quality)) {
      return true;
    }
    if (!this.constraint.empty && !this.constraint.equals(shadow.constraint)) {
      return true;
    }
    if (!this.access.empty && !this.access.equals(shadow.access)) {
      return true;
    }
  }
  /**
   * Search the inheritance chain for a bitmap field defining a specific bit.
   */
  bitDefinition(bit) {
    return new ModelTraversal().findBitDefinition(this, bit);
  }
  /**
   * Clone the model with minimum metadata required to ensure model is valid.
   */
  cloneAsReference() {
    const Type = this.constructor;
    return new Type(this.requiredFields);
  }
  get requiredFields() {
    return { name: this.name };
  }
  valueOf() {
    const result = super.valueOf();
    for (const k of ["conformance", "access", "quality", "constraint"]) {
      const v = this[k];
      if (v && !v.empty) {
        result[k] = v.valueOf();
      }
    }
    if (result.default === void 0) {
      delete result.default;
    }
    return result;
  }
  constructor(definition, ...children) {
    super(definition, ...children);
    const match = this.type?.match(/^list\[(.*)\]$/);
    if (match) {
      this.type = "list";
      this.children.push(new Model.types.field({ name: "entry", type: match[1] }));
    }
    if (definition instanceof Model) {
      Aspects.cloneAspects(definition, this, CONSTRAINT, CONFORMANCE, ACCESS, QUALITY);
    }
  }
}
export {
  ValueModel
};
//# sourceMappingURL=ValueModel.js.map
