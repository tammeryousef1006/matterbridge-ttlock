/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { MatterDefinition } from "../MatterDefinition.js";
import { DatatypeElement as Datatype } from "../../elements/index.js";
const list = Datatype({
  name: "list",
  description: "List",
  isSeed: true,
  metatype: "array",
  details: 'A list is defined as a collection of entries of the same data type, with a finite count from 0 to 65534. A cluster specification may define further constraints on the maximum possible count. The list entry data type shall be any defined data type, except a list data type, or any data type derived from a list.\nThe quality columns for a list definition are for the list.\nThe list entries are indicated with an index that is an unsigned integer starting at 0 (zero). The maintained order of entries, by index, is defined in the cluster specification, or undefined. Data that is defined as a list is indicated with "list[X]" where X is the entry type. The data type of the list entry has its own qualities, constraints, and conformance.\n### To define qualities for the list entry data type, make the list entry data type a defined local derived data type, with a table including the columns required to define and constrain the data type.\nThere is an inline shortcut to define the list entry data type constraints. See List Constraints.\nIt is recommended to put a maximum constraint on the list and list entry data types.\nIt is recommended that a list entry data type be a struct, to enable the addition of new fields to the list\u2019s entries in the future.\n  \u2022 The cluster data version shall be incremented when the list order or entries change.\n  \u2022 An entry shall NOT be null.\n  \u2022 The list shall support reading and reporting all entries.\n  \u2022 The list shall support reporting, updates, and/or deletion of one or more entries.\n  \u2022 If the list is writable, it shall support writing or deleting the entire list.\n  \u2022 If the list is writable, it shall support updating one or more individual entries by indicating     an index per updated entry.\n  \u2022 If the list is writable, it shall support deleting one or more individual entries by indicating     an index per deleted entry.\n  \u2022 If the list is writable, it shall support adding one or more individual entries.\n  \u2022 A list may define an entry that is a struct that is fabric-scoped (see Fabric-Scoped Quality).\n### Fabric-Scoped List\n  \u2022 A fabric-scoped list shall define an entry data type that is a struct, which shall also be     fabric-scoped (see Fabric-Scoped Struct).\nEach entry in a fabric-scoped list shall be fabric-scoped to a particular fabric or no fabric.\n### Fabric-Filtered List\nA fabric-scoped list supports a fabric-filter that filters the view of the list for read and write interactions. This filter simplifies client side logic that does not want to read or write fabric data that is not associated with the accessing fabric.\n  \u2022 An interaction upon a list with fabric-filtering shall only indicate and access entries where     the associated fabric matches the accessing fabric, and all other entries shall be ignored.\n  \u2022 Fabric-filtered list entries shall be in the same order as the full list.\n  \u2022 Fabric-filtered list entries shall be indexed from 0 with no gaps, as if the other entries did     not exist.\n  \u2022 For a write interaction, fabric-filtering shall be enabled.\n  \u2022 When writing to a fabric-scoped list, the write interaction shall be on an accessing fabric,     otherwise, the write interaction shall fail (see Interaction Model).\n  \u2022 For a read interaction on a list, fabric-filtering may be enabled.\n  \u2022 For a read interaction on a list, with fabric-filtering disabled, the list shall be reported as     a full list with all entries.',
  xref: { document: "core", section: "7.19.1.8" }
});
MatterDefinition.children.push(list);
export {
  list
};
//# sourceMappingURL=list.js.map
