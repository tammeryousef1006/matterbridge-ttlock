/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */

/*** THIS FILE IS GENERATED, DO NOT EDIT ***/

import { MatterDefinition } from "../MatterDefinition.js";
import {
    ClusterElement as Cluster,
    AttributeElement as Attribute,
    EventElement as Event,
    FieldElement as Field,
    CommandElement as Command,
    DatatypeElement as Datatype
} from "../../elements/index.js";

export const CommissionerControl = Cluster(
    {
        name: "CommissionerControl", id: 0x751, classification: "node", pics: "CCTRL",

        details: "The Commissioner Control Cluster supports the ability for clients to request the commissioning of " +
            "themselves or other nodes onto a fabric which the cluster server can commission onto. An example use " +
            "case is ecosystem to ecosystem Fabric Synchronization setup." +
            "\n" +
            "The generalized flow supported by the Commissioner Control Cluster can be seen in the following " +
            "diagram." +
            "\n" +
            "Figure 103. Commissioner Control Cluster - General Flow",

        xref: { document: "core", section: "11.26" }
    },

    Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

    Attribute({
        name: "SupportedDeviceCategories", id: 0x0, type: "SupportedDeviceCategoryBitmap", access: "R M",
        conformance: "M", default: 0,
        details: "Indicates the device categories specified in SupportedDeviceCategoryBitmap that are supported by " +
            "this Commissioner Control Cluster server." +
            "\n" +
            "A client shall NOT send the RequestCommissioningApproval command if the intended node to be " +
            "commissioned does not conform to any of the values specified in SupportedDeviceCategories.",
        xref: { document: "core", section: "11.26.5.1" }
    }),

    Event(
        {
            name: "CommissioningRequestResult", id: 0x0, access: "S M", conformance: "M", priority: "info",

            details: "This event shall be generated by the server following a RequestCommissioningApproval command which " +
                "the server responded to with SUCCESS." +
                "\n" +
                "NOTE" +
                "\n" +
                "The approval is valid for a period determined by the manufacturer and characteristics of the node " +
                "presenting the Commissioner Control Cluster. Clients SHOULD send the CommissionNode command " +
                "immediately upon receiving a CommissioningRequestResult event." +
                "\n" +
                "11.26.7.2. RequestID / ClientNodeID Fields" +
                "\n" +
                "The RequestID shall match the RequestID provided to RequestCommissioningApproval and the " +
                "ClientNodeID shall match the NodeID of the client which generated the RequestCommissioningAp" +
                "\n" +
                "proval command.",

            xref: { document: "core", section: "11.26.7.1" }
        },

        Field({ name: "RequestId", id: 0x0, type: "uint64", access: "S", conformance: "M" }),
        Field({ name: "ClientNodeId", id: 0x1, type: "node-id", access: "S", conformance: "M" }),
        Field({ name: "StatusCode", id: 0x2, type: "status", access: "S", conformance: "M", constraint: "desc" }),
        Field({ name: "FabricIndex", id: 0xfe, type: "FabricIndex" })
    ),

    Command(
        {
            name: "RequestCommissioningApproval", id: 0x0, access: "M", conformance: "M", direction: "request",
            response: "status",

            details: "This command is sent by a client to request approval for a future CommissionNode call. This is " +
                "required to be a separate step in order to provide the server time for interacting with a user " +
                "before informing the client that the CommissionNode operation may be successful." +
                "\n" +
                "If the command is not executed via a CASE session, the command shall fail with a status code of " +
                "UNSUPPORTED_ACCESS." +
                "\n" +
                "The server may request approval from the user, but it is not required." +
                "\n" +
                "The server shall always return SUCCESS to a correctly formatted RequestCommissioningApproval " +
                "command, and then generate a CommissioningRequestResult event associated with the commandâ€™s" +
                "\n" +
                "accessing fabric once the result is ready." +
                "\n" +
                "Clients SHOULD avoid using the same RequestID. If the RequestID and client NodeID of a " +
                "RequestCommissioningApproval match a previously received RequestCommissioningApproval and the server " +
                "has not returned an error or completed commissioning of a device for the prior request, then the " +
                "server SHOULD return FAILURE." +
                "\n" +
                "The parameters for RequestCommissioningApproval command are as follows:",

            xref: { document: "core", section: "11.26.6.1" }
        },

        Field({ name: "RequestId", id: 0x0, type: "uint64", conformance: "M" }),
        Field({ name: "VendorId", id: 0x1, type: "vendor-id", conformance: "M" }),
        Field({ name: "ProductId", id: 0x2, type: "uint16", conformance: "M" }),
        Field({ name: "Label", id: 0x3, type: "string", conformance: "O", constraint: "max 64" })
    ),

    Command(
        {
            name: "CommissionNode", id: 0x1, access: "M", conformance: "M", direction: "request",
            response: "ReverseOpenCommissioningWindow",

            details: "This command is sent by a client to request that the server begins commissioning a previously " +
                "approved request." +
                "\n" +
                "The server shall return FAILURE if the CommissionNode command is not sent from the same NodeID and " +
                "on the same fabric as the RequestCommissioningApproval or if the provided RequestID to " +
                "CommissionNode does not match the value provided to RequestCommissioningApproval." +
                "\n" +
                "If the command is not executed via a CASE session, the command shall fail with a status code of" +
                "\n" +
                "UNSUPPORTED_ACCESS." +
                "\n" +
                "Upon receipt, the server shall respond with ReverseOpenCommissioningWindow if " +
                "CommissioningRequestResult was generated with StatusCode of SUCCESS for the matching RequestID field " +
                "and NodeID of the client." +
                "\n" +
                "The server shall return FAILURE if the CommissionNode command is received after the server has " +
                "already responded to a client with ReverseOpenCommissioningWindow for a matching RequestID field and " +
                "NodeID of the client unless the client has sent another RequestCommissioningApproval and received an " +
                "additional CommissioningRequestResult." +
                "\n" +
                "The parameters for CommissionNode command are as follows:",

            xref: { document: "core", section: "11.26.6.5" }
        },

        Field({ name: "RequestId", id: 0x0, type: "uint64", conformance: "M" }),
        Field({
            name: "ResponseTimeoutSeconds", id: 0x1, type: "uint16", conformance: "M", constraint: "30 to 120",
            default: 30
        })
    ),

    Command(
        {
            name: "ReverseOpenCommissioningWindow", id: 0x2, conformance: "M", direction: "response",

            details: "When received within the timeout specified by ResponseTimeoutSeconds in the CommissionNode command, " +
                "the client shall open a commissioning window on a node which matches the VendorID and ProductID " +
                "provided in the associated RequestCommissioningApproval command." +
                "\n" +
                "When commissioning this node, the server shall check that the VendorID and ProductID fields provided " +
                "in the RequestCommissioningApproval command match the VendorID and ProductID attributes of the Basic " +
                "Information Cluster which have already been verified during the Device Attestation Procedure. If " +
                "they do not match, the server shall NOT complete commissioning and SHOULD indicate an error to the " +
                "user." +
                "\n" +
                "NOTE" +
                "\n" +
                "This is an alias onto the Open Commissioning Window command within the Administrator Commissioning " +
                "Cluster. Refer to the Open Commissioning Window command for a description of the command behavior " +
                "and parameters." +
                "\n" +
                "The parameters for ReverseOpenCommissioningWindow command are as follows:",

            xref: { document: "core", section: "11.26.6.8" }
        },

        Field({ name: "CommissioningTimeout", id: 0x0, type: "uint16", conformance: "M", constraint: "desc" }),
        Field({ name: "PakePasscodeVerifier", id: 0x1, type: "octstr", conformance: "M" }),
        Field({ name: "Discriminator", id: 0x2, type: "uint16", conformance: "M", constraint: "max 4095" }),
        Field({ name: "Iterations", id: 0x3, type: "uint32", conformance: "M", constraint: "1000 to 100000" }),
        Field({ name: "Salt", id: 0x4, type: "octstr", conformance: "M", constraint: "16 to 32" })
    ),

    Datatype(
        { name: "SupportedDeviceCategoryBitmap", type: "map32", xref: { document: "core", section: "11.26.4.1" } },

        Field({
            name: "FabricSynchronization", constraint: "0",
            description: "Aggregators which support Fabric Synchronization may be commissioned.",
            details: "The FabricSynchronization bit shall be set to 1 if and only if the server supports commissioning " +
                "nodes that support Fabric Synchronization.",
            xref: { document: "core", section: "11.26.4.1.1" }
        })
    )
);

MatterDefinition.children.push(CommissionerControl);
