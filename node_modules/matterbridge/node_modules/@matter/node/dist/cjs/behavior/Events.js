"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __using = (stack, value, async) => {
  if (value != null) {
    if (typeof value !== "object" && typeof value !== "function") __typeError("Object expected");
    var dispose, inner;
    if (async) dispose = value[__knownSymbol("asyncDispose")];
    if (dispose === void 0) {
      dispose = value[__knownSymbol("dispose")];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") __typeError("Object not disposable");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    stack.push([async, dispose, value]);
  } else if (async) {
    stack.push([async]);
  }
  return value;
};
var __callDispose = (stack, error, hasError) => {
  var E = typeof SuppressedError === "function" ? SuppressedError : function(e, s, m, _) {
    return _ = Error(m), _.name = "SuppressedError", _.error = e, _.suppressed = s, _;
  };
  var fail = (e) => error = hasError ? new E(e, error, "An error was suppressed during disposal") : (hasError = true, e);
  var next = (it) => {
    while (it = stack.pop()) {
      try {
        var result = it[1] && it[1].call(it[2]);
        if (it[0]) return Promise.resolve(result).then(next, (e) => (fail(e), next()));
      } catch (e) {
        fail(e);
      }
    }
    if (hasError) throw error;
  };
  return next();
};
var Events_exports = {};
__export(Events_exports, {
  ElementEvent: () => ElementEvent,
  Events: () => Events,
  OfflineEvent: () => OfflineEvent,
  OnlineEvent: () => OnlineEvent,
  QuietEvent: () => QuietEvent
});
module.exports = __toCommonJS(Events_exports);
var import_general = require("#general");
var import_model = require("#model");
var import_NodeActivity = require("./context/NodeActivity.js");
/**
 * @license
 * Copyright 2022-2025 Project CHIP Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("Logger");
class Events extends import_general.EventEmitter {
  #endpoint;
  #behavior;
  setContext(endpoint, behavior) {
    this.#endpoint = endpoint;
    this.#behavior = behavior;
  }
  /**
   * Emitted when state associated with this behavior is first mutated by a specific interaction.
   */
  interactionBegin = (0, import_general.Observable)();
  /**
   * Emitted when a mutating interaction completes.
   */
  interactionEnd = (0, import_general.AsyncObservable)();
  get endpoint() {
    return this.#endpoint;
  }
  get behavior() {
    return this.#behavior;
  }
  toString() {
    return `${this.#endpoint ?? "?"}.${this.#behavior?.id ?? "?"}.events`;
  }
}
class ElementEvent extends import_general.BasicObservable {
  #schema;
  #owner;
  constructor(schema, owner, errorHandler, promiseHandler) {
    super(errorHandler, promiseHandler);
    this.#schema = schema;
    this.#owner = owner;
  }
  /**
   * The element that triggers this event.
   */
  get schema() {
    return this.#schema;
  }
  get owner() {
    return this.#owner;
  }
}
class OfflineEvent extends ElementEvent {
  constructor(schema, owner) {
    super(
      schema,
      owner,
      void 0,
      async (promise, observer) => {
        var _stack = [];
        try {
          const _actor = __using(_stack, this.owner.endpoint?.env.get(import_NodeActivity.NodeActivity).begin(descriptionOf(this, observer)));
          await promise;
        } catch (_) {
          var _error = _, _hasError = true;
        } finally {
          __callDispose(_stack, _error, _hasError);
        }
      }
    );
  }
}
class OnlineEvent extends ElementEvent {
  isQuieter = false;
  constructor(schema, owner) {
    super(
      schema,
      owner,
      (error, observer) => {
        logger.error(`Error in ${descriptionOf(this, observer)}`, error);
      },
      async (promise, observer) => {
        var _stack = [];
        try {
          const _actor = __using(_stack, this.owner.endpoint?.env.get(import_NodeActivity.NodeActivity).begin(descriptionOf(this, observer)));
          try {
            await promise;
          } catch (e) {
            this.handleError((0, import_general.asError)(e), observer);
          }
        } catch (_) {
          var _error = _, _hasError = true;
        } finally {
          __callDispose(_stack, _error, _hasError);
        }
      }
    );
  }
  /**
   * An {@link Observable} that emits only those events conveyed between nodes.
   *
   * Normally this is the {@link OnlineEvent}, but in the case of server-side elements that are
   * {@link Quality.quieter} this is {@link quiet}.
   */
  get online() {
    return this;
  }
  /**
   * A quieter version of the {@link OnlineEvent}.
   *
   * Throws if the node is not a server or the associated element is not {@link Quality.quieter}.
   *
   * By default emits latest changes once per second but you can reconfigure via {@link QuietObservable} properties
   * and/or trigger emits using {@link QuietObservable.emitNow} and {@link QuietObservable.emitSoon}.
   */
  get quiet() {
    throw new import_general.ImplementationError(`Matter does not define ${this} with "quieter" (Q) quality`);
  }
  toString() {
    const base = `${this.owner.toString()}.${(0, import_general.camelize)(this.schema.name)}`;
    if (this.schema.tag === import_model.ElementTag.Attribute || this.schema.tag === import_model.ElementTag.Field) {
      return `${base}$Changed`;
    }
    return base;
  }
}
class QuietEvent extends OnlineEvent {
  isQuieter = true;
  #quiet;
  constructor(schema, owner, config) {
    super(schema, owner);
    this.#quiet = new import_general.QuietObservable({
      shouldEmit(...args) {
        const [oldValue, newValue] = args;
        return oldValue === null || newValue === null && oldValue !== newValue ? "now" : true;
      },
      ...config,
      source: this
    });
  }
  get online() {
    return this.#quiet;
  }
  get quiet() {
    return this.#quiet;
  }
  [Symbol.dispose]() {
    this.#quiet[Symbol.dispose]();
    super[Symbol.dispose]();
  }
}
function descriptionOf(observable, observer) {
  let desc = `${observable} observer`;
  if (observer.name) {
    desc = `${desc} ${observer.name}`;
  }
  return desc;
}
//# sourceMappingURL=Events.js.map
