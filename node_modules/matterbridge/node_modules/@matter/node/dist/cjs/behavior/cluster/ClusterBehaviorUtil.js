"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ClusterBehaviorUtil_exports = {};
__export(ClusterBehaviorUtil_exports, {
  createType: () => createType,
  introspectionInstanceOf: () => introspectionInstanceOf
});
module.exports = __toCommonJS(ClusterBehaviorUtil_exports);
var import_Events = require("#behavior/Events.js");
var import_general = require("#general");
var import_model = require("#model");
var import_Behavior = require("../Behavior.js");
var import_StateType = require("../state/StateType.js");
var import_ClusterBehaviorCache = require("./ClusterBehaviorCache.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const KNOWN_DEFAULTS = Symbol("knownDefaults");
function introspectionInstanceOf(type) {
  return new type();
}
function createType(cluster, base, schema) {
  if (schema === void 0) {
    if (base.schema) {
      schema = base.schema;
    }
    if (!schema) {
      schema = schemaForCluster(cluster);
    }
  }
  schema = syncFeatures(schema, cluster);
  const cached = import_ClusterBehaviorCache.ClusterBehaviorCache.get(cluster, base, schema);
  if (cached) {
    return cached;
  }
  let name;
  if (base.name.startsWith(cluster.name)) {
    name = base.name;
  } else {
    name = `${cluster.name}Behavior`;
  }
  schema.freeze();
  const newProps = {};
  const scope = (0, import_model.Scope)(schema);
  const type = (0, import_general.GeneratedClass)({
    name,
    base,
    // These are really read-only but installing as getters on the prototype prevents us from overriding using
    // namespace overrides.  If we instead override as static properties then we lose the automatic interface type.
    // So just publish as static properties.
    staticProperties: {
      State: createDerivedState(cluster, scope, base, newProps),
      Events: createDerivedEvents(cluster, scope, base, newProps)
    },
    staticDescriptors: {
      id: {
        value: (0, import_general.camelize)(cluster.name),
        enumerable: true
      },
      cluster: {
        value: cluster,
        enumerable: true
      },
      schema: {
        value: schema
      }
    },
    instanceDescriptors: createDefaultCommandDescriptors(cluster, base)
  });
  import_ClusterBehaviorCache.ClusterBehaviorCache.set(cluster, base, schema, type);
  return type;
}
function createDerivedState(cluster, scope, base, newProps) {
  const BaseState = base["State"];
  if (BaseState === void 0) {
    throw new import_general.ImplementationError(`No state class defined for behavior class ${base.name}`);
  }
  const oldDefaults = new BaseState();
  let knownDefaults = BaseState[KNOWN_DEFAULTS];
  let featuresAvailable, featuresSupported;
  if (scope.owner instanceof import_model.ClusterModel) {
    const normalized = import_model.FeatureSet.normalize(scope.owner.featureMap, scope.owner.supportedFeatures);
    featuresAvailable = normalized.featuresAvailable;
    featuresSupported = normalized.featuresSupported;
  } else {
    featuresAvailable = new import_model.FeatureSet();
    featuresSupported = new import_model.FeatureSet();
  }
  const props = {};
  for (const member of scope.membersOf(scope.owner, { conformance: "deconflicted" })) {
    const name = (0, import_general.camelize)(member.name);
    if (props[name]) {
      props[name].push(member);
    } else {
      props[name] = [member];
    }
  }
  const defaults = {};
  for (const name in props) {
    const attrs = props[name];
    let propSchema;
    let isConditional = false;
    for (const attr of attrs) {
      const applicability = attr.effectiveConformance.applicabilityOf(featuresAvailable, featuresSupported);
      if (!applicability) {
        continue;
      }
      if (applicability === import_model.Conformance.Applicability.Conditional) {
        isConditional = true;
      }
      propSchema = attr;
      break;
    }
    if (propSchema === void 0) {
      if (isConditional) {
        return;
      }
      if (oldDefaults[name] !== void 0) {
        if (!knownDefaults) {
          knownDefaults = {};
        } else if (knownDefaults === BaseState[KNOWN_DEFAULTS]) {
          knownDefaults = { ...knownDefaults };
        }
        knownDefaults[name] = oldDefaults[name];
        defaults[name] = void 0;
      }
      continue;
    }
    newProps[name] = propSchema;
    const attribute = cluster.attributes[name];
    if (attribute?.id === import_model.FeatureMap.id) {
      defaults[name] = cluster.supportedFeatures;
      continue;
    }
    defaults[name] = selectDefaultValue(
      scope,
      oldDefaults[name] === void 0 ? knownDefaults?.[name] : oldDefaults[name],
      attribute,
      propSchema
    );
  }
  const StateType = (0, import_StateType.DerivedState)({
    name: `${cluster.name}$State`,
    base: base.State,
    values: defaults
  });
  if (knownDefaults) {
    StateType[KNOWN_DEFAULTS] = knownDefaults;
  }
  return StateType;
}
function createDerivedEvents(cluster, scope, base, newProps) {
  const instanceDescriptors = {};
  const baseInstance = new base.Events();
  const eventNames = /* @__PURE__ */ new Set();
  const applicableClusterEvents = /* @__PURE__ */ new Set();
  for (const event of scope.membersOf(scope.owner, {
    conformance: "conformant",
    tags: [import_model.ElementTag.Event]
  })) {
    const name = (0, import_general.camelize)(event.name);
    applicableClusterEvents.add(name);
    if (!cluster.events[name]?.optional && baseInstance[name] === void 0) {
      eventNames.add(name);
      instanceDescriptors[name] = createEventDescriptor(
        name,
        event,
        event.quality.quieter ? import_Events.QuietEvent : import_Events.OnlineEvent
      );
    }
  }
  for (const attrName in newProps) {
    const changing = `${attrName}$Changing`;
    const prop = newProps[attrName];
    if (baseInstance[changing] === void 0) {
      eventNames.add(changing);
      instanceDescriptors[changing] = createEventDescriptor(changing, prop, import_Events.OfflineEvent);
    }
    const changed = `${attrName}$Changed`;
    if (baseInstance[changed] === void 0) {
      eventNames.add(changed);
      instanceDescriptors[changed] = createEventDescriptor(
        changed,
        prop,
        prop.quality.quieter ? import_Events.QuietEvent : import_Events.OnlineEvent
      );
    }
  }
  return (0, import_general.GeneratedClass)({
    name: `${cluster.name}$Events`,
    base: base.Events,
    instanceDescriptors,
    initialize() {
      this.interactionBegin = new import_general.AsyncObservable();
      this.interactionEnd = new import_general.AsyncObservable();
      for (const name of eventNames) {
        this.addEvent(name);
      }
    }
  });
}
function schemaForCluster(cluster) {
  let schema;
  for (const child of import_model.Matter.children) {
    if (child.tag === import_model.ElementTag.Cluster && child.id === cluster.id) {
      schema = child;
      break;
    }
  }
  if (schema === void 0) {
    throw new import_general.ImplementationError(`Cannot locate schema for cluster ${cluster.id}, please supply manually`);
  }
  return schema;
}
const configuredSchemaCache = /* @__PURE__ */ new Map();
function syncFeatures(schema, cluster) {
  if (!(schema instanceof import_model.ClusterModel)) {
    return schema;
  }
  const incomingFeatures = new import_model.FeatureSet(cluster.supportedFeatures);
  if (new import_model.FeatureSet(cluster.supportedFeatures).is(schema.supportedFeatures)) {
    return schema;
  }
  const featureKey = [...incomingFeatures].sort().join(",");
  let schemaBucket = configuredSchemaCache.get(schema);
  if (schemaBucket === void 0) {
    schemaBucket = {};
    configuredSchemaCache.set(schema, schemaBucket);
  } else {
    if (featureKey in schemaBucket) {
      return schemaBucket[featureKey];
    }
  }
  schema = schema.clone();
  schema.supportedFeatures = incomingFeatures;
  schemaBucket[featureKey] = schema;
  return schema;
}
function createDefaultCommandDescriptors(cluster, base) {
  const result = {};
  const instance = introspectionInstanceOf(base);
  for (const name in cluster.commands) {
    if (!instance[name]) {
      result[name] = {
        value: import_Behavior.Behavior.unimplemented,
        writable: true
      };
    }
  }
  return result;
}
function selectDefaultValue(scope, oldDefault, clusterAttr, schemaProp) {
  if (oldDefault !== void 0) {
    return oldDefault;
  }
  if (clusterAttr?.optional) {
    return;
  }
  if (clusterAttr?.default !== void 0) {
    return clusterAttr.default;
  }
  if (!schemaProp) {
    return;
  }
  if (schemaProp.nullable) {
    return null;
  }
  const effectiveDefault = (0, import_model.DefaultValue)(scope, schemaProp);
  if (effectiveDefault) {
    return effectiveDefault;
  }
  const conformance = schemaProp.effectiveConformance;
  if (!conformance.isMandatory) {
    return;
  }
  switch (schemaProp.effectiveMetatype) {
    case import_model.Metatype.bitmap:
    case import_model.Metatype.object:
      return {};
    case import_model.Metatype.array:
      return [];
  }
}
function createEventDescriptor(name, schema, constructor) {
  return {
    get() {
      if (this.hasEvent(name, true)) {
        return this.getEvent(name);
      }
      const event = new constructor(schema, this);
      this.addEvent(name, event);
      return event;
    },
    enumerable: true
  };
}
//# sourceMappingURL=ClusterBehaviorUtil.js.map
