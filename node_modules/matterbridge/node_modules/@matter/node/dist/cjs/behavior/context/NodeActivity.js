"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var NodeActivity_exports = {};
__export(NodeActivity_exports, {
  NodeActivity: () => NodeActivity
});
module.exports = __toCommonJS(NodeActivity_exports);
var import_general = require("#general");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
class NodeActivity {
  #actors = /* @__PURE__ */ new Set();
  #active = (0, import_general.Observable)();
  #inactive = (0, import_general.Observable)();
  get isActive() {
    return this.#actors.size !== 0;
  }
  get active() {
    return this.#active;
  }
  get inactive() {
    return this.#inactive;
  }
  get actors() {
    return [...this.#actors.values()];
  }
  begin(description, onClose) {
    const elapsed = import_general.Diagnostic.elapsed();
    const actor = {
      stack: [description],
      get elapsed() {
        return elapsed;
      },
      get [import_general.Diagnostic.value]() {
        const result = Array();
        for (const frame of this.stack) {
          if (result.length) {
            result.push("\u25B8");
          }
          result.push(frame);
        }
        return result;
      },
      frame(description2) {
        this.stack.push(description2);
        return {
          [Symbol.dispose]: () => {
            this.stack.pop();
          }
        };
      },
      close: () => {
        onClose?.();
        this.#actors.delete(actor);
        if (!this.#actors.size) {
          this.#inactive.emit();
        }
      },
      [Symbol.dispose]: () => {
        actor.close();
      }
    };
    this.#actors.add(actor);
    if (this.#actors.size === 1) {
      this.#active.emit();
    }
    return actor;
  }
  get [import_general.Diagnostic.value]() {
    if (!this.#actors.size) {
      return import_general.Diagnostic.list([import_general.Diagnostic.weak("none")]);
    }
    return import_general.Diagnostic.list(this.actors);
  }
}
//# sourceMappingURL=NodeActivity.js.map
