"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var OfflineContext_exports = {};
__export(OfflineContext_exports, {
  OfflineContext: () => OfflineContext,
  nextInternalId: () => nextInternalId
});
module.exports = __toCommonJS(OfflineContext_exports);
var import_general = require("#general");
var import_model = require("#model");
var import_protocol = require("#protocol");
var import_Contextual = require("../Contextual.js");
var import_ContextAgents = require("./ContextAgents.js");
/**
 * @license
 * Copyright 2022-2025 Project CHIP Authors
 * SPDX-License-Identifier: Apache-2.0
 */
let nextInternalId = 1;
const OfflineContext = {
  /**
   * Operate in offline context.  Interactions with private Matter.js APIs happen in an offline context.
   *
   * {@link act} provides an {@link ActionContext} you can use to access agents for a {@link Endpoint}.
   * State changes and change events occur once {@link actor} returns.
   * It can return a promise even if the actor method does not return a promise, so manual checks are needed.
   *
   * The {@link Transaction} is destroyed with {@link act} exits so you should not keep a reference to any agents
   * beyond the lifespan of {@link actor}.
   *
   * Offline context is very permissive.  You should use carefully.
   */
  act(purpose, activity, actor, options) {
    const id = nextInternalId;
    nextInternalId = (nextInternalId + 1) % 65535;
    const via = import_general.Diagnostic.via(`${purpose}#${id.toString(16)}`);
    let context;
    let frame;
    const actOffline = (transaction) => {
      context = createOfflineContext(transaction, frame, options);
      return actor(context);
    };
    let isAsync = false;
    try {
      frame = activity?.begin(via);
      const result = import_general.Transaction.act(via, actOffline);
      if (import_general.MaybePromise.is(result)) {
        isAsync = true;
        return Promise.resolve(result).finally(() => {
          frame?.[Symbol.dispose]();
        });
      }
      return result;
    } finally {
      if (!isAsync) {
        frame?.[Symbol.dispose]();
      }
    }
  },
  /**
   * Normally you need to use {@link OfflineContext.act} to work with behaviors, and you can only interact with the
   * behaviors in the actor function.  This {@link ActionContext} allows you to create offline agents that remain
   * functional for the lifespan of the node.
   *
   * Write operations will throw an error with this context.
   */
  ReadOnly: createOfflineContext(import_general.Transaction.ReadOnly),
  [Symbol.toStringTag]: "OfflineContext"
};
function createOfflineContext(transaction, activity, options) {
  let agents;
  const context = Object.freeze({
    ...options,
    // Disable access level enforcement
    offline: true,
    transaction,
    activity,
    authorityAt(desiredAccessLevel) {
      return desiredAccessLevel === import_model.AccessLevel.View ? import_protocol.AccessControl.Authority.Granted : import_protocol.AccessControl.Authority.Unauthorized;
    },
    agentFor(endpoint) {
      if (!agents) {
        agents = (0, import_ContextAgents.ContextAgents)(context);
      }
      return agents?.agentFor(endpoint);
    },
    get [import_Contextual.Contextual.context]() {
      return this;
    },
    [Symbol.toStringTag]: "OfflineContext"
  });
  return context;
}
//# sourceMappingURL=OfflineContext.js.map
