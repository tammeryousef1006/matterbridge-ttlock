"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var OnlineContext_exports = {};
__export(OnlineContext_exports, {
  OnlineContext: () => OnlineContext
});
module.exports = __toCommonJS(OnlineContext_exports);
var import_access_control = require("#behaviors/access-control");
var import_general = require("#general");
var import_protocol = require("#protocol");
var import_Contextual = require("../Contextual.js");
var import_ContextAgents = require("./ContextAgents.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
function OnlineContext(options) {
  let fabric;
  let subject;
  let nodeProtocol;
  let accessLevelCache;
  const { exchange } = options;
  const session = exchange?.session;
  if (session) {
    (0, import_protocol.assertSecureSession)(session);
    fabric = session.fabric?.fabricIndex;
    subject = session.peerNodeId;
  } else {
    fabric = options.fabric;
    subject = options.subject;
  }
  if (subject === void 0) {
    throw new import_general.ImplementationError("OnlineContext requires an authorized subject");
  }
  const { message } = options;
  const via = import_general.Diagnostic.via(
    `online#${message?.packetHeader?.messageId?.toString(16) ?? "?"}@${subject.toString(16)}`
  );
  return {
    /**
     * Run an actor with a read/write context.
     *
     * If the actor changes state, this may return a promise even if {@link actor} does not return a promise.
     */
    act(actor) {
      const { close, trace } = initialize();
      const traceError = (e) => {
        if (trace) {
          const status = e.code;
          if (typeof status === "number") {
            trace.status = status;
          }
        }
        throw e;
      };
      let context;
      const actOnline = (transaction) => {
        context = createContext(transaction, trace);
        return actor(context);
      };
      let isAsync = false;
      try {
        const result = import_general.Transaction.act(via, actOnline);
        if (import_general.MaybePromise.is(result)) {
          isAsync = true;
          return Promise.resolve(result).catch(traceError).finally(close);
        }
        return result;
      } catch (e) {
        traceError(e);
        throw e;
      } finally {
        if (!isAsync && context) {
          close();
        }
      }
    },
    /**
     * Begin an operation with a read-only context.  You must close the context after use to properly deregister
     * activity.
     */
    beginReadOnly() {
      const { close, trace } = initialize();
      const context = createContext(import_general.Transaction.ReadOnly, trace);
      context[Symbol.dispose] = close;
      return context;
    },
    [Symbol.toStringTag]: "OnlineContext"
  };
  function initialize() {
    let trace;
    const activity = options.activity?.frame(via);
    if (options.tracer && options.actionType) {
      trace = {
        type: options.actionType
      };
    }
    const close = () => {
      if (trace) {
        options.tracer?.record(trace);
      }
      if (message) {
        import_Contextual.Contextual.setContextOf(message, void 0);
      }
      if (activity) {
        activity[Symbol.dispose]();
      }
    };
    return {
      close,
      trace
    };
  }
  function createContext(transaction, trace) {
    let agents;
    const context = {
      ...options,
      session,
      exchange,
      subject,
      fabric,
      transaction,
      trace,
      interactionComplete: exchange?.closed,
      // TODO - Matter 1.4 - add support for ARLs
      authorityAt(desiredAccessLevel, location) {
        if (location === void 0) {
          throw new import_general.InternalError("AccessControl.Location is required");
        }
        const cachedAccessLevels = accessLevelCache?.get(location);
        if (cachedAccessLevels !== void 0) {
          return cachedAccessLevels.includes(desiredAccessLevel) ? import_protocol.AccessControl.Authority.Granted : import_protocol.AccessControl.Authority.Unauthorized;
        }
        if (options.node === void 0) {
          throw new import_general.InternalError("OnlineContext initialized without node");
        }
        const accessControl = options.node.act((agent) => agent.get(import_access_control.AccessControlServer));
        if (import_general.MaybePromise.is(accessControl)) {
          throw new import_general.InternalError("AccessControlServer should already be initialized.");
        }
        const accessLevels = accessControl.accessLevelsFor(context, location, aclEndpointContextFor(location));
        if (accessLevelCache === void 0) {
          accessLevelCache = /* @__PURE__ */ new Map();
        }
        accessLevelCache.set(location, accessLevels);
        return accessLevels.includes(desiredAccessLevel) ? import_protocol.AccessControl.Authority.Granted : import_protocol.AccessControl.Authority.Unauthorized;
      },
      agentFor(endpoint) {
        if (!agents) {
          agents = (0, import_ContextAgents.ContextAgents)(context);
        }
        return agents.agentFor(endpoint);
      },
      get [import_Contextual.Contextual.context]() {
        return this;
      }
    };
    if (message) {
      import_Contextual.Contextual.setContextOf(message, context);
    }
    return context;
  }
  function aclEndpointContextFor({ endpoint: number }) {
    if (number === void 0) {
      throw new import_general.InternalError("Online location missing required endpoint number");
    }
    if (options.node === void 0) {
      throw new import_general.InternalError("Online context has no node defined");
    }
    if (nodeProtocol === void 0) {
      nodeProtocol = options.node.protocol;
    }
    const endpoint = nodeProtocol[number];
    if (endpoint === void 0) {
      throw new import_general.InternalError(`Unknown endpoint number ${number} in access control location`);
    }
    return endpoint;
  }
}
//# sourceMappingURL=OnlineContext.js.map
