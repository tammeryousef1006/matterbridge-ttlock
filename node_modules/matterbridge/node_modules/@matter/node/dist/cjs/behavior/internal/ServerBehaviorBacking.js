"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ServerBehaviorBacking_exports = {};
__export(ServerBehaviorBacking_exports, {
  ServerBehaviorBacking: () => ServerBehaviorBacking
});
module.exports = __toCommonJS(ServerBehaviorBacking_exports);
var import_ClusterBehavior = require("#behavior/cluster/ClusterBehavior.js");
var import_ValidatedElements = require("#behavior/cluster/ValidatedElements.js");
var import_general = require("#general");
var import_model = require("#model");
var import_ServerNodeStore = require("#node/storage/ServerNodeStore.js");
var import_types = require("#types");
var import_BehaviorBacking = require("./BehaviorBacking.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const NoElements = /* @__PURE__ */ new Set();
class ServerBehaviorBacking extends import_BehaviorBacking.BehaviorBacking {
  #store;
  #elements;
  get store() {
    if (!this.#store) {
      this.#store = this.#serverStore.endpointStores.storeForEndpoint(this.endpoint).storeForBehavior(this.type.id);
    }
    return this.#store;
  }
  get elements() {
    return this.#elements;
  }
  invokeInitializer(behavior, options) {
    const finalizeState = () => {
      this.#applyTransitiveDefaults(behavior.state);
      if (behavior instanceof import_ClusterBehavior.ClusterBehavior) {
        this.#configureElements(behavior);
      } else {
        this.#elements = {
          attributes: NoElements,
          commands: NoElements,
          events: NoElements
        };
      }
      const context = behavior.context;
      this.datasource.validate(context, behavior.state);
    };
    const promise = super.invokeInitializer(behavior, options);
    if (promise) {
      return promise.then(finalizeState);
    }
    finalizeState();
  }
  get #serverStore() {
    return this.endpoint.env.get(import_ServerNodeStore.ServerNodeStore);
  }
  /**
   * Schema may specify that state fields default to the value of another field.  We apply these defaults after
   * initialization when the other field should be defined.
   */
  #applyTransitiveDefaults(state) {
    const schema = this.type.schema;
    if (!schema) {
      return;
    }
    for (const member of this.type.supervisor.membersOf(schema)) {
      const name = (0, import_general.camelize)(member.name);
      if (state[name] === void 0) {
        const referenced = import_model.FieldValue.referenced(member.default);
        if (referenced) {
          const val = state[(0, import_general.camelize)(referenced)];
          if (val !== void 0) {
            state[name] = val;
          }
        }
      }
    }
  }
  #configureElements(behavior) {
    const validation = new import_ValidatedElements.ValidatedElements(behavior.constructor, behavior);
    validation.report();
    const globals = behavior.state;
    const attributeDefs = behavior.cluster.attributes;
    globals.attributeList = [...validation.attributes].map((name) => attributeDefs[name].id);
    const commandDefs = behavior.cluster.commands;
    const commands = [...validation.commands].map((name) => commandDefs[name]);
    globals.acceptedCommandList = commands.map((command) => command.requestId);
    globals.generatedCommandList = [
      ...new Set(
        commands.filter((command) => command.responseSchema !== import_types.TlvNoResponse).map((command) => command.responseId)
      )
    ];
    this.#elements = {
      attributes: validation.attributes,
      commands: validation.commands,
      events: validation.events
    };
  }
}
//# sourceMappingURL=ServerBehaviorBacking.js.map
