"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var BitmapManager_exports = {};
__export(BitmapManager_exports, {
  BitmapManager: () => BitmapManager
});
module.exports = __toCommonJS(BitmapManager_exports);
var import_general = require("#general");
var import_model = require("#model");
var import_protocol = require("#protocol");
var import_assertions = require("../../validation/assertions.js");
var import_Instrumentation = require("../Instrumentation.js");
var import_Internal = require("../Internal.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const SESSION = Symbol("options");
function BitmapManager(owner, schema) {
  const instanceDescriptors = {};
  const byteSize = schema.metabase?.byteSize;
  if (byteSize === void 0) {
    throw new import_protocol.SchemaImplementationError((0, import_model.DataModelPath)(schema.path), `Base bitmap type has no byteSize defined`);
  }
  const maxBit = byteSize * 8;
  for (const member of owner.membersOf(schema)) {
    let name;
    if (schema.id === import_model.FeatureMap.id) {
      name = (0, import_general.camelize)(member.description ?? member.name);
    } else {
      name = (0, import_general.camelize)(member.name);
    }
    const descriptor = configureProperty(name, maxBit, member);
    instanceDescriptors[name] = descriptor;
  }
  const Wrapper = (0, import_general.GeneratedClass)({
    name: schema.name,
    initialize(ref, session) {
      if (!(0, import_general.isObject)(ref.value)) {
        throw new import_protocol.SchemaImplementationError(
          ref.location,
          `Cannot manage ${typeof ref.value} because it is not a bitmap object`
        );
      }
      Object.defineProperties(this, {
        [import_Internal.Internal.reference]: {
          value: ref
        },
        [SESSION]: {
          value: session
        }
      });
      Object.defineProperties(this, instanceDescriptors);
    }
  });
  import_Instrumentation.Instrumentation.instrumentStruct(Wrapper);
  return (reference, session) => {
    reference.owner = new Wrapper(reference, session);
    return reference.owner;
  };
}
function configureProperty(name, maxBit, schema) {
  const constraint = schema.effectiveConstraint;
  let startBit, stopBit;
  if (typeof constraint.value === "number") {
    startBit = constraint.value;
    stopBit = startBit + 1;
  } else if (typeof constraint.min === "number" && typeof constraint.max === "number") {
    startBit = constraint.min;
    stopBit = constraint.max + 1;
    if (startBit > stopBit) {
      const temp = startBit;
      startBit = stopBit;
      stopBit = temp;
    }
  } else {
    throw new import_protocol.SchemaImplementationError((0, import_model.DataModelPath)(schema.path), `Bitfield is not properly constrained`);
  }
  if (stopBit > maxBit) {
    throw new import_protocol.SchemaImplementationError(
      (0, import_model.DataModelPath)(schema.path),
      `Bitfield range end ${stopBit} is too large for a ${maxBit}-bit bitmap`
    );
  }
  const max = 1 << stopBit - startBit;
  if (max === 2) {
    return {
      enumerable: true,
      get() {
        const bits = this[import_Internal.Internal.reference].value;
        if (bits === void 0) {
          throw new import_protocol.PhantomReferenceError(this[import_Internal.Internal.reference].location);
        }
        return !!bits[name];
      },
      set(value) {
        const ref = this[import_Internal.Internal.reference];
        if (value !== void 0) {
          (0, import_assertions.assertBoolean)(value, ref.location.path);
        }
        ref.change(() => {
          const bits = ref.value;
          if (bits === void 0) {
            throw new import_protocol.PhantomReferenceError(this[import_Internal.Internal.reference].location);
          }
          bits[name] = !!value;
        });
      }
    };
  }
  return {
    enumerable: true,
    get() {
      const bits = this[import_Internal.Internal.reference].value;
      if (bits === void 0) {
        throw new import_protocol.PhantomReferenceError(this[import_Internal.Internal.reference].location);
      }
      return bits[name];
    },
    set(value) {
      const ref = this[import_Internal.Internal.reference];
      if (value !== void 0) {
        (0, import_assertions.assertNumber)(value, ref.location.path);
        if (value >= max) {
          throw new import_protocol.ConstraintError(
            schema,
            this[import_Internal.Internal.reference].location,
            `Value ${value} is too large for bitfield`
          );
        } else if (value < 0) {
          throw new import_protocol.ConstraintError(
            schema,
            this[import_Internal.Internal.reference].location,
            `Illegal negative value ${value} for bitfield`
          );
        }
      }
      ref.change(() => {
        const bits = ref.value;
        if (bits === void 0) {
          throw new import_protocol.PhantomReferenceError(this[import_Internal.Internal.reference].location);
        }
        bits[name] = value ? value : 0;
      });
    }
  };
}
//# sourceMappingURL=BitmapManager.js.map
