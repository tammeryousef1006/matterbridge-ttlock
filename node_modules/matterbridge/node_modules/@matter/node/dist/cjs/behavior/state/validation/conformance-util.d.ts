/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import type { Schema } from "#model";
import { Conformance, SchemaErrorPath, SchemaImplementationError } from "#model";
import { Val } from "#protocol";
import { ValidationLocation } from "./location.js";
export declare class UnsupportedConformanceNodeError extends SchemaImplementationError {
    constructor(schema: Schema, compiledNode: DynamicNode);
}
export declare enum Code {
    Nonconformant = "nonconformant",
    Conformant = "conformant",
    Optional = "optional",
    Disallowed = "disallowed",
    Value = "value",
    Evaluate = "evaluate"
}
export interface ValueNode {
    code: Code.Value;
    value: Val;
}
export type StaticNode = {
    code: Code.Nonconformant | Code.Optional | Code.Conformant | Code.Disallowed;
} | ValueNode;
export interface RuntimeNode {
    code: Code.Evaluate;
    evaluate: (value: Val, location: ValidationLocation) => StaticNode;
}
export type DynamicNode = StaticNode | RuntimeNode;
/**
 * Convert a static node to a dynamic node at runtime.
 */
export declare function evaluateNode(node: DynamicNode, value: Val, location: ValidationLocation): StaticNode;
/**
 * Cast value nodes to a conformance.
 *
 * A value node is conformant if the value is defined
 *
 * Non-value nodes are returned unchanged.
 */
export declare function asConformance<T extends DynamicNode>(node: T): T | {
    readonly code: Code.Nonconformant | Code.Conformant;
};
export declare function isStatic(node: DynamicNode): node is StaticNode;
export declare function asBoolean(node: StaticNode): boolean;
/**
 * Throw an error if a node is not a value.
 *
 * We use this to ensure inputs to binary operators make sense.
 */
export declare function assertValue(location: SchemaErrorPath, node: DynamicNode, where: string): asserts node is ValueNode;
export declare const ConformantNode: {
    readonly code: Code.Conformant;
};
export declare const NonconformantNode: {
    readonly code: Code.Nonconformant;
};
/**
 * Create a node that logically inverts the value of the input node.
 */
export declare function createLogicalInversion(node: DynamicNode): DynamicNode;
type BinaryOperator<T> = (lhs: T, rhs: T) => boolean;
/**
 * Create a node that evaluates a logical binary operator at runtime.
 */
export declare function createLogicalBinaryEvaluator(lhs: RuntimeNode, rhs: RuntimeNode, operator: BinaryOperator<boolean>): RuntimeNode;
/**
 * Create a node that evaluates a comparison operator.
 */
export declare function createComparison(operatorName: Conformance.Operator, lhs: DynamicNode, rhs: DynamicNode, schema: Schema): DynamicNode;
/**
 * Create a node that performs a runtime boolean test.
 */
export declare function createBooleanTest(node: DynamicNode): DynamicNode;
export type EnumMemberValidator = (location: ValidationLocation) => void;
export {};
//# sourceMappingURL=conformance-util.d.ts.map