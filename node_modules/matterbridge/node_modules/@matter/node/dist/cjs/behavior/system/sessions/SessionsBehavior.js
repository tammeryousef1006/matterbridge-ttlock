"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var SessionsBehavior_exports = {};
__export(SessionsBehavior_exports, {
  SessionsBehavior: () => SessionsBehavior
});
module.exports = __toCommonJS(SessionsBehavior_exports);
var import_general = require("#general");
var import_protocol = require("#protocol");
var import_Behavior = require("../../Behavior.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
class SessionsBehavior extends import_Behavior.Behavior {
  static id = "sessions";
  initialize() {
    const env = this.env;
    if (env.has(import_protocol.SessionManager)) {
      this.#enterOnlineMode(env.get(import_protocol.SessionManager));
    }
    this.reactTo(this.endpoint.lifecycle.offline, this.#enterOfflineMode);
  }
  #convertToExposedSession(session) {
    return {
      name: session.name,
      nodeId: session.nodeId,
      peerNodeId: session.peerNodeId,
      fabric: session.fabric?.externalInformation,
      isPeerActive: session.isPeerActive(),
      lastInteractionTimestamp: session.timestamp,
      lastActiveTimestamp: session.activeTimestamp,
      numberOfActiveSubscriptions: session.subscriptions.size
    };
  }
  #enterOnlineMode(sessions) {
    this.reactTo(sessions.sessions.added, this.#sessionOpened);
    this.reactTo(sessions.sessions.deleted, this.#sessionClosed);
    this.reactTo(sessions.subscriptionsChanged, this.#subscriptionsChanged, { lock: true });
  }
  #sessionOpened(session) {
    if (session.isPase) {
      return;
    }
    const exposedSession = this.#convertToExposedSession(session);
    this.state.sessions[session.id] = exposedSession;
    this.events.opened.emit(exposedSession);
  }
  #sessionClosed(session) {
    if (!(session.id in this.state.sessions)) {
      return;
    }
    delete this.state.sessions[session.id];
    this.events.closed.emit(this.#convertToExposedSession(session));
  }
  #subscriptionsChanged(session, subscription) {
    if (session.isPase) {
      return;
    }
    if (session.subscriptions.has(subscription)) {
      this.events.subscriptionAdded.emit(subscription);
    }
    const sessionEntry = this.state.sessions[session.id];
    if (sessionEntry === void 0) {
      return;
    }
    sessionEntry.numberOfActiveSubscriptions = session.subscriptions.size;
    this.state.sessions[session.id] = sessionEntry;
    this.events.subscriptionsChanged.emit(sessionEntry);
  }
  #enterOfflineMode() {
    this.state.sessions = {};
  }
}
((SessionsBehavior2) => {
  class State {
    sessions = {};
  }
  SessionsBehavior2.State = State;
  class Events extends import_general.EventEmitter {
    opened = (0, import_general.Observable)();
    closed = (0, import_general.Observable)();
    subscriptionsChanged = (0, import_general.Observable)();
    subscriptionAdded = (0, import_general.Observable)();
  }
  SessionsBehavior2.Events = Events;
})(SessionsBehavior || (SessionsBehavior = {}));
//# sourceMappingURL=SessionsBehavior.js.map
