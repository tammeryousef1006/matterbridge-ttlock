/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { ActionContext } from "#behavior/context/ActionContext.js";
import { Behavior } from "#behavior/index.js";
import { Transitions } from "#behavior/Transitions.js";
import { ColorControl } from "#clusters/color-control";
import { Endpoint } from "#endpoint/Endpoint.js";
import { MaybePromise } from "#general";
import { ClusterType, TypeFromPartialBitSchema } from "#types";
import { AsyncObservable } from "@matter/general";
import { Val } from "@matter/protocol";
declare const ColorControlBase: import("#behavior/index.js").ClusterBehavior.Type<import("#types").ClusterComposer.WithFeatures<ColorControl.Cluster, readonly [ColorControl.Feature.HueSaturation, ColorControl.Feature.EnhancedHue, ColorControl.Feature.ColorLoop, ColorControl.Feature.Xy, ColorControl.Feature.ColorTemperature]>, import("#behavior/index.js").ClusterBehavior.Type<ColorControl.Cluster, import("#behavior/index.js").ClusterBehavior.Type<ClusterType.Of<{
    readonly id: 0;
    readonly revision: 0;
    readonly name: "Unknown";
    readonly attributes: {};
    readonly commands: {};
    readonly events: {};
}>, typeof import("#behavior/index.js").ClusterBehavior, import("./ColorControlInterface.js").ColorControlInterface>, import("./ColorControlInterface.js").ColorControlInterface>, import("./ColorControlInterface.js").ColorControlInterface>;
/**
 * This is the default server implementation of {@link ColorControlBehavior}.
 *
 * This implementation includes all features of {@link ColorControl.Cluster} and implements all mandatory commands. You
 * should use {@link ColorControlServer.with} to specialize the class for the features your implementation supports.
 *
 * This default implementation also handles together with the LevelControl cluster the currentLevel dependency as
 * defined by the Matter specification automatically.
 *
 * This implementation ignores by default all transition times and sets the new color immediately. Alternatively, you
 * can set the {@link ColorControl.State#managedTransitionTimeHandling} state attribute to true to have matter.js manage
 * transition times by changing the level value step-wise every second. This might be an intermediate solution if you
 * develop independently of defined hardware.
 *
 * If your hardware supports transitions natively, you may override {@link createTransitions} to return a
 * {@link Transitions} implementation adapted to your hardware.  This allows matter.js to handle Matter requirements
 * such as remaining time and level reporting.
 *
 * Alternatively, you may override the following methods in this class to implement lower-level logic yourself.
 * Implementing a cluster in this way will disable much of the logic matter.js implements for you in the default
 * implementations.
 *
 * * {@link ColorControlBaseServer.moveToHueLogic} Logic to move the hue to a defined value in a defined time
 * * {@link ColorControlBaseServer.moveHueLogic} Logic to move the hue by a defined rate/second
 * * {@link ColorControlBaseServer.stepHueLogic} Logic to move the hue one defined step in a defined time
 * * {@link ColorControlBaseServer.moveToSaturationLogic} Logic to move the saturation to a defined value in a defined
 *   time
 * * {@link ColorControlBaseServer.moveSaturationLogic} Logic to move the saturation by a defined rate/second
 * * {@link ColorControlBaseServer.stepSaturationLogic} Logic to move the saturation one defined step in a defined time
 * * {@link ColorControlBaseServer.moveToHueAndSaturationLogic} Logic to move the hue and saturation to a defined value
 *   in a defined time
 * * {@link ColorControlBaseServer.moveToColorLogic} Logic to move the x/y color to a defined value in a defined time
 * * {@link ColorControlBaseServer.moveColorLogic} Logic to move the x/y color by a defined rate/second
 * * {@link ColorControlBaseServer.stepColorLogic} Logic to move the x/y color one defined step in a defined time
 * * {@link ColorControlBaseServer.moveToColorTemperatureLogic} Logic to move the color temperature to a defined value
 *   in a defined time
 * * {@link ColorControlBaseServer.moveToEnhancedHueAndSaturationLogic} Logic to move the enhanced hue and saturation
 *   to a defined value in a defined time
 * * {@link ColorControlBaseServer.moveColorTemperatureLogic} Logic to move the color temperature by a defined
 *   rate/second
 * * {@link ColorControlBaseServer.stepColorTemperatureLogic} Logic to move the color temperature one defined step in a
 *   defined time
 * * {@link ColorControlBaseServer.stopHueAndSaturationMovement} Logic to stop any hue and saturation movements
 * * {@link ColorControlBaseServer.stopAllColorMovement} Logic to stop any color movements
 * * {@link ColorControlBaseServer.startColorLoopLogic} Logic to start the color loop (looping enhanced hue endlessly)
 * * {@link ColorControlBaseServer.stopColorLoopLogic} Logic to stop the color loop
 * * {@link ColorControlBaseServer.stopMoveStepLogic} Logic to stop all movements beside color loops
 * * {@link ColorControlBaseServer.switchColorMode} Logic to switch the color mode and to set the current attributes of
 *   the new mode
 *
 * All overridable methods may be implemented sync or async by returning a Promise.
 *
 * For own implementations you can use:
 *
 * * {@link ColorControlBaseServer#setColorMode} to set the color mode
 * * {@link ColorControlBaseServer#setEnhancedColorMode} to set the enhanced color mode
 *
 * The default implementation of {@link ColorControlBaseServer.switchColorMode} tries to convert the color values
 * between the different modi. When switching from color temperature mode to any other mode the value can be converted
 * when the color temperature was between 1000K and 20.000K. For other values no conversion takes place.
 *
 * The method {@link ColorControlBaseServer.syncColorTemperatureWithLevelLogic} is handling the sync between the
 * LevelControl and ColorControl cluster when the color temperature is used.
 *
 * Additionally there are some convenience properties to access the current attribute values for all relevant color
 * attributes (x,y, hue, saturation, mireds/kelvin, colorTemperatur, ...) in their CIE value format instead the matter
 * data ranges.
 */
export declare class ColorControlBaseServer extends ColorControlBase {
    #private;
    protected internal: ColorControlBaseServer.Internal;
    state: ColorControlBaseServer.State;
    events: ColorControlBaseServer.Events;
    /** Returns the current X value as decimal number according to CIE in the range 0..1. */
    get x(): number;
    /**
     * Sets the current X value as decimal number according to CIE in the range 0..1 and converts into Matter number
     * range.
     */
    set x(value: number);
    /** Returns the current Y value as decimal number according to CIE in the range 0..1. */
    get y(): number;
    /**
     * Sets the current Y value as decimal number according to CIE in the range 0..1 and converts into Matter number
     * range.
     */
    set y(value: number);
    /**
     * Returns the current hue value as decimal number in the range 0..360.
     */
    get hue(): number;
    /**
     * Sets the current hue value as decimal number in the range 0..360 and converts into Matter number range.
     */
    set hue(value: number);
    /** Returns the current enhanced hue value as decimal number in the range 0..0xFFFF. */
    get enhancedHue(): number;
    /**
     * Sets the current enhanced hue value as decimal number in the range 0..0xFFFF and converts into Matter number range.
     */
    set enhancedHue(value: number);
    /** Returns the current saturation value as decimal number in the range 0..1. */
    get saturation(): number;
    /**
     * Sets the current saturation value as decimal number in the range 0..1 and converts into Matter number range.
     */
    set saturation(value: number);
    /** Returns the current color temperature value in Mireds (0..0xFFFF). */
    get mireds(): number;
    /**
     * Sets the current color temperature value in Mireds (0..0xFFFF) and converts into Matter number range.
     */
    set mireds(value: number);
    /** Returns the current color temperature value in Kelvin (from internal Mireds). */
    get kelvin(): number;
    /** Sets the current color temperature value in Kelvin and updates the internal mireds value. */
    set kelvin(value: number);
    /**
     * Returns the minimum color temperature value in Mireds (0..0xFFFF). This automatically handled the case that no
     * physical minimum value is defined.
     */
    get minimumColorTemperatureMireds(): number;
    /**
     * Returns the maximum color temperature value in Mireds (0..0xFFFF). This automatically handled the case that no
     * physical maximum value is defined.
     */
    get maximumColorTemperatureMireds(): number;
    /** Returns the current whitePoint X value as decimal number according to CIE in the range 0..1. */
    get whitePointX(): number | undefined;
    /**
     * Sets the current whitePoint X value as decimal number according to CIE in the range 0..1 and converts into Matter
     * number range.
     */
    set whitePointX(value: number | undefined);
    /** Returns the current whitePoint Y value as decimal number according to CIE in the range 0..1. */
    get whitePointY(): number | undefined;
    /**
     * Sets the current whitePoint Y value as decimal number according to CIE in the range 0..1 and converts into Matter
     * number range.
     */
    set whitePointY(value: number | undefined);
    /** Returns the current colorPoint Rx value as decimal number according to CIE in the range 0..1. */
    get colorPointRx(): number | undefined;
    /**
     * Sets the current colorPoint Rx value as decimal number according to CIE in the range 0..1 and converts into Matter
     * number range.
     */
    set colorPointRx(value: number | undefined);
    /** Returns the current colorPoint Ry value as decimal number according to CIE in the range 0..1. */
    get colorPointRy(): number | undefined;
    /**
     * Sets the current colorPoint Ry value as decimal number according to CIE in the range 0..1 and converts into Matter
     * number range.
     */
    set colorPointRy(value: number | undefined);
    /** Returns the current colorPoint Gx value as decimal number according to CIE in the range 0..1. */
    get colorPointGx(): number | undefined;
    /**
     * Sets the current colorPoint Gx value as decimal number according to CIE in the range 0..1 and converts into Matter
     * number range.
     */
    set colorPointGx(value: number | undefined);
    /** Returns the current colorPoint Gy value as decimal number according to CIE in the range 0..1. */
    get colorPointGy(): number | undefined;
    /**
     * Sets the current colorPoint Gy value as decimal number according to CIE in the range 0..1 and converts into Matter
     * number range.
     */
    set colorPointGy(value: number | undefined);
    /** Returns the current colorPoint Bx value as decimal number according to CIE in the range 0..1. */
    get colorPointBx(): number | undefined;
    /**
     * Sets the current colorPoint Bx value as decimal number according to CIE in the range 0..1 and converts into Matter
     * number range.
     */
    set colorPointBx(value: number | undefined);
    initialize(): MaybePromise;
    /**
     * Initialize Color Temperature features.
     *
     * This only applies if the Color Control cluster has the "CT" feature enabled.
     */
    protected initializeColorTemperature(): void;
    /**
     * Default implementation notes:
     * This method ignores the transition time provided by the command and just sets the hue value to the
     * requested value. After the options and value checks and the potential color mode switch it uses the
     * {@link moveToHueLogic} method to set the hue. If you want to implement own logic just override
     * {@link moveToHueLogic} with is also used for {@link enhancedMoveToHue}, {@link moveToHueAndSaturation} and
     * {@link enhancedMoveToHueAndSaturation}.
     */
    moveToHue({ optionsMask, optionsOverride, hue, direction, transitionTime, }: ColorControl.MoveToHueRequest): MaybePromise<void>;
    /**
     * Default implementation of the moveToHue logic. When a transition time is specified the implementation uses a
     * step based to manage the move. The method handled hue and enhanced-Hue changes depending on the last parameter.
     *
     * @param targetHue The target hue value to move to (in range of the matter hue or enhanced hue ranges)
     * @param direction The direction to move to the target hue
     * @param transitionTime The time in seconds to move to the target hue. 0 means "as fast as possible"
     * @param isEnhancedHue If true the enhanced hue is handled, otherwise the normal hue
     * @protected
     */
    protected moveToHueLogic(targetHue: number, direction: ColorControl.Direction, transitionTime: number, isEnhancedHue?: boolean): MaybePromise;
    /**
     * Default implementation notes:
     * After the options checks it uses the {@link moveHueLogic} method to set the hue.
     * If you want to implement own logic just override {@link moveHueLogic} with is also used for {@link enhancedMoveHue}.
     * If a currently running movement should be stopped {@link stopHueAndSaturationMovement} is used which can also be
     * overridden.
     * The logic is implemented as follows: Depending on the provided rate the server will move as fast as possible, but
     * increase only one rate directly if the managed transition is not used. Else the step logic is applied and the
     * level is increased or decreased by the step size every second.
     */
    moveHue({ optionsMask, optionsOverride, moveMode, rate }: ColorControl.MoveHueRequest): MaybePromise<void>;
    /**
     * Default implementation of the moveHue logic. The method handled hue and enhanced-Hue changes depending on the
     * last parameter.
     * If the managed transition time handling is disabled the method directly increases the hue value by one rate step.
     * So without managed transition not too much happens.
     * Otherwise, the method initiates a transition with the given rate.
     *
     * @param moveMode Move Mode to move the hue up or down (Stop should not be provided in here because already handled)
     * @param rate The rate to move the hue up or down. 0 should never be provided her because handled here.
     * @param isEnhancedHue If true the enhanced hue is handled, otherwise the normal hue
     * @protected
     */
    protected moveHueLogic(moveMode: ColorControl.MoveMode, rate: number, isEnhancedHue?: boolean): MaybePromise;
    /**
     * Default implementation notes:
     * This method is called to stop any hue, enhanced hue and/or saturation movements potentially in progress. Override
     * this method with hardware specific logic to implement this functionality.
     * @protected
     */
    protected stopHueAndSaturationMovement(): MaybePromise;
    /**
     * Default implementation notes:
     * After the options checks it uses the {@link stepHueLogic} method to set the hue.
     * If you want to implement own logic just override {@link stepHueLogic} with is also used for {@link enhancedStepHue}.
     * The logic is implemented as follows: When no transition time is provided, the server will move as fast as
     * possible, so we set to min/max directly. Else the step logic is applied and the hue is increased or decreased
     * by the step size every transition time interval.
     */
    stepHue({ optionsMask, optionsOverride, stepMode, stepSize, transitionTime, }: ColorControl.StepHueRequest): MaybePromise<void>;
    /**
     * Default implementation of the stepHue logic. The method handled hue and enhanced-Hue changes depending on the
     * last parameter.
     * The logic is implemented as follows: When no transition time is provided, the server will move as fast as
     * possible, so we set to current Hue +/- stepSize directly. Else the step logic is applied and the hue is increased
     * or decreased by the step size every transition time interval.
     * @param stepMode The step mode to move the hue up or down
     * @param stepSize The step size to move the hue up or down
     * @param transitionTime The time in seconds to move the hue. 0 means "as fast as possible"
     * @param isEnhancedHue If true the enhanced hue is handled, otherwise the normal hue
     * @protected
     */
    protected stepHueLogic(stepMode: ColorControl.StepMode, stepSize: number, transitionTime: number, isEnhancedHue?: boolean): MaybePromise;
    /**
     * Default implementation notes:
     * After the options checks and potentially switching the color mode it uses the {@link moveToSaturationLogic}
     * method to set the hue.
     * If you want to implement own logic just override {@link moveToSaturationLogic} with is also used for
     * {@link moveToHueAndSaturation}.
     * The logic is implemented as follows: When no transition time is provided, the server will move as fast as
     * possible, so we set the target value directly. Else the step logic is applied and the saturation is increased or
     * decreased by the step size every transition time interval.
     */
    moveToSaturation({ optionsMask, optionsOverride, saturation, transitionTime, }: ColorControl.MoveToSaturationRequest): MaybePromise<void>;
    /**
     * Default implementation of the moveToSaturation logic.
     * If the managed transition time handling is disabled the method directly sets the new saturation value.
     * Otherwise, the method initiates a transition with the given rate.
     *
     * @param targetSaturation The target saturation value to move to
     * @param transitionTime The time in seconds to move to the target saturation. 0 means "as fast as possible"
     * @protected
     */
    protected moveToSaturationLogic(targetSaturation: number, transitionTime: number): MaybePromise;
    /**
     * Default implementation notes:
     * After the options checks it uses the {@link moveSaturationLogic} method to set the hue.
     * If you want to implement own logic just override {@link moveSaturationLogic}.
     * The logic is implemented as follows: When no transition time is provided, the server will move as fast as
     * possible, so we set to min/max directly. Else the step logic is applied and the saturation is increased or
     * decreased by the step size every transition time interval.
     */
    moveSaturation({ optionsMask, optionsOverride, moveMode, rate }: ColorControl.MoveSaturationRequest): MaybePromise<void>;
    /**
     * Default implementation of the moveSaturation logic.
     * If the managed transition time handling is disabled the method directly sets the new saturation value.
     * Otherwise the method initiates a transition with the given rate.
     *
     * @param moveMode Move Mode to move the saturation up or down
     * @param rate The rate to move the saturation up or down
     * @protected
     */
    protected moveSaturationLogic(moveMode: ColorControl.MoveMode, rate: number): MaybePromise;
    /**
     * Default implementation notes:
     * After the options checks and potentially switching the color mode it uses the {@link stepSaturationLogic}
     * method to set the hue.
     * If you want to implement own logic just override {@link stepSaturationLogic}.
     * The logic is implemented as follows: When no transition time is provided, the server will move as fast as
     * possible, so we set the target values directly. Else the step logic is applied and the hue and saturation are
     * increased or decreased by the step size every transition time interval.
     */
    stepSaturation({ optionsMask, optionsOverride, stepMode, stepSize, transitionTime, }: ColorControl.StepSaturationRequest): MaybePromise<void>;
    /**
     * Default implementation of the stepSaturation logic.
     * If the managed transition time handling is disabled the method directly sets the new saturation value.
     * Otherwise the method initiates a transition with the given rate.
     *
     * @param stepMode The step mode to move the saturation up or down
     * @param stepSize The step size to move the saturation up or down
     * @param transitionTime The time in seconds to move the saturation. 0 means "as fast as possible"
     * @protected
     */
    protected stepSaturationLogic(stepMode: ColorControl.StepMode, stepSize: number, transitionTime: number): MaybePromise;
    /**
     * Default implementation notes:
     * After the options checks and potentially switching the color mode it uses the {@link moveToHueAndSaturationLogic}
     * method to set the hue.
     * If you want to implement own logic just override {@link moveToHueAndSaturationLogic}.
     * The logic is implemented as follows: When no transition time is provided, the server will move as fast as
     * possible, so we set the target values directly. Else the step logic is applied and the hue and saturation is
     * increased or decreased by the step size every transition time interval.
     */
    moveToHueAndSaturation({ optionsOverride, optionsMask, saturation, hue, transitionTime, }: ColorControl.MoveToHueAndSaturationRequest): MaybePromise<void>;
    /**
     * Default implementation of the moveToHueAndSaturation logic.
     * If the managed transition time handling is disabled the method directly sets the new hue and saturation values.
     * Otherwise the method initiates a transition with the given rate.
     * This method internally uses {@link moveToHueLogic} and {@link moveToSaturationLogic} to handle the hue and
     * saturation changes, so if you have implemented them already you might not need to override this method.
     *
     * @param targetHue The target hue value to move to
     * @param targetSaturation The target saturation value to move to
     * @param transitionTime The time in seconds to move to the target hue and saturation. 0 means "as fast as possible"
     * @protected
     */
    protected moveToHueAndSaturationLogic(targetHue: number, targetSaturation: number, transitionTime: number): MaybePromise;
    /**
     * Default implementation notes:
     * After the options checks it uses the {@link moveToColorLogic} method to set the x and y value.
     * If you want to implement own logic just override {@link moveToColorLogic}.
     * The logic is implemented as follows: When no transition time is provided, the server will move as fast as
     * possible, so we set the target values directly. Else the step logic is applied and the x and y is
     * increased or decreased by the step size every transition time interval.
     */
    moveToColor({ optionsMask, optionsOverride, colorX, colorY, transitionTime, }: ColorControl.MoveToColorRequest): MaybePromise<void>;
    /**
     * Default implementation of the moveToColor logic.
     * If the managed transition time handling is disabled the method directly sets the new x and y values.
     * Otherwise the method initiates a transition with the given rate.
     * This method internally uses {@link moveToColorLogic} to handle the x and y changes, so if you have implemented it
     * already you might not need to override this method.
     *
     * @param targetX The target x value to move to
     * @param targetY The target y value to move to
     * @param transitionTime The time in seconds to move to the target x and y. 0 means "as fast as possible"
     * @protected
     */
    protected moveToColorLogic(targetX: number, targetY: number, transitionTime: number): MaybePromise;
    /**
     * Default implementation notes:
     * After the options checks it uses the {@link moveColorLogic} method to set the x and y value.
     * If you want to implement own logic just override {@link moveColorLogic}.
     * The logic is implemented as follows: When no transition time is provided, the server will move as fast as
     * possible, so we set the target values directly. Else the step logic is applied and the x and y is
     * increased or decreased by the step size every transition time interval.
     */
    moveColor({ optionsOverride, optionsMask, rateX, rateY }: ColorControl.MoveColorRequest): MaybePromise;
    /**
     * Default implementation notes:
     * This method is called to stop any color movements potentially in progress, including any x/y, hue, saturation and
     * color temperature transitions. Override this method with hardware specific logic to implement this functionality.
     * @protected
     */
    protected stopAllColorMovement(): MaybePromise;
    /**
     * Default implementation of the moveColor logic.
     * If the managed transition time handling is disabled the method directly sets the new x and y values.
     * Otherwise the method initiates a transition with the given rate.
     *
     * @param rateX The rate to move the x value up or down (positive values mean up, negative down)
     * @param rateY The rate to move the y value up or down (positive values mean up, negative down)
     * @protected
     */
    protected moveColorLogic(rateX: number, rateY: number): MaybePromise;
    /**
     * Default implementation notes:
     * After the options checks it uses the {@link stepColorLogic} method to set the x and y value.
     * If you want to implement own logic just override {@link stepColorLogic}.
     * The logic is implemented as follows: When no transition time is provided, the server will move as fast as
     * possible, so we set the target values directly. Else the step logic is applied and the x and y is
     * increased or decreased by the step size every transition time interval.
     */
    stepColor({ optionsOverride, optionsMask, stepX, stepY, transitionTime, }: ColorControl.StepColorRequest): MaybePromise;
    /**
     * Default implementation of the stepColor logic.
     * If the managed transition time handling is disabled the method directly sets the new x and y values.
     * Otherwise, the method initiates a transition with the given rate.
     *
     * @param stepX The step size to move the x value up or down
     * @param stepY The step size to move the y value up or down
     * @param transitionTime The time in seconds to move the x and y. 0 means "as fast as possible"
     * @protected
     */
    protected stepColorLogic(stepX: number, stepY: number, transitionTime: number): MaybePromise;
    /**
     * Default implementation notes:
     * After the options checks it uses the {@link moveToColorTemperatureLogic} method to set the color temperature.
     * If you want to implement own logic just override {@link moveToColorTemperatureLogic}.
     * The logic is implemented as follows: When no transition time is provided, the server will move as fast as
     * possible, so we set the target value directly. Else the step logic is applied and the color temperature is
     * increased or decreased by the step size every transition time interval.
     */
    moveToColorTemperature({ optionsOverride, optionsMask, colorTemperatureMireds, transitionTime, }: ColorControl.MoveToColorTemperatureRequest): MaybePromise;
    /**
     * Default implementation of the moveToColorTemperature logic.
     * If the managed transition time handling is disabled the method directly sets the new color temperature value.
     * Otherwise the method initiates a transition with the given rate.
     *
     * @param targetMireds The target color temperature value to move to
     * @param transitionTime The time in seconds to move to the target color temperature. 0 means "as fast as possible"
     * @protected
     */
    protected moveToColorTemperatureLogic(targetMireds: number, transitionTime: number): MaybePromise;
    /**
     * Default implementation notes:
     * After the options checks it uses the {@link moveToHueLogic} method to set the enhanced hue.
     * If you want to implement own logic just override {@link moveToHueLogic} which is used together with
     * {@link moveToHue}.
     * The logic is implemented as follows: When no transition time is provided, the server will move as fast as
     * possible, so we set the target value directly. Else the step logic is applied and the color temperature is
     * increased or decreased by the step size every transition time interval.
     */
    enhancedMoveToHue({ optionsMask, optionsOverride, enhancedHue, direction, transitionTime, }: ColorControl.EnhancedMoveToHueRequest): MaybePromise<void>;
    /**
     * Default implementation notes:
     * After the options checks it uses the {@link moveHueLogic} method to set the enhanced hue.
     * If you want to implement own logic just override {@link moveHueLogic} which is used together with
     * {@link moveHue}.
     * The logic is implemented as follows: Depending on the provided rate the server will move as fast as possible, but
     * increase only one rate directly if the managed transition is not used. Else the step logic is applied and the
     * level is increased or decreased by the step size every second.
     */
    enhancedMoveHue({ optionsMask, optionsOverride, moveMode, rate }: ColorControl.EnhancedMoveHueRequest): MaybePromise<void>;
    /**
     * Default implementation notes:
     * After the options checks it uses the {@link stepHueLogic} method to set the enhanced hue.
     * If you want to implement own logic just override {@link stepHueLogic} which is used together with
     * {@link stepHue}.
     * The logic is implemented as follows: When no transition time is provided, the server will move as fast as
     * possible, so we set the target value directly. Else the step logic is applied and the hue is increased or
     * decreased by the step size every transition time interval.
     */
    enhancedStepHue({ optionsMask, optionsOverride, stepMode, stepSize, transitionTime, }: ColorControl.EnhancedStepHueRequest): MaybePromise<void>;
    /**
     * Default implementation notes:
     * After the options checks it uses the {@link moveToEnhancedHueAndSaturationLogic} method to set the enhanced hue
     * and saturation.
     * If you want to implement own logic just override {@link moveToEnhancedHueAndSaturationLogic}.
     * The logic is implemented as follows: Depending on the provided rate the server will move as fast as possible, so
     * we set to min/max directly if the managed transition is not used. Else the step logic is applied and the
     * level is increased or decreased by the step size every second.
     */
    enhancedMoveToHueAndSaturation({ optionsOverride, optionsMask, enhancedHue, saturation, transitionTime, }: ColorControl.EnhancedMoveToHueAndSaturationRequest): MaybePromise;
    /**
     * Default implementation notes:
     * After the options checks it uses the {@link moveToHueLogic} and {@link moveToSaturationLogic} methods to set the
     * hue and saturation.
     * Both methods are also used for other commands, so it maybe is not needed to override this method.
     * The logic is implemented as follows: Depending on the provided rate the server will move as fast as possible, so
     * we set to min/max directly if the managed transition is not used. Else the step logic is applied and the
     * level is increased or decreased by the step size every second.
     */
    protected moveToEnhancedHueAndSaturationLogic(targetEnhancedHue: number, targetSaturation: number, transitionTime: number): MaybePromise;
    /**
     * Default implementation notes:
     * After the options checks and potentially switching the color mode it uses the {@link stopColorLoopLogic}
     * method to stop color loops or {@link startColorLoopLogic} to start a color loop at a defined enhanced hue value.
     * If you want to implement own logic just override these methods.
     * The logic is implemented as follows: When no transition time is provided, the server will move as fast as
     * possible, so we set the target value directly. Else the step logic is applied and the color temperature is
     * increased or decreased by the step size every transition time interval.
     */
    colorLoopSet({ optionsMask, optionsOverride, updateFlags, action, direction, time, startHue, }: ColorControl.ColorLoopSetRequest): void | PromiseLike<void>;
    /**
     * Default implementation notes:
     * Implement stopping the color loop here if any special hardware specific logic is needed.
     * @protected
     */
    protected stopColorLoopLogic(): MaybePromise;
    /**
     * Default implementation notes:
     * This method uses {@link moveHueLogic} to start a enhanced color loop and sets the required start hue beforehand.
     * If this is sufficient for your implementation you might not need to override this method.
     *
     * @param startHue The hue to start the color loop at
     * @protected
     */
    protected startColorLoopLogic(startHue: number): MaybePromise;
    /**
     * Default implementation notes:
     * After the options checks it uses the {@link stopMoveStepLogic} method to stop any ongoing color movement.
     * If you want to implement own logic just override {@link stopMoveStepLogic}.
     */
    stopMoveStep({ optionsOverride, optionsMask }: ColorControl.StopMoveStepRequest): MaybePromise;
    /**
     * Default implementation notes:
     * Implement stopping any ongoing color movement here if any special hardware specific logic is needed. In fact this
     * needs to stop any ongoing saturation, color temperature, x or y movement. Hue transitions should only be stopped
     * when they do not belong to a color loop.
     * @protected
     */
    protected stopMoveStepLogic(): MaybePromise;
    /**
     * Default implementation notes:
     * After the options checks and potentially changing the color mode it uses the {@link moveColorTemperatureLogic}
     * method to set the color temperature.
     * If the current movement should be stopped {@link stopHueAndSaturationMovement} is used.
     * If you want to implement own logic just override {@link moveColorTemperatureLogic}.
     * The logic is implemented as follows: When no transition time is provided, the server will move as fast as
     * possible, so we set the target value directly. Else the step logic is applied and the color temperature is
     * increased or decreased by the step size every transition time interval.
     */
    moveColorTemperature({ optionsOverride, optionsMask, moveMode, colorTemperatureMinimumMireds, colorTemperatureMaximumMireds, rate, }: ColorControl.MoveColorTemperatureRequest): MaybePromise;
    /**
     * Default implementation of the moveColorTemperature logic.
     * If the managed transition time handling is disabled the method directly sets the min or max color temperature value.
     * Otherwise the method initiates a transition with the given rate.
     *
     * @param moveMode
     * @param rate
     * @param colorTemperatureMinimumMireds
     * @param colorTemperatureMaximumMireds
     * @protected
     */
    protected moveColorTemperatureLogic(moveMode: ColorControl.MoveMode, rate: number, colorTemperatureMinimumMireds: number, colorTemperatureMaximumMireds: number): MaybePromise;
    /**
     * Default implementation notes:
     * After the options checks and potentially switching the color mode it uses the {@link stepColorTemperatureLogic}
     * method to set the color temperature.
     * If you want to implement own logic just override {@link stepColorTemperatureLogic}.
     * The logic is implemented as follows: When no transition time is provided, the server will move as fast as
     * possible, so we set the target value directly. Else the step logic is applied and the color temperature is
     * increased or decreased by the step size every transition time interval.
     */
    stepColorTemperature({ optionsOverride, optionsMask, stepMode, stepSize, transitionTime, colorTemperatureMinimumMireds, colorTemperatureMaximumMireds, }: ColorControl.StepColorTemperatureRequest): MaybePromise<void>;
    /**
     * Default implementation of the stepColorTemperature logic.
     * If the managed transition time handling is disabled the method directly sets the new color temperature value.
     * Otherwise the method initiates a transition with the given rate.
     *
     * @param stepMode Step Mode to move the color temperature up or down
     * @param stepSize Step size to move the color temperature up or down
     * @param transitionTime Time in seconds to move the color temperature. 0 means "as fast as possible"
     * @param colorTemperatureMinimumMireds Minimum allowed color temperature value
     * @param colorTemperatureMaximumMireds Maximum allowed color temperature value
     * @protected
     */
    protected stepColorTemperatureLogic(stepMode: ColorControl.StepMode, stepSize: number, transitionTime: number, colorTemperatureMinimumMireds: number, colorTemperatureMaximumMireds: number): MaybePromise;
    /**
     * Convenient method to change the color mode of the device. It uses {@link switchColorMode} to
     * convert the current color attributes to the new mode. Override this method for device specific behavior.
     * @private
     */
    protected setColorMode(mode: ColorControl.ColorMode): MaybePromise;
    /**
     * Convenient method to change the enhanced color mode of the device. it uses {@link switchColorMode} to
     * convert the current color attributes to the new mode. Override this method for device specific behavior.
     * @private
     */
    protected setEnhancedColorMode(mode: ColorControl.EnhancedColorMode): MaybePromise;
    /**
     * Default implementation notes:
     * This method is used to switch the device color mode. It converts the current color attributes to the new mode on
     * a best effort "as close as possible" basis. If the device hardware can do this better this method should be
     * overridden to implement this switch logic and to update all state attributes for the new mode. The color mode
     * attribute update itself is handled by the calling method, so is not needed to be done here.
     *
     * @param oldMode Old color Mode
     * @param newMode New color Mode
     * @protected
     */
    protected switchColorMode(oldMode: ColorControl.ColorMode, newMode: ColorControl.ColorMode): MaybePromise;
    /**
     * This method is used internally to potentially handle the dependency between the ColorControl and LevelControl
     * cluster.
     * Do not override this method! Please use the {@link syncColorTemperatureWithLevelLogic} method instead which is
     * called by this method if a sync is needed.
     */
    syncColorTemperatureWithLevel(level: number): MaybePromise;
    /**
     * This method is used internally to potentially handle the dependency between the ColorControl and LevelControl
     * clusters as defined by the Matter specification. It uses {@link moveToColorTemperatureLogic} with a transition
     * time of 0 (as fast as possible) to set the determined color temperature. Unless you have special requirements
     * you do not need to override it.
     *
     * @param level The current level value from the LevelControl cluster
     * @protected
     */
    protected syncColorTemperatureWithLevelLogic(level: number): MaybePromise;
    /**
     * Create transition management instance.
     *
     * We manage transitions using {@link Transitions} if
     * {@link LevelControlBaseServer.State#managedTransitionTimeHandling} is true.
     *
     * You may override this method to replace the {@link Transitions} implementation customized for your application.
     * The provided configuration object is the default one used for Color Control transitions, but can be adjusted
     * if needed.
     */
    protected createTransitions<B extends Behavior>(config: Transitions.Configuration<B>): Transitions<B>;
    [Symbol.asyncDispose](): Promise<void>;
}
export declare namespace ColorControlBaseServer {
    class Internal {
        /**
         * Transition management.
         */
        transitions?: Transitions<ColorControlBaseServer>;
    }
    class State extends ColorControlBase.State {
        /**
         * The default implementation always set the target level immediately and so ignores all transition times
         * requested or configured.
         * Set this to true to manage transition times by changing the level value step wise every second. This is in
         * most cases not the best way because hardware supporting levels usually have ways to specify the change rate
         * or target value and transition time.
         */
        managedTransitionTimeHandling: boolean;
        /**
         * If transition management is disabled you may specify this as the "end time" for transitions.  The remaining
         * time attribute will then report correctly.
         */
        transitionEndTimeMs: undefined;
        /**
         * When managing transitions, this is the interval at which steps occur in ms.
         */
        transitionStepIntervalMs: number;
        [Val.properties](endpoint: Endpoint): {
            get remainingTime(): number;
            set remainingTime(value: number);
        } | {
            remainingTime: number;
        };
    }
    class Events extends ColorControlBase.Events {
        transitionEndTime$Changed: AsyncObservable<[value: number, oldValue: number, context: ActionContext], void>;
    }
    const ExtensionInterface: {
        moveToHueLogic(targetHue: number, direction: ColorControl.Direction, transitionTime: number, isEnhancedHue: boolean): MaybePromise;
        moveHueLogic(moveMode: ColorControl.MoveMode, rate: number, isEnhancedHue: boolean): MaybePromise;
        stopHueAndSaturationMovement(): MaybePromise;
        stepHueLogic(stepMode: ColorControl.StepMode, stepSize: number, transitionTime: number, isEnhancedHue: boolean): MaybePromise;
        moveToSaturationLogic(targetSaturation: number, transitionTime: number): MaybePromise;
        moveSaturationLogic(moveMode: ColorControl.MoveMode, rate: number): MaybePromise;
        stepSaturationLogic(stepMode: ColorControl.StepMode, stepSize: number, transitionTime: number): MaybePromise;
        moveToHueAndSaturationLogic(targetHue: number, targetSaturation: number, transitionTime: number): MaybePromise;
        moveToColorLogic(targetX: number, targetY: number, transitionTime: number): MaybePromise;
        stopAllColorMovement(): MaybePromise;
        moveColorLogic(rateX: number, rateY: number): MaybePromise;
        stepColorLogic(stepX: number, stepY: number, transitionTime: number): MaybePromise;
        moveToColorTemperatureLogic(targetMireds: number, transitionTime: number): MaybePromise;
        moveToEnhancedHueAndSaturationLogic(targetEnhancedHue: number, targetSaturation: number, transitionTime: number): MaybePromise;
        stopColorLoopLogic(): MaybePromise;
        startColorLoopLogic(startHue: number): MaybePromise;
        stopMoveStepLogic(): MaybePromise;
        moveColorTemperatureLogic(moveMode: ColorControl.MoveMode, rate: number, colorTemperatureMinimumMireds: number, colorTemperatureMaximumMireds: number): MaybePromise;
        stepColorTemperatureLogic(stepMode: ColorControl.StepMode, stepSize: number, transitionTime: number, colorTemperatureMinimumMireds: number, colorTemperatureMaximumMireds: number): MaybePromise;
        switchColorMode(oldMode: ColorControl.ColorMode, newMode: ColorControl.ColorMode): MaybePromise;
        setColorMode(mode: ColorControl.ColorMode): MaybePromise;
        setEnhancedColorMode(mode: ColorControl.EnhancedColorMode): MaybePromise;
        syncColorTemperatureWithLevelLogic(level: number): MaybePromise;
        createTransitions<B extends Behavior>(config: Transitions.Configuration<B>): Transitions<B>;
    };
}
declare const ColorControlServer_base: import("#behavior/index.js").ClusterBehavior.Type<ClusterType.Of<{
    readonly id: 768;
    readonly name: "ColorControl";
    readonly revision: 7;
    readonly features: {
        readonly hueSaturation: import("#types").BitFlag;
        readonly enhancedHue: import("#types").BitFlag;
        readonly colorLoop: import("#types").BitFlag;
        readonly xy: import("#types").BitFlag;
        readonly colorTemperature: import("#types").BitFlag;
    };
    readonly attributes: {
        readonly remainingTime: import("#types").OptionalAttribute<number, any>;
        readonly driftCompensation: import("#types").OptionalAttribute<ColorControl.DriftCompensation, any>;
        readonly compensationText: import("#types").OptionalAttribute<string, any>;
        readonly colorMode: import("#types").Attribute<ColorControl.ColorMode, any>;
        readonly options: import("#types").WritableAttribute<TypeFromPartialBitSchema<{
            executeIfOff: import("#types").BitFlag;
        }>, any>;
        readonly numberOfPrimaries: import("#types").FixedAttribute<number | null, any>;
        readonly primary1X: import("#types").OptionalFixedAttribute<number, any>;
        readonly primary1Y: import("#types").OptionalFixedAttribute<number, any>;
        readonly primary1Intensity: import("#types").OptionalFixedAttribute<number | null, any>;
        readonly primary2X: import("#types").OptionalFixedAttribute<number, any>;
        readonly primary2Y: import("#types").OptionalFixedAttribute<number, any>;
        readonly primary2Intensity: import("#types").OptionalFixedAttribute<number | null, any>;
        readonly primary3X: import("#types").OptionalFixedAttribute<number, any>;
        readonly primary3Y: import("#types").OptionalFixedAttribute<number, any>;
        readonly primary3Intensity: import("#types").OptionalFixedAttribute<number | null, any>;
        readonly primary4X: import("#types").OptionalFixedAttribute<number, any>;
        readonly primary4Y: import("#types").OptionalFixedAttribute<number, any>;
        readonly primary4Intensity: import("#types").OptionalFixedAttribute<number | null, any>;
        readonly primary5X: import("#types").OptionalFixedAttribute<number, any>;
        readonly primary5Y: import("#types").OptionalFixedAttribute<number, any>;
        readonly primary5Intensity: import("#types").OptionalFixedAttribute<number | null, any>;
        readonly primary6X: import("#types").OptionalFixedAttribute<number, any>;
        readonly primary6Y: import("#types").OptionalFixedAttribute<number, any>;
        readonly primary6Intensity: import("#types").OptionalFixedAttribute<number | null, any>;
        readonly whitePointX: import("#types").OptionalWritableAttribute<number, any>;
        readonly whitePointY: import("#types").OptionalWritableAttribute<number, any>;
        readonly colorPointRx: import("#types").OptionalWritableAttribute<number, any>;
        readonly colorPointRy: import("#types").OptionalWritableAttribute<number, any>;
        readonly colorPointRIntensity: import("#types").OptionalWritableAttribute<number | null, any>;
        readonly colorPointGx: import("#types").OptionalWritableAttribute<number, any>;
        readonly colorPointGy: import("#types").OptionalWritableAttribute<number, any>;
        readonly colorPointGIntensity: import("#types").OptionalWritableAttribute<number | null, any>;
        readonly colorPointBx: import("#types").OptionalWritableAttribute<number, any>;
        readonly colorPointBy: import("#types").OptionalWritableAttribute<number, any>;
        readonly colorPointBIntensity: import("#types").OptionalWritableAttribute<number | null, any>;
        readonly enhancedColorMode: import("#types").Attribute<ColorControl.EnhancedColorMode, any>;
        readonly colorCapabilities: import("#types").Attribute<TypeFromPartialBitSchema<{
            hueSaturation: import("#types").BitFlag;
            enhancedHue: import("#types").BitFlag;
            colorLoop: import("#types").BitFlag;
            xy: import("#types").BitFlag;
            colorTemperature: import("#types").BitFlag;
        }>, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly hueSaturation: true;
        };
        readonly component: {
            readonly attributes: {
                readonly currentHue: import("#types").Attribute<number, any>;
                readonly currentSaturation: import("#types").Attribute<number, any>;
            };
            readonly commands: {
                readonly moveToHue: import("#types").Command<import("#types").TypeFromFields<{
                    hue: import("#types").FieldType<number>;
                    direction: import("#types").FieldType<ColorControl.Direction>;
                    transitionTime: import("#types").FieldType<number>;
                    optionsMask: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                    optionsOverride: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                }>, void, any>;
                readonly moveHue: import("#types").Command<import("#types").TypeFromFields<{
                    moveMode: import("#types").FieldType<ColorControl.MoveMode>;
                    rate: import("#types").FieldType<number>;
                    optionsMask: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                    optionsOverride: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                }>, void, any>;
                readonly stepHue: import("#types").Command<import("#types").TypeFromFields<{
                    stepMode: import("#types").FieldType<ColorControl.StepMode>;
                    stepSize: import("#types").FieldType<number>;
                    transitionTime: import("#types").FieldType<number>;
                    optionsMask: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                    optionsOverride: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                }>, void, any>;
                readonly moveToSaturation: import("#types").Command<import("#types").TypeFromFields<{
                    saturation: import("#types").FieldType<number>;
                    transitionTime: import("#types").FieldType<number>;
                    optionsMask: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                    optionsOverride: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                }>, void, any>;
                readonly moveSaturation: import("#types").Command<import("#types").TypeFromFields<{
                    moveMode: import("#types").FieldType<ColorControl.MoveMode>;
                    rate: import("#types").FieldType<number>;
                    optionsMask: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                    optionsOverride: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                }>, void, any>;
                readonly stepSaturation: import("#types").Command<import("#types").TypeFromFields<{
                    stepMode: import("#types").FieldType<ColorControl.StepMode>;
                    stepSize: import("#types").FieldType<number>;
                    transitionTime: import("#types").FieldType<number>;
                    optionsMask: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                    optionsOverride: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                }>, void, any>;
                readonly moveToHueAndSaturation: import("#types").Command<import("#types").TypeFromFields<{
                    hue: import("#types").FieldType<number>;
                    saturation: import("#types").FieldType<number>;
                    transitionTime: import("#types").FieldType<number>;
                    optionsMask: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                    optionsOverride: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly xy: true;
        };
        readonly component: {
            readonly attributes: {
                readonly currentX: import("#types").Attribute<number, any>;
                readonly currentY: import("#types").Attribute<number, any>;
            };
            readonly commands: {
                readonly moveToColor: import("#types").Command<import("#types").TypeFromFields<{
                    colorX: import("#types").FieldType<number>;
                    colorY: import("#types").FieldType<number>;
                    transitionTime: import("#types").FieldType<number>;
                    optionsMask: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                    optionsOverride: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                }>, void, any>;
                readonly moveColor: import("#types").Command<import("#types").TypeFromFields<{
                    rateX: import("#types").FieldType<number>;
                    rateY: import("#types").FieldType<number>;
                    optionsMask: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                    optionsOverride: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                }>, void, any>;
                readonly stepColor: import("#types").Command<import("#types").TypeFromFields<{
                    stepX: import("#types").FieldType<number>;
                    stepY: import("#types").FieldType<number>;
                    transitionTime: import("#types").FieldType<number>;
                    optionsMask: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                    optionsOverride: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly colorTemperature: true;
        };
        readonly component: {
            readonly attributes: {
                readonly colorTemperatureMireds: import("#types").Attribute<number, any>;
                readonly colorTempPhysicalMinMireds: import("#types").Attribute<number, any>;
                readonly colorTempPhysicalMaxMireds: import("#types").Attribute<number, any>;
                readonly coupleColorTempToLevelMinMireds: import("#types").OptionalAttribute<number, any>;
                readonly startUpColorTemperatureMireds: import("#types").OptionalWritableAttribute<number | null, any>;
            };
            readonly commands: {
                readonly moveToColorTemperature: import("#types").Command<import("#types").TypeFromFields<{
                    colorTemperatureMireds: import("#types").FieldType<number>;
                    transitionTime: import("#types").FieldType<number>;
                    optionsMask: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                    optionsOverride: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                }>, void, any>;
                readonly moveColorTemperature: import("#types").Command<import("#types").TypeFromFields<{
                    moveMode: import("#types").FieldType<ColorControl.MoveMode>;
                    rate: import("#types").FieldType<number>;
                    colorTemperatureMinimumMireds: import("#types").FieldType<number>;
                    colorTemperatureMaximumMireds: import("#types").FieldType<number>;
                    optionsMask: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                    optionsOverride: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                }>, void, any>;
                readonly stepColorTemperature: import("#types").Command<import("#types").TypeFromFields<{
                    stepMode: import("#types").FieldType<ColorControl.StepMode>;
                    stepSize: import("#types").FieldType<number>;
                    transitionTime: import("#types").FieldType<number>;
                    colorTemperatureMinimumMireds: import("#types").FieldType<number>;
                    colorTemperatureMaximumMireds: import("#types").FieldType<number>;
                    optionsMask: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                    optionsOverride: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly enhancedHue: true;
        };
        readonly component: {
            readonly attributes: {
                readonly enhancedCurrentHue: import("#types").Attribute<number, any>;
            };
            readonly commands: {
                readonly enhancedMoveToHue: import("#types").Command<import("#types").TypeFromFields<{
                    enhancedHue: import("#types").FieldType<number>;
                    direction: import("#types").FieldType<ColorControl.Direction>;
                    transitionTime: import("#types").FieldType<number>;
                    optionsMask: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                    optionsOverride: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                }>, void, any>;
                readonly enhancedMoveHue: import("#types").Command<import("#types").TypeFromFields<{
                    moveMode: import("#types").FieldType<ColorControl.MoveMode>;
                    rate: import("#types").FieldType<number>;
                    optionsMask: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                    optionsOverride: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                }>, void, any>;
                readonly enhancedStepHue: import("#types").Command<import("#types").TypeFromFields<{
                    stepMode: import("#types").FieldType<ColorControl.StepMode>;
                    stepSize: import("#types").FieldType<number>;
                    transitionTime: import("#types").FieldType<number>;
                    optionsMask: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                    optionsOverride: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                }>, void, any>;
                readonly enhancedMoveToHueAndSaturation: import("#types").Command<import("#types").TypeFromFields<{
                    enhancedHue: import("#types").FieldType<number>;
                    saturation: import("#types").FieldType<number>;
                    transitionTime: import("#types").FieldType<number>;
                    optionsMask: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                    optionsOverride: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly colorLoop: true;
        };
        readonly component: {
            readonly attributes: {
                readonly colorLoopActive: import("#types").Attribute<ColorControl.ColorLoopActive, any>;
                readonly colorLoopDirection: import("#types").Attribute<ColorControl.ColorLoopDirection, any>;
                readonly colorLoopTime: import("#types").Attribute<number, any>;
                readonly colorLoopStartEnhancedHue: import("#types").Attribute<number, any>;
                readonly colorLoopStoredEnhancedHue: import("#types").Attribute<number, any>;
            };
            readonly commands: {
                readonly colorLoopSet: import("#types").Command<import("#types").TypeFromFields<{
                    updateFlags: import("#types").FieldType<TypeFromPartialBitSchema<{
                        updateAction: import("#types").BitFlag;
                        updateDirection: import("#types").BitFlag;
                        updateTime: import("#types").BitFlag;
                        updateStartHue: import("#types").BitFlag;
                    }>>;
                    action: import("#types").FieldType<ColorControl.ColorLoopAction>;
                    direction: import("#types").FieldType<ColorControl.ColorLoopDirection>;
                    time: import("#types").FieldType<number>;
                    startHue: import("#types").FieldType<number>;
                    optionsMask: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                    optionsOverride: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly hueSaturation: true;
        };
        readonly component: {
            readonly commands: {
                readonly stopMoveStep: import("#types").Command<import("#types").TypeFromFields<{
                    optionsMask: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                    optionsOverride: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly xy: true;
        };
        readonly component: {
            readonly commands: {
                readonly stopMoveStep: import("#types").Command<import("#types").TypeFromFields<{
                    optionsMask: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                    optionsOverride: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly colorTemperature: true;
        };
        readonly component: {
            readonly commands: {
                readonly stopMoveStep: import("#types").Command<import("#types").TypeFromFields<{
                    optionsMask: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                    optionsOverride: import("#types").FieldType<TypeFromPartialBitSchema<{
                        executeIfOff: import("#types").BitFlag;
                    }>>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly enhancedHue: true;
            readonly hueSaturation: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly colorLoop: true;
            readonly enhancedHue: false;
        };
        readonly component: false;
    }];
}>, typeof ColorControlBaseServer, import("./ColorControlInterface.js").ColorControlInterface>;
export declare class ColorControlServer extends ColorControlServer_base {
}
export {};
//# sourceMappingURL=ColorControlServer.d.ts.map