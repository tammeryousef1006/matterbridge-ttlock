"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ColorConversionUtils_exports = {};
__export(ColorConversionUtils_exports, {
  hsvToMireds: () => hsvToMireds,
  hsvToRgb: () => hsvToRgb,
  hsvToXy: () => hsvToXy,
  kelvinToMireds: () => kelvinToMireds,
  miredsToHsv: () => miredsToHsv,
  miredsToKelvin: () => miredsToKelvin,
  miredsToXy: () => miredsToXy,
  rgbToHsv: () => rgbToHsv,
  rgbToXy: () => rgbToXy,
  xyToHsv: () => xyToHsv,
  xyToMireds: () => xyToMireds,
  xyToRgb: () => xyToRgb
});
module.exports = __toCommonJS(ColorConversionUtils_exports);
var import_general = require("#general");
var import_kelvinToXy = require("./kelvinToXy.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
function hsvToXy(hue, saturation) {
  const [r, g, b] = hsvToRgb(hue, saturation);
  const [x, y] = rgbToXy(r, g, b);
  return [(0, import_general.cropValueRange)(x, 0, 1), (0, import_general.cropValueRange)(y, 0, 1)];
}
function xyToHsv(x, y) {
  const [r, g, b] = xyToRgb(x, y);
  const [h, s] = rgbToHsv(r, g, b);
  return [h, s];
}
function hsvToMireds(hue, saturation) {
  const [x, y] = hsvToXy(hue, saturation);
  return xyToMireds(x, y);
}
function miredsToHsv(mireds) {
  const [x, y] = miredsToXy(mireds) ?? [-1, -1];
  if (x === -1 || y === -1) {
    return void 0;
  }
  return xyToHsv(x, y);
}
function hsvToRgb(h, s, v = 1) {
  h = h / 360;
  let r;
  let g;
  let b;
  const i = Math.floor(h * 6);
  const f = h * 6 - i;
  const p = v * (1 - s);
  const q = v * (1 - f * s);
  const t = v * (1 - (1 - f) * s);
  switch (i % 6) {
    case 0:
      r = v;
      g = t;
      b = p;
      break;
    case 1:
      r = q;
      g = v;
      b = p;
      break;
    case 2:
      r = p;
      g = v;
      b = t;
      break;
    case 3:
      r = p;
      g = q;
      b = v;
      break;
    case 4:
      r = t;
      g = p;
      b = v;
      break;
    case 5:
    default:
      r = v;
      g = p;
      b = q;
  }
  return [r, g, b];
}
function rgbToHsv(r, g, b) {
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const d = max - min;
  let h;
  const s = max === 0 ? 0 : d / max;
  const v = max;
  switch (max) {
    case min:
      h = 0;
      break;
    case r:
      h = g - b + d * (g < b ? 6 : 0);
      h /= 6 * d;
      break;
    case g:
      h = b - r + d * 2;
      h /= 6 * d;
      break;
    case b:
    default:
      h = r - g + d * 4;
      h /= 6 * d;
      break;
  }
  return [h * 360, s, v];
}
function rgbToXy(r, g, b) {
  r = r > 0.04045 ? Math.pow((r + 0.055) / (1 + 0.055), 2.4) : r / 12.92;
  g = g > 0.04045 ? Math.pow((g + 0.055) / (1 + 0.055), 2.4) : g / 12.92;
  b = b > 0.04045 ? Math.pow((b + 0.055) / (1 + 0.055), 2.4) : b / 12.92;
  const X = r * 0.664511 + g * 0.154324 + b * 0.162028;
  const Y = r * 0.283881 + g * 0.668433 + b * 0.047685;
  const Z = r * 88e-6 + g * 0.07231 + b * 0.986039;
  const sum = X + Y + Z;
  const retX = sum == 0 ? 0 : X / sum;
  const retY = sum == 0 ? 0 : Y / sum;
  return [retX, retY];
}
function xyToRgb(x, y) {
  const brightness = 254;
  y = y === 0 ? 1e-11 : y;
  const z = 1 - x - y;
  const Y = Number((brightness / 254).toFixed(2));
  const X = Y / y * x;
  const Z = Y / y * z;
  let rgb = [
    X * 1.656492 - Y * 0.354851 - Z * 0.255038,
    -X * 0.707196 + Y * 1.655397 + Z * 0.036152,
    X * 0.051713 - Y * 0.121364 + Z * 1.01153
  ];
  rgb = rgb.map((x2) => x2 <= 31308e-7 ? 12.92 * x2 : (1 + 0.055) * Math.pow(x2, 1 / 2.4) - 0.055);
  rgb = rgb.map((x2) => Math.max(0, x2));
  const max = Math.max(...rgb);
  if (max > 1) {
    rgb = rgb.map((x2) => x2 / max);
  }
  rgb = rgb.map((x2) => isNaN(x2) || x2 < 0 ? 0 : x2);
  return [rgb[0], rgb[1], rgb[2]];
}
function miredsToKelvin(mireds) {
  return Math.round(1e6 / mireds);
}
function kelvinToMireds(kelvin) {
  return Math.round(1e6 / kelvin);
}
function xyToMireds(x, y) {
  const n = (x - 0.332) / (0.1858 - y);
  const kelvin = Math.abs(437 * Math.pow(n, 3) + 3601 * Math.pow(n, 2) + 6861 * n + 5517);
  return kelvinToMireds(kelvin);
}
function miredsToXy(mireds) {
  const kelvin = miredsToKelvin(mireds);
  const detailedValue = (0, import_kelvinToXy.kelvinToXyLookup)(kelvin);
  if (detailedValue !== void 0) {
    return [detailedValue.x, detailedValue.y];
  }
}
//# sourceMappingURL=ColorConversionUtils.js.map
