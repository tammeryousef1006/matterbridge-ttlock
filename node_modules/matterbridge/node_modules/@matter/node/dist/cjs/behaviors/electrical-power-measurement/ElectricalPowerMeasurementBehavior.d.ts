/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
/*** THIS FILE IS GENERATED, DO NOT EDIT ***/
import { ElectricalPowerMeasurement } from "#clusters/electrical-power-measurement";
import { ClusterBehavior } from "../../behavior/cluster/ClusterBehavior.js";
import { ClusterType } from "#types";
/**
 * ElectricalPowerMeasurementBehavior is the base class for objects that support interaction with
 * {@link ElectricalPowerMeasurement.Cluster}.
 *
 * ElectricalPowerMeasurement.Cluster requires you to enable one or more optional features. You can do so using
 * {@link ElectricalPowerMeasurementBehavior.with}.
 */
export declare const ElectricalPowerMeasurementBehavior: ClusterBehavior.Type<ClusterType.Of<{
    readonly id: 144;
    readonly name: "ElectricalPowerMeasurement";
    readonly revision: 1;
    readonly features: {
        readonly directCurrent: import("#types").BitFlag;
        readonly alternatingCurrent: import("#types").BitFlag;
        readonly polyphasePower: import("#types").BitFlag;
        readonly harmonics: import("#types").BitFlag;
        readonly powerQuality: import("#types").BitFlag;
    };
    readonly attributes: {
        readonly powerMode: import("#types").Attribute<ElectricalPowerMeasurement.PowerMode, any>;
        readonly numberOfMeasurementTypes: import("#types").FixedAttribute<number, any>;
        readonly accuracy: import("#types").FixedAttribute<import("#types").TypeFromFields<{
            measurementType: import("#types").FieldType<import("#types").MeasurementType>;
            measured: import("#types").FieldType<boolean>;
            minMeasuredValue: import("#types").FieldType<number | bigint>;
            maxMeasuredValue: import("#types").FieldType<number | bigint>;
            accuracyRanges: import("#types").FieldType<import("#types").TypeFromFields<{
                rangeMin: import("#types").FieldType<number | bigint>;
                rangeMax: import("#types").FieldType<number | bigint>;
                percentMax: import("#types").OptionalFieldType<number>;
                percentMin: import("#types").OptionalFieldType<number>;
                percentTypical: import("#types").OptionalFieldType<number>;
                fixedMax: import("#types").OptionalFieldType<number | bigint>;
                fixedMin: import("#types").OptionalFieldType<number | bigint>;
                fixedTypical: import("#types").OptionalFieldType<number | bigint>;
            }>[]>;
        }>[], any>;
        readonly ranges: import("#types").OptionalAttribute<import("#types").TypeFromFields<{
            measurementType: import("#types").FieldType<import("#types").MeasurementType>;
            min: import("#types").FieldType<number | bigint>;
            max: import("#types").FieldType<number | bigint>;
            startTimestamp: import("#types").OptionalFieldType<number>;
            endTimestamp: import("#types").OptionalFieldType<number>;
            minTimestamp: import("#types").OptionalFieldType<number>;
            maxTimestamp: import("#types").OptionalFieldType<number>;
            startSystime: import("#types").OptionalFieldType<number | bigint>;
            endSystime: import("#types").OptionalFieldType<number | bigint>;
            minSystime: import("#types").OptionalFieldType<number | bigint>;
            maxSystime: import("#types").OptionalFieldType<number | bigint>;
        }>[], any>;
        readonly voltage: import("#types").OptionalAttribute<number | bigint | null, any>;
        readonly activeCurrent: import("#types").OptionalAttribute<number | bigint | null, any>;
        readonly activePower: import("#types").Attribute<number | bigint | null, any>;
    };
    readonly events: {
        readonly measurementPeriodRanges: import("#types").OptionalEvent<import("#types").TypeFromFields<{
            ranges: import("#types").FieldType<import("#types").TypeFromFields<{
                measurementType: import("#types").FieldType<import("#types").MeasurementType>;
                min: import("#types").FieldType<number | bigint>;
                max: import("#types").FieldType<number | bigint>;
                startTimestamp: import("#types").OptionalFieldType<number>;
                endTimestamp: import("#types").OptionalFieldType<number>;
                minTimestamp: import("#types").OptionalFieldType<number>;
                maxTimestamp: import("#types").OptionalFieldType<number>;
                startSystime: import("#types").OptionalFieldType<number | bigint>;
                endSystime: import("#types").OptionalFieldType<number | bigint>;
                minSystime: import("#types").OptionalFieldType<number | bigint>;
                maxSystime: import("#types").OptionalFieldType<number | bigint>;
            }>[]>;
        }>, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly alternatingCurrent: true;
        };
        readonly component: {
            readonly attributes: {
                readonly reactiveCurrent: import("#types").OptionalAttribute<number | bigint | null, any>;
                readonly apparentCurrent: import("#types").OptionalAttribute<number | bigint | null, any>;
                readonly reactivePower: import("#types").OptionalAttribute<number | bigint | null, any>;
                readonly apparentPower: import("#types").OptionalAttribute<number | bigint | null, any>;
                readonly rmsVoltage: import("#types").OptionalAttribute<number | bigint | null, any>;
                readonly rmsCurrent: import("#types").OptionalAttribute<number | bigint | null, any>;
                readonly rmsPower: import("#types").OptionalAttribute<number | bigint | null, any>;
                readonly frequency: import("#types").OptionalAttribute<number | bigint | null, any>;
                readonly powerFactor: import("#types").OptionalAttribute<number | bigint | null, any>;
            };
        };
    }, {
        readonly flags: {
            readonly harmonics: true;
        };
        readonly component: {
            readonly attributes: {
                readonly harmonicCurrents: import("#types").Attribute<import("#types").TypeFromFields<{
                    order: import("#types").FieldType<number>;
                    measurement: import("#types").FieldType<number | bigint | null>;
                }>[] | null, any>;
            };
        };
    }, {
        readonly flags: {
            readonly powerQuality: true;
        };
        readonly component: {
            readonly attributes: {
                readonly harmonicPhases: import("#types").Attribute<import("#types").TypeFromFields<{
                    order: import("#types").FieldType<number>;
                    measurement: import("#types").FieldType<number | bigint | null>;
                }>[] | null, any>;
            };
        };
    }, {
        readonly flags: {
            readonly polyphasePower: true;
        };
        readonly component: {
            readonly attributes: {
                readonly neutralCurrent: import("#types").OptionalAttribute<number | bigint | null, any>;
            };
        };
    }, {
        readonly flags: {
            readonly polyphasePower: true;
            readonly alternatingCurrent: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly harmonics: true;
            readonly alternatingCurrent: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly powerQuality: true;
            readonly alternatingCurrent: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly directCurrent: false;
            readonly alternatingCurrent: false;
        };
        readonly component: false;
    }];
}>, typeof ClusterBehavior, {
    components: never[];
}>;
type ElectricalPowerMeasurementBehaviorType = InstanceType<typeof ElectricalPowerMeasurementBehavior>;
export interface ElectricalPowerMeasurementBehavior extends ElectricalPowerMeasurementBehaviorType {
}
type StateType = InstanceType<typeof ElectricalPowerMeasurementBehavior.State>;
export declare namespace ElectricalPowerMeasurementBehavior {
    interface State extends StateType {
    }
}
export {};
//# sourceMappingURL=ElectricalPowerMeasurementBehavior.d.ts.map