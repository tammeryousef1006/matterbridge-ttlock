/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { ActionContext } from "#behavior/context/ActionContext.js";
import { Behavior } from "#behavior/index.js";
import { Transitions } from "#behavior/Transitions.js";
import { LevelControl } from "#clusters/level-control";
import { Endpoint } from "#endpoint/index.js";
import { AsyncObservable, MaybePromise } from "#general";
import { Val } from "#protocol";
import { TypeFromPartialBitSchema } from "#types";
import { ClusterType } from "@matter/types";
declare const LevelControlBase: import("#behavior/index.js").ClusterBehavior.Type<import("#types").ClusterComposer.WithFeatures<LevelControl.Cluster, readonly [LevelControl.Feature.OnOff, LevelControl.Feature.Lighting]>, import("#behavior/index.js").ClusterBehavior.Type<LevelControl.Cluster, import("#behavior/index.js").ClusterBehavior.Type<ClusterType.Of<{
    readonly id: 0;
    readonly revision: 0;
    readonly name: "Unknown";
    readonly attributes: {};
    readonly commands: {};
    readonly events: {};
}>, typeof import("#behavior/index.js").ClusterBehavior, import("./LevelControlInterface.js").LevelControlInterface>, import("./LevelControlInterface.js").LevelControlInterface>, import("./LevelControlInterface.js").LevelControlInterface>;
/**
 * This is the default server implementation of {@link LevelControlBehavior}.
 *
 * You should use {@link LevelControlServer.with} to specialize the class for the features your implementation supports.
 *
 * This implementation includes all features of {@link LevelControl.Cluster} and all mandatory commands. It also handles
 * the OnOff cluster dependency and the ColorControl dependency as defined by the Matter specification.
 *
 * By default, this implementation ignores transition times and sets levels immediately.  You can set
 * {@link LevelControl.State#managedTransitionTimeHandling} to enable higher-level logic in Matter.js to manage level
 * changes.
 *
 * If your hardware supports transitions natively, you may override {@link createTransitions} to return a
 * {@link Transitions} implementation adapted to your hardware.  This allows matter.js to handle Matter requirements
 * such as remaining time and level reporting.
 *
 * Alternatively, you may override the following methods in this class to implement lower-level logic yourself.
 * Implementing a cluster in this way will disable much of the logic matter.js implements for you in the default
 * implementations.
 *
 * * {@link LevelControlBaseServer.moveToLevelLogic} moves the value to a defined level with a transition time
 * * {@link LevelControlBaseServer.moveLogic} moves the value up or down with a defined rate
 * * {@link LevelControlBaseServer.stepLogic} steps the value up or down with a defined step size and transition
 * * {@link LevelControlBaseServer.stopLogic} stops any currently running transitions
 * * {@link LevelControlBaseServer.couple} couples the current level with other clusters (e.g. ColorControl)
 * * {@link LevelControlBaseServer.handleOnOffChange} transition to onLevel when device turns on or off
 *
 * All overridable methods may be implemented sync or async by returning a Promise.
 */
export declare class LevelControlBaseServer extends LevelControlBase {
    #private;
    protected internal: LevelControlBaseServer.Internal;
    state: LevelControlBaseServer.State;
    events: LevelControlBaseServer.Events;
    /** Returns the minimum level, including feature specific fallback value handling. */
    get minLevel(): number;
    /** Returns the maximum level, including feature specific fallback value handling. */
    get maxLevel(): number;
    /**
     * The current level value as number.
     *
     * Throws a StatusResponse Error when null.
     */
    get currentLevel(): number;
    initialize(): MaybePromise;
    /**
     * Create transition management instance.
     *
     * We manage transitions using {@link Transitions} if
     * {@link LevelControlBaseServer.State#managedTransitionTimeHandling} is true.
     *
     * You may override this method to replace the {@link Transitions} implementation customized for your application.
     * The provided configuration object is the default one used for Level Control transitions, but can be adjusted
     * if needed.
     */
    protected createTransitions<B extends Behavior>(config: Transitions.Configuration<B>): Transitions<B>;
    /**
     * Initialize lighting features.
     *
     * This only applies if the Level Control cluster has the "LT" feature enabled.
     */
    protected initializeLighting(): void;
    /**
     * Initialize On/Off cluster integration.
     *
     * This only applies if the Level Control cluster has the "OO" feature enabled.
     */
    protected initializeOnOff(): void;
    /**
     * Default command implementation.
     *
     * After checking input we use {@link moveToLevelLogic} method to set the level.  To replace the default logic,
     * override {@link moveToLevelLogic} which also implements {@link moveToLevelWithOnOff}.
     */
    moveToLevel({ level, transitionTime, optionsMask, optionsOverride, }: LevelControl.MoveToLevelRequest): MaybePromise;
    /**
     * Default command implementation.
     *
     * To replace this logic, override {@link moveToLevelLogic} whicih also implements {@link moveToLevel}.
     */
    moveToLevelWithOnOff({ level, transitionTime }: LevelControl.MoveToLevelRequest): MaybePromise;
    /**
     * Default "MoveToLevel" implementation.
     *
     * When a transition time is not null the implementation uses a step based logic to manage the move. It also checks
     * if the level is within min/max range and sets the level accordingly.
     *
     * @param level Level to set
     * @param transitionTime transition time
     * @param withOnOff true if the method is called by a "WithOnOff" command variant
     * @param options Options for the command
     */
    protected moveToLevelLogic(level: number, transitionTime: number | null, withOnOff: boolean, options?: TypeFromPartialBitSchema<typeof LevelControl.Options>): MaybePromise;
    /**
     * Default command implementation.
     *
     * After checking input we use {@link moveLogic} method to set the level.
     *
     * To replace default behavior, override {@link moveLogic} which also implements {@link moveWithOnOff}.
     */
    move({ moveMode, rate, optionsMask, optionsOverride }: LevelControl.MoveRequest): MaybePromise;
    /**
     * Default command implementation.
     *
     * We use {@link moveLogic} method to set the level.
     *
     * To replace default behavior, override {@link moveLogic} which also implements {@link move}.
     */
    moveWithOnOff({ moveMode, rate }: LevelControl.MoveRequest): MaybePromise;
    /**
     * Default implementation of the "Move" commands.
     *
     * When move rate is null and there is no default move rate, we move to to the min or max level directly. Otherwise
     * we apply step logic and increase or decrease by step size for every step.
     *
     * @param moveMode Mode (Up/Down) of the move action
     * @param rate Rate of the move action, null if no rate is provided and the default should be used
     * @param withOnOff true if the method is called by a *WithOnOff command
     * @param options Options for the command
     */
    protected moveLogic(moveMode: LevelControl.MoveMode, rate: number | null, withOnOff: boolean, options?: TypeFromPartialBitSchema<typeof LevelControl.Options>): MaybePromise;
    /**
     * Default command implementation.
     *
     * After checking options we use {@link stepLogic} to set the level.
     *
     * To replace default beahavior, override {@link stepLogic} which also implements {@link stepWithOnOff}.
     */
    step({ stepMode, stepSize, transitionTime, optionsMask, optionsOverride, }: LevelControl.StepRequest): MaybePromise;
    /**
     * Default command implementation.
     *
     * To replace default beahavior, override {@link stepLogic} which also implements {@link step}.
     */
    stepWithOnOff({ stepMode, stepSize, transitionTime }: LevelControl.StepRequest): MaybePromise;
    /**
     * Default step implementation.
     *
     * When transition time is null, we move immediately to the min or max level. Otherwise we increase or decrease the
     * level by the step size for each step.
     *
     * @param stepMode Mode (Up/Down) of the step action
     * @param stepSize Size of the step action
     * @param transitionTime Time of the step action in 10th of a second
     * @param withOnOff true if the method is called by a *WithOnOff command
     * @param options Options for the command
     */
    protected stepLogic(stepMode: LevelControl.StepMode, stepSize: number, transitionTime: number | null, withOnOff: boolean, options?: TypeFromPartialBitSchema<typeof LevelControl.Options>): MaybePromise;
    stop({ optionsMask, optionsOverride }: LevelControl.StopRequest): MaybePromise;
    stopWithOnOff(request: LevelControl.StopRequest): MaybePromise;
    /**
     * Default stop logic. This aborts any level transition currently underway and sets the remaining time to 0.
     */
    protected stopLogic(_options?: TypeFromPartialBitSchema<typeof LevelControl.Options>): MaybePromise;
    /**
     * Change to a designated level.
     *
     * @param targetLevel the new level once transition completes; if omitted transition will stop at min or max value
     * @param changePerS the move rate; 0 or nullish means transition instantly
     * @param withOnOff if true follows rules for On/Off command variants
     * @param options additional options supplied by the client
     */
    protected transition(targetLevel?: number, changePerS?: number | null, withOnOff?: boolean, options?: TypeFromPartialBitSchema<typeof LevelControl.Options>): MaybePromise;
    /**
     * Configure the current transaction to synchronize state with other clusters.
     *
     * This handles of on/off state in the On/Off cluster and color temperature in the Color Control cluster.
     */
    couple(withOnOff: boolean, options?: TypeFromPartialBitSchema<typeof LevelControl.Options>, targetLevel?: number): MaybePromise;
    /**
     * Implement mandatory interaction with the OnOff cluster on the same endpoint when "OnOff" feature is enabled
     *
     * By default we set the current level to the onLevel value when the device is turned on.
     *
     * Other fading up/down logic required by the {@link MatterSpecification.v12.Cluster} ยง1.6.4.1.1 needs to be
     * implemented in a specialized implementation if needed.
     *
     * @param onOff The new onOff state
     */
    protected handleOnOffChange(onOff: boolean): MaybePromise;
    [Symbol.asyncDispose](): Promise<void>;
}
export declare namespace LevelControlBaseServer {
    class Internal {
        /**
         * Transition management.
         */
        transitions?: Transitions<LevelControlBaseServer>;
    }
    class State extends LevelControlBase.State {
        /**
         * The default implementation always set the target level immediately and so ignores all transition times
         * requested or configured.
         *
         * Set this to true to manage transition changes using {@link Transitions}.  You should only use this if your
         * hardware doesn't support transition management on its own.
         */
        managedTransitionTimeHandling: boolean;
        /**
         * If transition management is disabled you may specify this as the "end time" for transitions.  The remaining
         * time attribute will then report correctly.
         */
        transitionEndTimeMs: undefined;
        /**
         * When managing transitions, this is the interval at which steps occur in ms.
         */
        transitionStepIntervalMs: number;
        [Val.properties](endpoint: Endpoint): {
            get remainingTime(): number;
            set remainingTime(value: number);
        } | {
            remainingTime: number;
        };
    }
    class Events extends LevelControlBase.Events {
        transitionEndTime$Changed: AsyncObservable<[value: number, oldValue: number, context: ActionContext], void>;
    }
    const ExtensionInterface: {
        moveToLevelLogic(level: number, transitionTime: number | null, withOnOff: boolean, options: TypeFromPartialBitSchema<typeof LevelControl.Options>): MaybePromise;
        moveLogic(moveMode: LevelControl.MoveMode, rate: number | null, withOnOff: boolean, options: TypeFromPartialBitSchema<typeof LevelControl.Options>): MaybePromise;
        stepLogic(stepMode: LevelControl.StepMode, stepSize: number, transitionTime: number | null, withOnOff: boolean, options: TypeFromPartialBitSchema<typeof LevelControl.Options>): MaybePromise;
        stopLogic(options: TypeFromPartialBitSchema<typeof LevelControl.Options>): MaybePromise;
        couple(withOnOff: boolean, options: TypeFromPartialBitSchema<typeof LevelControl.Options>): MaybePromise;
        handleOnOffChange(onOff: boolean): MaybePromise;
        createTransitions<B extends Behavior>(config: Transitions.Configuration<B>): Transitions<B>;
    };
}
declare const LevelControlServer_base: import("#behavior/index.js").ClusterBehavior.Type<ClusterType.Of<{
    readonly id: 8;
    readonly name: "LevelControl";
    readonly revision: 6;
    readonly features: {
        readonly onOff: import("#types").BitFlag;
        readonly lighting: import("#types").BitFlag;
        readonly frequency: import("#types").BitFlag;
    };
    readonly attributes: {
        readonly currentLevel: import("#types").Attribute<number | null, any>;
        readonly maxLevel: import("#types").OptionalAttribute<number, any>;
        readonly options: import("#types").WritableAttribute<TypeFromPartialBitSchema<{
            executeIfOff: import("#types").BitFlag;
            coupleColorTempToLevel: import("#types").BitFlag;
        }>, any>;
        readonly onOffTransitionTime: import("#types").OptionalWritableAttribute<number, any>;
        readonly onLevel: import("#types").WritableAttribute<number | null, any>;
        readonly onTransitionTime: import("#types").OptionalWritableAttribute<number | null, any>;
        readonly offTransitionTime: import("#types").OptionalWritableAttribute<number | null, any>;
        readonly defaultMoveRate: import("#types").OptionalWritableAttribute<number | null, any>;
    };
    readonly commands: {
        readonly moveToLevel: import("#types").Command<import("#types").TypeFromFields<{
            level: import("#types").FieldType<number>;
            transitionTime: import("#types").FieldType<number | null>;
            optionsMask: import("#types").FieldType<TypeFromPartialBitSchema<{
                executeIfOff: import("#types").BitFlag;
                coupleColorTempToLevel: import("#types").BitFlag;
            }>>;
            optionsOverride: import("#types").FieldType<TypeFromPartialBitSchema<{
                executeIfOff: import("#types").BitFlag;
                coupleColorTempToLevel: import("#types").BitFlag;
            }>>;
        }>, void, any>;
        readonly move: import("#types").Command<import("#types").TypeFromFields<{
            moveMode: import("#types").FieldType<LevelControl.MoveMode>;
            rate: import("#types").FieldType<number | null>;
            optionsMask: import("#types").FieldType<TypeFromPartialBitSchema<{
                executeIfOff: import("#types").BitFlag;
                coupleColorTempToLevel: import("#types").BitFlag;
            }>>;
            optionsOverride: import("#types").FieldType<TypeFromPartialBitSchema<{
                executeIfOff: import("#types").BitFlag;
                coupleColorTempToLevel: import("#types").BitFlag;
            }>>;
        }>, void, any>;
        readonly step: import("#types").Command<import("#types").TypeFromFields<{
            stepMode: import("#types").FieldType<LevelControl.StepMode>;
            stepSize: import("#types").FieldType<number>;
            transitionTime: import("#types").FieldType<number | null>;
            optionsMask: import("#types").FieldType<TypeFromPartialBitSchema<{
                executeIfOff: import("#types").BitFlag;
                coupleColorTempToLevel: import("#types").BitFlag;
            }>>;
            optionsOverride: import("#types").FieldType<TypeFromPartialBitSchema<{
                executeIfOff: import("#types").BitFlag;
                coupleColorTempToLevel: import("#types").BitFlag;
            }>>;
        }>, void, any>;
        readonly stop: import("#types").Command<import("#types").TypeFromFields<{
            optionsMask: import("#types").FieldType<TypeFromPartialBitSchema<{
                executeIfOff: import("#types").BitFlag;
                coupleColorTempToLevel: import("#types").BitFlag;
            }>>;
            optionsOverride: import("#types").FieldType<TypeFromPartialBitSchema<{
                executeIfOff: import("#types").BitFlag;
                coupleColorTempToLevel: import("#types").BitFlag;
            }>>;
        }>, void, any>;
        readonly moveToLevelWithOnOff: import("#types").Command<import("#types").TypeFromFields<{
            level: import("#types").FieldType<number>;
            transitionTime: import("#types").FieldType<number | null>;
            optionsMask: import("#types").FieldType<TypeFromPartialBitSchema<{
                executeIfOff: import("#types").BitFlag;
                coupleColorTempToLevel: import("#types").BitFlag;
            }>>;
            optionsOverride: import("#types").FieldType<TypeFromPartialBitSchema<{
                executeIfOff: import("#types").BitFlag;
                coupleColorTempToLevel: import("#types").BitFlag;
            }>>;
        }>, void, any>;
        readonly moveWithOnOff: import("#types").Command<import("#types").TypeFromFields<{
            moveMode: import("#types").FieldType<LevelControl.MoveMode>;
            rate: import("#types").FieldType<number | null>;
            optionsMask: import("#types").FieldType<TypeFromPartialBitSchema<{
                executeIfOff: import("#types").BitFlag;
                coupleColorTempToLevel: import("#types").BitFlag;
            }>>;
            optionsOverride: import("#types").FieldType<TypeFromPartialBitSchema<{
                executeIfOff: import("#types").BitFlag;
                coupleColorTempToLevel: import("#types").BitFlag;
            }>>;
        }>, void, any>;
        readonly stepWithOnOff: import("#types").Command<import("#types").TypeFromFields<{
            stepMode: import("#types").FieldType<LevelControl.StepMode>;
            stepSize: import("#types").FieldType<number>;
            transitionTime: import("#types").FieldType<number | null>;
            optionsMask: import("#types").FieldType<TypeFromPartialBitSchema<{
                executeIfOff: import("#types").BitFlag;
                coupleColorTempToLevel: import("#types").BitFlag;
            }>>;
            optionsOverride: import("#types").FieldType<TypeFromPartialBitSchema<{
                executeIfOff: import("#types").BitFlag;
                coupleColorTempToLevel: import("#types").BitFlag;
            }>>;
        }>, void, any>;
        readonly stopWithOnOff: import("#types").Command<import("#types").TypeFromFields<{
            optionsMask: import("#types").FieldType<TypeFromPartialBitSchema<{
                executeIfOff: import("#types").BitFlag;
                coupleColorTempToLevel: import("#types").BitFlag;
            }>>;
            optionsOverride: import("#types").FieldType<TypeFromPartialBitSchema<{
                executeIfOff: import("#types").BitFlag;
                coupleColorTempToLevel: import("#types").BitFlag;
            }>>;
        }>, void, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly lighting: true;
        };
        readonly component: {
            readonly attributes: {
                readonly remainingTime: import("#types").Attribute<number, any>;
                readonly minLevel: import("#types").OptionalAttribute<number, any>;
                readonly startUpCurrentLevel: import("#types").WritableAttribute<number | null, any>;
            };
        };
    }, {
        readonly flags: {
            readonly lighting: false;
        };
        readonly component: {
            readonly attributes: {
                readonly minLevel: import("#types").OptionalAttribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly frequency: true;
        };
        readonly component: {
            readonly attributes: {
                readonly currentFrequency: import("#types").Attribute<number, any>;
                readonly minFrequency: import("#types").Attribute<number, any>;
                readonly maxFrequency: import("#types").Attribute<number, any>;
            };
            readonly commands: {
                readonly moveToClosestFrequency: import("#types").Command<import("#types").TypeFromFields<{
                    frequency: import("#types").FieldType<number>;
                }>, void, any>;
            };
        };
    }];
}>, typeof LevelControlBaseServer, import("./LevelControlInterface.js").LevelControlInterface>;
export declare class LevelControlServer extends LevelControlServer_base {
}
export {};
//# sourceMappingURL=LevelControlServer.d.ts.map