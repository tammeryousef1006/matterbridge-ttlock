/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
/*** THIS FILE IS GENERATED, DO NOT EDIT ***/
import { OccupancySensing } from "#clusters/occupancy-sensing";
import { ClusterBehavior } from "../../behavior/cluster/ClusterBehavior.js";
import { ClusterType } from "#types";
/**
 * OccupancySensingBehavior is the base class for objects that support interaction with
 * {@link OccupancySensing.Cluster}.
 *
 * OccupancySensing.Cluster requires you to enable one or more optional features. You can do so using
 * {@link OccupancySensingBehavior.with}.
 */
export declare const OccupancySensingBehavior: ClusterBehavior.Type<ClusterType.Of<{
    readonly id: 1030;
    readonly name: "OccupancySensing";
    readonly revision: 5;
    readonly features: {
        readonly other: import("#types").BitFlag;
        readonly passiveInfrared: import("#types").BitFlag;
        readonly ultrasonic: import("#types").BitFlag;
        readonly physicalContact: import("#types").BitFlag;
        readonly activeInfrared: import("#types").BitFlag;
        readonly radar: import("#types").BitFlag;
        readonly rfSensing: import("#types").BitFlag;
        readonly vision: import("#types").BitFlag;
    };
    readonly attributes: {
        readonly occupancy: import("#types").Attribute<import("#types").TypeFromPartialBitSchema<{
            occupied: import("#types").BitFlag;
        }>, any>;
        readonly occupancySensorType: import("#types").FixedAttribute<OccupancySensing.OccupancySensorType, any>;
        readonly occupancySensorTypeBitmap: import("#types").FixedAttribute<import("#types").TypeFromPartialBitSchema<{
            pir: import("#types").BitFlag;
            ultrasonic: import("#types").BitFlag;
            physicalContact: import("#types").BitFlag;
        }>, any>;
        readonly holdTime: import("#types").OptionalWritableAttribute<number, any>;
        readonly holdTimeLimits: import("#types").OptionalFixedAttribute<import("#types").TypeFromFields<{
            holdTimeMin: import("#types").FieldType<number>;
            holdTimeMax: import("#types").FieldType<number>;
            holdTimeDefault: import("#types").FieldType<number>;
        }>, any>;
    };
    readonly events: {
        readonly occupancyChanged: import("#types").OptionalEvent<import("#types").TypeFromFields<{
            occupancy: import("#types").FieldType<import("#types").TypeFromPartialBitSchema<{
                occupied: import("#types").BitFlag;
            }>>;
        }>, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly passiveInfrared: true;
        };
        readonly component: {
            readonly attributes: {
                readonly pirOccupiedToUnoccupiedDelay: import("#types").OptionalWritableAttribute<number, any>;
                readonly pirUnoccupiedToOccupiedDelay: import("#types").OptionalWritableAttribute<number, any>;
                readonly pirUnoccupiedToOccupiedThreshold: import("#types").OptionalWritableAttribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly ultrasonic: true;
        };
        readonly component: {
            readonly attributes: {
                readonly ultrasonicOccupiedToUnoccupiedDelay: import("#types").OptionalWritableAttribute<number, any>;
                readonly ultrasonicUnoccupiedToOccupiedDelay: import("#types").OptionalWritableAttribute<number, any>;
                readonly ultrasonicUnoccupiedToOccupiedThreshold: import("#types").OptionalWritableAttribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly physicalContact: true;
        };
        readonly component: {
            readonly attributes: {
                readonly physicalContactOccupiedToUnoccupiedDelay: import("#types").OptionalWritableAttribute<number, any>;
                readonly physicalContactUnoccupiedToOccupiedDelay: import("#types").OptionalWritableAttribute<number, any>;
                readonly physicalContactUnoccupiedToOccupiedThreshold: import("#types").OptionalWritableAttribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly other: false;
            readonly passiveInfrared: false;
            readonly ultrasonic: false;
            readonly physicalContact: false;
            readonly activeInfrared: false;
            readonly radar: false;
            readonly rfSensing: false;
            readonly vision: false;
        };
        readonly component: false;
    }];
}>, typeof ClusterBehavior, {
    components: never[];
}>;
type OccupancySensingBehaviorType = InstanceType<typeof OccupancySensingBehavior>;
export interface OccupancySensingBehavior extends OccupancySensingBehaviorType {
}
type StateType = InstanceType<typeof OccupancySensingBehavior.State>;
export declare namespace OccupancySensingBehavior {
    interface State extends StateType {
    }
}
export {};
//# sourceMappingURL=OccupancySensingBehavior.d.ts.map