/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { OnOff } from "#clusters/on-off";
import { MaybePromise, Timer } from "#general";
declare const OnOffLogicBase: import("../../index.js").ClusterBehavior.Type<import("@matter/types").ClusterComposer.WithFeatures<OnOff.Cluster, readonly [OnOff.Feature.Lighting]>, import("../../index.js").ClusterBehavior.Type<OnOff.Cluster, import("../../index.js").ClusterBehavior.Type<import("@matter/types").ClusterType.Of<{
    readonly id: 0;
    readonly revision: 0;
    readonly name: "Unknown";
    readonly attributes: {};
    readonly commands: {};
    readonly events: {};
}>, typeof import("../../index.js").ClusterBehavior, import("./OnOffInterface.js").OnOffInterface>, import("./OnOffInterface.js").OnOffInterface>, import("./OnOffInterface.js").OnOffInterface>;
/**
 * This is the default server implementation of {@link OnOffBehavior}.
 *
 * This implementation includes all features of {@link OnOff.Cluster}. You should use {@link OnOffServer.with} to
 * specialize the class for the features your implementation supports. Alternatively you can extend this class and
 * override the methods you need to change or add mandatory commands.
 *
 * The "OffOnly" and "Lighting" features are automatically supported because the commands are disabled by conformance.
 * The default implementation do not contain any logic for the DeadFrontBehavior feature because this is very use case
 * specific, so this needs to be implemented by the device implementor as needed.
 */
export declare class OnOffBaseServer extends OnOffLogicBase {
    #private;
    protected internal: OnOffBaseServer.Internal;
    initialize(): MaybePromise;
    [Symbol.asyncDispose](): Promise<void>;
    on(): MaybePromise;
    off(): MaybePromise;
    /**
     * Default implementation notes:
     * This method uses the on/off methods when timed actions should occur. This means that it is enough to override
     * on() and off() with custom control logic.
     */
    toggle(): MaybePromise;
    /**
     * Default implementation notes:
     * * This implementation ignores the effect and just calls off().
     * * Global Scene Control is not supported yet.
     */
    offWithEffect(): MaybePromise;
    /**
     * Default implementation notes:
     * * Global Scene Control is not supported yet, so the device is just turned on.
     */
    onWithRecallGlobalScene(): MaybePromise;
    /**
     * Default implementation notes:
     * * This method uses the on/off methods when timed actions should occur. This means that it is enough to override
     * on() and off() with custom control logic.
     */
    onWithTimedOff({ onOffControl, offWaitTime, onTime }: OnOff.OnWithTimedOffRequest): MaybePromise;
    protected get timedOnTimer(): Timer;
    protected get delayedOffTimer(): Timer;
}
export declare namespace OnOffBaseServer {
    class Internal {
        timedOnTimer?: Timer;
        delayedOffTimer?: Timer;
    }
}
declare const OnOffServer_base: import("../../index.js").ClusterBehavior.Type<import("@matter/types").ClusterComposer.WithFeatures<import("@matter/types").ClusterComposer.WithFeatures<OnOff.Cluster, readonly [OnOff.Feature.Lighting]>, readonly []>, typeof OnOffBaseServer, import("./OnOffInterface.js").OnOffInterface>;
export declare class OnOffServer extends OnOffServer_base {
}
export {};
//# sourceMappingURL=OnOffServer.d.ts.map