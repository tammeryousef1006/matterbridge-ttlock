/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { PowerTopology } from "#clusters/power-topology";
import { ClusterType, EndpointNumber } from "#types";
declare const PowerTopologyBase: import("../../index.js").ClusterBehavior.Type<import("#types").ClusterComposer.WithFeatures<ClusterType.Of<{
    readonly id: 156;
    readonly name: "PowerTopology";
    readonly revision: 1;
    readonly features: {
        readonly nodeTopology: import("#types").BitFlag;
        readonly treeTopology: import("#types").BitFlag;
        readonly setTopology: import("#types").BitFlag;
        readonly dynamicPowerFlow: import("#types").BitFlag;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly setTopology: true;
        };
        readonly component: {
            readonly attributes: {
                readonly availableEndpoints: import("#types").FixedAttribute<EndpointNumber[], any>;
            };
        };
    }, {
        readonly flags: {
            readonly dynamicPowerFlow: true;
        };
        readonly component: {
            readonly attributes: {
                readonly activeEndpoints: import("#types").Attribute<EndpointNumber[], any>;
            };
        };
    }, {
        readonly flags: {
            readonly dynamicPowerFlow: true;
            readonly setTopology: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly nodeTopology: true;
            readonly treeTopology: true;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly nodeTopology: true;
            readonly setTopology: true;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly treeTopology: true;
            readonly setTopology: true;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly nodeTopology: false;
            readonly treeTopology: false;
            readonly setTopology: false;
        };
        readonly component: false;
    }];
}>, readonly [PowerTopology.Feature.SetTopology, PowerTopology.Feature.DynamicPowerFlow]>, import("../../index.js").ClusterBehavior.Type<ClusterType.Of<{
    readonly id: 156;
    readonly name: "PowerTopology";
    readonly revision: 1;
    readonly features: {
        readonly nodeTopology: import("#types").BitFlag;
        readonly treeTopology: import("#types").BitFlag;
        readonly setTopology: import("#types").BitFlag;
        readonly dynamicPowerFlow: import("#types").BitFlag;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly setTopology: true;
        };
        readonly component: {
            readonly attributes: {
                readonly availableEndpoints: import("#types").FixedAttribute<EndpointNumber[], any>;
            };
        };
    }, {
        readonly flags: {
            readonly dynamicPowerFlow: true;
        };
        readonly component: {
            readonly attributes: {
                readonly activeEndpoints: import("#types").Attribute<EndpointNumber[], any>;
            };
        };
    }, {
        readonly flags: {
            readonly dynamicPowerFlow: true;
            readonly setTopology: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly nodeTopology: true;
            readonly treeTopology: true;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly nodeTopology: true;
            readonly setTopology: true;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly treeTopology: true;
            readonly setTopology: true;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly nodeTopology: false;
            readonly treeTopology: false;
            readonly setTopology: false;
        };
        readonly component: false;
    }];
}>, typeof import("../../index.js").ClusterBehavior, {
    components: never[];
}>, {
    components: never[];
}>;
/**
 * This is the default server implementation of {@link PowerTopologyBehavior}.
 *
 * The Matter specification requires the PowerTopology cluster to support features we do not enable by default. You
 * should use {@link PowerTopologyServer.with} to specialize the class for the features your implementation supports.
 *
 * The default implementation verifies that the active endpoints are a subset of the available endpoints when
 * the SetTopology and DynamicPowerFlow features are used.
 */
export declare class PowerTopologyBaseServer extends PowerTopologyBase {
    #private;
    initialize(): Promise<void>;
}
declare const PowerTopologyServer_base: import("../../index.js").ClusterBehavior.Type<ClusterType.Of<{
    readonly id: 156;
    readonly name: "PowerTopology";
    readonly revision: 1;
    readonly features: {
        readonly nodeTopology: import("#types").BitFlag;
        readonly treeTopology: import("#types").BitFlag;
        readonly setTopology: import("#types").BitFlag;
        readonly dynamicPowerFlow: import("#types").BitFlag;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly setTopology: true;
        };
        readonly component: {
            readonly attributes: {
                readonly availableEndpoints: import("#types").FixedAttribute<EndpointNumber[], any>;
            };
        };
    }, {
        readonly flags: {
            readonly dynamicPowerFlow: true;
        };
        readonly component: {
            readonly attributes: {
                readonly activeEndpoints: import("#types").Attribute<EndpointNumber[], any>;
            };
        };
    }, {
        readonly flags: {
            readonly dynamicPowerFlow: true;
            readonly setTopology: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly nodeTopology: true;
            readonly treeTopology: true;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly nodeTopology: true;
            readonly setTopology: true;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly treeTopology: true;
            readonly setTopology: true;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly nodeTopology: false;
            readonly treeTopology: false;
            readonly setTopology: false;
        };
        readonly component: false;
    }];
}>, typeof PowerTopologyBaseServer, {
    components: never[];
}>;
export declare class PowerTopologyServer extends PowerTopologyServer_base {
}
export {};
//# sourceMappingURL=PowerTopologyServer.d.ts.map