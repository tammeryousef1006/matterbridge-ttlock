/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
/*** THIS FILE IS GENERATED, DO NOT EDIT ***/
import { SmokeCoAlarm } from "#clusters/smoke-co-alarm";
import { ClusterBehavior } from "../../behavior/cluster/ClusterBehavior.js";
import { SmokeCoAlarmInterface } from "./SmokeCoAlarmInterface.js";
import { ClusterType } from "#types";
/**
 * SmokeCoAlarmBehavior is the base class for objects that support interaction with {@link SmokeCoAlarm.Cluster}.
 *
 * SmokeCoAlarm.Cluster requires you to enable one or more optional features. You can do so using
 * {@link SmokeCoAlarmBehavior.with}.
 */
export declare const SmokeCoAlarmBehavior: ClusterBehavior.Type<ClusterType.Of<{
    readonly id: 92;
    readonly name: "SmokeCoAlarm";
    readonly revision: 1;
    readonly features: {
        readonly smokeAlarm: import("#types").BitFlag;
        readonly coAlarm: import("#types").BitFlag;
    };
    readonly attributes: {
        readonly expressedState: import("#types").Attribute<SmokeCoAlarm.ExpressedState, any>;
        readonly batteryAlert: import("#types").Attribute<SmokeCoAlarm.AlarmState, any>;
        readonly deviceMuted: import("#types").OptionalAttribute<SmokeCoAlarm.MuteState, any>;
        readonly testInProgress: import("#types").Attribute<boolean, any>;
        readonly hardwareFaultAlert: import("#types").Attribute<boolean, any>;
        readonly endOfServiceAlert: import("#types").Attribute<SmokeCoAlarm.EndOfService, any>;
        readonly interconnectSmokeAlarm: import("#types").OptionalAttribute<SmokeCoAlarm.AlarmState, any>;
        readonly interconnectCoAlarm: import("#types").OptionalAttribute<SmokeCoAlarm.AlarmState, any>;
        readonly expiryDate: import("#types").OptionalFixedAttribute<number, any>;
    };
    readonly commands: {
        readonly selfTestRequest: import("#types").OptionalCommand<void, void, any>;
    };
    readonly events: {
        readonly lowBattery: import("#types").Event<import("#types").TypeFromFields<{
            alarmSeverityLevel: import("#types").FieldType<SmokeCoAlarm.AlarmState>;
        }>, any>;
        readonly hardwareFault: import("#types").Event<void, any>;
        readonly endOfService: import("#types").Event<void, any>;
        readonly selfTestComplete: import("#types").Event<void, any>;
        readonly alarmMuted: import("#types").OptionalEvent<void, any>;
        readonly muteEnded: import("#types").OptionalEvent<void, any>;
        readonly allClear: import("#types").Event<void, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly smokeAlarm: true;
        };
        readonly component: {
            readonly attributes: {
                readonly smokeState: import("#types").Attribute<SmokeCoAlarm.AlarmState, any>;
                readonly contaminationState: import("#types").OptionalAttribute<SmokeCoAlarm.ContaminationState, any>;
                readonly smokeSensitivityLevel: import("#types").OptionalWritableAttribute<SmokeCoAlarm.Sensitivity, any>;
            };
            readonly events: {
                readonly smokeAlarm: import("#types").Event<import("#types").TypeFromFields<{
                    alarmSeverityLevel: import("#types").FieldType<SmokeCoAlarm.AlarmState>;
                }>, any>;
                readonly interconnectSmokeAlarm: import("#types").OptionalEvent<import("#types").TypeFromFields<{
                    alarmSeverityLevel: import("#types").FieldType<SmokeCoAlarm.AlarmState>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly coAlarm: true;
        };
        readonly component: {
            readonly attributes: {
                readonly coState: import("#types").Attribute<SmokeCoAlarm.AlarmState, any>;
            };
            readonly events: {
                readonly coAlarm: import("#types").Event<import("#types").TypeFromFields<{
                    alarmSeverityLevel: import("#types").FieldType<SmokeCoAlarm.AlarmState>;
                }>, any>;
                readonly interconnectCoAlarm: import("#types").OptionalEvent<import("#types").TypeFromFields<{
                    alarmSeverityLevel: import("#types").FieldType<SmokeCoAlarm.AlarmState>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly smokeAlarm: false;
            readonly coAlarm: false;
        };
        readonly component: false;
    }];
}>, ClusterBehavior.Type<ClusterType.Of<{
    readonly id: 0;
    readonly revision: 0;
    readonly name: "Unknown";
    readonly attributes: {};
    readonly commands: {};
    readonly events: {};
}>, typeof ClusterBehavior, SmokeCoAlarmInterface>, SmokeCoAlarmInterface>;
type SmokeCoAlarmBehaviorType = InstanceType<typeof SmokeCoAlarmBehavior>;
export interface SmokeCoAlarmBehavior extends SmokeCoAlarmBehaviorType {
}
type StateType = InstanceType<typeof SmokeCoAlarmBehavior.State>;
export declare namespace SmokeCoAlarmBehavior {
    interface State extends StateType {
    }
}
export {};
//# sourceMappingURL=SmokeCoAlarmBehavior.d.ts.map