/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { SmokeCoAlarm } from "#clusters/smoke-co-alarm";
import { ClusterType } from "@matter/types";
declare const SmokeCoAlarmBase: import("../../index.js").ClusterBehavior.Type<import("@matter/types").ClusterComposer.WithFeatures<ClusterType.Of<{
    readonly id: 92;
    readonly name: "SmokeCoAlarm";
    readonly revision: 1;
    readonly features: {
        readonly smokeAlarm: import("@matter/types").BitFlag;
        readonly coAlarm: import("@matter/types").BitFlag;
    };
    readonly attributes: {
        readonly expressedState: import("@matter/types").Attribute<SmokeCoAlarm.ExpressedState, any>;
        readonly batteryAlert: import("@matter/types").Attribute<SmokeCoAlarm.AlarmState, any>;
        readonly deviceMuted: import("@matter/types").OptionalAttribute<SmokeCoAlarm.MuteState, any>;
        readonly testInProgress: import("@matter/types").Attribute<boolean, any>;
        readonly hardwareFaultAlert: import("@matter/types").Attribute<boolean, any>;
        readonly endOfServiceAlert: import("@matter/types").Attribute<SmokeCoAlarm.EndOfService, any>;
        readonly interconnectSmokeAlarm: import("@matter/types").OptionalAttribute<SmokeCoAlarm.AlarmState, any>;
        readonly interconnectCoAlarm: import("@matter/types").OptionalAttribute<SmokeCoAlarm.AlarmState, any>;
        readonly expiryDate: import("@matter/types").OptionalFixedAttribute<number, any>;
    };
    readonly commands: {
        readonly selfTestRequest: import("@matter/types").OptionalCommand<void, void, any>;
    };
    readonly events: {
        readonly lowBattery: import("@matter/types").Event<import("@matter/types").TypeFromFields<{
            alarmSeverityLevel: import("@matter/types").FieldType<SmokeCoAlarm.AlarmState>;
        }>, any>;
        readonly hardwareFault: import("@matter/types").Event<void, any>;
        readonly endOfService: import("@matter/types").Event<void, any>;
        readonly selfTestComplete: import("@matter/types").Event<void, any>;
        readonly alarmMuted: import("@matter/types").OptionalEvent<void, any>;
        readonly muteEnded: import("@matter/types").OptionalEvent<void, any>;
        readonly allClear: import("@matter/types").Event<void, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly smokeAlarm: true;
        };
        readonly component: {
            readonly attributes: {
                readonly smokeState: import("@matter/types").Attribute<SmokeCoAlarm.AlarmState, any>;
                readonly contaminationState: import("@matter/types").OptionalAttribute<SmokeCoAlarm.ContaminationState, any>;
                readonly smokeSensitivityLevel: import("@matter/types").OptionalWritableAttribute<SmokeCoAlarm.Sensitivity, any>;
            };
            readonly events: {
                readonly smokeAlarm: import("@matter/types").Event<import("@matter/types").TypeFromFields<{
                    alarmSeverityLevel: import("@matter/types").FieldType<SmokeCoAlarm.AlarmState>;
                }>, any>;
                readonly interconnectSmokeAlarm: import("@matter/types").OptionalEvent<import("@matter/types").TypeFromFields<{
                    alarmSeverityLevel: import("@matter/types").FieldType<SmokeCoAlarm.AlarmState>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly coAlarm: true;
        };
        readonly component: {
            readonly attributes: {
                readonly coState: import("@matter/types").Attribute<SmokeCoAlarm.AlarmState, any>;
            };
            readonly events: {
                readonly coAlarm: import("@matter/types").Event<import("@matter/types").TypeFromFields<{
                    alarmSeverityLevel: import("@matter/types").FieldType<SmokeCoAlarm.AlarmState>;
                }>, any>;
                readonly interconnectCoAlarm: import("@matter/types").OptionalEvent<import("@matter/types").TypeFromFields<{
                    alarmSeverityLevel: import("@matter/types").FieldType<SmokeCoAlarm.AlarmState>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly smokeAlarm: false;
            readonly coAlarm: false;
        };
        readonly component: false;
    }];
}>, readonly [SmokeCoAlarm.Feature.SmokeAlarm, SmokeCoAlarm.Feature.CoAlarm]>, import("../../index.js").ClusterBehavior.Type<ClusterType.Of<{
    readonly id: 92;
    readonly name: "SmokeCoAlarm";
    readonly revision: 1;
    readonly features: {
        readonly smokeAlarm: import("@matter/types").BitFlag;
        readonly coAlarm: import("@matter/types").BitFlag;
    };
    readonly attributes: {
        readonly expressedState: import("@matter/types").Attribute<SmokeCoAlarm.ExpressedState, any>;
        readonly batteryAlert: import("@matter/types").Attribute<SmokeCoAlarm.AlarmState, any>;
        readonly deviceMuted: import("@matter/types").OptionalAttribute<SmokeCoAlarm.MuteState, any>;
        readonly testInProgress: import("@matter/types").Attribute<boolean, any>;
        readonly hardwareFaultAlert: import("@matter/types").Attribute<boolean, any>;
        readonly endOfServiceAlert: import("@matter/types").Attribute<SmokeCoAlarm.EndOfService, any>;
        readonly interconnectSmokeAlarm: import("@matter/types").OptionalAttribute<SmokeCoAlarm.AlarmState, any>;
        readonly interconnectCoAlarm: import("@matter/types").OptionalAttribute<SmokeCoAlarm.AlarmState, any>;
        readonly expiryDate: import("@matter/types").OptionalFixedAttribute<number, any>;
    };
    readonly commands: {
        readonly selfTestRequest: import("@matter/types").OptionalCommand<void, void, any>;
    };
    readonly events: {
        readonly lowBattery: import("@matter/types").Event<import("@matter/types").TypeFromFields<{
            alarmSeverityLevel: import("@matter/types").FieldType<SmokeCoAlarm.AlarmState>;
        }>, any>;
        readonly hardwareFault: import("@matter/types").Event<void, any>;
        readonly endOfService: import("@matter/types").Event<void, any>;
        readonly selfTestComplete: import("@matter/types").Event<void, any>;
        readonly alarmMuted: import("@matter/types").OptionalEvent<void, any>;
        readonly muteEnded: import("@matter/types").OptionalEvent<void, any>;
        readonly allClear: import("@matter/types").Event<void, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly smokeAlarm: true;
        };
        readonly component: {
            readonly attributes: {
                readonly smokeState: import("@matter/types").Attribute<SmokeCoAlarm.AlarmState, any>;
                readonly contaminationState: import("@matter/types").OptionalAttribute<SmokeCoAlarm.ContaminationState, any>;
                readonly smokeSensitivityLevel: import("@matter/types").OptionalWritableAttribute<SmokeCoAlarm.Sensitivity, any>;
            };
            readonly events: {
                readonly smokeAlarm: import("@matter/types").Event<import("@matter/types").TypeFromFields<{
                    alarmSeverityLevel: import("@matter/types").FieldType<SmokeCoAlarm.AlarmState>;
                }>, any>;
                readonly interconnectSmokeAlarm: import("@matter/types").OptionalEvent<import("@matter/types").TypeFromFields<{
                    alarmSeverityLevel: import("@matter/types").FieldType<SmokeCoAlarm.AlarmState>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly coAlarm: true;
        };
        readonly component: {
            readonly attributes: {
                readonly coState: import("@matter/types").Attribute<SmokeCoAlarm.AlarmState, any>;
            };
            readonly events: {
                readonly coAlarm: import("@matter/types").Event<import("@matter/types").TypeFromFields<{
                    alarmSeverityLevel: import("@matter/types").FieldType<SmokeCoAlarm.AlarmState>;
                }>, any>;
                readonly interconnectCoAlarm: import("@matter/types").OptionalEvent<import("@matter/types").TypeFromFields<{
                    alarmSeverityLevel: import("@matter/types").FieldType<SmokeCoAlarm.AlarmState>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly smokeAlarm: false;
            readonly coAlarm: false;
        };
        readonly component: false;
    }];
}>, import("../../index.js").ClusterBehavior.Type<ClusterType.Of<{
    readonly id: 0;
    readonly revision: 0;
    readonly name: "Unknown";
    readonly attributes: {};
    readonly commands: {};
    readonly events: {};
}>, typeof import("../../index.js").ClusterBehavior, import("./SmokeCoAlarmInterface.js").SmokeCoAlarmInterface>, import("./SmokeCoAlarmInterface.js").SmokeCoAlarmInterface>, import("./SmokeCoAlarmInterface.js").SmokeCoAlarmInterface>;
/**
 * This is the default server implementation of {@link SmokeCoAlarmBehavior}.
 *
 * The Matter specification requires the SmokeCoAlarm cluster to support features we do not enable by default. You
 * should use {@link SmokeCoAlarmServer.with} to specialize the class for the features your implementation supports.
 */
export declare class SmokeCoAlarmBaseServer extends SmokeCoAlarmBase {
    initialize(): void;
}
declare const SmokeCoAlarmServer_base: import("../../index.js").ClusterBehavior.Type<ClusterType.Of<{
    readonly id: 92;
    readonly name: "SmokeCoAlarm";
    readonly revision: 1;
    readonly features: {
        readonly smokeAlarm: import("@matter/types").BitFlag;
        readonly coAlarm: import("@matter/types").BitFlag;
    };
    readonly attributes: {
        readonly expressedState: import("@matter/types").Attribute<SmokeCoAlarm.ExpressedState, any>;
        readonly batteryAlert: import("@matter/types").Attribute<SmokeCoAlarm.AlarmState, any>;
        readonly deviceMuted: import("@matter/types").OptionalAttribute<SmokeCoAlarm.MuteState, any>;
        readonly testInProgress: import("@matter/types").Attribute<boolean, any>;
        readonly hardwareFaultAlert: import("@matter/types").Attribute<boolean, any>;
        readonly endOfServiceAlert: import("@matter/types").Attribute<SmokeCoAlarm.EndOfService, any>;
        readonly interconnectSmokeAlarm: import("@matter/types").OptionalAttribute<SmokeCoAlarm.AlarmState, any>;
        readonly interconnectCoAlarm: import("@matter/types").OptionalAttribute<SmokeCoAlarm.AlarmState, any>;
        readonly expiryDate: import("@matter/types").OptionalFixedAttribute<number, any>;
    };
    readonly commands: {
        readonly selfTestRequest: import("@matter/types").OptionalCommand<void, void, any>;
    };
    readonly events: {
        readonly lowBattery: import("@matter/types").Event<import("@matter/types").TypeFromFields<{
            alarmSeverityLevel: import("@matter/types").FieldType<SmokeCoAlarm.AlarmState>;
        }>, any>;
        readonly hardwareFault: import("@matter/types").Event<void, any>;
        readonly endOfService: import("@matter/types").Event<void, any>;
        readonly selfTestComplete: import("@matter/types").Event<void, any>;
        readonly alarmMuted: import("@matter/types").OptionalEvent<void, any>;
        readonly muteEnded: import("@matter/types").OptionalEvent<void, any>;
        readonly allClear: import("@matter/types").Event<void, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly smokeAlarm: true;
        };
        readonly component: {
            readonly attributes: {
                readonly smokeState: import("@matter/types").Attribute<SmokeCoAlarm.AlarmState, any>;
                readonly contaminationState: import("@matter/types").OptionalAttribute<SmokeCoAlarm.ContaminationState, any>;
                readonly smokeSensitivityLevel: import("@matter/types").OptionalWritableAttribute<SmokeCoAlarm.Sensitivity, any>;
            };
            readonly events: {
                readonly smokeAlarm: import("@matter/types").Event<import("@matter/types").TypeFromFields<{
                    alarmSeverityLevel: import("@matter/types").FieldType<SmokeCoAlarm.AlarmState>;
                }>, any>;
                readonly interconnectSmokeAlarm: import("@matter/types").OptionalEvent<import("@matter/types").TypeFromFields<{
                    alarmSeverityLevel: import("@matter/types").FieldType<SmokeCoAlarm.AlarmState>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly coAlarm: true;
        };
        readonly component: {
            readonly attributes: {
                readonly coState: import("@matter/types").Attribute<SmokeCoAlarm.AlarmState, any>;
            };
            readonly events: {
                readonly coAlarm: import("@matter/types").Event<import("@matter/types").TypeFromFields<{
                    alarmSeverityLevel: import("@matter/types").FieldType<SmokeCoAlarm.AlarmState>;
                }>, any>;
                readonly interconnectCoAlarm: import("@matter/types").OptionalEvent<import("@matter/types").TypeFromFields<{
                    alarmSeverityLevel: import("@matter/types").FieldType<SmokeCoAlarm.AlarmState>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly smokeAlarm: false;
            readonly coAlarm: false;
        };
        readonly component: false;
    }];
}>, typeof SmokeCoAlarmBaseServer, import("./SmokeCoAlarmInterface.js").SmokeCoAlarmInterface>;
export declare class SmokeCoAlarmServer extends SmokeCoAlarmServer_base {
}
export {};
//# sourceMappingURL=SmokeCoAlarmServer.d.ts.map