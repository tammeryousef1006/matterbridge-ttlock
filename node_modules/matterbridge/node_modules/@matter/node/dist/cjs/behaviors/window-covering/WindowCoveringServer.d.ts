/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { WindowCovering } from "#clusters/window-covering";
import { MaybePromise } from "#general";
import { ClusterType, TypeFromPartialBitSchema } from "#types";
declare const WindowCoveringBase: import("../../index.js").ClusterBehavior.Type<import("#types").ClusterComposer.WithFeatures<ClusterType.Of<{
    readonly id: 258;
    readonly name: "WindowCovering";
    readonly revision: 5;
    readonly features: {
        readonly lift: import("#types").BitFlag;
        readonly tilt: import("#types").BitFlag;
        readonly positionAwareLift: import("#types").BitFlag;
        readonly absolutePosition: import("#types").BitFlag;
        readonly positionAwareTilt: import("#types").BitFlag;
    };
    readonly attributes: {
        readonly type: import("#types").FixedAttribute<WindowCovering.WindowCoveringType, any>;
        readonly configStatus: import("#types").Attribute<TypeFromPartialBitSchema<{
            operational: import("#types").BitFlag;
            onlineReserved: import("#types").BitFlag;
            liftMovementReversed: import("#types").BitFlag;
            liftPositionAware: import("#types").BitFlag;
            tiltPositionAware: import("#types").BitFlag;
            liftEncoderControlled: import("#types").BitFlag;
            tiltEncoderControlled: import("#types").BitFlag;
        }>, any>;
        readonly operationalStatus: import("#types").Attribute<TypeFromPartialBitSchema<{
            global: import("#types").BitFieldEnum<WindowCovering.MovementStatus>;
            lift: import("#types").BitFieldEnum<WindowCovering.MovementStatus>;
            tilt: import("#types").BitFieldEnum<WindowCovering.MovementStatus>;
        }>, any>;
        readonly endProductType: import("#types").FixedAttribute<WindowCovering.EndProductType, any>;
        readonly mode: import("#types").WritableAttribute<TypeFromPartialBitSchema<{
            motorDirectionReversed: import("#types").BitFlag;
            calibrationMode: import("#types").BitFlag;
            maintenanceMode: import("#types").BitFlag;
            ledFeedback: import("#types").BitFlag;
        }>, any>;
        readonly safetyStatus: import("#types").OptionalAttribute<TypeFromPartialBitSchema<{
            remoteLockout: import("#types").BitFlag;
            tamperDetection: import("#types").BitFlag;
            failedCommunication: import("#types").BitFlag;
            positionFailure: import("#types").BitFlag;
            thermalProtection: import("#types").BitFlag;
            obstacleDetected: import("#types").BitFlag;
            power: import("#types").BitFlag;
            stopInput: import("#types").BitFlag;
            motorJammed: import("#types").BitFlag;
            hardwareFailure: import("#types").BitFlag;
            manualOperation: import("#types").BitFlag;
            protection: import("#types").BitFlag;
        }>, any>;
    };
    readonly commands: {
        readonly upOrOpen: import("#types").Command<void, void, any>;
        readonly downOrClose: import("#types").Command<void, void, any>;
        readonly stopMotion: import("#types").Command<void, void, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly lift: true;
            readonly positionAwareLift: true;
            readonly absolutePosition: true;
        };
        readonly component: {
            readonly attributes: {
                readonly physicalClosedLimitLift: import("#types").OptionalFixedAttribute<number, any>;
                readonly currentPositionLift: import("#types").OptionalAttribute<number | null, any>;
                readonly installedOpenLimitLift: import("#types").Attribute<number, any>;
                readonly installedClosedLimitLift: import("#types").Attribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly tilt: true;
            readonly positionAwareTilt: true;
            readonly absolutePosition: true;
        };
        readonly component: {
            readonly attributes: {
                readonly physicalClosedLimitTilt: import("#types").OptionalFixedAttribute<number, any>;
                readonly currentPositionTilt: import("#types").OptionalAttribute<number | null, any>;
                readonly installedOpenLimitTilt: import("#types").Attribute<number, any>;
                readonly installedClosedLimitTilt: import("#types").Attribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly lift: true;
        };
        readonly component: {
            readonly attributes: {
                readonly numberOfActuationsLift: import("#types").OptionalAttribute<number, any>;
            };
            readonly commands: {
                readonly goToLiftPercentage: import("#types").OptionalCommand<import("#types").TypeFromFields<{
                    liftPercent100thsValue: import("#types").FieldType<number>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly tilt: true;
        };
        readonly component: {
            readonly attributes: {
                readonly numberOfActuationsTilt: import("#types").OptionalAttribute<number, any>;
            };
            readonly commands: {
                readonly goToTiltPercentage: import("#types").OptionalCommand<import("#types").TypeFromFields<{
                    tiltPercent100thsValue: import("#types").FieldType<number>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly lift: true;
            readonly positionAwareLift: true;
        };
        readonly component: {
            readonly attributes: {
                readonly currentPositionLiftPercentage: import("#types").OptionalAttribute<number | null, any>;
                readonly targetPositionLiftPercent100ths: import("#types").Attribute<number | null, any>;
                readonly currentPositionLiftPercent100ths: import("#types").Attribute<number | null, any>;
            };
            readonly commands: {
                readonly goToLiftPercentage: import("#types").Command<import("#types").TypeFromFields<{
                    liftPercent100thsValue: import("#types").FieldType<number>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly tilt: true;
            readonly positionAwareTilt: true;
        };
        readonly component: {
            readonly attributes: {
                readonly currentPositionTiltPercentage: import("#types").OptionalAttribute<number | null, any>;
                readonly targetPositionTiltPercent100ths: import("#types").Attribute<number | null, any>;
                readonly currentPositionTiltPercent100ths: import("#types").Attribute<number | null, any>;
            };
            readonly commands: {
                readonly goToTiltPercentage: import("#types").Command<import("#types").TypeFromFields<{
                    tiltPercent100thsValue: import("#types").FieldType<number>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly lift: true;
            readonly absolutePosition: true;
        };
        readonly component: {
            readonly commands: {
                readonly goToLiftValue: import("#types").OptionalCommand<import("#types").TypeFromFields<{
                    liftValue: import("#types").FieldType<number>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly tilt: true;
            readonly absolutePosition: true;
        };
        readonly component: {
            readonly commands: {
                readonly goToTiltValue: import("#types").OptionalCommand<import("#types").TypeFromFields<{
                    tiltValue: import("#types").FieldType<number>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly positionAwareLift: true;
            readonly lift: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly positionAwareTilt: true;
            readonly tilt: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly lift: false;
            readonly tilt: false;
        };
        readonly component: false;
    }];
}>, readonly [WindowCovering.Feature.Lift, WindowCovering.Feature.Tilt, WindowCovering.Feature.PositionAwareLift, WindowCovering.Feature.PositionAwareTilt]>, import("../../index.js").ClusterBehavior.Type<ClusterType.Of<{
    readonly id: 258;
    readonly name: "WindowCovering";
    readonly revision: 5;
    readonly features: {
        readonly lift: import("#types").BitFlag;
        readonly tilt: import("#types").BitFlag;
        readonly positionAwareLift: import("#types").BitFlag;
        readonly absolutePosition: import("#types").BitFlag;
        readonly positionAwareTilt: import("#types").BitFlag;
    };
    readonly attributes: {
        readonly type: import("#types").FixedAttribute<WindowCovering.WindowCoveringType, any>;
        readonly configStatus: import("#types").Attribute<TypeFromPartialBitSchema<{
            operational: import("#types").BitFlag;
            onlineReserved: import("#types").BitFlag;
            liftMovementReversed: import("#types").BitFlag;
            liftPositionAware: import("#types").BitFlag;
            tiltPositionAware: import("#types").BitFlag;
            liftEncoderControlled: import("#types").BitFlag;
            tiltEncoderControlled: import("#types").BitFlag;
        }>, any>;
        readonly operationalStatus: import("#types").Attribute<TypeFromPartialBitSchema<{
            global: import("#types").BitFieldEnum<WindowCovering.MovementStatus>;
            lift: import("#types").BitFieldEnum<WindowCovering.MovementStatus>;
            tilt: import("#types").BitFieldEnum<WindowCovering.MovementStatus>;
        }>, any>;
        readonly endProductType: import("#types").FixedAttribute<WindowCovering.EndProductType, any>;
        readonly mode: import("#types").WritableAttribute<TypeFromPartialBitSchema<{
            motorDirectionReversed: import("#types").BitFlag;
            calibrationMode: import("#types").BitFlag;
            maintenanceMode: import("#types").BitFlag;
            ledFeedback: import("#types").BitFlag;
        }>, any>;
        readonly safetyStatus: import("#types").OptionalAttribute<TypeFromPartialBitSchema<{
            remoteLockout: import("#types").BitFlag;
            tamperDetection: import("#types").BitFlag;
            failedCommunication: import("#types").BitFlag;
            positionFailure: import("#types").BitFlag;
            thermalProtection: import("#types").BitFlag;
            obstacleDetected: import("#types").BitFlag;
            power: import("#types").BitFlag;
            stopInput: import("#types").BitFlag;
            motorJammed: import("#types").BitFlag;
            hardwareFailure: import("#types").BitFlag;
            manualOperation: import("#types").BitFlag;
            protection: import("#types").BitFlag;
        }>, any>;
    };
    readonly commands: {
        readonly upOrOpen: import("#types").Command<void, void, any>;
        readonly downOrClose: import("#types").Command<void, void, any>;
        readonly stopMotion: import("#types").Command<void, void, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly lift: true;
            readonly positionAwareLift: true;
            readonly absolutePosition: true;
        };
        readonly component: {
            readonly attributes: {
                readonly physicalClosedLimitLift: import("#types").OptionalFixedAttribute<number, any>;
                readonly currentPositionLift: import("#types").OptionalAttribute<number | null, any>;
                readonly installedOpenLimitLift: import("#types").Attribute<number, any>;
                readonly installedClosedLimitLift: import("#types").Attribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly tilt: true;
            readonly positionAwareTilt: true;
            readonly absolutePosition: true;
        };
        readonly component: {
            readonly attributes: {
                readonly physicalClosedLimitTilt: import("#types").OptionalFixedAttribute<number, any>;
                readonly currentPositionTilt: import("#types").OptionalAttribute<number | null, any>;
                readonly installedOpenLimitTilt: import("#types").Attribute<number, any>;
                readonly installedClosedLimitTilt: import("#types").Attribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly lift: true;
        };
        readonly component: {
            readonly attributes: {
                readonly numberOfActuationsLift: import("#types").OptionalAttribute<number, any>;
            };
            readonly commands: {
                readonly goToLiftPercentage: import("#types").OptionalCommand<import("#types").TypeFromFields<{
                    liftPercent100thsValue: import("#types").FieldType<number>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly tilt: true;
        };
        readonly component: {
            readonly attributes: {
                readonly numberOfActuationsTilt: import("#types").OptionalAttribute<number, any>;
            };
            readonly commands: {
                readonly goToTiltPercentage: import("#types").OptionalCommand<import("#types").TypeFromFields<{
                    tiltPercent100thsValue: import("#types").FieldType<number>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly lift: true;
            readonly positionAwareLift: true;
        };
        readonly component: {
            readonly attributes: {
                readonly currentPositionLiftPercentage: import("#types").OptionalAttribute<number | null, any>;
                readonly targetPositionLiftPercent100ths: import("#types").Attribute<number | null, any>;
                readonly currentPositionLiftPercent100ths: import("#types").Attribute<number | null, any>;
            };
            readonly commands: {
                readonly goToLiftPercentage: import("#types").Command<import("#types").TypeFromFields<{
                    liftPercent100thsValue: import("#types").FieldType<number>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly tilt: true;
            readonly positionAwareTilt: true;
        };
        readonly component: {
            readonly attributes: {
                readonly currentPositionTiltPercentage: import("#types").OptionalAttribute<number | null, any>;
                readonly targetPositionTiltPercent100ths: import("#types").Attribute<number | null, any>;
                readonly currentPositionTiltPercent100ths: import("#types").Attribute<number | null, any>;
            };
            readonly commands: {
                readonly goToTiltPercentage: import("#types").Command<import("#types").TypeFromFields<{
                    tiltPercent100thsValue: import("#types").FieldType<number>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly lift: true;
            readonly absolutePosition: true;
        };
        readonly component: {
            readonly commands: {
                readonly goToLiftValue: import("#types").OptionalCommand<import("#types").TypeFromFields<{
                    liftValue: import("#types").FieldType<number>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly tilt: true;
            readonly absolutePosition: true;
        };
        readonly component: {
            readonly commands: {
                readonly goToTiltValue: import("#types").OptionalCommand<import("#types").TypeFromFields<{
                    tiltValue: import("#types").FieldType<number>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly positionAwareLift: true;
            readonly lift: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly positionAwareTilt: true;
            readonly tilt: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly lift: false;
            readonly tilt: false;
        };
        readonly component: false;
    }];
}>, import("../../index.js").ClusterBehavior.Type<ClusterType.Of<{
    readonly id: 0;
    readonly revision: 0;
    readonly name: "Unknown";
    readonly attributes: {};
    readonly commands: {};
    readonly events: {};
}>, typeof import("../../index.js").ClusterBehavior, import("./WindowCoveringInterface.js").WindowCoveringInterface>, import("./WindowCoveringInterface.js").WindowCoveringInterface>, import("./WindowCoveringInterface.js").WindowCoveringInterface>;
/** What element should move? */
export declare enum MovementType {
    Lift = 0,
    Tilt = 1
}
/** Status of the Calibration mode. */
export declare enum CalibrationMode {
    Enabled = 0,
    Running = 1,
    Disabled = 2
}
/**
 * Direction the Window covering should move.
 * The special state "DefinedByPosition" is used to indicate that the direction should be determined by the target
 * position and the implementation needs to determine it himself.
 */
export declare enum MovementDirection {
    Open = 0,
    Close = 1,
    DefinedByPosition = 2
}
/**
 * This is the default server implementation of {@link WindowCoveringBehavior}.
 *
 * This implementation includes all features of {@link WindowCovering.Cluster} and implements all mandatory commands.
 * You should use {@link WindowCoveringServer.with} to specialize the class for the features your implementation
 * supports.
 *
 * If you enable position awareness (positionAware* features), the default logic automatically syncs current positions
 * and operational state when the currentPosition*Percent100ths attributes change. You should update
 * currentPosition*Percent100ths with the actual position from your device.  This updates other attributes
 * automatically.
 *
 * When targetPosition*Percent100ths attributes change, operational state updates bases on the current and target
 * values.
 *
 * If you do not override {@link handleMovement} the default implementation updates current position to the target
 * position immediately.
 *
 * In addition to Matter attributes, {@link WindowCoveringBaseServer.State} includes the following configuration
 * properties:
 *
 *   * supportsMaintenanceMode (default true): Set to false if the device has no maintenance mode
 *
 * The internal state allows to configure implementation details when extending the class:
 *   * supportsCalibration (default false): Set to true if the device supports calibration. You must implement
 {@link WindowCoveringBaseServer.executeCalibration} to perform actual calibration.
 *   * disableOperationalModeHandling (default false): Set to true if you want to handle the operational status yourself
 *
 * When developing for specific hardware you should extend {@link WindowCoveringServer} and implement the following
 * methods to map movement to your device. The default implementation maps Matter commands to these methods. The benefit
 * of this structure is that basic data validations and option checks are already done and you can focus on the actual
 * hardware interaction:
 *
 *   * {@link WindowCoveringBaseServer.handleMovement} Logic to actually move the device. Via Parameters the movement
 *     type (Lift/Tilt), direction, target percentage and information if motor is configured reversed are provided. When
 *     the device moves the current Positions (if supported by the device) are updated with the movement. The
 *     operational state is automatically updated by the default implementation based on current and target values of
 *     the cluster state.
 *
 *   * {@link WindowCoveringBaseServer.handleStopMovement} Logic to stop any movement of the device. You can use the
 *     super.handleStopMovement() to set the target positions to the current positions or do this yourself.
 *
 *   * {@link WindowCoveringBaseServer.executeCalibration} If supported, override this method to implement the
 *     calibration process. The default implementation returns an error to indicate calibration is unsupported. If
 *     unsupported you should also add a Changing event handler to the mode attribute to ensure calibration mode is not
 *     set (needs to throw an ConstraintError).
 *
 * IMPORTANT NOTE:
 *
 * This default implementation could have pitfalls when the calibration process and/or movement is handled via
 * long-running promises. There could be edge cases not correctly handled by the current implementation when it comes
 * to long-running movements or calibration processes - especially when these processes are long-running async JS
 * operations.
 *
 * A movement coming in while another movement is still running is assumed to be handled by the device. It is not
 * handled here. If this causes you trouble please provide feedback, and we can discuss how to improve the default
 * implementation.
 */
export declare class WindowCoveringBaseServer extends WindowCoveringBase {
    #private;
    protected internal: WindowCoveringBaseServer.Internal;
    state: WindowCoveringBaseServer.State;
    initialize(): MaybePromise;
    /**
     * Calibrate the device.  The default implementation takes no action. Override to implement calibration if
     * necessary.
     *
     * @protected
     */
    protected executeCalibration(): MaybePromise;
    /**
     * Perform actual "movement".  Override to initiate movement of your device.
     * The logic tries to determine the direction to Open or Close also when a target percentage is given. The direction
     * value `DefinedByPosition` only is set if we can not determine the direction based on the current data.
     * When a `targetPercent100ths` is set (not undefined) then this is the target value to use.
     *
     * The default implementation logs and immediately updates current position to the target positions.  This is
     * probably not desirable for a real device so do not invoke `super.handleMovement()` from your implementation.
     *
     * @param type Which element should move, Lift or Tilt
     * @param reversed If the motor is configured reversed
     * @param direction The direction of the movement (Open, Close, DefinedByPosition)
     * @param targetPercent100ths Optionally the target position in percent 100ths. It depends on the used feature set
     * of the cluster if this is provided or not.
     *
     * @protected
     */
    protected handleMovement(type: MovementType, reversed: boolean, direction: MovementDirection, targetPercent100ths?: number): Promise<void>;
    /**
     * Stop device movement.  Sets the target position to the current position and updates operational state. Override
     * to implement the actual stop movement logic.
     *
     * If you update the current positions you can include the default logic via "super.handleStopMovement()".
     *
     * @protected
     */
    protected handleStopMovement(): MaybePromise;
    /**
     * Move the WindowCovering up or open. For position aware devices the target position is set to 0%. The method calls
     * the handleMovement method to actually move the device.
     */
    upOrOpen(): MaybePromise;
    /**
     * Move the WindowCovering down or close. For position aware devices the target position is set to 100%. The method
     * calls the handleMovement method to actually move the device.
     */
    downOrClose(): MaybePromise;
    /**
     * Stop any movement of the WindowCovering. The method calls the handleStopMovement method to actually stop the
     * movement of the device.
     */
    stopMotion(): MaybePromise;
    /**
     * Move the WindowCovering to a specific tilt value. The method calls the handleMovement method to actually move the
     * device to the defined position.
     */
    goToLiftPercentage({ liftPercent100thsValue }: WindowCovering.GoToLiftPercentageRequest): MaybePromise;
    /**
     * Move the WindowCovering to a specific tilt value. The method calls the handleMovement method to actually move the
     * device to the defined position.
     */
    goToTiltPercentage({ tiltPercent100thsValue }: WindowCovering.GoToTiltPercentageRequest): MaybePromise;
}
export declare namespace WindowCoveringBaseServer {
    class Internal {
        /** Does the device supports calibration? */
        supportsCalibration: boolean;
        /** Status of the Device Calibration mode. */
        calibrationMode: CalibrationMode;
        /** Status of the Device Maintenance mode. */
        inMaintenanceMode: boolean;
        /**
         * Disable OperationalMode and position value management.
         * This requires the device developer to set all these states (operationalMode, percentage and
         * absolute values according to the feature set) according to the Matter specification!
         */
        disableOperationalModeHandling: boolean;
    }
    class State extends WindowCoveringBase.State {
        /** Does the device supports maintenance mode? */
        supportsMaintenanceMode: boolean;
    }
    const ExtensionInterface: {
        handleMovement(type: MovementType, reversed: boolean, direction: MovementDirection, targetPercent100ths?: number): Promise<void>;
        handleStopMovement(): MaybePromise;
        executeCalibration(): MaybePromise;
    };
}
declare const WindowCoveringServer_base: import("../../index.js").ClusterBehavior.Type<ClusterType.Of<{
    readonly id: 258;
    readonly name: "WindowCovering";
    readonly revision: 5;
    readonly features: {
        readonly lift: import("#types").BitFlag;
        readonly tilt: import("#types").BitFlag;
        readonly positionAwareLift: import("#types").BitFlag;
        readonly absolutePosition: import("#types").BitFlag;
        readonly positionAwareTilt: import("#types").BitFlag;
    };
    readonly attributes: {
        readonly type: import("#types").FixedAttribute<WindowCovering.WindowCoveringType, any>;
        readonly configStatus: import("#types").Attribute<TypeFromPartialBitSchema<{
            operational: import("#types").BitFlag;
            onlineReserved: import("#types").BitFlag;
            liftMovementReversed: import("#types").BitFlag;
            liftPositionAware: import("#types").BitFlag;
            tiltPositionAware: import("#types").BitFlag;
            liftEncoderControlled: import("#types").BitFlag;
            tiltEncoderControlled: import("#types").BitFlag;
        }>, any>;
        readonly operationalStatus: import("#types").Attribute<TypeFromPartialBitSchema<{
            global: import("#types").BitFieldEnum<WindowCovering.MovementStatus>;
            lift: import("#types").BitFieldEnum<WindowCovering.MovementStatus>;
            tilt: import("#types").BitFieldEnum<WindowCovering.MovementStatus>;
        }>, any>;
        readonly endProductType: import("#types").FixedAttribute<WindowCovering.EndProductType, any>;
        readonly mode: import("#types").WritableAttribute<TypeFromPartialBitSchema<{
            motorDirectionReversed: import("#types").BitFlag;
            calibrationMode: import("#types").BitFlag;
            maintenanceMode: import("#types").BitFlag;
            ledFeedback: import("#types").BitFlag;
        }>, any>;
        readonly safetyStatus: import("#types").OptionalAttribute<TypeFromPartialBitSchema<{
            remoteLockout: import("#types").BitFlag;
            tamperDetection: import("#types").BitFlag;
            failedCommunication: import("#types").BitFlag;
            positionFailure: import("#types").BitFlag;
            thermalProtection: import("#types").BitFlag;
            obstacleDetected: import("#types").BitFlag;
            power: import("#types").BitFlag;
            stopInput: import("#types").BitFlag;
            motorJammed: import("#types").BitFlag;
            hardwareFailure: import("#types").BitFlag;
            manualOperation: import("#types").BitFlag;
            protection: import("#types").BitFlag;
        }>, any>;
    };
    readonly commands: {
        readonly upOrOpen: import("#types").Command<void, void, any>;
        readonly downOrClose: import("#types").Command<void, void, any>;
        readonly stopMotion: import("#types").Command<void, void, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly lift: true;
            readonly positionAwareLift: true;
            readonly absolutePosition: true;
        };
        readonly component: {
            readonly attributes: {
                readonly physicalClosedLimitLift: import("#types").OptionalFixedAttribute<number, any>;
                readonly currentPositionLift: import("#types").OptionalAttribute<number | null, any>;
                readonly installedOpenLimitLift: import("#types").Attribute<number, any>;
                readonly installedClosedLimitLift: import("#types").Attribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly tilt: true;
            readonly positionAwareTilt: true;
            readonly absolutePosition: true;
        };
        readonly component: {
            readonly attributes: {
                readonly physicalClosedLimitTilt: import("#types").OptionalFixedAttribute<number, any>;
                readonly currentPositionTilt: import("#types").OptionalAttribute<number | null, any>;
                readonly installedOpenLimitTilt: import("#types").Attribute<number, any>;
                readonly installedClosedLimitTilt: import("#types").Attribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly lift: true;
        };
        readonly component: {
            readonly attributes: {
                readonly numberOfActuationsLift: import("#types").OptionalAttribute<number, any>;
            };
            readonly commands: {
                readonly goToLiftPercentage: import("#types").OptionalCommand<import("#types").TypeFromFields<{
                    liftPercent100thsValue: import("#types").FieldType<number>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly tilt: true;
        };
        readonly component: {
            readonly attributes: {
                readonly numberOfActuationsTilt: import("#types").OptionalAttribute<number, any>;
            };
            readonly commands: {
                readonly goToTiltPercentage: import("#types").OptionalCommand<import("#types").TypeFromFields<{
                    tiltPercent100thsValue: import("#types").FieldType<number>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly lift: true;
            readonly positionAwareLift: true;
        };
        readonly component: {
            readonly attributes: {
                readonly currentPositionLiftPercentage: import("#types").OptionalAttribute<number | null, any>;
                readonly targetPositionLiftPercent100ths: import("#types").Attribute<number | null, any>;
                readonly currentPositionLiftPercent100ths: import("#types").Attribute<number | null, any>;
            };
            readonly commands: {
                readonly goToLiftPercentage: import("#types").Command<import("#types").TypeFromFields<{
                    liftPercent100thsValue: import("#types").FieldType<number>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly tilt: true;
            readonly positionAwareTilt: true;
        };
        readonly component: {
            readonly attributes: {
                readonly currentPositionTiltPercentage: import("#types").OptionalAttribute<number | null, any>;
                readonly targetPositionTiltPercent100ths: import("#types").Attribute<number | null, any>;
                readonly currentPositionTiltPercent100ths: import("#types").Attribute<number | null, any>;
            };
            readonly commands: {
                readonly goToTiltPercentage: import("#types").Command<import("#types").TypeFromFields<{
                    tiltPercent100thsValue: import("#types").FieldType<number>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly lift: true;
            readonly absolutePosition: true;
        };
        readonly component: {
            readonly commands: {
                readonly goToLiftValue: import("#types").OptionalCommand<import("#types").TypeFromFields<{
                    liftValue: import("#types").FieldType<number>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly tilt: true;
            readonly absolutePosition: true;
        };
        readonly component: {
            readonly commands: {
                readonly goToTiltValue: import("#types").OptionalCommand<import("#types").TypeFromFields<{
                    tiltValue: import("#types").FieldType<number>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly positionAwareLift: true;
            readonly lift: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly positionAwareTilt: true;
            readonly tilt: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly lift: false;
            readonly tilt: false;
        };
        readonly component: false;
    }];
}>, typeof WindowCoveringBaseServer, import("./WindowCoveringInterface.js").WindowCoveringInterface>;
export declare class WindowCoveringServer extends WindowCoveringServer_base {
}
export {};
//# sourceMappingURL=WindowCoveringServer.d.ts.map