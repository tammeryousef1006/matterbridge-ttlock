/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
/*** THIS FILE IS GENERATED, DO NOT EDIT ***/
import { IdentifyServer as BaseIdentifyServer } from "../behaviors/identify/IdentifyServer.js";
import { MutableEndpoint } from "../endpoint/type/MutableEndpoint.js";
import { Identity } from "#general";
/**
 * A Heat Pump device is a device that uses electrical energy to heat either spaces or water tanks using ground, water
 * or air as the heat source. These typically can heat the air or can pump water via central heating radiators or
 * underfloor heating systems. It is typical to also heat hot water and store the heat in a hot water tank.
 *
 * Note that the Water Heater device type can also be heated by a heat pump and has similar requirements, but that
 * cannot be used for space heating.
 *
 * @see {@link MatterSpecification.v14.Device} ยง 14.5
 */
export interface HeatPumpDevice extends Identity<typeof HeatPumpDeviceDefinition> {
}
export declare namespace HeatPumpRequirements {
    /**
     * The Identify cluster is optional per the Matter specification.
     *
     * We provide this alias to the default implementation {@link IdentifyServer} for convenience.
     */
    const IdentifyServer: typeof BaseIdentifyServer;
    /**
     * The Thermostat cluster is optional per the Matter specification.
     *
     * We provide this alias to the default implementation {@link ThermostatBehavior} for convenience.
     */
    const ThermostatBehavior: import("../index.js").ClusterBehavior.Type<import("@matter/types").ClusterType.Of<{
        readonly id: 513;
        readonly name: "Thermostat";
        readonly revision: 8;
        readonly features: {
            readonly heating: import("@matter/types").BitFlag;
            readonly cooling: import("@matter/types").BitFlag;
            readonly occupancy: import("@matter/types").BitFlag;
            readonly scheduleConfiguration: import("@matter/types").BitFlag;
            readonly setback: import("@matter/types").BitFlag;
            readonly autoMode: import("@matter/types").BitFlag;
            readonly localTemperatureNotExposed: import("@matter/types").BitFlag;
            readonly matterScheduleConfiguration: import("@matter/types").BitFlag;
            readonly presets: import("@matter/types").BitFlag;
        };
        readonly attributes: {
            readonly localTemperature: import("@matter/types").Attribute<number | null, any>;
            readonly outdoorTemperature: import("@matter/types").OptionalAttribute<number | null, any>;
            readonly hvacSystemTypeConfiguration: import("@matter/types").OptionalWritableAttribute<import("@matter/types").TypeFromPartialBitSchema<{
                coolingStage: import("@matter/types").BitField;
                heatingStage: import("@matter/types").BitField;
                heatingIsHeatPump: import("@matter/types").BitFlag;
                heatingUsesFuel: import("@matter/types").BitFlag;
            }>, any>;
            readonly remoteSensing: import("@matter/types").OptionalWritableAttribute<import("@matter/types").TypeFromPartialBitSchema<{
                localTemperature: import("@matter/types").BitFlag;
                outdoorTemperature: import("@matter/types").BitFlag;
                occupancy: import("@matter/types").BitFlag;
            }>, any>;
            readonly controlSequenceOfOperation: import("@matter/types").WritableAttribute<import("@matter/types/clusters/thermostat").Thermostat.ControlSequenceOfOperation, any>;
            readonly systemMode: import("@matter/types").WritableAttribute<import("@matter/types/clusters/thermostat").Thermostat.SystemMode, any>;
            readonly temperatureSetpointHold: import("@matter/types").OptionalWritableAttribute<import("@matter/types/clusters/thermostat").Thermostat.TemperatureSetpointHold, any>;
            readonly temperatureSetpointHoldDuration: import("@matter/types").OptionalWritableAttribute<number | null, any>;
            readonly thermostatProgrammingOperationMode: import("@matter/types").OptionalWritableAttribute<import("@matter/types").TypeFromPartialBitSchema<{
                scheduleActive: import("@matter/types").BitFlag;
                autoRecovery: import("@matter/types").BitFlag;
                economy: import("@matter/types").BitFlag;
            }>, any>;
            readonly thermostatRunningState: import("@matter/types").OptionalAttribute<import("@matter/types").TypeFromPartialBitSchema<{
                heat: import("@matter/types").BitFlag;
                cool: import("@matter/types").BitFlag;
                fan: import("@matter/types").BitFlag;
                heatStage2: import("@matter/types").BitFlag;
                coolStage2: import("@matter/types").BitFlag;
                fanStage2: import("@matter/types").BitFlag;
                fanStage3: import("@matter/types").BitFlag;
            }>, any>;
            readonly setpointChangeSource: import("@matter/types").OptionalAttribute<import("@matter/types/clusters/thermostat").Thermostat.SetpointChangeSource, any>;
            readonly setpointChangeAmount: import("@matter/types").OptionalAttribute<number | null, any>;
            readonly setpointChangeSourceTimestamp: import("@matter/types").OptionalAttribute<number, any>;
            readonly emergencyHeatDelta: import("@matter/types").OptionalWritableAttribute<number, any>;
            readonly acType: import("@matter/types").OptionalWritableAttribute<import("@matter/types/clusters/thermostat").Thermostat.AcType, any>;
            readonly acCapacity: import("@matter/types").OptionalWritableAttribute<number, any>;
            readonly acRefrigerantType: import("@matter/types").OptionalWritableAttribute<import("@matter/types/clusters/thermostat").Thermostat.AcRefrigerantType, any>;
            readonly acCompressorType: import("@matter/types").OptionalWritableAttribute<import("@matter/types/clusters/thermostat").Thermostat.AcCompressorType, any>;
            readonly acErrorCode: import("@matter/types").OptionalWritableAttribute<import("@matter/types").TypeFromPartialBitSchema<{
                compressorFail: import("@matter/types").BitFlag;
                roomSensorFail: import("@matter/types").BitFlag;
                outdoorSensorFail: import("@matter/types").BitFlag;
                coilSensorFail: import("@matter/types").BitFlag;
                fanFail: import("@matter/types").BitFlag;
            }>, any>;
            readonly acLouverPosition: import("@matter/types").OptionalWritableAttribute<import("@matter/types/clusters/thermostat").Thermostat.AcLouverPosition, any>;
            readonly acCoilTemperature: import("@matter/types").OptionalAttribute<number | null, any>;
            readonly acCapacityFormat: import("@matter/types").OptionalWritableAttribute<import("@matter/types/clusters/thermostat").Thermostat.AcCapacityFormat, any>;
            readonly setpointHoldExpiryTimestamp: import("@matter/types").OptionalAttribute<number | null, any>;
        };
        readonly commands: {
            readonly setpointRaiseLower: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                mode: import("@matter/types").FieldType<import("@matter/types/clusters/thermostat").Thermostat.SetpointRaiseLowerMode>;
                amount: import("@matter/types").FieldType<number>;
            }>, void, any>;
        };
        readonly extensions: readonly [{
            readonly flags: {
                readonly occupancy: true;
            };
            readonly component: {
                readonly attributes: {
                    readonly occupancy: import("@matter/types").Attribute<import("@matter/types").TypeFromPartialBitSchema<{
                        occupied: import("@matter/types").BitFlag;
                    }>, any>;
                };
            };
        }, {
            readonly flags: {
                readonly heating: true;
            };
            readonly component: {
                readonly attributes: {
                    readonly absMinHeatSetpointLimit: import("@matter/types").OptionalFixedAttribute<number, any>;
                    readonly absMaxHeatSetpointLimit: import("@matter/types").OptionalFixedAttribute<number, any>;
                    readonly piHeatingDemand: import("@matter/types").OptionalAttribute<number, any>;
                    readonly occupiedHeatingSetpoint: import("@matter/types").WritableAttribute<number, any>;
                    readonly minHeatSetpointLimit: import("@matter/types").OptionalWritableAttribute<number, any>;
                    readonly maxHeatSetpointLimit: import("@matter/types").OptionalWritableAttribute<number, any>;
                };
            };
        }, {
            readonly flags: {
                readonly cooling: true;
            };
            readonly component: {
                readonly attributes: {
                    readonly absMinCoolSetpointLimit: import("@matter/types").OptionalFixedAttribute<number, any>;
                    readonly absMaxCoolSetpointLimit: import("@matter/types").OptionalFixedAttribute<number, any>;
                    readonly piCoolingDemand: import("@matter/types").OptionalAttribute<number, any>;
                    readonly occupiedCoolingSetpoint: import("@matter/types").WritableAttribute<number, any>;
                    readonly minCoolSetpointLimit: import("@matter/types").OptionalWritableAttribute<number, any>;
                    readonly maxCoolSetpointLimit: import("@matter/types").OptionalWritableAttribute<number, any>;
                };
            };
        }, {
            readonly flags: {
                readonly localTemperatureNotExposed: false;
            };
            readonly component: {
                readonly attributes: {
                    readonly localTemperatureCalibration: import("@matter/types").OptionalWritableAttribute<number, any>;
                };
            };
        }, {
            readonly flags: {
                readonly cooling: true;
                readonly occupancy: true;
            };
            readonly component: {
                readonly attributes: {
                    readonly unoccupiedCoolingSetpoint: import("@matter/types").WritableAttribute<number, any>;
                };
            };
        }, {
            readonly flags: {
                readonly heating: true;
                readonly occupancy: true;
            };
            readonly component: {
                readonly attributes: {
                    readonly unoccupiedHeatingSetpoint: import("@matter/types").WritableAttribute<number, any>;
                };
            };
        }, {
            readonly flags: {
                readonly autoMode: true;
            };
            readonly component: {
                readonly attributes: {
                    readonly minSetpointDeadBand: import("@matter/types").WritableAttribute<number, any>;
                    readonly thermostatRunningMode: import("@matter/types").OptionalAttribute<import("@matter/types/clusters/thermostat").Thermostat.ThermostatRunningMode, any>;
                };
            };
        }, {
            readonly flags: {
                readonly scheduleConfiguration: true;
            };
            readonly component: {
                readonly attributes: {
                    readonly startOfWeek: import("@matter/types").FixedAttribute<import("@matter/types/clusters/thermostat").Thermostat.StartOfWeek, any>;
                    readonly numberOfWeeklyTransitions: import("@matter/types").FixedAttribute<number, any>;
                    readonly numberOfDailyTransitions: import("@matter/types").FixedAttribute<number, any>;
                };
                readonly commands: {
                    readonly setWeeklySchedule: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                        numberOfTransitionsForSequence: import("@matter/types").FieldType<number>;
                        dayOfWeekForSequence: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                            sunday: import("@matter/types").BitFlag;
                            monday: import("@matter/types").BitFlag;
                            tuesday: import("@matter/types").BitFlag;
                            wednesday: import("@matter/types").BitFlag;
                            thursday: import("@matter/types").BitFlag;
                            friday: import("@matter/types").BitFlag;
                            saturday: import("@matter/types").BitFlag;
                            away: import("@matter/types").BitFlag;
                        }>>;
                        modeForSequence: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                            heatSetpointPresent: import("@matter/types").BitFlag;
                            coolSetpointPresent: import("@matter/types").BitFlag;
                        }>>;
                        transitions: import("@matter/types").FieldType<import("@matter/types").TypeFromFields<{
                            transitionTime: import("@matter/types").FieldType<number>;
                            heatSetpoint: import("@matter/types").FieldType<number | null>;
                            coolSetpoint: import("@matter/types").FieldType<number | null>;
                        }>[]>;
                    }>, void, any>;
                    readonly getWeeklySchedule: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                        daysToReturn: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                            sunday: import("@matter/types").BitFlag;
                            monday: import("@matter/types").BitFlag;
                            tuesday: import("@matter/types").BitFlag;
                            wednesday: import("@matter/types").BitFlag;
                            thursday: import("@matter/types").BitFlag;
                            friday: import("@matter/types").BitFlag;
                            saturday: import("@matter/types").BitFlag;
                            away: import("@matter/types").BitFlag;
                        }>>;
                        modeToReturn: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                            heatSetpointPresent: import("@matter/types").BitFlag;
                            coolSetpointPresent: import("@matter/types").BitFlag;
                        }>>;
                    }>, import("@matter/types").TypeFromFields<{
                        numberOfTransitionsForSequence: import("@matter/types").FieldType<number>;
                        dayOfWeekForSequence: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                            sunday: import("@matter/types").BitFlag;
                            monday: import("@matter/types").BitFlag;
                            tuesday: import("@matter/types").BitFlag;
                            wednesday: import("@matter/types").BitFlag;
                            thursday: import("@matter/types").BitFlag;
                            friday: import("@matter/types").BitFlag;
                            saturday: import("@matter/types").BitFlag;
                            away: import("@matter/types").BitFlag;
                        }>>;
                        modeForSequence: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                            heatSetpointPresent: import("@matter/types").BitFlag;
                            coolSetpointPresent: import("@matter/types").BitFlag;
                        }>>;
                        transitions: import("@matter/types").FieldType<import("@matter/types").TypeFromFields<{
                            transitionTime: import("@matter/types").FieldType<number>;
                            heatSetpoint: import("@matter/types").FieldType<number | null>;
                            coolSetpoint: import("@matter/types").FieldType<number | null>;
                        }>[]>;
                    }>, any>;
                    readonly clearWeeklySchedule: import("@matter/types").Command<void, void, any>;
                };
            };
        }, {
            readonly flags: {
                readonly setback: true;
            };
            readonly component: {
                readonly attributes: {
                    readonly occupiedSetback: import("@matter/types").WritableAttribute<number | null, any>;
                    readonly occupiedSetbackMin: import("@matter/types").FixedAttribute<number | null, any>;
                    readonly occupiedSetbackMax: import("@matter/types").FixedAttribute<number | null, any>;
                };
            };
        }, {
            readonly flags: {
                readonly setback: true;
                readonly occupancy: true;
            };
            readonly component: {
                readonly attributes: {
                    readonly unoccupiedSetback: import("@matter/types").WritableAttribute<number | null, any>;
                    readonly unoccupiedSetbackMin: import("@matter/types").FixedAttribute<number | null, any>;
                    readonly unoccupiedSetbackMax: import("@matter/types").FixedAttribute<number | null, any>;
                };
            };
        }, {
            readonly flags: {
                readonly presets: true;
            };
            readonly component: {
                readonly attributes: {
                    readonly presetTypes: import("@matter/types").FixedAttribute<import("@matter/types").TypeFromFields<{
                        presetScenario: import("@matter/types").FieldType<import("@matter/types/clusters/thermostat").Thermostat.PresetScenario>;
                        numberOfPresets: import("@matter/types").FieldType<number>;
                        presetTypeFeatures: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                            automatic: import("@matter/types").BitFlag;
                            supportsNames: import("@matter/types").BitFlag;
                        }>>;
                    }>[], any>;
                    readonly numberOfPresets: import("@matter/types").FixedAttribute<number, any>;
                    readonly activePresetHandle: import("@matter/types").Attribute<Uint8Array<ArrayBufferLike> | null, any>;
                    readonly presets: import("@matter/types").WritableAttribute<import("@matter/types").TypeFromFields<{
                        presetHandle: import("@matter/types").FieldType<Uint8Array<ArrayBufferLike> | null>;
                        presetScenario: import("@matter/types").FieldType<import("@matter/types/clusters/thermostat").Thermostat.PresetScenario>;
                        name: import("@matter/types").OptionalFieldType<string | null>;
                        coolingSetpoint: import("@matter/types").OptionalFieldType<number>;
                        heatingSetpoint: import("@matter/types").OptionalFieldType<number>;
                        builtIn: import("@matter/types").FieldType<boolean | null>;
                    }>[], any>;
                };
                readonly commands: {
                    readonly setActivePresetRequest: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                        presetHandle: import("@matter/types").FieldType<Uint8Array<ArrayBufferLike> | null>;
                    }>, void, any>;
                };
            };
        }, {
            readonly flags: {
                readonly matterScheduleConfiguration: true;
            };
            readonly component: {
                readonly attributes: {
                    readonly scheduleTypes: import("@matter/types").FixedAttribute<import("@matter/types").TypeFromFields<{
                        systemMode: import("@matter/types").FieldType<import("@matter/types/clusters/thermostat").Thermostat.SystemMode>;
                        numberOfSchedules: import("@matter/types").FieldType<number>;
                        scheduleTypeFeatures: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                            supportsPresets: import("@matter/types").BitFlag;
                            supportsSetpoints: import("@matter/types").BitFlag;
                            supportsNames: import("@matter/types").BitFlag;
                            supportsOff: import("@matter/types").BitFlag;
                        }>>;
                    }>[], any>;
                    readonly numberOfSchedules: import("@matter/types").FixedAttribute<number, any>;
                    readonly numberOfScheduleTransitions: import("@matter/types").FixedAttribute<number, any>;
                    readonly numberOfScheduleTransitionPerDay: import("@matter/types").FixedAttribute<number | null, any>;
                    readonly activeScheduleHandle: import("@matter/types").Attribute<Uint8Array<ArrayBufferLike> | null, any>;
                    readonly schedules: import("@matter/types").WritableAttribute<import("@matter/types").TypeFromFields<{
                        scheduleHandle: import("@matter/types").FieldType<Uint8Array<ArrayBufferLike> | null>;
                        systemMode: import("@matter/types").FieldType<import("@matter/types/clusters/thermostat").Thermostat.SystemMode>;
                        name: import("@matter/types").OptionalFieldType<string>;
                        presetHandle: import("@matter/types").OptionalFieldType<Uint8Array<ArrayBufferLike>>;
                        transitions: import("@matter/types").FieldType<import("@matter/types").TypeFromFields<{
                            dayOfWeek: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                                sunday: import("@matter/types").BitFlag;
                                monday: import("@matter/types").BitFlag;
                                tuesday: import("@matter/types").BitFlag;
                                wednesday: import("@matter/types").BitFlag;
                                thursday: import("@matter/types").BitFlag;
                                friday: import("@matter/types").BitFlag;
                                saturday: import("@matter/types").BitFlag;
                                away: import("@matter/types").BitFlag;
                            }>>;
                            transitionTime: import("@matter/types").FieldType<number>;
                            presetHandle: import("@matter/types").OptionalFieldType<Uint8Array<ArrayBufferLike>>;
                            systemMode: import("@matter/types").OptionalFieldType<import("@matter/types/clusters/thermostat").Thermostat.SystemMode>;
                            coolingSetpoint: import("@matter/types").OptionalFieldType<number>;
                            heatingSetpoint: import("@matter/types").OptionalFieldType<number>;
                        }>[]>;
                        builtIn: import("@matter/types").FieldType<boolean | null>;
                    }>[], any>;
                };
                readonly commands: {
                    readonly setActiveScheduleRequest: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                        scheduleHandle: import("@matter/types").FieldType<Uint8Array<ArrayBufferLike>>;
                    }>, void, any>;
                };
            };
        }, {
            readonly flags: {
                readonly autoMode: true;
                readonly heating: false;
            };
            readonly component: false;
        }, {
            readonly flags: {
                readonly autoMode: true;
                readonly cooling: false;
            };
            readonly component: false;
        }, {
            readonly flags: {
                readonly heating: false;
                readonly cooling: false;
            };
            readonly component: false;
        }];
    }>, import("../index.js").ClusterBehavior.Type<import("@matter/types").ClusterType.Of<{
        readonly id: 0;
        readonly revision: 0;
        readonly name: "Unknown";
        readonly attributes: {};
        readonly commands: {};
        readonly events: {};
    }>, typeof import("../index.js").ClusterBehavior, import("../behaviors/index.js").ThermostatInterface>, import("../behaviors/index.js").ThermostatInterface>;
    /**
     * An implementation for each server cluster supported by the endpoint per the Matter specification.
     */
    const server: {
        optional: {
            Identify: typeof BaseIdentifyServer;
        };
        mandatory: {};
    };
    /**
     * A definition for each client cluster supported by the endpoint per the Matter specification.
     */
    const client: {
        optional: {
            Thermostat: import("../index.js").ClusterBehavior.Type<import("@matter/types").ClusterType.Of<{
                readonly id: 513;
                readonly name: "Thermostat";
                readonly revision: 8;
                readonly features: {
                    readonly heating: import("@matter/types").BitFlag;
                    readonly cooling: import("@matter/types").BitFlag;
                    readonly occupancy: import("@matter/types").BitFlag;
                    readonly scheduleConfiguration: import("@matter/types").BitFlag;
                    readonly setback: import("@matter/types").BitFlag;
                    readonly autoMode: import("@matter/types").BitFlag;
                    readonly localTemperatureNotExposed: import("@matter/types").BitFlag;
                    readonly matterScheduleConfiguration: import("@matter/types").BitFlag;
                    readonly presets: import("@matter/types").BitFlag;
                };
                readonly attributes: {
                    readonly localTemperature: import("@matter/types").Attribute<number | null, any>;
                    readonly outdoorTemperature: import("@matter/types").OptionalAttribute<number | null, any>;
                    readonly hvacSystemTypeConfiguration: import("@matter/types").OptionalWritableAttribute<import("@matter/types").TypeFromPartialBitSchema<{
                        coolingStage: import("@matter/types").BitField;
                        heatingStage: import("@matter/types").BitField;
                        heatingIsHeatPump: import("@matter/types").BitFlag;
                        heatingUsesFuel: import("@matter/types").BitFlag;
                    }>, any>;
                    readonly remoteSensing: import("@matter/types").OptionalWritableAttribute<import("@matter/types").TypeFromPartialBitSchema<{
                        localTemperature: import("@matter/types").BitFlag;
                        outdoorTemperature: import("@matter/types").BitFlag;
                        occupancy: import("@matter/types").BitFlag;
                    }>, any>;
                    readonly controlSequenceOfOperation: import("@matter/types").WritableAttribute<import("@matter/types/clusters/thermostat").Thermostat.ControlSequenceOfOperation, any>;
                    readonly systemMode: import("@matter/types").WritableAttribute<import("@matter/types/clusters/thermostat").Thermostat.SystemMode, any>;
                    readonly temperatureSetpointHold: import("@matter/types").OptionalWritableAttribute<import("@matter/types/clusters/thermostat").Thermostat.TemperatureSetpointHold, any>;
                    readonly temperatureSetpointHoldDuration: import("@matter/types").OptionalWritableAttribute<number | null, any>;
                    readonly thermostatProgrammingOperationMode: import("@matter/types").OptionalWritableAttribute<import("@matter/types").TypeFromPartialBitSchema<{
                        scheduleActive: import("@matter/types").BitFlag;
                        autoRecovery: import("@matter/types").BitFlag;
                        economy: import("@matter/types").BitFlag;
                    }>, any>;
                    readonly thermostatRunningState: import("@matter/types").OptionalAttribute<import("@matter/types").TypeFromPartialBitSchema<{
                        heat: import("@matter/types").BitFlag;
                        cool: import("@matter/types").BitFlag;
                        fan: import("@matter/types").BitFlag;
                        heatStage2: import("@matter/types").BitFlag;
                        coolStage2: import("@matter/types").BitFlag;
                        fanStage2: import("@matter/types").BitFlag;
                        fanStage3: import("@matter/types").BitFlag;
                    }>, any>;
                    readonly setpointChangeSource: import("@matter/types").OptionalAttribute<import("@matter/types/clusters/thermostat").Thermostat.SetpointChangeSource, any>;
                    readonly setpointChangeAmount: import("@matter/types").OptionalAttribute<number | null, any>;
                    readonly setpointChangeSourceTimestamp: import("@matter/types").OptionalAttribute<number, any>;
                    readonly emergencyHeatDelta: import("@matter/types").OptionalWritableAttribute<number, any>;
                    readonly acType: import("@matter/types").OptionalWritableAttribute<import("@matter/types/clusters/thermostat").Thermostat.AcType, any>;
                    readonly acCapacity: import("@matter/types").OptionalWritableAttribute<number, any>;
                    readonly acRefrigerantType: import("@matter/types").OptionalWritableAttribute<import("@matter/types/clusters/thermostat").Thermostat.AcRefrigerantType, any>;
                    readonly acCompressorType: import("@matter/types").OptionalWritableAttribute<import("@matter/types/clusters/thermostat").Thermostat.AcCompressorType, any>;
                    readonly acErrorCode: import("@matter/types").OptionalWritableAttribute<import("@matter/types").TypeFromPartialBitSchema<{
                        compressorFail: import("@matter/types").BitFlag;
                        roomSensorFail: import("@matter/types").BitFlag;
                        outdoorSensorFail: import("@matter/types").BitFlag;
                        coilSensorFail: import("@matter/types").BitFlag;
                        fanFail: import("@matter/types").BitFlag;
                    }>, any>;
                    readonly acLouverPosition: import("@matter/types").OptionalWritableAttribute<import("@matter/types/clusters/thermostat").Thermostat.AcLouverPosition, any>;
                    readonly acCoilTemperature: import("@matter/types").OptionalAttribute<number | null, any>;
                    readonly acCapacityFormat: import("@matter/types").OptionalWritableAttribute<import("@matter/types/clusters/thermostat").Thermostat.AcCapacityFormat, any>;
                    readonly setpointHoldExpiryTimestamp: import("@matter/types").OptionalAttribute<number | null, any>;
                };
                readonly commands: {
                    readonly setpointRaiseLower: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                        mode: import("@matter/types").FieldType<import("@matter/types/clusters/thermostat").Thermostat.SetpointRaiseLowerMode>;
                        amount: import("@matter/types").FieldType<number>;
                    }>, void, any>;
                };
                readonly extensions: readonly [{
                    readonly flags: {
                        readonly occupancy: true;
                    };
                    readonly component: {
                        readonly attributes: {
                            readonly occupancy: import("@matter/types").Attribute<import("@matter/types").TypeFromPartialBitSchema<{
                                occupied: import("@matter/types").BitFlag;
                            }>, any>;
                        };
                    };
                }, {
                    readonly flags: {
                        readonly heating: true;
                    };
                    readonly component: {
                        readonly attributes: {
                            readonly absMinHeatSetpointLimit: import("@matter/types").OptionalFixedAttribute<number, any>;
                            readonly absMaxHeatSetpointLimit: import("@matter/types").OptionalFixedAttribute<number, any>;
                            readonly piHeatingDemand: import("@matter/types").OptionalAttribute<number, any>;
                            readonly occupiedHeatingSetpoint: import("@matter/types").WritableAttribute<number, any>;
                            readonly minHeatSetpointLimit: import("@matter/types").OptionalWritableAttribute<number, any>;
                            readonly maxHeatSetpointLimit: import("@matter/types").OptionalWritableAttribute<number, any>;
                        };
                    };
                }, {
                    readonly flags: {
                        readonly cooling: true;
                    };
                    readonly component: {
                        readonly attributes: {
                            readonly absMinCoolSetpointLimit: import("@matter/types").OptionalFixedAttribute<number, any>;
                            readonly absMaxCoolSetpointLimit: import("@matter/types").OptionalFixedAttribute<number, any>;
                            readonly piCoolingDemand: import("@matter/types").OptionalAttribute<number, any>;
                            readonly occupiedCoolingSetpoint: import("@matter/types").WritableAttribute<number, any>;
                            readonly minCoolSetpointLimit: import("@matter/types").OptionalWritableAttribute<number, any>;
                            readonly maxCoolSetpointLimit: import("@matter/types").OptionalWritableAttribute<number, any>;
                        };
                    };
                }, {
                    readonly flags: {
                        readonly localTemperatureNotExposed: false;
                    };
                    readonly component: {
                        readonly attributes: {
                            readonly localTemperatureCalibration: import("@matter/types").OptionalWritableAttribute<number, any>;
                        };
                    };
                }, {
                    readonly flags: {
                        readonly cooling: true;
                        readonly occupancy: true;
                    };
                    readonly component: {
                        readonly attributes: {
                            readonly unoccupiedCoolingSetpoint: import("@matter/types").WritableAttribute<number, any>;
                        };
                    };
                }, {
                    readonly flags: {
                        readonly heating: true;
                        readonly occupancy: true;
                    };
                    readonly component: {
                        readonly attributes: {
                            readonly unoccupiedHeatingSetpoint: import("@matter/types").WritableAttribute<number, any>;
                        };
                    };
                }, {
                    readonly flags: {
                        readonly autoMode: true;
                    };
                    readonly component: {
                        readonly attributes: {
                            readonly minSetpointDeadBand: import("@matter/types").WritableAttribute<number, any>;
                            readonly thermostatRunningMode: import("@matter/types").OptionalAttribute<import("@matter/types/clusters/thermostat").Thermostat.ThermostatRunningMode, any>;
                        };
                    };
                }, {
                    readonly flags: {
                        readonly scheduleConfiguration: true;
                    };
                    readonly component: {
                        readonly attributes: {
                            readonly startOfWeek: import("@matter/types").FixedAttribute<import("@matter/types/clusters/thermostat").Thermostat.StartOfWeek, any>;
                            readonly numberOfWeeklyTransitions: import("@matter/types").FixedAttribute<number, any>;
                            readonly numberOfDailyTransitions: import("@matter/types").FixedAttribute<number, any>;
                        };
                        readonly commands: {
                            readonly setWeeklySchedule: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                                numberOfTransitionsForSequence: import("@matter/types").FieldType<number>;
                                dayOfWeekForSequence: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                                    sunday: import("@matter/types").BitFlag;
                                    monday: import("@matter/types").BitFlag;
                                    tuesday: import("@matter/types").BitFlag;
                                    wednesday: import("@matter/types").BitFlag;
                                    thursday: import("@matter/types").BitFlag;
                                    friday: import("@matter/types").BitFlag;
                                    saturday: import("@matter/types").BitFlag;
                                    away: import("@matter/types").BitFlag;
                                }>>;
                                modeForSequence: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                                    heatSetpointPresent: import("@matter/types").BitFlag;
                                    coolSetpointPresent: import("@matter/types").BitFlag;
                                }>>;
                                transitions: import("@matter/types").FieldType<import("@matter/types").TypeFromFields<{
                                    transitionTime: import("@matter/types").FieldType<number>;
                                    heatSetpoint: import("@matter/types").FieldType<number | null>;
                                    coolSetpoint: import("@matter/types").FieldType<number | null>;
                                }>[]>;
                            }>, void, any>;
                            readonly getWeeklySchedule: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                                daysToReturn: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                                    sunday: import("@matter/types").BitFlag;
                                    monday: import("@matter/types").BitFlag;
                                    tuesday: import("@matter/types").BitFlag;
                                    wednesday: import("@matter/types").BitFlag;
                                    thursday: import("@matter/types").BitFlag;
                                    friday: import("@matter/types").BitFlag;
                                    saturday: import("@matter/types").BitFlag;
                                    away: import("@matter/types").BitFlag;
                                }>>;
                                modeToReturn: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                                    heatSetpointPresent: import("@matter/types").BitFlag;
                                    coolSetpointPresent: import("@matter/types").BitFlag;
                                }>>;
                            }>, import("@matter/types").TypeFromFields<{
                                numberOfTransitionsForSequence: import("@matter/types").FieldType<number>;
                                dayOfWeekForSequence: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                                    sunday: import("@matter/types").BitFlag;
                                    monday: import("@matter/types").BitFlag;
                                    tuesday: import("@matter/types").BitFlag;
                                    wednesday: import("@matter/types").BitFlag;
                                    thursday: import("@matter/types").BitFlag;
                                    friday: import("@matter/types").BitFlag;
                                    saturday: import("@matter/types").BitFlag;
                                    away: import("@matter/types").BitFlag;
                                }>>;
                                modeForSequence: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                                    heatSetpointPresent: import("@matter/types").BitFlag;
                                    coolSetpointPresent: import("@matter/types").BitFlag;
                                }>>;
                                transitions: import("@matter/types").FieldType<import("@matter/types").TypeFromFields<{
                                    transitionTime: import("@matter/types").FieldType<number>;
                                    heatSetpoint: import("@matter/types").FieldType<number | null>;
                                    coolSetpoint: import("@matter/types").FieldType<number | null>;
                                }>[]>;
                            }>, any>;
                            readonly clearWeeklySchedule: import("@matter/types").Command<void, void, any>;
                        };
                    };
                }, {
                    readonly flags: {
                        readonly setback: true;
                    };
                    readonly component: {
                        readonly attributes: {
                            readonly occupiedSetback: import("@matter/types").WritableAttribute<number | null, any>;
                            readonly occupiedSetbackMin: import("@matter/types").FixedAttribute<number | null, any>;
                            readonly occupiedSetbackMax: import("@matter/types").FixedAttribute<number | null, any>;
                        };
                    };
                }, {
                    readonly flags: {
                        readonly setback: true;
                        readonly occupancy: true;
                    };
                    readonly component: {
                        readonly attributes: {
                            readonly unoccupiedSetback: import("@matter/types").WritableAttribute<number | null, any>;
                            readonly unoccupiedSetbackMin: import("@matter/types").FixedAttribute<number | null, any>;
                            readonly unoccupiedSetbackMax: import("@matter/types").FixedAttribute<number | null, any>;
                        };
                    };
                }, {
                    readonly flags: {
                        readonly presets: true;
                    };
                    readonly component: {
                        readonly attributes: {
                            readonly presetTypes: import("@matter/types").FixedAttribute<import("@matter/types").TypeFromFields<{
                                presetScenario: import("@matter/types").FieldType<import("@matter/types/clusters/thermostat").Thermostat.PresetScenario>;
                                numberOfPresets: import("@matter/types").FieldType<number>;
                                presetTypeFeatures: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                                    automatic: import("@matter/types").BitFlag;
                                    supportsNames: import("@matter/types").BitFlag;
                                }>>;
                            }>[], any>;
                            readonly numberOfPresets: import("@matter/types").FixedAttribute<number, any>;
                            readonly activePresetHandle: import("@matter/types").Attribute<Uint8Array<ArrayBufferLike> | null, any>;
                            readonly presets: import("@matter/types").WritableAttribute<import("@matter/types").TypeFromFields<{
                                presetHandle: import("@matter/types").FieldType<Uint8Array<ArrayBufferLike> | null>;
                                presetScenario: import("@matter/types").FieldType<import("@matter/types/clusters/thermostat").Thermostat.PresetScenario>;
                                name: import("@matter/types").OptionalFieldType<string | null>;
                                coolingSetpoint: import("@matter/types").OptionalFieldType<number>;
                                heatingSetpoint: import("@matter/types").OptionalFieldType<number>;
                                builtIn: import("@matter/types").FieldType<boolean | null>;
                            }>[], any>;
                        };
                        readonly commands: {
                            readonly setActivePresetRequest: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                                presetHandle: import("@matter/types").FieldType<Uint8Array<ArrayBufferLike> | null>;
                            }>, void, any>;
                        };
                    };
                }, {
                    readonly flags: {
                        readonly matterScheduleConfiguration: true;
                    };
                    readonly component: {
                        readonly attributes: {
                            readonly scheduleTypes: import("@matter/types").FixedAttribute<import("@matter/types").TypeFromFields<{
                                systemMode: import("@matter/types").FieldType<import("@matter/types/clusters/thermostat").Thermostat.SystemMode>;
                                numberOfSchedules: import("@matter/types").FieldType<number>;
                                scheduleTypeFeatures: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                                    supportsPresets: import("@matter/types").BitFlag;
                                    supportsSetpoints: import("@matter/types").BitFlag;
                                    supportsNames: import("@matter/types").BitFlag;
                                    supportsOff: import("@matter/types").BitFlag;
                                }>>;
                            }>[], any>;
                            readonly numberOfSchedules: import("@matter/types").FixedAttribute<number, any>;
                            readonly numberOfScheduleTransitions: import("@matter/types").FixedAttribute<number, any>;
                            readonly numberOfScheduleTransitionPerDay: import("@matter/types").FixedAttribute<number | null, any>;
                            readonly activeScheduleHandle: import("@matter/types").Attribute<Uint8Array<ArrayBufferLike> | null, any>;
                            readonly schedules: import("@matter/types").WritableAttribute<import("@matter/types").TypeFromFields<{
                                scheduleHandle: import("@matter/types").FieldType<Uint8Array<ArrayBufferLike> | null>;
                                systemMode: import("@matter/types").FieldType<import("@matter/types/clusters/thermostat").Thermostat.SystemMode>;
                                name: import("@matter/types").OptionalFieldType<string>;
                                presetHandle: import("@matter/types").OptionalFieldType<Uint8Array<ArrayBufferLike>>;
                                transitions: import("@matter/types").FieldType<import("@matter/types").TypeFromFields<{
                                    dayOfWeek: import("@matter/types").FieldType<import("@matter/types").TypeFromPartialBitSchema<{
                                        sunday: import("@matter/types").BitFlag;
                                        monday: import("@matter/types").BitFlag;
                                        tuesday: import("@matter/types").BitFlag;
                                        wednesday: import("@matter/types").BitFlag;
                                        thursday: import("@matter/types").BitFlag;
                                        friday: import("@matter/types").BitFlag;
                                        saturday: import("@matter/types").BitFlag;
                                        away: import("@matter/types").BitFlag;
                                    }>>;
                                    transitionTime: import("@matter/types").FieldType<number>;
                                    presetHandle: import("@matter/types").OptionalFieldType<Uint8Array<ArrayBufferLike>>;
                                    systemMode: import("@matter/types").OptionalFieldType<import("@matter/types/clusters/thermostat").Thermostat.SystemMode>;
                                    coolingSetpoint: import("@matter/types").OptionalFieldType<number>;
                                    heatingSetpoint: import("@matter/types").OptionalFieldType<number>;
                                }>[]>;
                                builtIn: import("@matter/types").FieldType<boolean | null>;
                            }>[], any>;
                        };
                        readonly commands: {
                            readonly setActiveScheduleRequest: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                                scheduleHandle: import("@matter/types").FieldType<Uint8Array<ArrayBufferLike>>;
                            }>, void, any>;
                        };
                    };
                }, {
                    readonly flags: {
                        readonly autoMode: true;
                        readonly heating: false;
                    };
                    readonly component: false;
                }, {
                    readonly flags: {
                        readonly autoMode: true;
                        readonly cooling: false;
                    };
                    readonly component: false;
                }, {
                    readonly flags: {
                        readonly heating: false;
                        readonly cooling: false;
                    };
                    readonly component: false;
                }];
            }>, import("../index.js").ClusterBehavior.Type<import("@matter/types").ClusterType.Of<{
                readonly id: 0;
                readonly revision: 0;
                readonly name: "Unknown";
                readonly attributes: {};
                readonly commands: {};
                readonly events: {};
            }>, typeof import("../index.js").ClusterBehavior, import("../behaviors/index.js").ThermostatInterface>, import("../behaviors/index.js").ThermostatInterface>;
        };
        mandatory: {};
    };
}
export declare const HeatPumpDeviceDefinition: MutableEndpoint.With<import("../index.js").EndpointType.For<{
    readonly name: "HeatPump";
    readonly deviceType: 777;
    readonly deviceRevision: 1;
    readonly requirements: typeof HeatPumpRequirements;
    readonly behaviors: {};
}>, {}>;
export declare const HeatPumpDevice: HeatPumpDevice;
//# sourceMappingURL=heat-pump.d.ts.map