/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
/*** THIS FILE IS GENERATED, DO NOT EDIT ***/
import { IdentifyServer as BaseIdentifyServer } from "../behaviors/identify/IdentifyServer.js";
import { MutableEndpoint } from "../endpoint/type/MutableEndpoint.js";
import { Identity } from "#general";
/**
 * A Window Covering Controller is a device that controls an automatic window covering.
 *
 * @see {@link MatterSpecification.v14.Device} ยง 8.4
 */
export interface WindowCoveringControllerDevice extends Identity<typeof WindowCoveringControllerDeviceDefinition> {
}
export declare namespace WindowCoveringControllerRequirements {
    /**
     * The Identify cluster is optional per the Matter specification.
     *
     * We provide this alias to the default implementation {@link IdentifyServer} for convenience.
     */
    const IdentifyServer: typeof BaseIdentifyServer;
    /**
     * The WindowCovering cluster is required by the Matter specification.
     *
     * We provide this alias to the default implementation {@link WindowCoveringBehavior} for convenience.
     */
    const WindowCoveringBehavior: import("../index.js").ClusterBehavior.Type<import("@matter/types").ClusterType.Of<{
        readonly id: 258;
        readonly name: "WindowCovering";
        readonly revision: 5;
        readonly features: {
            readonly lift: import("@matter/types").BitFlag;
            readonly tilt: import("@matter/types").BitFlag;
            readonly positionAwareLift: import("@matter/types").BitFlag;
            readonly absolutePosition: import("@matter/types").BitFlag;
            readonly positionAwareTilt: import("@matter/types").BitFlag;
        };
        readonly attributes: {
            readonly type: import("@matter/types").FixedAttribute<import("@matter/types/clusters/window-covering").WindowCovering.WindowCoveringType, any>;
            readonly configStatus: import("@matter/types").Attribute<import("@matter/types").TypeFromPartialBitSchema<{
                operational: import("@matter/types").BitFlag;
                onlineReserved: import("@matter/types").BitFlag;
                liftMovementReversed: import("@matter/types").BitFlag;
                liftPositionAware: import("@matter/types").BitFlag;
                tiltPositionAware: import("@matter/types").BitFlag;
                liftEncoderControlled: import("@matter/types").BitFlag;
                tiltEncoderControlled: import("@matter/types").BitFlag;
            }>, any>;
            readonly operationalStatus: import("@matter/types").Attribute<import("@matter/types").TypeFromPartialBitSchema<{
                global: import("@matter/types").BitFieldEnum<import("@matter/types/clusters/window-covering").WindowCovering.MovementStatus>;
                lift: import("@matter/types").BitFieldEnum<import("@matter/types/clusters/window-covering").WindowCovering.MovementStatus>;
                tilt: import("@matter/types").BitFieldEnum<import("@matter/types/clusters/window-covering").WindowCovering.MovementStatus>;
            }>, any>;
            readonly endProductType: import("@matter/types").FixedAttribute<import("@matter/types/clusters/window-covering").WindowCovering.EndProductType, any>;
            readonly mode: import("@matter/types").WritableAttribute<import("@matter/types").TypeFromPartialBitSchema<{
                motorDirectionReversed: import("@matter/types").BitFlag;
                calibrationMode: import("@matter/types").BitFlag;
                maintenanceMode: import("@matter/types").BitFlag;
                ledFeedback: import("@matter/types").BitFlag;
            }>, any>;
            readonly safetyStatus: import("@matter/types").OptionalAttribute<import("@matter/types").TypeFromPartialBitSchema<{
                remoteLockout: import("@matter/types").BitFlag;
                tamperDetection: import("@matter/types").BitFlag;
                failedCommunication: import("@matter/types").BitFlag;
                positionFailure: import("@matter/types").BitFlag;
                thermalProtection: import("@matter/types").BitFlag;
                obstacleDetected: import("@matter/types").BitFlag;
                power: import("@matter/types").BitFlag;
                stopInput: import("@matter/types").BitFlag;
                motorJammed: import("@matter/types").BitFlag;
                hardwareFailure: import("@matter/types").BitFlag;
                manualOperation: import("@matter/types").BitFlag;
                protection: import("@matter/types").BitFlag;
            }>, any>;
        };
        readonly commands: {
            readonly upOrOpen: import("@matter/types").Command<void, void, any>;
            readonly downOrClose: import("@matter/types").Command<void, void, any>;
            readonly stopMotion: import("@matter/types").Command<void, void, any>;
        };
        readonly extensions: readonly [{
            readonly flags: {
                readonly lift: true;
                readonly positionAwareLift: true;
                readonly absolutePosition: true;
            };
            readonly component: {
                readonly attributes: {
                    readonly physicalClosedLimitLift: import("@matter/types").OptionalFixedAttribute<number, any>;
                    readonly currentPositionLift: import("@matter/types").OptionalAttribute<number | null, any>;
                    readonly installedOpenLimitLift: import("@matter/types").Attribute<number, any>;
                    readonly installedClosedLimitLift: import("@matter/types").Attribute<number, any>;
                };
            };
        }, {
            readonly flags: {
                readonly tilt: true;
                readonly positionAwareTilt: true;
                readonly absolutePosition: true;
            };
            readonly component: {
                readonly attributes: {
                    readonly physicalClosedLimitTilt: import("@matter/types").OptionalFixedAttribute<number, any>;
                    readonly currentPositionTilt: import("@matter/types").OptionalAttribute<number | null, any>;
                    readonly installedOpenLimitTilt: import("@matter/types").Attribute<number, any>;
                    readonly installedClosedLimitTilt: import("@matter/types").Attribute<number, any>;
                };
            };
        }, {
            readonly flags: {
                readonly lift: true;
            };
            readonly component: {
                readonly attributes: {
                    readonly numberOfActuationsLift: import("@matter/types").OptionalAttribute<number, any>;
                };
                readonly commands: {
                    readonly goToLiftPercentage: import("@matter/types").OptionalCommand<import("@matter/types").TypeFromFields<{
                        liftPercent100thsValue: import("@matter/types").FieldType<number>;
                    }>, void, any>;
                };
            };
        }, {
            readonly flags: {
                readonly tilt: true;
            };
            readonly component: {
                readonly attributes: {
                    readonly numberOfActuationsTilt: import("@matter/types").OptionalAttribute<number, any>;
                };
                readonly commands: {
                    readonly goToTiltPercentage: import("@matter/types").OptionalCommand<import("@matter/types").TypeFromFields<{
                        tiltPercent100thsValue: import("@matter/types").FieldType<number>;
                    }>, void, any>;
                };
            };
        }, {
            readonly flags: {
                readonly lift: true;
                readonly positionAwareLift: true;
            };
            readonly component: {
                readonly attributes: {
                    readonly currentPositionLiftPercentage: import("@matter/types").OptionalAttribute<number | null, any>;
                    readonly targetPositionLiftPercent100ths: import("@matter/types").Attribute<number | null, any>;
                    readonly currentPositionLiftPercent100ths: import("@matter/types").Attribute<number | null, any>;
                };
                readonly commands: {
                    readonly goToLiftPercentage: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                        liftPercent100thsValue: import("@matter/types").FieldType<number>;
                    }>, void, any>;
                };
            };
        }, {
            readonly flags: {
                readonly tilt: true;
                readonly positionAwareTilt: true;
            };
            readonly component: {
                readonly attributes: {
                    readonly currentPositionTiltPercentage: import("@matter/types").OptionalAttribute<number | null, any>;
                    readonly targetPositionTiltPercent100ths: import("@matter/types").Attribute<number | null, any>;
                    readonly currentPositionTiltPercent100ths: import("@matter/types").Attribute<number | null, any>;
                };
                readonly commands: {
                    readonly goToTiltPercentage: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                        tiltPercent100thsValue: import("@matter/types").FieldType<number>;
                    }>, void, any>;
                };
            };
        }, {
            readonly flags: {
                readonly lift: true;
                readonly absolutePosition: true;
            };
            readonly component: {
                readonly commands: {
                    readonly goToLiftValue: import("@matter/types").OptionalCommand<import("@matter/types").TypeFromFields<{
                        liftValue: import("@matter/types").FieldType<number>;
                    }>, void, any>;
                };
            };
        }, {
            readonly flags: {
                readonly tilt: true;
                readonly absolutePosition: true;
            };
            readonly component: {
                readonly commands: {
                    readonly goToTiltValue: import("@matter/types").OptionalCommand<import("@matter/types").TypeFromFields<{
                        tiltValue: import("@matter/types").FieldType<number>;
                    }>, void, any>;
                };
            };
        }, {
            readonly flags: {
                readonly positionAwareLift: true;
                readonly lift: false;
            };
            readonly component: false;
        }, {
            readonly flags: {
                readonly positionAwareTilt: true;
                readonly tilt: false;
            };
            readonly component: false;
        }, {
            readonly flags: {
                readonly lift: false;
                readonly tilt: false;
            };
            readonly component: false;
        }];
    }>, import("../index.js").ClusterBehavior.Type<import("@matter/types").ClusterType.Of<{
        readonly id: 0;
        readonly revision: 0;
        readonly name: "Unknown";
        readonly attributes: {};
        readonly commands: {};
        readonly events: {};
    }>, typeof import("../index.js").ClusterBehavior, import("../behaviors/index.js").WindowCoveringInterface>, import("../behaviors/index.js").WindowCoveringInterface>;
    /**
     * The Identify cluster is optional per the Matter specification.
     *
     * We provide this alias to the default implementation {@link IdentifyBehavior} for convenience.
     */
    const IdentifyBehavior: import("../index.js").ClusterBehavior.Type<import("@matter/types/clusters/identify").Identify.Cluster, import("../index.js").ClusterBehavior.Type<import("@matter/types").ClusterType.Of<{
        readonly id: 0;
        readonly revision: 0;
        readonly name: "Unknown";
        readonly attributes: {};
        readonly commands: {};
        readonly events: {};
    }>, typeof import("../index.js").ClusterBehavior, import("../behaviors/index.js").IdentifyInterface>, import("../behaviors/index.js").IdentifyInterface>;
    /**
     * The Groups cluster is optional per the Matter specification.
     *
     * We provide this alias to the default implementation {@link GroupsBehavior} for convenience.
     */
    const GroupsBehavior: import("../index.js").ClusterBehavior.Type<import("@matter/types/clusters/groups").Groups.Cluster, import("../index.js").ClusterBehavior.Type<import("@matter/types").ClusterType.Of<{
        readonly id: 0;
        readonly revision: 0;
        readonly name: "Unknown";
        readonly attributes: {};
        readonly commands: {};
        readonly events: {};
    }>, typeof import("../index.js").ClusterBehavior, import("../behaviors/index.js").GroupsInterface>, import("../behaviors/index.js").GroupsInterface>;
    /**
     * An implementation for each server cluster supported by the endpoint per the Matter specification.
     */
    const server: {
        optional: {
            Identify: typeof BaseIdentifyServer;
        };
        mandatory: {};
    };
    /**
     * A definition for each client cluster supported by the endpoint per the Matter specification.
     */
    const client: {
        mandatory: {
            WindowCovering: import("../index.js").ClusterBehavior.Type<import("@matter/types").ClusterType.Of<{
                readonly id: 258;
                readonly name: "WindowCovering";
                readonly revision: 5;
                readonly features: {
                    readonly lift: import("@matter/types").BitFlag;
                    readonly tilt: import("@matter/types").BitFlag;
                    readonly positionAwareLift: import("@matter/types").BitFlag;
                    readonly absolutePosition: import("@matter/types").BitFlag;
                    readonly positionAwareTilt: import("@matter/types").BitFlag;
                };
                readonly attributes: {
                    readonly type: import("@matter/types").FixedAttribute<import("@matter/types/clusters/window-covering").WindowCovering.WindowCoveringType, any>;
                    readonly configStatus: import("@matter/types").Attribute<import("@matter/types").TypeFromPartialBitSchema<{
                        operational: import("@matter/types").BitFlag;
                        onlineReserved: import("@matter/types").BitFlag;
                        liftMovementReversed: import("@matter/types").BitFlag;
                        liftPositionAware: import("@matter/types").BitFlag;
                        tiltPositionAware: import("@matter/types").BitFlag;
                        liftEncoderControlled: import("@matter/types").BitFlag;
                        tiltEncoderControlled: import("@matter/types").BitFlag;
                    }>, any>;
                    readonly operationalStatus: import("@matter/types").Attribute<import("@matter/types").TypeFromPartialBitSchema<{
                        global: import("@matter/types").BitFieldEnum<import("@matter/types/clusters/window-covering").WindowCovering.MovementStatus>;
                        lift: import("@matter/types").BitFieldEnum<import("@matter/types/clusters/window-covering").WindowCovering.MovementStatus>;
                        tilt: import("@matter/types").BitFieldEnum<import("@matter/types/clusters/window-covering").WindowCovering.MovementStatus>;
                    }>, any>;
                    readonly endProductType: import("@matter/types").FixedAttribute<import("@matter/types/clusters/window-covering").WindowCovering.EndProductType, any>;
                    readonly mode: import("@matter/types").WritableAttribute<import("@matter/types").TypeFromPartialBitSchema<{
                        motorDirectionReversed: import("@matter/types").BitFlag;
                        calibrationMode: import("@matter/types").BitFlag;
                        maintenanceMode: import("@matter/types").BitFlag;
                        ledFeedback: import("@matter/types").BitFlag;
                    }>, any>;
                    readonly safetyStatus: import("@matter/types").OptionalAttribute<import("@matter/types").TypeFromPartialBitSchema<{
                        remoteLockout: import("@matter/types").BitFlag;
                        tamperDetection: import("@matter/types").BitFlag;
                        failedCommunication: import("@matter/types").BitFlag;
                        positionFailure: import("@matter/types").BitFlag;
                        thermalProtection: import("@matter/types").BitFlag;
                        obstacleDetected: import("@matter/types").BitFlag;
                        power: import("@matter/types").BitFlag;
                        stopInput: import("@matter/types").BitFlag;
                        motorJammed: import("@matter/types").BitFlag;
                        hardwareFailure: import("@matter/types").BitFlag;
                        manualOperation: import("@matter/types").BitFlag;
                        protection: import("@matter/types").BitFlag;
                    }>, any>;
                };
                readonly commands: {
                    readonly upOrOpen: import("@matter/types").Command<void, void, any>;
                    readonly downOrClose: import("@matter/types").Command<void, void, any>;
                    readonly stopMotion: import("@matter/types").Command<void, void, any>;
                };
                readonly extensions: readonly [{
                    readonly flags: {
                        readonly lift: true;
                        readonly positionAwareLift: true;
                        readonly absolutePosition: true;
                    };
                    readonly component: {
                        readonly attributes: {
                            readonly physicalClosedLimitLift: import("@matter/types").OptionalFixedAttribute<number, any>;
                            readonly currentPositionLift: import("@matter/types").OptionalAttribute<number | null, any>;
                            readonly installedOpenLimitLift: import("@matter/types").Attribute<number, any>;
                            readonly installedClosedLimitLift: import("@matter/types").Attribute<number, any>;
                        };
                    };
                }, {
                    readonly flags: {
                        readonly tilt: true;
                        readonly positionAwareTilt: true;
                        readonly absolutePosition: true;
                    };
                    readonly component: {
                        readonly attributes: {
                            readonly physicalClosedLimitTilt: import("@matter/types").OptionalFixedAttribute<number, any>;
                            readonly currentPositionTilt: import("@matter/types").OptionalAttribute<number | null, any>;
                            readonly installedOpenLimitTilt: import("@matter/types").Attribute<number, any>;
                            readonly installedClosedLimitTilt: import("@matter/types").Attribute<number, any>;
                        };
                    };
                }, {
                    readonly flags: {
                        readonly lift: true;
                    };
                    readonly component: {
                        readonly attributes: {
                            readonly numberOfActuationsLift: import("@matter/types").OptionalAttribute<number, any>;
                        };
                        readonly commands: {
                            readonly goToLiftPercentage: import("@matter/types").OptionalCommand<import("@matter/types").TypeFromFields<{
                                liftPercent100thsValue: import("@matter/types").FieldType<number>;
                            }>, void, any>;
                        };
                    };
                }, {
                    readonly flags: {
                        readonly tilt: true;
                    };
                    readonly component: {
                        readonly attributes: {
                            readonly numberOfActuationsTilt: import("@matter/types").OptionalAttribute<number, any>;
                        };
                        readonly commands: {
                            readonly goToTiltPercentage: import("@matter/types").OptionalCommand<import("@matter/types").TypeFromFields<{
                                tiltPercent100thsValue: import("@matter/types").FieldType<number>;
                            }>, void, any>;
                        };
                    };
                }, {
                    readonly flags: {
                        readonly lift: true;
                        readonly positionAwareLift: true;
                    };
                    readonly component: {
                        readonly attributes: {
                            readonly currentPositionLiftPercentage: import("@matter/types").OptionalAttribute<number | null, any>;
                            readonly targetPositionLiftPercent100ths: import("@matter/types").Attribute<number | null, any>;
                            readonly currentPositionLiftPercent100ths: import("@matter/types").Attribute<number | null, any>;
                        };
                        readonly commands: {
                            readonly goToLiftPercentage: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                                liftPercent100thsValue: import("@matter/types").FieldType<number>;
                            }>, void, any>;
                        };
                    };
                }, {
                    readonly flags: {
                        readonly tilt: true;
                        readonly positionAwareTilt: true;
                    };
                    readonly component: {
                        readonly attributes: {
                            readonly currentPositionTiltPercentage: import("@matter/types").OptionalAttribute<number | null, any>;
                            readonly targetPositionTiltPercent100ths: import("@matter/types").Attribute<number | null, any>;
                            readonly currentPositionTiltPercent100ths: import("@matter/types").Attribute<number | null, any>;
                        };
                        readonly commands: {
                            readonly goToTiltPercentage: import("@matter/types").Command<import("@matter/types").TypeFromFields<{
                                tiltPercent100thsValue: import("@matter/types").FieldType<number>;
                            }>, void, any>;
                        };
                    };
                }, {
                    readonly flags: {
                        readonly lift: true;
                        readonly absolutePosition: true;
                    };
                    readonly component: {
                        readonly commands: {
                            readonly goToLiftValue: import("@matter/types").OptionalCommand<import("@matter/types").TypeFromFields<{
                                liftValue: import("@matter/types").FieldType<number>;
                            }>, void, any>;
                        };
                    };
                }, {
                    readonly flags: {
                        readonly tilt: true;
                        readonly absolutePosition: true;
                    };
                    readonly component: {
                        readonly commands: {
                            readonly goToTiltValue: import("@matter/types").OptionalCommand<import("@matter/types").TypeFromFields<{
                                tiltValue: import("@matter/types").FieldType<number>;
                            }>, void, any>;
                        };
                    };
                }, {
                    readonly flags: {
                        readonly positionAwareLift: true;
                        readonly lift: false;
                    };
                    readonly component: false;
                }, {
                    readonly flags: {
                        readonly positionAwareTilt: true;
                        readonly tilt: false;
                    };
                    readonly component: false;
                }, {
                    readonly flags: {
                        readonly lift: false;
                        readonly tilt: false;
                    };
                    readonly component: false;
                }];
            }>, import("../index.js").ClusterBehavior.Type<import("@matter/types").ClusterType.Of<{
                readonly id: 0;
                readonly revision: 0;
                readonly name: "Unknown";
                readonly attributes: {};
                readonly commands: {};
                readonly events: {};
            }>, typeof import("../index.js").ClusterBehavior, import("../behaviors/index.js").WindowCoveringInterface>, import("../behaviors/index.js").WindowCoveringInterface>;
        };
        optional: {
            Identify: import("../index.js").ClusterBehavior.Type<import("@matter/types/clusters/identify").Identify.Cluster, import("../index.js").ClusterBehavior.Type<import("@matter/types").ClusterType.Of<{
                readonly id: 0;
                readonly revision: 0;
                readonly name: "Unknown";
                readonly attributes: {};
                readonly commands: {};
                readonly events: {};
            }>, typeof import("../index.js").ClusterBehavior, import("../behaviors/index.js").IdentifyInterface>, import("../behaviors/index.js").IdentifyInterface>;
            Groups: import("../index.js").ClusterBehavior.Type<import("@matter/types/clusters/groups").Groups.Cluster, import("../index.js").ClusterBehavior.Type<import("@matter/types").ClusterType.Of<{
                readonly id: 0;
                readonly revision: 0;
                readonly name: "Unknown";
                readonly attributes: {};
                readonly commands: {};
                readonly events: {};
            }>, typeof import("../index.js").ClusterBehavior, import("../behaviors/index.js").GroupsInterface>, import("../behaviors/index.js").GroupsInterface>;
        };
    };
}
export declare const WindowCoveringControllerDeviceDefinition: MutableEndpoint.With<import("../index.js").EndpointType.For<{
    readonly name: "WindowCoveringController";
    readonly deviceType: 515;
    readonly deviceRevision: 3;
    readonly requirements: typeof WindowCoveringControllerRequirements;
    readonly behaviors: {};
}>, {}>;
export declare const WindowCoveringControllerDevice: WindowCoveringControllerDevice;
//# sourceMappingURL=window-covering-controller.d.ts.map