/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import type { Behavior } from "#behavior/Behavior.js";
import { ActionContext } from "#behavior/context/ActionContext.js";
import { MaybePromise } from "#general";
import { DescriptorBehavior } from "../behaviors/descriptor/DescriptorBehavior.js";
import type { Endpoint } from "./Endpoint.js";
import type { SupportedBehaviors } from "./properties/SupportedBehaviors.js";
import { EndpointType } from "./type/EndpointType.js";
export declare const INSTALL_BEHAVIOR: unique symbol;
/**
 * An Agent offers interaction with a single endpoint.  This is the operational interface to endpoints.  It is separate
 * from the {@link Endpoint} because the agent is context-aware and may be bound to a specific fabric.
 *
 * An endpoint agent manages one or more {@link Behavior} instances that implement a discrete subset of the agent's
 * functionality.
 *
 * Each endpoint agent has an associated {@link Agent.Type} that defines each {@link Behavior.Type} the endpoint
 * supports.
 *
 * {@link Agent.Type} is a permanent feature of an endpoint but agent instances themselves are transitory and there is
 * no guarantee they will exist beyond the lifecycle of a single transaction.
 */
export declare class Agent {
    #private;
    constructor(endpoint: Endpoint, context: ActionContext);
    /**
     * Access the {@link Endpoint} this agent acts on behalf of.
     */
    get endpoint(): Endpoint<EndpointType.Empty>;
    /**
     * Access an {@link Agent} for this agent's owner.
     */
    get owner(): Agent | undefined;
    /**
     * Access the agent's {@link ActionContext}.
     */
    get context(): ActionContext;
    /**
     * Test to see if a {@link Behavior.Type} is supported by this agent.
     */
    has<BehaviorT extends Behavior.Type>(type: BehaviorT): this is InstanceType<BehaviorT>;
    /**
     * Obtain a {@link Behavior} supported by this agent.  Throws an error if the {@link Behavior.Type} isn't supported
     * or is still initializing.
     *
     * You may also access behaviors using normal property access, e.g. `agent.descriptor` is the same as
     * `agent.get(DescriptorBehavior)`.
     *
     * Property access is available in TypeScript when the set of behaviors is defined statically.
     */
    get<T extends Behavior.Type>(type: T): InstanceType<T>;
    /**
     * Obtain a behavior supported by this agent.  Throws an error if the {@link Behavior.Type} isn't supported.  Waits
     * if the behavior is not yet initialized.
     */
    load<T extends Behavior.Type>(type: T): MaybePromise<InstanceType<T>>;
    /**
     * Trigger initialization of a supported {@link Behavior.Type}.
     *
     * Functionally identical to {@link load} but has no return value and errors are logged rather than thrown.
     */
    activate(type: Behavior.Type): void;
    /**
     * Add support for a {@link Behavior.Type}.
     */
    require<T extends Behavior.Type>(type: T, options?: Behavior.Options<T>): void;
    /**
     * Determine whether a behavior is loaded (does not validate class, only by ID).
     */
    isLoaded(type: Behavior.Type): boolean;
    get env(): import("#general").Environment;
    toString(): string;
    /**
     * Create a new {@link Agent} that supports the specified behaviors.
     */
    static for<T extends EndpointType>(type: EndpointType, behaviors: SupportedBehaviors): Agent.Type<T>;
    [INSTALL_BEHAVIOR](behavior: Behavior): void;
}
export declare namespace Agent {
    /**
     * Static type for {@link Agent} with a property for each statically defined behavior.
     *
     * Behaviors available at construction time are available as instance properties.  You must use {@link Agent.get} or
     * {@link Agent.require} to acquire behaviors added via {@link Agent.require}.
     */
    interface Type<T extends EndpointType = EndpointType.Empty> {
        new (endpoint: Endpoint, context: ActionContext): Instance<T>;
    }
    type Instance<T extends EndpointType = EndpointType.Empty> = Agent & {
        readonly [K in keyof T["behaviors"] & string]: InstanceType<T["behaviors"][K]>;
    } & {
        readonly descriptor: DescriptorBehavior;
    };
    /**
     * Internal interface used by Behavior's constructor to install.
     */
    interface Internal {
        [INSTALL_BEHAVIOR](behavior: Behavior): void;
    }
}
//# sourceMappingURL=Agent.d.ts.map