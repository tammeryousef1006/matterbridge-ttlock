"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Behaviors_exports = {};
__export(Behaviors_exports, {
  Behaviors: () => Behaviors
});
module.exports = __toCommonJS(Behaviors_exports);
var import_Behavior = require("#behavior/Behavior.js");
var import_ActionTracer = require("#behavior/context/ActionTracer.js");
var import_NodeActivity = require("#behavior/context/NodeActivity.js");
var import_OfflineContext = require("#behavior/context/server/OfflineContext.js");
var import_general = require("#general");
var import_model = require("#model");
var import_ProtocolService = require("#node/server/ProtocolService.js");
var import_DescriptorServer = require("../../behaviors/descriptor/DescriptorServer.js");
var import_EndpointVariableService = require("../EndpointVariableService.js");
var import_errors = require("../errors.js");
var import_EndpointInitializer = require("./EndpointInitializer.js");
var import_EndpointLifecycle = require("./EndpointLifecycle.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("Behaviors");
class Behaviors {
  #endpoint;
  #supported;
  #backings = {};
  #options;
  #protocol;
  /**
   * The {@link SupportedBehaviors} of the {@link Endpoint}.
   */
  get supported() {
    return this.#supported;
  }
  get status() {
    const status = {};
    for (const key in this.#supported) {
      status[key] = this.#backings[key]?.status ?? import_general.Lifecycle.Status.Inactive;
    }
    return status;
  }
  get [import_general.Diagnostic.value]() {
    return import_general.Diagnostic.lifecycleList(this.status);
  }
  get detailedDiagnostic() {
    return Object.entries(this.#supported).map(([name, type]) => {
      const backing = this.#backings[name];
      const result = [(0, import_general.Diagnostic)(backing?.status ?? import_general.Lifecycle.Status.Inactive, name)];
      const cluster = clusterOf(type);
      if (!cluster) {
        return result;
      }
      const elements = this.elementsOf(type);
      const elementDiagnostic = Array();
      const features = new import_model.FeatureSet(cluster.supportedFeatures);
      if (features.size) {
        elementDiagnostic.push([import_general.Diagnostic.strong("features"), features]);
      }
      if (elements.attributes.size) {
        elementDiagnostic.push([import_general.Diagnostic.strong("attributes"), elements.attributes]);
      }
      if (elements.commands.size) {
        elementDiagnostic.push([import_general.Diagnostic.strong("commands"), elements.commands]);
      }
      if (elements.events.size) {
        elementDiagnostic.push([import_general.Diagnostic.strong("events"), elements.events]);
      }
      if (elementDiagnostic.length) {
        result.push(import_general.Diagnostic.list(elementDiagnostic));
      }
      return result;
    });
  }
  constructor(endpoint, options) {
    const { type } = endpoint;
    if (typeof type?.behaviors !== "object") {
      throw new import_general.ImplementationError('EndpointType "behaviors" must be an array of Behavior.Type instances');
    }
    this.#endpoint = endpoint;
    this.#supported = type.behaviors;
    this.#options = options;
    if (!this.#supported.descriptor) {
      this.#supported.descriptor = import_DescriptorServer.DescriptorServer;
    }
    for (const id in this.#supported) {
      const type2 = this.#supported[id];
      if (!(type2.prototype instanceof import_Behavior.Behavior)) {
        throw new import_general.ImplementationError(`${endpoint}.${id}" is not a Behavior.Type`);
      }
      if (typeof type2.id !== "string") {
        throw new import_general.ImplementationError(`${endpoint}.${id} has no ID`);
      }
      this.#augmentEndpoint(type2);
    }
  }
  /**
   * Activate any behaviors designated for immediate activation.  Returns a promise iff any behaviors have ongoing
   * initialization.
   *
   * Throws an error if any behavior crashes, but we allow all behaviors to settle before throwing.  The goal is to
   * surface multiple configuration errors and prevent inconsistent state caused by partial initialization.
   */
  initialize() {
    if (!this.#endpoint.lifecycle.isInstalled) {
      throw new import_general.ImplementationError(`Cannot initialize behaviors because endpoint is not installed`);
    }
    const initializeBehaviors = (context) => {
      const agent = context.agentFor(this.#endpoint);
      for (const type of Object.values(this.supported)) {
        if (type.early) {
          this.activate(type, agent);
        }
      }
      let promise2 = import_general.Construction.all(
        {
          [Symbol.iterator]: () => {
            return Object.values(this.#backings)[Symbol.iterator]();
          }
        },
        (causes) => new import_errors.EndpointBehaviorsError(causes)
      );
      const endpointInitializer = this.#endpoint.env.get(import_EndpointInitializer.EndpointInitializer);
      if (promise2) {
        promise2 = promise2.then(() => endpointInitializer.behaviorsInitialized(agent));
      } else {
        promise2 = endpointInitializer.behaviorsInitialized(agent);
      }
      return promise2;
    };
    const activity = this.#endpoint.env.get(import_NodeActivity.NodeActivity);
    const trace = this.#endpoint.env.has(import_ActionTracer.ActionTracer) ? { type: import_ActionTracer.ActionTracer.ActionType.Initialize } : void 0;
    let promise = import_OfflineContext.OfflineContext.act(`initialize<${this.#endpoint}>`, activity, initializeBehaviors, { trace });
    const onReady = () => {
      this.#endpoint.lifecycle.change(import_EndpointLifecycle.EndpointLifecycle.Change.Ready);
      if (trace) {
        trace.path = this.#endpoint.path;
        this.#endpoint.env.get(import_ActionTracer.ActionTracer).record(trace);
      }
    };
    if (promise) {
      promise = promise.then(onReady);
    } else {
      onReady();
    }
    return promise;
  }
  /**
   * Does the {@link Endpoint} support a specified behavior?
   */
  has(type) {
    const myType = this.#supported[type.id];
    return myType === type || myType?.supports(type);
  }
  /**
   * Add behavior support dynamically at runtime.  Typically called via {@link Agent.require}.
   */
  require(type, options) {
    if (options) {
      this.#options[type.id] = options;
    }
    if (this.#supported[type.id]) {
      if (!this.has(type)) {
        throw new import_general.ImplementationError(
          `Cannot require ${this.#endpoint}.${type.id} because incompatible implementation already exists`
        );
      }
      return;
    }
    if (this.#supported === this.#endpoint.type.behaviors) {
      this.#supported = { ...this.#supported };
    }
    this.#supported[type.id] = type;
    this.#augmentEndpoint(type);
    this.#endpoint.lifecycle.change(import_EndpointLifecycle.EndpointLifecycle.Change.ServersChanged);
    if (type.early && this.#endpoint.lifecycle.isInstalled) {
      this.#activateLate(type);
    }
  }
  /**
   * Create a behavior synchronously.  Fails if the behavior is not fully initialized.
   */
  createSync(type, agent) {
    const behavior = this.createMaybeAsync(type, agent);
    if (import_general.MaybePromise.is(behavior)) {
      throw new import_general.ImplementationError(
        `Synchronous access to ${this.#endpoint}.${type.id} is impossible because it is still initializing`
      );
    }
    return behavior;
  }
  /**
   * Create a behavior asynchronously.  Waits for the behavior to complete initialization.
   */
  async createAsync(type, agent) {
    return import_general.MaybePromise.then(
      () => this.createMaybeAsync(type, agent),
      void 0,
      (e) => {
        const backing = this.#backings[type.id];
        if (!backing) {
          throw e;
        }
        backing.construction.assert(backing.toString());
      }
    );
  }
  /**
   * Create a behavior, possibly asynchronously.
   *
   * This method returns a {@link Promise} only if await is necessary so the behavior can be used immediately if
   * possible.
   */
  createMaybeAsync(type, agent) {
    this.activate(type, agent);
    const backing = this.#backings[type.id];
    const getBehavior = () => {
      if (agent.isLoaded(type)) {
        return agent.get(type);
      }
      return backing.createBehavior(agent, type);
    };
    if (backing.construction.status === import_general.Lifecycle.Status.Initializing) {
      return backing.construction.then(() => getBehavior()).catch(() => {
        backing.construction.assert(backing.toString());
        return getBehavior();
      });
    }
    backing.construction.assert(backing.toString());
    return getBehavior();
  }
  /**
   * Activate a behavior.
   *
   * Semantically identical to createAsync() but does not return a {@link Promise} or throw an error.
   *
   * Behaviors that fail initialization will be marked with crashed {@link status}.
   */
  activate(type, agent) {
    if (!this.#backings[type.id]) {
      this.#createBacking(type, agent);
    }
  }
  /**
   * Determine if a specified behavior is supported and active.
   */
  isActive(type) {
    const backing = this.#backings[type.id];
    return !!backing && backing.type.supports(type);
  }
  /**
   * Destroy all behaviors that are initialized (have backings present).  The object may be reused after close.
   */
  async close() {
    const dispose = async (context) => {
      const agent = context.agentFor(this.#endpoint);
      let destroyNow = new Set(Object.keys(this.#backings));
      while (destroyNow.size) {
        for (const key in this.#backings) {
          const dependencies = this.#backings[key].type.dependencies;
          if (!dependencies) {
            continue;
          }
          for (const type of dependencies) {
            destroyNow.delete(type.id);
          }
          if (!destroyNow.size) {
            throw new import_general.ImplementationError("Cannot destroy behaviors due to circular dependency");
          }
        }
        for (const id of destroyNow) {
          const backing = this.#backings[id];
          this.#protocol?.deleteCluster(backing);
          await this.#backings[id].close(agent);
          delete this.#backings[id];
        }
        destroyNow = new Set(Object.keys(this.#backings));
      }
      const transaction = agent.context.transaction;
      if (transaction.status === import_general.Transaction.Status.Exclusive) {
        await transaction.commit();
      }
    };
    await import_OfflineContext.OfflineContext.act(`close<${this.#endpoint}>`, this.#endpoint.env.get(import_NodeActivity.NodeActivity), dispose);
  }
  /**
   * Ensure a set of behavior requirements are met.  Throws an error detailing missing requirements.
   */
  validateRequirements(requirements) {
    if (!requirements) {
      return;
    }
    const missing = Array();
    for (const requirement of Object.values(requirements)) {
      let name = (0, import_general.camelize)(requirement.name, true);
      if (this.#endpoint.behaviors.has(requirement)) {
        continue;
      }
      const cluster = clusterOf(requirement);
      if (cluster) {
        const other = this.#endpoint.behaviors.supported[requirement.id];
        if (clusterOf(other)?.id === cluster.id) {
          continue;
        }
        name = `${name} (0x${cluster.id.toString(16)})`;
      }
      missing.push(name);
    }
    if (missing.length) {
      throw new import_general.ImplementationError(
        `${this.#endpoint} is missing required behaviors: ${(0, import_general.describeList)("and", ...missing)}`
      );
    }
  }
  /**
   * Obtain default values for a behavior.  This is state values as present when the behavior is first initialized for
   * a new endpoint.
   */
  defaultsFor(type) {
    let defaults;
    const options = this.#options[type.id];
    if (options) {
      for (const key in type.defaults) {
        if (key in options) {
          if (!defaults) {
            defaults = {};
          }
          defaults[key] = options[key];
        }
      }
    }
    const varService = this.#endpoint.env.get(import_EndpointVariableService.EndpointVariableService);
    const vars = varService.forBehaviorInstance(this.#endpoint, type);
    if (vars !== void 0) {
      defaults = { ...defaults, ...type.supervisor.cast(vars) };
    }
    return defaults;
  }
  /**
   * Retrieve the options for a behavior type provided to the endpoint.
   */
  optionsFor(type) {
    return this.#options[type.id];
  }
  /**
   * Access internal state for a {@link Behavior}.
   *
   * Internal state is not stable API and not intended for consumption outside of the behavior.  However it is not
   * truly private and may be accessed by tightly coupled implementation.
   *
   * As this API is intended for use by "friendly" code, it does not perform the same initialization assertions as
   * does access to {@link Behavior.State} and {@link Behavior.Events}.
   */
  internalsOf(type) {
    const backing = this.#backingFor(type);
    return backing.getInternal();
  }
  /**
   * Obtain current data version of behavior.
   */
  versionOf(type) {
    const backing = this.#backingFor(type);
    return backing.datasource.version;
  }
  /**
   * Access elements supported by a behavior.
   */
  elementsOf(type) {
    if (!this.has(type)) {
      throw new import_general.ImplementationError(`Endpoint ${this.#endpoint} does not support behavior ${type.id}`);
    }
    const elements = this.#backingFor(type).elements;
    if (elements === void 0) {
      throw new import_general.ImplementationError(
        `Endpoint ${this.#endpoint} behavior ${type.id} elements accessed before initialization`
      );
    }
    return elements;
  }
  [Symbol.iterator]() {
    return Object.values(this.#supported)[Symbol.iterator]();
  }
  #activateLate(type) {
    const result = import_OfflineContext.OfflineContext.act("behavior-late-activation", this.#endpoint.env.get(import_NodeActivity.NodeActivity), (context) => {
      this.activate(type, context.agentFor(this.#endpoint));
      const backing = this.#backingFor(type);
      return backing.construction.ready;
    });
    if (import_general.MaybePromise.is(result)) {
      result.then(void 0, (error) => {
        const backing = this.#backings[type.id];
        if (error instanceof import_errors.BehaviorInitializationError) {
          logger.error(error);
        } else if (backing) {
          logger.error(`Error initializing ${backing}:`, error);
        } else {
          logger.error(`Unexpected rejection initializing ${type.name}:`, error);
        }
      });
    }
  }
  /**
   * Create a read-only online view of a behavior.
   */
  createOnlineView(type) {
    return this.#backingFor(type).datasource;
  }
  /**
   * Obtain a backing for a behavior.
   */
  #backingFor(type) {
    if (this.#endpoint.construction.status !== import_general.Lifecycle.Status.Initializing) {
      this.#endpoint.construction.assert(this.#endpoint.toString(), `behavior ${type.id}`);
    }
    let backing = this.#backings[type.id];
    if (!backing) {
      this.#activateLate(type);
      backing = this.#backings[type.id];
      if (backing === void 0) {
        throw new import_errors.BehaviorInitializationError(`${this.#endpoint}.${type.id}`, "initialization failed");
      }
    }
    return backing;
  }
  #createBacking(type, agent) {
    const myType = this.#getBehaviorType(type);
    if (!myType) {
      throw new import_errors.BehaviorInitializationError(`Initializing ${this.#endpoint}.${type.id}: Unsupported behavior`);
    }
    const backing = this.#endpoint.env.get(import_EndpointInitializer.EndpointInitializer).createBacking(this.#endpoint, myType);
    this.#backings[type.id] = backing;
    if (!this.#protocol) {
      this.#protocol = this.#endpoint.env.get(import_ProtocolService.ProtocolService);
    }
    this.#protocol.addCluster(backing);
    backing.construction.start(agent);
    return backing;
  }
  #getBehaviorType(type) {
    const myType = this.#supported[type.id];
    if (myType === void 0) {
      return myType;
    }
    if (typeof myType !== "function" || !(myType.prototype instanceof import_Behavior.Behavior)) {
      throw new import_general.ImplementationError(`Endpoint behavior "${type.id}" implementation is not a Behavior`);
    }
    return myType;
  }
  /**
   * Updates endpoint "state" and "events" properties to include properties for a supported behavior.
   */
  #augmentEndpoint(type) {
    const stateDescriptor = {
      get: () => {
        return this.#backingFor(type).stateView;
      },
      enumerable: true
    };
    Object.defineProperty(this.#endpoint.state, type.id, stateDescriptor);
    if (type.schema?.id !== void 0) {
      Object.defineProperty(this.#endpoint.state, type.schema.id, stateDescriptor);
    }
    let events;
    Object.defineProperty(this.#endpoint.events, type.id, {
      get: () => {
        if (!events) {
          events = new type.Events();
          if (typeof events.setContext === "function") {
            events.setContext(this.#endpoint, type);
          }
        }
        return events;
      },
      enumerable: true
    });
  }
}
function clusterOf(behavior) {
  return behavior?.cluster;
}
//# sourceMappingURL=Behaviors.js.map
