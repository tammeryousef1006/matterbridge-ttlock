/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Behavior } from "#behavior/Behavior.js";
import { DescriptorBehavior } from "../../behaviors/descriptor/DescriptorBehavior.js";
/**
 * A set of behaviors an endpoint supports.
 */
export type SupportedBehaviors = Record<string, Behavior.Type>;
/**
 * Create SupportedBehaviors from a list of behavior types.
 */
export declare function SupportedBehaviors<const T extends SupportedBehaviors.List>(...types: T): SupportedBehaviors.MapOf<T>;
/**
 * Utility functions and definitions for modifying lists of clusters.
 */
export declare namespace SupportedBehaviors {
    type List = readonly Behavior.Type[];
    /**
     * Create a new list with additional behaviors, replacing any previous
     * behavior for the same cluster.  Replacement updates the set of supported
     * cluster features.
     *
     * Note: Functional equivalent of With<> but you can't have a method named
     * "with" in a namespace.
     */
    function extend<const BehaviorsT extends SupportedBehaviors, const NewBehaviorsT extends List>(currentTypes: BehaviorsT, newTypes: NewBehaviorsT): With<BehaviorsT, NewBehaviorsT>;
    /**
     * Add or replace behaviors.
     */
    type With<CurrentT extends SupportedBehaviors, NewT extends List> = Omit<CurrentT, NewT[number]["id"]> & MapOf<NewT>;
    /**
     * Convert a List to BehaviorTypes.
     */
    type MapOf<T extends List> = T extends readonly [infer F extends Behavior.Type] ? {
        readonly [K in F["id"]]: F;
    } : T extends readonly [infer F extends Behavior.Type, ...infer R extends List] ? {
        readonly [K in F["id"]]: F;
    } & MapOf<R> : {};
    /**
     * Properties of an endpoint contributed by listed behaviors.
     */
    type EndpointProperties<SB extends SupportedBehaviors> = {
        readonly [K in keyof SB]: InstanceType<SB[K]>;
    };
    /**
     * Compound state for all behaviors.
     */
    type StateOf<SB extends SupportedBehaviors> = {
        [K in keyof SB]: Behavior.StateOf<SB[K]>;
    } & {
        descriptor: Behavior.StateOf<typeof DescriptorBehavior>;
    };
    /**
     * Compound events for all behaviors.
     */
    type EventsOf<SB extends SupportedBehaviors> = {
        [K in keyof SB]: Behavior.EventsOf<SB[K]>;
    };
    /**
     * Input version of {@link StateOf}.
     */
    type InputStateOf<SB extends SupportedBehaviors> = {
        [K in keyof SB]?: Behavior.InputStateOf<SB[K]>;
    } & {
        descriptor?: Behavior.InputStateOf<typeof DescriptorBehavior>;
    };
    /**
     * Patch input version of {@link StateOf}.
     */
    type StatePatchOf<SB extends SupportedBehaviors> = {
        [K in keyof SB]?: Behavior.PatchStateOf<SB[K]>;
    } & {
        descriptor?: Behavior.PatchStateOf<typeof DescriptorBehavior>;
    };
}
//# sourceMappingURL=SupportedBehaviors.d.ts.map