"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var BehaviorServer_exports = {};
__export(BehaviorServer_exports, {
  BehaviorServer: () => BehaviorServer
});
module.exports = __toCommonJS(BehaviorServer_exports);
var import_Contextual = require("#behavior/context/Contextual.js");
var import_StructManager = require("#behavior/state/managed/values/StructManager.js");
var import_general = require("#general");
var import_model = require("#model");
var import_protocol = require("#protocol");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("BehaviorServer");
function BehaviorServer(endpointServer, type) {
  const { id, name, attributes, commands, events } = type.cluster;
  const { endpoint } = endpointServer;
  const datasource = createClusterDatasource(endpoint, type);
  const observers = new import_general.ObserverGroup();
  const clusterServer = {
    id,
    name,
    datasource,
    attributes: {},
    commands: {},
    events: {},
    close() {
      observers.close();
    }
  };
  const stateView = endpoint.stateOf(type);
  const observables = endpoint.eventsOf(type);
  const elements = endpointServer.endpoint.behaviors.elementsOf(type);
  for (const name2 of elements.attributes) {
    const attribute = attributes[name2];
    const server = createAttributeServer(
      name2,
      attribute,
      endpoint,
      type,
      datasource,
      stateView,
      observables,
      observers
    );
    clusterServer.attributes[name2] = server;
    server.assignToEndpoint(endpointServer);
  }
  for (const name2 of elements.commands) {
    const command = commands[name2];
    clusterServer.commands[name2] = createCommandServer(name2, command, endpoint, type);
  }
  for (const name2 of elements.events) {
    const server = createEventServer(name2, events[name2], endpoint, type, observables, observers);
    clusterServer.events[name2] = server;
    server.assignToEndpoint(endpointServer);
  }
  return clusterServer;
}
function createClusterDatasource(endpoint, type) {
  const env = endpoint.env;
  return {
    get version() {
      return endpoint.behaviors.versionOf(type);
    },
    get eventHandler() {
      return env.get(import_protocol.OccurrenceManager);
    },
    get fabrics() {
      return env.get(import_protocol.FabricManager).fabrics;
    },
    // We handle change management ourselves
    changed() {
    },
    // We handle version management ourselves
    increaseVersion() {
      return this.version;
    }
  };
}
function createAttributeServer(name, definition, endpoint, type, datasource, stateView, observables, observers) {
  function getter(_session, _endpoint, _isFabricFiltered, message) {
    if (!message) {
      return stateView[name];
    }
    const behavior = behaviorFor(endpoint, type, message);
    behavior.context.activity?.frame(`read ${name}`);
    const trace = behavior.context.trace;
    if (trace) {
      trace.path = endpoint.path.at(name);
    }
    const state = behavior.state;
    import_StructManager.StructManager.assertDirectReadAuthorized(state, definition.id);
    if (trace) {
      trace.output = state[name];
    }
    return state[name];
  }
  function setter(value, _session, _endpoint, message) {
    const behavior = behaviorFor(endpoint, type, message);
    behavior.context.activity?.frame(`write ${name}`);
    logger.info("Write", import_general.Diagnostic.strong(`${endpoint}.state.${name}`), "via", behavior.context.transaction.via);
    const trace = behavior.context.trace;
    if (trace) {
      trace.path = endpoint.path.at(name);
      trace.input = value;
    }
    const state = behavior.state;
    state[name] = value;
    return behavior.context.transaction?.status === import_general.Transaction.Status.Exclusive;
  }
  const server = (0, import_protocol.createAttributeServer)(
    type.cluster,
    definition,
    name,
    stateView[name],
    datasource,
    getter,
    setter
  );
  if (server instanceof import_protocol.AttributeServer) {
    const observable = observables[`${name}$Changed`]?.online;
    if (observable !== void 0) {
      observers.on(observable, (_value, _oldValue, context) => {
        const session = context.session;
        if (session instanceof import_protocol.SecureSession) {
          server.updated(session);
        } else {
          server.updatedLocal();
        }
      });
    }
  }
  return server;
}
function createCommandServer(name, definition, endpoint, type) {
  const schema = type.schema?.member((0, import_general.camelize)(name, true), [import_model.ElementTag.Command]);
  if (schema === void 0) {
    throw new import_general.ImplementationError(`There is no metadata for command ${name}`);
  }
  const access = (0, import_protocol.AccessControl)(schema);
  const handler = (request, _session, message) => {
    let requestDiagnostic;
    if ((0, import_general.isObject)(request)) {
      requestDiagnostic = import_general.Diagnostic.dict(request);
    } else if (request !== void 0) {
      requestDiagnostic = request;
    } else {
      requestDiagnostic = import_general.Diagnostic.weak("(no payload)");
    }
    const behavior = behaviorFor(endpoint, type, message);
    const path = endpoint.path.at(name);
    const trace = behavior.context.trace;
    if (trace) {
      trace.path = endpoint.path.at(name);
      trace.input = request;
    }
    logger.info("Invoke", import_general.Diagnostic.strong(path.toString()), behavior.context.transaction.via, requestDiagnostic);
    access.authorizeInvoke(behavior.context, {
      path,
      endpoint: endpoint.number,
      cluster: behavior.cluster.id
    });
    let isAsync = false;
    let activity;
    let result;
    try {
      activity = behavior.context?.activity?.frame(`invoke ${name}`);
      const invoke = behavior[name].bind(behavior);
      if (behavior.constructor.lockOnInvoke) {
        const tx = behavior.context.transaction;
        if (import_general.Transaction.Resource.isLocked(behavior)) {
          result = async function invokeAsync() {
            await tx.addResources(behavior);
            await tx.begin();
            return invoke(request);
          }();
        } else {
          tx.addResourcesSync(behavior);
          tx.beginSync();
          result = invoke(request);
        }
      } else {
        result = invoke(request);
      }
      if (import_general.MaybePromise.is(result)) {
        isAsync = true;
        result = Promise.resolve(result).then((result2) => {
          if (trace) {
            trace.output = result2;
          }
          return result2;
        }).finally(() => activity?.[Symbol.dispose]());
      } else if (trace) {
        trace.output = result;
      }
    } finally {
      if (!isAsync) {
        activity?.[Symbol.dispose]();
      }
    }
    return result;
  };
  const server = new import_protocol.CommandServer(
    definition.requestId,
    definition.responseId,
    name,
    definition.requestSchema,
    definition.responseSchema,
    definition.timed,
    definition.invokeAcl,
    handler
  );
  server.debug = () => {
  };
  return server;
}
function createEventServer(name, definition, endpoint, type, observables, observers) {
  const observable = observables[name];
  const server = new import_protocol.EventServer(
    definition.id,
    type.cluster.id,
    name,
    definition.schema,
    definition.priority,
    definition.readAcl
  );
  if (observable !== void 0) {
    observers.on(observable.online, (payload, _context) => {
      const maybePromise = server.triggerEvent(payload);
      if (import_general.MaybePromise.is(maybePromise)) {
        endpoint.env.runtime.add(maybePromise);
      }
    });
  }
  const promise = server.bindToEventHandler(endpoint.env.get(import_protocol.OccurrenceManager));
  if (import_general.MaybePromise.is(promise)) {
    throw new import_general.InternalError("Event handler binding returned a promise");
  }
  return server;
}
function behaviorFor(endpoint, type, message) {
  const context = import_Contextual.Contextual.contextOf(message);
  if (!context) {
    throw new import_general.InternalError("Message context not installed");
  }
  const agent = context.agentFor(endpoint);
  return agent.get(type);
}
//# sourceMappingURL=BehaviorServer.js.map
