"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var EndpointServer_exports = {};
__export(EndpointServer_exports, {
  EndpointServer: () => EndpointServer
});
module.exports = __toCommonJS(EndpointServer_exports);
var import_ClusterBehavior = require("#behavior/cluster/ClusterBehavior.js");
var import_general = require("#general");
var import_BehaviorServer = require("./BehaviorServer.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const SERVER = Symbol("server");
class EndpointServer {
  #endpoint;
  #name = "";
  #clusterServers = /* @__PURE__ */ new Map();
  get endpoint() {
    return this.#endpoint;
  }
  get deviceType() {
    return this.#endpoint.type.deviceType;
  }
  constructor(endpoint) {
    if (endpoint[SERVER] !== void 0) {
      throw new import_general.InternalError(`Server creation attempted on ${endpoint} that is already served`);
    }
    if (!endpoint.lifecycle.isReady) {
      throw new import_general.InternalError(`Server creation attempted before ${endpoint} is ready`);
    }
    this.#endpoint = endpoint;
    this.#name = endpoint.type.name;
    endpoint[SERVER] = this;
    for (const type of Object.values(endpoint.behaviors.supported)) {
      if (!(type.prototype instanceof import_ClusterBehavior.ClusterBehavior)) {
        continue;
      }
      this.#serve(type);
    }
  }
  get number() {
    return this.#endpoint.number;
  }
  get name() {
    return this.#name;
  }
  updateServers() {
    for (const type of Object.values(this.#endpoint.behaviors.supported)) {
      if (!(type.prototype instanceof import_ClusterBehavior.ClusterBehavior)) {
        continue;
      }
      if (this.#clusterServers.has(type.cluster?.id)) {
        continue;
      }
      this.#serve(type);
    }
  }
  getNumber() {
    if (this.number === void 0) {
      throw new import_general.InternalError("Endpoint ID has not been assigned yet");
    }
    return this.number;
  }
  removeFromStructure() {
  }
  updatePartsList() {
    return [];
  }
  getChildEndpoints() {
    if (this.#endpoint.hasParts) {
      const parts = this.#endpoint.parts;
      return [...parts].filter((endpoint) => endpoint.lifecycle.isReady).map((endpoint) => EndpointServer.forEndpoint(endpoint));
    }
    return [];
  }
  determineUniqueID() {
    return this.#endpoint.id;
  }
  verifyRequiredClusters() {
    this.#endpoint.behaviors.validateRequirements(this.#endpoint.type.requirements.server?.mandatory);
  }
  close() {
  }
  async [Symbol.asyncDispose]() {
    for (const server of this.#clusterServers.values()) {
      server.close();
    }
    this.#clusterServers.clear();
    delete this.#endpoint[SERVER];
    for (const endpoint of this.#endpoint.parts) {
      const server = endpoint[SERVER];
      if (server) {
        await server[Symbol.asyncDispose]();
      }
    }
  }
  setStructureChangedCallback() {
  }
  addClusterServer(server) {
    this.#clusterServers.set(server.id, server);
  }
  hasClusterServer(cluster) {
    return this.#clusterServers.has(cluster.id);
  }
  getClusterServer(cluster) {
    const server = this.#clusterServers.get(cluster.id);
    if (server !== void 0) {
      return server;
    }
  }
  getClusterServerById(clusterId) {
    return this.#clusterServers.get(clusterId);
  }
  getAllClusterServers() {
    return [...this.#clusterServers.values()];
  }
  getAllClusterClients() {
    return [];
  }
  addClusterClient() {
    throw new import_general.NotImplementedError("Cluster clients unavailable on EndpointServer");
  }
  getClusterClient() {
    throw new import_general.NotImplementedError("Cluster clients unavailable on EndpointServer");
  }
  addChildEndpoint(endpoint) {
    if (endpoint instanceof EndpointServer) {
      this.#endpoint.parts.add(endpoint.#endpoint);
    } else {
      throw new import_general.ImplementationError("Attempt to add unmanaged endpoint as child of Endpoint");
    }
  }
  getChildEndpoint(id) {
    if (!this.#endpoint.hasParts) {
      return;
    }
    for (const endpoint of this.#endpoint.parts) {
      if (endpoint.number === id) {
        return EndpointServer.forEndpoint(endpoint);
      }
    }
  }
  /**
   * Install a ClusterServer for a behavior.
   */
  #serve(type) {
    const { cluster } = type;
    if (cluster === void 0) {
      throw new import_general.InternalError(`Cannot serve ${this.endpoint} behavior ${type.id}} because it is not a cluster`);
    }
    if (this.#clusterServers.has(cluster.id)) {
      throw new import_general.ImplementationError(`Duplicate behaviors for ${this.endpoint} define cluster ${cluster.id}`);
    }
    const clusterServer = (0, import_BehaviorServer.BehaviorServer)(this, type);
    this.#clusterServers.set(cluster.id, clusterServer);
  }
  /**
   * Retrieve the server for an endpoint.
   */
  static forEndpoint(endpoint) {
    let server = endpoint[SERVER];
    if (!server) {
      server = endpoint[SERVER] = new EndpointServer(endpoint);
    }
    return server;
  }
}
//# sourceMappingURL=EndpointServer.js.map
