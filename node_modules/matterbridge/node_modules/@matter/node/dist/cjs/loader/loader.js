"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var loader_exports = {};
__export(loader_exports, {
  loader: () => loader
});
module.exports = __toCommonJS(loader_exports);
var import_general = require("#general");
var import_load = require("@matter/node/load");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const cache = {};
var loader;
((loader2) => {
  function behavior(name) {
    const exportName = `${(0, import_general.camelize)(name, true)}Behavior`;
    return doLoad(
      `behavior ${name}`,
      exportName,
      `../behaviors/${(0, import_general.decamelize)(name)}/${exportName}.js`
    );
  }
  loader2.behavior = behavior;
  function device(name) {
    const exportName = `${(0, import_general.camelize)(name, true)}Device`;
    return doLoad(
      `device type ${name}`,
      exportName,
      `../devices/${(0, import_general.decamelize)(name)}.js`
    );
  }
  loader2.device = device;
  function endpoint(name) {
    const exportName = `${(0, import_general.camelize)(name, true)}Endpoint`;
    return doLoad(
      `endpoint type ${name}`,
      exportName,
      `../endpoints/${(0, import_general.decamelize)(name)}.js`
    );
  }
  loader2.endpoint = endpoint;
})(loader || (loader = {}));
function doLoad(description, exportName, path) {
  const cachedResult = cache[path];
  if (cachedResult) {
    return cachedResult;
  }
  function extractExport(module2) {
    if (exportName in module2) {
      return module2[exportName];
    }
    failure();
  }
  try {
    const module2 = (0, import_load.load)(path);
    if (import_general.MaybePromise.is(module2)) {
      return module2.then(extractExport, failure);
    }
    return extractExport(module2);
  } catch (e) {
    failure();
  }
  function failure() {
    throw new import_general.ImplementationError(`No implementation available for ${description}`);
  }
}
//# sourceMappingURL=loader.js.map
