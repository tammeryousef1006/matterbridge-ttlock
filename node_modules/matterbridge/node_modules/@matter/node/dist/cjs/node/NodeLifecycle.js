"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var NodeLifecycle_exports = {};
__export(NodeLifecycle_exports, {
  NodeLifecycle: () => NodeLifecycle
});
module.exports = __toCommonJS(NodeLifecycle_exports);
var import_EndpointLifecycle = require("#endpoint/properties/EndpointLifecycle.js");
var import_general = require("#general");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
class NodeLifecycle extends import_EndpointLifecycle.EndpointLifecycle {
  #online = (0, import_general.AsyncObservable)();
  #goingOffline = (0, import_general.AsyncObservable)();
  #offline = (0, import_general.Observable)();
  #commissioned = (0, import_general.Observable)();
  #decommissioned = (0, import_general.Observable)();
  #initialized = (0, import_general.Observable)();
  #onlineAt;
  #isCommissioned = false;
  #mutex;
  constructor(endpoint) {
    super(endpoint);
    this.#mutex = new import_general.Mutex(endpoint);
    this.#online.on(() => {
      this.#onlineAt = /* @__PURE__ */ new Date();
    });
    this.#offline.on(() => {
      this.#onlineAt = void 0;
    });
    this.#commissioned.on(() => {
      this.#isCommissioned = true;
    });
    this.#decommissioned.on(() => {
      this.#isCommissioned = false;
    });
    this.#initialized.on((isCommissioned) => {
      this.#isCommissioned = isCommissioned;
    });
  }
  /**
   * True when the node is connected to the network.
   */
  get isOnline() {
    return this.#onlineAt !== void 0;
  }
  /**
   * The time the node went online.
   */
  get onlineAt() {
    return this.#onlineAt;
  }
  /**
   * Emits when the node is first online.
   */
  get online() {
    return this.#online;
  }
  /**
   * Emits when the node's endpoint tree is ready/initialized and used to initialize the commissioning state
   */
  get initialized() {
    return this.#initialized;
  }
  /**
   * Emits when the node is going offline.
   */
  get goingOffline() {
    return this.#goingOffline;
  }
  /**
   * Emits when the node goes offline.
   */
  get offline() {
    return this.#offline;
  }
  /**
   * True when the node is part of at least one fabric.
   */
  get isCommissioned() {
    return this.#isCommissioned;
  }
  /**
   * Emits when node is first commissioned.
   */
  get commissioned() {
    return this.#commissioned;
  }
  /**
   * Emits when node is no longer comissioned.
   */
  get decommissioned() {
    return this.#decommissioned;
  }
  /**
   * Mutex for protecting node lifecycle transitions.
   *
   * Methods that implement complex async lifecycle transitions use this mutex to ensure conflicting operations cannot
   * intermingle.
   *
   * Generally methods that hold this mutex have a protected "*WithMutex" variant.  This allows for nesting of logic
   * that requires the mutex without causing deadlock.
   */
  get mutex() {
    return this.#mutex;
  }
}
//# sourceMappingURL=NodeLifecycle.js.map
