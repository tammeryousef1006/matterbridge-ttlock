"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ClientNodes_exports = {};
__export(ClientNodes_exports, {
  ClientNodes: () => ClientNodes
});
module.exports = __toCommonJS(ClientNodes_exports);
var import_RemoteDescriptor = require("#behavior/system/commissioning/RemoteDescriptor.js");
var import_CommissioningDiscovery = require("#behavior/system/controller/discovery/CommissioningDiscovery.js");
var import_ContinuousDiscovery = require("#behavior/system/controller/discovery/ContinuousDiscovery.js");
var import_InstanceDiscovery = require("#behavior/system/controller/discovery/InstanceDiscovery.js");
var import_EndpointContainer = require("#endpoint/properties/EndpointContainer.js");
var import_general = require("#general");
var import_ServerNodeStore = require("#node/storage/ServerNodeStore.js");
var import_protocol = require("#protocol");
var import_ClientNode = require("../ClientNode.js");
var import_ClientNodeFactory = require("./ClientNodeFactory.js");
var import_NodePeerAddressStore = require("./NodePeerAddressStore.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const DEFAULT_TTL = 900 * 1e3;
const EXPIRATION_INTERVAL = 60 * 1e3;
class ClientNodes extends import_EndpointContainer.EndpointContainer {
  #expirationInterval;
  constructor(owner) {
    super(owner);
    if (!owner.env.has(import_ClientNodeFactory.ClientNodeFactory)) {
      owner.env.set(import_ClientNodeFactory.ClientNodeFactory, new Factory(this));
    }
    this.owner.env.set(import_protocol.PeerAddressStore, new import_NodePeerAddressStore.NodePeerAddressStore(owner));
    this.added.on(this.#manageExpiration.bind(this));
    this.deleted.on(this.#manageExpiration.bind(this));
  }
  /**
   * Load nodes.  Invoked automatically by owner.
   */
  initialize() {
    const factory = this.owner.env.get(import_ClientNodeFactory.ClientNodeFactory);
    const clientStores = this.owner.env.get(import_ServerNodeStore.ServerNodeStore).clientStores;
    for (const id of clientStores.knownIds) {
      this.add(
        factory.create({
          id,
          owner: this.owner
        })
      );
    }
  }
  /**
   * Find a specific commissionable node.
   */
  locate(options) {
    return new import_InstanceDiscovery.InstanceDiscovery(this.owner, options);
  }
  /**
   * Employ discovery to find a set of commissionable nodes.
   *
   * If you do not provide a timeout value, will search until canceled and you need to add a listener to
   * {@link Discovery#discovered} or {@link added} to receive discovered nodes.
   */
  discover(options) {
    return new import_ContinuousDiscovery.ContinuousDiscovery(this.owner, options);
  }
  commission(optionsOrPasscode, discriminator) {
    if (typeof optionsOrPasscode !== "object") {
      optionsOrPasscode = { passcode: optionsOrPasscode };
    }
    if (discriminator !== void 0) {
      optionsOrPasscode.longDiscriminator = discriminator;
    }
    return new import_CommissioningDiscovery.CommissioningDiscovery(this.owner, optionsOrPasscode);
  }
  get(id) {
    if (typeof id !== "string") {
      const address = (0, import_protocol.PeerAddress)(id);
      for (const node of this) {
        const nodeAddress = node.state.commissioning.peerAddress;
        if (nodeAddress && (0, import_protocol.PeerAddress)(nodeAddress) === address) {
          return node;
        }
      }
      return void 0;
    }
    return super.get(id);
  }
  get owner() {
    return super.owner;
  }
  add(node) {
    node.owner = this.owner;
    super.add(node);
  }
  async close() {
    this.#cancelExpiration();
    await super.close();
  }
  #cancelExpiration() {
    if (this.#expirationInterval) {
      this.#expirationInterval.cancel();
      this.#expirationInterval = void 0;
    }
  }
  #manageExpiration() {
    if (this.#expirationInterval) {
      if (!this.size) {
        this.#cancelExpiration();
      }
      return;
    }
    if (!this.size) {
      return;
    }
    this.#expirationInterval = import_general.Time.sleep("client node expiration", EXPIRATION_INTERVAL).then(async () => {
      this.#expirationInterval = void 0;
      try {
        await this.#cullExpiredNodesAndAddresses();
      } finally {
        this.#manageExpiration();
      }
    });
  }
  async #cullExpiredNodesAndAddresses() {
    const now = import_general.Time.nowMs();
    for (const node of this) {
      const state = node.state.commissioning;
      const { addresses } = state;
      const isCommissioned = state.peerAddress !== void 0;
      if (addresses === void 0 || isCommissioned && addresses.length === 1) {
        return;
      }
      let newAddresses = addresses.filter((addr) => {
        const exp = expirationOf(addr);
        if (exp === void 0) {
          return true;
        }
        return exp > now;
      });
      if (!isCommissioned) {
        if (!newAddresses?.length || expirationOf(state) <= now) {
          await node.delete();
          continue;
        }
      }
      if (isCommissioned && addresses.length && !newAddresses.length) {
        if (addresses.length === 1) {
          return;
        }
        const freshestExp = addresses.reduce((freshestExp2, addr) => {
          return Math.max(freshestExp2, expirationOf(addr));
        }, 0);
        newAddresses = addresses.filter((addr) => expirationOf(addr) === freshestExp);
      }
      if (addresses.length !== newAddresses.length) {
        await node.set({ commissioning: { addresses } });
      }
    }
  }
}
class Factory extends import_ClientNodeFactory.ClientNodeFactory {
  #owner;
  constructor(owner) {
    super();
    this.#owner = owner;
  }
  create(options) {
    if (options.id === void 0) {
      options.id = this.#owner.owner.env.get(import_ServerNodeStore.ServerNodeStore).clientStores.allocateId();
    }
    const node = new import_ClientNode.ClientNode({
      ...options,
      owner: this.#owner.owner
    });
    node.construction.start();
    return node;
  }
  find(descriptor) {
    for (const node of this.#owner) {
      if (import_RemoteDescriptor.RemoteDescriptor.is(node.state.commissioning, descriptor)) {
        return node;
      }
    }
  }
  get nodes() {
    return this.#owner;
  }
}
function expirationOf(lifespan) {
  if (lifespan.discoveredAt !== void 0) {
    return lifespan.discoveredAt + (lifespan.ttl ?? DEFAULT_TTL);
  }
  return void 0;
}
//# sourceMappingURL=ClientNodes.js.map
