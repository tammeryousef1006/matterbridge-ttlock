"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __using = (stack, value, async) => {
  if (value != null) {
    if (typeof value !== "object" && typeof value !== "function") __typeError("Object expected");
    var dispose, inner;
    if (async) dispose = value[__knownSymbol("asyncDispose")];
    if (dispose === void 0) {
      dispose = value[__knownSymbol("dispose")];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") __typeError("Object not disposable");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    stack.push([async, dispose, value]);
  } else if (async) {
    stack.push([async]);
  }
  return value;
};
var __callDispose = (stack, error, hasError) => {
  var E = typeof SuppressedError === "function" ? SuppressedError : function(e, s, m, _) {
    return _ = Error(m), _.name = "SuppressedError", _.error = e, _.suppressed = s, _;
  };
  var fail = (e) => error = hasError ? new E(e, error, "An error was suppressed during disposal") : (hasError = true, e);
  var next = (it) => {
    while (it = stack.pop()) {
      try {
        var result = it[1] && it[1].call(it[2]);
        if (it[0]) return Promise.resolve(result).then(next, (e) => (fail(e), next()));
      } catch (e) {
        fail(e);
      }
    }
    if (hasError) throw error;
  };
  return next();
};
var TransactionalInteractionServer_exports = {};
__export(TransactionalInteractionServer_exports, {
  TransactionalInteractionServer: () => TransactionalInteractionServer
});
module.exports = __toCommonJS(TransactionalInteractionServer_exports);
var import_ActionTracer = require("#behavior/context/ActionTracer.js");
var import_NodeActivity = require("#behavior/context/NodeActivity.js");
var import_OfflineContext = require("#behavior/context/server/OfflineContext.js");
var import_OnlineContext = require("#behavior/context/server/OnlineContext.js");
var import_access_control = require("#clusters/access-control");
var import_EndpointLifecycle = require("#endpoint/properties/EndpointLifecycle.js");
var import_EndpointServer = require("#endpoint/server/EndpointServer.js");
var import_general = require("#general");
var import_protocol = require("#protocol");
var import_types = require("#types");
var import_AccessControlServer = require("../../behaviors/access-control/AccessControlServer.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("TransactionalInteractionServer");
const activityKey = Symbol("activity");
const AclClusterId = import_access_control.AccessControlCluster.id;
const AclAttributeId = import_access_control.AccessControlCluster.attributes.acl.id;
class TransactionalInteractionServer extends import_protocol.InteractionServer {
  #endpointStructure;
  #changeListener;
  #node;
  #activity;
  #newActivityBlocked = false;
  #aclServer;
  #aclUpdateIsDelayedInExchange = /* @__PURE__ */ new Set();
  static async create(node, sessions) {
    const structure = new import_protocol.InteractionEndpointStructure();
    return new TransactionalInteractionServer(node, {
      sessions,
      structure,
      subscriptionOptions: node.state.network.subscriptionOptions,
      maxPathsPerInvoke: node.state.basicInformation.maxPathsPerInvoke,
      initiateExchange: (address, protocolId) => node.env.get(import_protocol.ExchangeManager).initiateExchange(address, protocolId)
    });
  }
  constructor(node, context) {
    super(context);
    const { structure } = context;
    this.#activity = node.env.get(import_NodeActivity.NodeActivity);
    this.#node = node;
    this.#endpointStructure = structure;
    this.#updateStructure();
    this.#changeListener = (type, endpoint) => {
      switch (type) {
        case import_EndpointLifecycle.EndpointLifecycle.Change.ServersChanged:
          import_EndpointServer.EndpointServer.forEndpoint(endpoint).updateServers();
          this.#updateStructure();
          break;
        case import_EndpointLifecycle.EndpointLifecycle.Change.PartsReady:
        case import_EndpointLifecycle.EndpointLifecycle.Change.ClientsChanged:
        case import_EndpointLifecycle.EndpointLifecycle.Change.Destroyed:
          this.#updateStructure();
          break;
      }
    };
    node.lifecycle.changed.on(this.#changeListener);
  }
  async [Symbol.asyncDispose]() {
    this.#node.lifecycle.changed.off(this.#changeListener);
    await this.close();
    this.#endpointStructure.close();
    await import_EndpointServer.EndpointServer.forEndpoint(this.#node)[Symbol.asyncDispose]();
  }
  blockNewActivity() {
    this.#newActivityBlocked = true;
  }
  async onNewExchange(exchange, message) {
    var _stack = [];
    try {
      if (this.#newActivityBlocked || this.isClosing) {
        return;
      }
      if (message.payloadHeader.messageType === import_protocol.MessageType.ReportData && this.clientHandler) {
        return this.clientHandler.onNewExchange(exchange, message);
      }
      const activity = __using(_stack, this.#activity.begin(`session#${exchange.session.id.toString(16)}`));
      exchange[activityKey] = activity;
      return new import_protocol.InteractionServerMessenger(exchange).handleRequest(this).finally(() => delete exchange[activityKey]);
    } catch (_) {
      var _error = _, _hasError = true;
    } finally {
      __callDispose(_stack, _error, _hasError);
    }
  }
  get aclServer() {
    if (this.#aclServer !== void 0) {
      return this.#aclServer;
    }
    const aclServer = this.#node.act((agent) => agent.get(import_AccessControlServer.AccessControlServer));
    if (import_general.MaybePromise.is(aclServer)) {
      throw new import_general.InternalError("AccessControlServer should already be initialized.");
    }
    return this.#aclServer = aclServer;
  }
  readAttribute(path, attribute, exchange, fabricFiltered, message, offline = false) {
    const readAttribute = () => super.readAttribute(path, attribute, exchange, fabricFiltered, message, offline);
    const endpoint = this.#endpointStructure.getEndpoint(path.endpointId);
    if (!endpoint) {
      throw new import_general.InternalError("Endpoint not found for ACL check. This should never happen.");
    }
    const result = offline ? import_OfflineContext.OfflineContext.act("offline-read", this.#activity, readAttribute) : (0, import_OnlineContext.OnlineContext)({
      activity: exchange[activityKey],
      fabricFiltered,
      message,
      exchange,
      tracer: this.#tracer,
      actionType: import_ActionTracer.ActionTracer.ActionType.Read,
      node: this.#node
    }).act(readAttribute);
    if (import_general.MaybePromise.is(result)) {
      throw new import_general.InternalError("Reads should not return a promise.");
    }
    return result;
  }
  /**
   * Reads the attributes for the given endpoint.
   * This can currently only be used for subscriptions because errors are ignored!
   */
  readEndpointAttributesForSubscription(attributes, exchange, fabricFiltered, message, offline = false) {
    const readAttributes = () => {
      const result2 = new Array();
      for (const { path, attribute } of attributes) {
        try {
          const value = super.readAttribute(path, attribute, exchange, fabricFiltered, message, offline);
          result2.push({ path, attribute, value: value.value, version: value.version });
        } catch (error) {
          if (import_types.StatusResponseError.is(error, import_types.StatusCode.UnsupportedAccess)) {
            logger.warn(
              `Permission denied reading attribute ${this.#endpointStructure.resolveAttributeName(path)}`
            );
          } else {
            logger.warn(
              `Error reading attribute ${this.#endpointStructure.resolveAttributeName(path)}:`,
              error
            );
          }
        }
      }
      return result2;
    };
    const result = offline ? import_OfflineContext.OfflineContext.act("offline-read", this.#activity, readAttributes) : (0, import_OnlineContext.OnlineContext)({
      activity: exchange[activityKey],
      fabricFiltered,
      message,
      exchange,
      tracer: this.#tracer,
      actionType: import_ActionTracer.ActionTracer.ActionType.Read,
      node: this.#node
    }).act(readAttributes);
    if (import_general.MaybePromise.is(result)) {
      throw new import_general.InternalError("Online read should not return a promise.");
    }
    return result;
  }
  async readEvent(path, eventFilters, event, exchange, fabricFiltered, message) {
    const readEvent = (context) => {
      if (context.authorityAt(event.readAcl, {
        endpoint: path.endpointId,
        cluster: path.clusterId
      }) !== import_protocol.AccessControl.Authority.Granted) {
        throw new import_protocol.AccessDeniedError(
          `Access to ${path.endpointId}/${import_general.Diagnostic.hex(path.clusterId)} denied on ${exchange.session.name}.`
        );
      }
      return super.readEvent(path, eventFilters, event, exchange, fabricFiltered, message);
    };
    return (0, import_OnlineContext.OnlineContext)({
      activity: exchange[activityKey],
      fabricFiltered,
      message,
      exchange,
      tracer: this.#tracer,
      actionType: import_ActionTracer.ActionTracer.ActionType.Read,
      node: this.#node
    }).act(readEvent);
  }
  async handleWriteRequest(exchange, writeRequest, message) {
    let result;
    try {
      result = await super.handleWriteRequest(exchange, writeRequest, message);
    } catch (error) {
      if (this.#aclUpdateIsDelayedInExchange.has(exchange)) {
        this.#aclUpdateIsDelayedInExchange.delete(exchange);
        if (this.#aclUpdateIsDelayedInExchange.size === 0) {
          this.aclServer.resetDelayedAccessControlList();
        } else {
          logger.error("One of multiple concurrent ACL writes failed, unhandled case for now.");
        }
      }
      throw error;
    }
    if (this.#aclUpdateIsDelayedInExchange.has(exchange)) {
      this.#aclUpdateIsDelayedInExchange.delete(exchange);
      if (this.#aclUpdateIsDelayedInExchange.size === 0) {
        this.aclServer.aclUpdateDelayed = false;
      } else {
        logger.info("Multiple concurrent ACL writes, waiting for all to finish.");
      }
    }
    return result;
  }
  async writeAttribute(path, attribute, value, exchange, message, endpoint, timed = false, isListWrite) {
    const writeAttribute = () => super.writeAttribute(path, attribute, value, exchange, message, endpoint, timed, isListWrite);
    if (path.endpointId === 0 && path.clusterId === AclClusterId && path.attributeId === AclAttributeId) {
      this.aclServer.aclUpdateDelayed = true;
      this.#aclUpdateIsDelayedInExchange.add(exchange);
    } else {
      if (this.#aclUpdateIsDelayedInExchange.has(exchange)) {
        this.#aclUpdateIsDelayedInExchange.delete(exchange);
        if (this.#aclUpdateIsDelayedInExchange.size === 0) {
          this.aclServer.aclUpdateDelayed = false;
        } else {
          logger.info("Multiple concurrent ACL writes, waiting for all to finish.");
        }
      }
    }
    return (0, import_OnlineContext.OnlineContext)({
      activity: exchange[activityKey],
      timed,
      message,
      exchange,
      fabricFiltered: true,
      tracer: this.#tracer,
      actionType: import_ActionTracer.ActionTracer.ActionType.Write,
      node: this.#node
    }).act(writeAttribute);
  }
  async invokeCommand(path, command, exchange, commandFields, message, endpoint, timed = false) {
    const invokeCommand = (context) => {
      if (context.authorityAt(command.invokeAcl, {
        endpoint: endpoint.number,
        cluster: path.clusterId
      }) !== import_protocol.AccessControl.Authority.Granted) {
        throw new import_protocol.AccessDeniedError(
          `Access to ${endpoint.number}/${import_general.Diagnostic.hex(path.clusterId)} denied on ${exchange.session.name}.`
        );
      }
      return super.invokeCommand(path, command, exchange, commandFields, message, endpoint, timed);
    };
    return (0, import_OnlineContext.OnlineContext)({
      activity: exchange[activityKey],
      command: true,
      timed,
      message,
      exchange,
      tracer: this.#tracer,
      actionType: import_ActionTracer.ActionTracer.ActionType.Invoke,
      node: this.#node
    }).act(invokeCommand);
  }
  get #tracer() {
    if (this.#node.env.has(import_ActionTracer.ActionTracer)) {
      return this.#node.env.get(import_ActionTracer.ActionTracer);
    }
  }
  #updateStructure() {
    if (this.#node.lifecycle.isPartsReady) {
      const server = import_EndpointServer.EndpointServer.forEndpoint(this.#node);
      this.#endpointStructure.initializeFromEndpoint(server);
    }
  }
}
//# sourceMappingURL=TransactionalInteractionServer.js.map
