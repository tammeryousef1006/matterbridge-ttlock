/**
 * @license
 * Copyright 2022-2025 Project CHIP Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import type { Endpoint } from "#endpoint/Endpoint.js";
import { AsyncObservable, BasicObservable, EventEmitter, Observable, ObserverErrorHandler, ObserverPromiseHandler, QuietObservable } from "#general";
import { type ValueModel } from "#model";
import type { Behavior } from "./Behavior.js";
/**
 * Events emitted by a {@link Behavior}.
 */
export declare class Events extends EventEmitter {
    #private;
    setContext(endpoint: Endpoint, behavior: Behavior.Type): void;
    /**
     * Emitted when state associated with this behavior is first mutated by a specific interaction.
     */
    interactionBegin: Observable<[], void>;
    /**
     * Emitted when a mutating interaction completes.
     */
    interactionEnd: AsyncObservable<[], void>;
    get endpoint(): Endpoint<import("../index.js").EndpointType.Empty> | undefined;
    get behavior(): Behavior.Type | undefined;
    toString(): string;
}
export declare namespace Events {
    interface Context {
    }
}
/**
 * An event associated with a specific matter element such as an {@link AttributeElement} or {@link EventElement}.
 */
export declare class ElementEvent<T extends any[] = any[], S extends ValueModel = ValueModel> extends BasicObservable<T> {
    #private;
    constructor(schema: S, owner: Events, errorHandler?: ObserverErrorHandler, promiseHandler?: ObserverPromiseHandler);
    /**
     * The element that triggers this event.
     */
    get schema(): S;
    protected get owner(): Events;
}
/**
 * An {@link  ElementEvent} that emits locally.
 *
 * Observers that throw errors will terminate the emitter.
 */
export declare class OfflineEvent<T extends any[] = any[], S extends ValueModel = ValueModel> extends ElementEvent<T> {
    constructor(schema: S, owner: Events);
}
/**
 * An {@link ElementEvent} that transmits to other Matter nodes.
 *
 * Online events emit externally.  Observers run sequentially and if async register as node activity but otherwise have
 * no affect on the emitter.
 */
export declare class OnlineEvent<T extends any[] = any[], S extends ValueModel = ValueModel> extends ElementEvent<T> {
    readonly isQuieter: boolean;
    constructor(schema: S, owner: Events);
    /**
     * An {@link Observable} that emits only those events conveyed between nodes.
     *
     * Normally this is the {@link OnlineEvent}, but in the case of server-side elements that are
     * {@link Quality.quieter} this is {@link quiet}.
     */
    get online(): Observable<T>;
    /**
     * A quieter version of the {@link OnlineEvent}.
     *
     * Throws if the node is not a server or the associated element is not {@link Quality.quieter}.
     *
     * By default emits latest changes once per second but you can reconfigure via {@link QuietObservable} properties
     * and/or trigger emits using {@link QuietObservable.emitNow} and {@link QuietObservable.emitSoon}.
     */
    get quiet(): QuietObservable<T>;
    toString(): string;
}
/**
 * An {@link OnlineEvent} for elements marked with {@link Quality#quieter}.
 *
 * Quiet events provide a second observable for {@link online} that implements configurable rate limiting.
 */
export declare class QuietEvent<T extends any[] = any[], S extends ValueModel = ValueModel> extends OnlineEvent<T, S> {
    #private;
    readonly isQuieter = true;
    constructor(schema: S, owner: Events, config?: QuietObservable.Configuration<T>);
    get online(): Observable<T>;
    get quiet(): QuietObservable<T>;
    [Symbol.dispose](): void;
}
//# sourceMappingURL=Events.d.ts.map