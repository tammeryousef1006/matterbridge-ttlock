/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { OfflineEvent, OnlineEvent, QuietEvent } from "#behavior/Events.js";
import { AsyncObservable, camelize, GeneratedClass, ImplementationError } from "#general";
import {
  ClusterModel,
  Conformance,
  DefaultValue,
  ElementTag,
  FeatureMap,
  FeatureSet,
  Matter,
  Metatype,
  Scope
} from "#model";
import { Behavior } from "../Behavior.js";
import { DerivedState } from "../state/StateType.js";
import { ClusterBehaviorCache } from "./ClusterBehaviorCache.js";
const KNOWN_DEFAULTS = Symbol("knownDefaults");
function introspectionInstanceOf(type) {
  return new type();
}
function createType(cluster, base, schema) {
  if (schema === void 0) {
    if (base.schema) {
      schema = base.schema;
    }
    if (!schema) {
      schema = schemaForCluster(cluster);
    }
  }
  schema = syncFeatures(schema, cluster);
  const cached = ClusterBehaviorCache.get(cluster, base, schema);
  if (cached) {
    return cached;
  }
  let name;
  if (base.name.startsWith(cluster.name)) {
    name = base.name;
  } else {
    name = `${cluster.name}Behavior`;
  }
  schema.freeze();
  const newProps = {};
  const scope = Scope(schema);
  const type = GeneratedClass({
    name,
    base,
    // These are really read-only but installing as getters on the prototype prevents us from overriding using
    // namespace overrides.  If we instead override as static properties then we lose the automatic interface type.
    // So just publish as static properties.
    staticProperties: {
      State: createDerivedState(cluster, scope, base, newProps),
      Events: createDerivedEvents(cluster, scope, base, newProps)
    },
    staticDescriptors: {
      id: {
        value: camelize(cluster.name),
        enumerable: true
      },
      cluster: {
        value: cluster,
        enumerable: true
      },
      schema: {
        value: schema
      }
    },
    instanceDescriptors: createDefaultCommandDescriptors(cluster, base)
  });
  ClusterBehaviorCache.set(cluster, base, schema, type);
  return type;
}
function createDerivedState(cluster, scope, base, newProps) {
  const BaseState = base["State"];
  if (BaseState === void 0) {
    throw new ImplementationError(`No state class defined for behavior class ${base.name}`);
  }
  const oldDefaults = new BaseState();
  let knownDefaults = BaseState[KNOWN_DEFAULTS];
  let featuresAvailable, featuresSupported;
  if (scope.owner instanceof ClusterModel) {
    const normalized = FeatureSet.normalize(scope.owner.featureMap, scope.owner.supportedFeatures);
    featuresAvailable = normalized.featuresAvailable;
    featuresSupported = normalized.featuresSupported;
  } else {
    featuresAvailable = new FeatureSet();
    featuresSupported = new FeatureSet();
  }
  const props = {};
  for (const member of scope.membersOf(scope.owner, { conformance: "deconflicted" })) {
    const name = camelize(member.name);
    if (props[name]) {
      props[name].push(member);
    } else {
      props[name] = [member];
    }
  }
  const defaults = {};
  for (const name in props) {
    const attrs = props[name];
    let propSchema;
    let isConditional = false;
    for (const attr of attrs) {
      const applicability = attr.effectiveConformance.applicabilityOf(featuresAvailable, featuresSupported);
      if (!applicability) {
        continue;
      }
      if (applicability === Conformance.Applicability.Conditional) {
        isConditional = true;
      }
      propSchema = attr;
      break;
    }
    if (propSchema === void 0) {
      if (isConditional) {
        return;
      }
      if (oldDefaults[name] !== void 0) {
        if (!knownDefaults) {
          knownDefaults = {};
        } else if (knownDefaults === BaseState[KNOWN_DEFAULTS]) {
          knownDefaults = { ...knownDefaults };
        }
        knownDefaults[name] = oldDefaults[name];
        defaults[name] = void 0;
      }
      continue;
    }
    newProps[name] = propSchema;
    const attribute = cluster.attributes[name];
    if (attribute?.id === FeatureMap.id) {
      defaults[name] = cluster.supportedFeatures;
      continue;
    }
    defaults[name] = selectDefaultValue(
      scope,
      oldDefaults[name] === void 0 ? knownDefaults?.[name] : oldDefaults[name],
      attribute,
      propSchema
    );
  }
  const StateType = DerivedState({
    name: `${cluster.name}$State`,
    base: base.State,
    values: defaults
  });
  if (knownDefaults) {
    StateType[KNOWN_DEFAULTS] = knownDefaults;
  }
  return StateType;
}
function createDerivedEvents(cluster, scope, base, newProps) {
  const instanceDescriptors = {};
  const baseInstance = new base.Events();
  const eventNames = /* @__PURE__ */ new Set();
  const applicableClusterEvents = /* @__PURE__ */ new Set();
  for (const event of scope.membersOf(scope.owner, {
    conformance: "conformant",
    tags: [ElementTag.Event]
  })) {
    const name = camelize(event.name);
    applicableClusterEvents.add(name);
    if (!cluster.events[name]?.optional && baseInstance[name] === void 0) {
      eventNames.add(name);
      instanceDescriptors[name] = createEventDescriptor(
        name,
        event,
        event.quality.quieter ? QuietEvent : OnlineEvent
      );
    }
  }
  for (const attrName in newProps) {
    const changing = `${attrName}$Changing`;
    const prop = newProps[attrName];
    if (baseInstance[changing] === void 0) {
      eventNames.add(changing);
      instanceDescriptors[changing] = createEventDescriptor(changing, prop, OfflineEvent);
    }
    const changed = `${attrName}$Changed`;
    if (baseInstance[changed] === void 0) {
      eventNames.add(changed);
      instanceDescriptors[changed] = createEventDescriptor(
        changed,
        prop,
        prop.quality.quieter ? QuietEvent : OnlineEvent
      );
    }
  }
  return GeneratedClass({
    name: `${cluster.name}$Events`,
    base: base.Events,
    instanceDescriptors,
    initialize() {
      this.interactionBegin = new AsyncObservable();
      this.interactionEnd = new AsyncObservable();
      for (const name of eventNames) {
        this.addEvent(name);
      }
    }
  });
}
function schemaForCluster(cluster) {
  let schema;
  for (const child of Matter.children) {
    if (child.tag === ElementTag.Cluster && child.id === cluster.id) {
      schema = child;
      break;
    }
  }
  if (schema === void 0) {
    throw new ImplementationError(`Cannot locate schema for cluster ${cluster.id}, please supply manually`);
  }
  return schema;
}
const configuredSchemaCache = /* @__PURE__ */ new Map();
function syncFeatures(schema, cluster) {
  if (!(schema instanceof ClusterModel)) {
    return schema;
  }
  const incomingFeatures = new FeatureSet(cluster.supportedFeatures);
  if (new FeatureSet(cluster.supportedFeatures).is(schema.supportedFeatures)) {
    return schema;
  }
  const featureKey = [...incomingFeatures].sort().join(",");
  let schemaBucket = configuredSchemaCache.get(schema);
  if (schemaBucket === void 0) {
    schemaBucket = {};
    configuredSchemaCache.set(schema, schemaBucket);
  } else {
    if (featureKey in schemaBucket) {
      return schemaBucket[featureKey];
    }
  }
  schema = schema.clone();
  schema.supportedFeatures = incomingFeatures;
  schemaBucket[featureKey] = schema;
  return schema;
}
function createDefaultCommandDescriptors(cluster, base) {
  const result = {};
  const instance = introspectionInstanceOf(base);
  for (const name in cluster.commands) {
    if (!instance[name]) {
      result[name] = {
        value: Behavior.unimplemented,
        writable: true
      };
    }
  }
  return result;
}
function selectDefaultValue(scope, oldDefault, clusterAttr, schemaProp) {
  if (oldDefault !== void 0) {
    return oldDefault;
  }
  if (clusterAttr?.optional) {
    return;
  }
  if (clusterAttr?.default !== void 0) {
    return clusterAttr.default;
  }
  if (!schemaProp) {
    return;
  }
  if (schemaProp.nullable) {
    return null;
  }
  const effectiveDefault = DefaultValue(scope, schemaProp);
  if (effectiveDefault) {
    return effectiveDefault;
  }
  const conformance = schemaProp.effectiveConformance;
  if (!conformance.isMandatory) {
    return;
  }
  switch (schemaProp.effectiveMetatype) {
    case Metatype.bitmap:
    case Metatype.object:
      return {};
    case Metatype.array:
      return [];
  }
}
function createEventDescriptor(name, schema, constructor) {
  return {
    get() {
      if (this.hasEvent(name, true)) {
        return this.getEvent(name);
      }
      const event = new constructor(schema, this);
      this.addEvent(name, event);
      return event;
    },
    enumerable: true
  };
}
export {
  createType,
  introspectionInstanceOf
};
//# sourceMappingURL=ClusterBehaviorUtil.js.map
