/**
 * @license
 * Copyright 2022-2025 Project CHIP Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Diagnostic, MaybePromise, Transaction } from "#general";
import { AccessLevel } from "#model";
import { AccessControl } from "#protocol";
import { Contextual } from "../Contextual.js";
import { ContextAgents } from "./ContextAgents.js";
let nextInternalId = 1;
const OfflineContext = {
  /**
   * Operate in offline context.  Interactions with private Matter.js APIs happen in an offline context.
   *
   * {@link act} provides an {@link ActionContext} you can use to access agents for a {@link Endpoint}.
   * State changes and change events occur once {@link actor} returns.
   * It can return a promise even if the actor method does not return a promise, so manual checks are needed.
   *
   * The {@link Transaction} is destroyed with {@link act} exits so you should not keep a reference to any agents
   * beyond the lifespan of {@link actor}.
   *
   * Offline context is very permissive.  You should use carefully.
   */
  act(purpose, activity, actor, options) {
    const id = nextInternalId;
    nextInternalId = (nextInternalId + 1) % 65535;
    const via = Diagnostic.via(`${purpose}#${id.toString(16)}`);
    let context;
    let frame;
    const actOffline = (transaction) => {
      context = createOfflineContext(transaction, frame, options);
      return actor(context);
    };
    let isAsync = false;
    try {
      frame = activity?.begin(via);
      const result = Transaction.act(via, actOffline);
      if (MaybePromise.is(result)) {
        isAsync = true;
        return Promise.resolve(result).finally(() => {
          frame?.[Symbol.dispose]();
        });
      }
      return result;
    } finally {
      if (!isAsync) {
        frame?.[Symbol.dispose]();
      }
    }
  },
  /**
   * Normally you need to use {@link OfflineContext.act} to work with behaviors, and you can only interact with the
   * behaviors in the actor function.  This {@link ActionContext} allows you to create offline agents that remain
   * functional for the lifespan of the node.
   *
   * Write operations will throw an error with this context.
   */
  ReadOnly: createOfflineContext(Transaction.ReadOnly),
  [Symbol.toStringTag]: "OfflineContext"
};
function createOfflineContext(transaction, activity, options) {
  let agents;
  const context = Object.freeze({
    ...options,
    // Disable access level enforcement
    offline: true,
    transaction,
    activity,
    authorityAt(desiredAccessLevel) {
      return desiredAccessLevel === AccessLevel.View ? AccessControl.Authority.Granted : AccessControl.Authority.Unauthorized;
    },
    agentFor(endpoint) {
      if (!agents) {
        agents = ContextAgents(context);
      }
      return agents?.agentFor(endpoint);
    },
    get [Contextual.context]() {
      return this;
    },
    [Symbol.toStringTag]: "OfflineContext"
  });
  return context;
}
export {
  OfflineContext,
  nextInternalId
};
//# sourceMappingURL=OfflineContext.js.map
