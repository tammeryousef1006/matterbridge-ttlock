/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { AccessControlServer } from "#behaviors/access-control";
import { Diagnostic, ImplementationError, InternalError, MaybePromise, Transaction } from "#general";
import { AccessControl, assertSecureSession } from "#protocol";
import { Contextual } from "../Contextual.js";
import { ContextAgents } from "./ContextAgents.js";
function OnlineContext(options) {
  let fabric;
  let subject;
  let nodeProtocol;
  let accessLevelCache;
  const { exchange } = options;
  const session = exchange?.session;
  if (session) {
    assertSecureSession(session);
    fabric = session.fabric?.fabricIndex;
    subject = session.peerNodeId;
  } else {
    fabric = options.fabric;
    subject = options.subject;
  }
  if (subject === void 0) {
    throw new ImplementationError("OnlineContext requires an authorized subject");
  }
  const { message } = options;
  const via = Diagnostic.via(
    `online#${message?.packetHeader?.messageId?.toString(16) ?? "?"}@${subject.toString(16)}`
  );
  return {
    /**
     * Run an actor with a read/write context.
     *
     * If the actor changes state, this may return a promise even if {@link actor} does not return a promise.
     */
    act(actor) {
      const { close, trace } = initialize();
      const traceError = (e) => {
        if (trace) {
          const status = e.code;
          if (typeof status === "number") {
            trace.status = status;
          }
        }
        throw e;
      };
      let context;
      const actOnline = (transaction) => {
        context = createContext(transaction, trace);
        return actor(context);
      };
      let isAsync = false;
      try {
        const result = Transaction.act(via, actOnline);
        if (MaybePromise.is(result)) {
          isAsync = true;
          return Promise.resolve(result).catch(traceError).finally(close);
        }
        return result;
      } catch (e) {
        traceError(e);
        throw e;
      } finally {
        if (!isAsync && context) {
          close();
        }
      }
    },
    /**
     * Begin an operation with a read-only context.  You must close the context after use to properly deregister
     * activity.
     */
    beginReadOnly() {
      const { close, trace } = initialize();
      const context = createContext(Transaction.ReadOnly, trace);
      context[Symbol.dispose] = close;
      return context;
    },
    [Symbol.toStringTag]: "OnlineContext"
  };
  function initialize() {
    let trace;
    const activity = options.activity?.frame(via);
    if (options.tracer && options.actionType) {
      trace = {
        type: options.actionType
      };
    }
    const close = () => {
      if (trace) {
        options.tracer?.record(trace);
      }
      if (message) {
        Contextual.setContextOf(message, void 0);
      }
      if (activity) {
        activity[Symbol.dispose]();
      }
    };
    return {
      close,
      trace
    };
  }
  function createContext(transaction, trace) {
    let agents;
    const context = {
      ...options,
      session,
      exchange,
      subject,
      fabric,
      transaction,
      trace,
      interactionComplete: exchange?.closed,
      // TODO - Matter 1.4 - add support for ARLs
      authorityAt(desiredAccessLevel, location) {
        if (location === void 0) {
          throw new InternalError("AccessControl.Location is required");
        }
        const cachedAccessLevels = accessLevelCache?.get(location);
        if (cachedAccessLevels !== void 0) {
          return cachedAccessLevels.includes(desiredAccessLevel) ? AccessControl.Authority.Granted : AccessControl.Authority.Unauthorized;
        }
        if (options.node === void 0) {
          throw new InternalError("OnlineContext initialized without node");
        }
        const accessControl = options.node.act((agent) => agent.get(AccessControlServer));
        if (MaybePromise.is(accessControl)) {
          throw new InternalError("AccessControlServer should already be initialized.");
        }
        const accessLevels = accessControl.accessLevelsFor(context, location, aclEndpointContextFor(location));
        if (accessLevelCache === void 0) {
          accessLevelCache = /* @__PURE__ */ new Map();
        }
        accessLevelCache.set(location, accessLevels);
        return accessLevels.includes(desiredAccessLevel) ? AccessControl.Authority.Granted : AccessControl.Authority.Unauthorized;
      },
      agentFor(endpoint) {
        if (!agents) {
          agents = ContextAgents(context);
        }
        return agents.agentFor(endpoint);
      },
      get [Contextual.context]() {
        return this;
      }
    };
    if (message) {
      Contextual.setContextOf(message, context);
    }
    return context;
  }
  function aclEndpointContextFor({ endpoint: number }) {
    if (number === void 0) {
      throw new InternalError("Online location missing required endpoint number");
    }
    if (options.node === void 0) {
      throw new InternalError("Online context has no node defined");
    }
    if (nodeProtocol === void 0) {
      nodeProtocol = options.node.protocol;
    }
    const endpoint = nodeProtocol[number];
    if (endpoint === void 0) {
      throw new InternalError(`Unknown endpoint number ${number} in access control location`);
    }
    return endpoint;
  }
}
export {
  OnlineContext
};
//# sourceMappingURL=OnlineContext.js.map
