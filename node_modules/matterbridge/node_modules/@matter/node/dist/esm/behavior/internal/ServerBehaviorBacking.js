/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { ClusterBehavior } from "#behavior/cluster/ClusterBehavior.js";
import { ValidatedElements } from "#behavior/cluster/ValidatedElements.js";
import { camelize } from "#general";
import { FieldValue } from "#model";
import { ServerNodeStore } from "#node/storage/ServerNodeStore.js";
import { TlvNoResponse } from "#types";
import { BehaviorBacking } from "./BehaviorBacking.js";
const NoElements = /* @__PURE__ */ new Set();
class ServerBehaviorBacking extends BehaviorBacking {
  #store;
  #elements;
  get store() {
    if (!this.#store) {
      this.#store = this.#serverStore.endpointStores.storeForEndpoint(this.endpoint).storeForBehavior(this.type.id);
    }
    return this.#store;
  }
  get elements() {
    return this.#elements;
  }
  invokeInitializer(behavior, options) {
    const finalizeState = () => {
      this.#applyTransitiveDefaults(behavior.state);
      if (behavior instanceof ClusterBehavior) {
        this.#configureElements(behavior);
      } else {
        this.#elements = {
          attributes: NoElements,
          commands: NoElements,
          events: NoElements
        };
      }
      const context = behavior.context;
      this.datasource.validate(context, behavior.state);
    };
    const promise = super.invokeInitializer(behavior, options);
    if (promise) {
      return promise.then(finalizeState);
    }
    finalizeState();
  }
  get #serverStore() {
    return this.endpoint.env.get(ServerNodeStore);
  }
  /**
   * Schema may specify that state fields default to the value of another field.  We apply these defaults after
   * initialization when the other field should be defined.
   */
  #applyTransitiveDefaults(state) {
    const schema = this.type.schema;
    if (!schema) {
      return;
    }
    for (const member of this.type.supervisor.membersOf(schema)) {
      const name = camelize(member.name);
      if (state[name] === void 0) {
        const referenced = FieldValue.referenced(member.default);
        if (referenced) {
          const val = state[camelize(referenced)];
          if (val !== void 0) {
            state[name] = val;
          }
        }
      }
    }
  }
  #configureElements(behavior) {
    const validation = new ValidatedElements(behavior.constructor, behavior);
    validation.report();
    const globals = behavior.state;
    const attributeDefs = behavior.cluster.attributes;
    globals.attributeList = [...validation.attributes].map((name) => attributeDefs[name].id);
    const commandDefs = behavior.cluster.commands;
    const commands = [...validation.commands].map((name) => commandDefs[name]);
    globals.acceptedCommandList = commands.map((command) => command.requestId);
    globals.generatedCommandList = [
      ...new Set(
        commands.filter((command) => command.responseSchema !== TlvNoResponse).map((command) => command.responseId)
      )
    ];
    this.#elements = {
      attributes: validation.attributes,
      commands: validation.commands,
      events: validation.events
    };
  }
}
export {
  ServerBehaviorBacking
};
//# sourceMappingURL=ServerBehaviorBacking.js.map
