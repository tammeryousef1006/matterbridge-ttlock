/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import {
  AsyncObservable,
  Diagnostic,
  EventEmitter,
  ImplementationError,
  Lifecycle,
  Logger,
  MatterFlowError,
  Observable
} from "#general";
import { DatatypeModel, FieldElement } from "#model";
import { FabricAction, FabricManager, FailsafeContext, PaseClient, Val } from "#protocol";
import {
  CommissioningFlowType,
  CommissioningOptions,
  DiscoveryCapabilitiesSchema,
  ManualPairingCodeCodec,
  QrCode,
  QrPairingCodeCodec
} from "#types";
import { BasicInformationBehavior } from "../../../behaviors/basic-information/BasicInformationBehavior.js";
import { OperationalCredentialsBehavior } from "../../../behaviors/operational-credentials/OperationalCredentialsBehavior.js";
import { Behavior } from "../../Behavior.js";
import { NetworkServer } from "../network/NetworkServer.js";
import { SessionsBehavior } from "../sessions/SessionsBehavior.js";
const logger = Logger.get("Commissioning");
class CommissioningServer extends Behavior {
  static id = "commissioning";
  static early = true;
  initialize() {
    if (this.state.passcode === -1) {
      this.state.passcode = PaseClient.generateRandomPasscode();
    } else if (CommissioningOptions.FORBIDDEN_PASSCODES.includes(this.state.passcode)) {
      throw new ImplementationError(`Passcode ${this.state.passcode} is not allowed`);
    }
    if (this.state.discriminator === -1) {
      this.state.discriminator = PaseClient.generateRandomDiscriminator();
    }
    this.reactTo(this.endpoint.lifecycle.online, this.#nodeOnline);
    this.reactTo(this.endpoint.lifecycle.partsReady, this.#initializeNode);
  }
  [Symbol.asyncDispose]() {
    this.internal.unregisterFailsafeListener?.();
  }
  handleFabricChange(fabricIndex, fabricAction) {
    if (this.env.has(FailsafeContext)) {
      const failsafe = this.env.get(FailsafeContext);
      if (fabricAction === FabricAction.Added || fabricAction === FabricAction.Updated) {
        if (failsafe.construction.status !== Lifecycle.Status.Destroyed) {
          if (failsafe.fabricIndex === fabricIndex) {
            this.#monitorFailsafe(failsafe);
            return;
          } else {
            throw new MatterFlowError(
              `Failsafe owns a different fabricIndex then ${failsafe.forUpdateNoc ? "updated" : "added"}.`
            );
          }
        }
      } else if (fabricAction === FabricAction.Removed) {
        if (failsafe.fabricIndex !== fabricIndex) {
          throw new MatterFlowError("Failsafe owns a different fabricIndex then removed.");
        }
      }
    }
    const commissioned = !!this.env.get(FabricManager).fabrics.length;
    let doFactoryReset = false;
    if (commissioned !== this.state.commissioned) {
      this.state.commissioned = commissioned;
      if (commissioned) {
        this.events.commissioned.emit(this.context);
        this.endpoint.lifecycle.commissioned.emit(this.context);
      } else {
        this.events.decommissioned.emit(this.context);
        this.endpoint.lifecycle.decommissioned.emit(this.context);
        doFactoryReset = true;
      }
    }
    this.events.fabricsChanged.emit(fabricIndex, fabricAction);
    if (doFactoryReset) {
      const sessions = this.agent.get(SessionsBehavior);
      if (Object.keys(sessions.state.sessions).length > 0) {
        this.reactTo(sessions.events.closed, this.#handleSessionClosed);
      } else {
        this.#triggerFactoryReset();
      }
    }
  }
  #handleSessionClosed() {
    const sessions = this.agent.get(SessionsBehavior);
    if (Object.keys(sessions.state.sessions).length === 0) {
      this.#triggerFactoryReset();
    }
  }
  #triggerFactoryReset() {
    this.env.runtime.add(this.endpoint.erase());
  }
  #monitorFailsafe(failsafe) {
    if (this.internal.unregisterFailsafeListener) {
      return;
    }
    const listener = this.callback(function(status) {
      if (status === Lifecycle.Status.Destroyed) {
        if (failsafe.fabricIndex !== void 0) {
          this.handleFabricChange(
            failsafe.fabricIndex,
            failsafe.forUpdateNoc ? FabricAction.Updated : FabricAction.Added
          );
        }
        this.internal.unregisterFailsafeListener?.();
      }
    });
    this.internal.unregisterFailsafeListener = this.callback(function() {
      failsafe.construction.change.off(listener);
      this.internal.unregisterFailsafeListener = void 0;
    });
    failsafe.construction.change.on(listener);
  }
  /**
   * The server invokes this method when the node is active but not yet commissioned unless you set
   * {@link CommissioningServer.State#enabled} to false.
   *
   * An uncommissioned node is not yet associated with fabrics.  It cannot be used until commissioned by a controller.
   *
   * The default implementation logs the QR code and credentials.
   */
  initiateCommissioning() {
    const { passcode, discriminator } = this.state;
    const { qrPairingCode, manualPairingCode } = this.state.pairingCodes;
    logger.notice(
      Diagnostic.strong(this.endpoint.toString()),
      "is uncommissioned",
      Diagnostic.dict({
        passcode,
        discriminator,
        "manual pairing code": manualPairingCode
      }),
      Diagnostic.list([
        QrCode.get(qrPairingCode).trim(),
        `QR code URL: https://project-chip.github.io/connectedhomeip/qrcode.html?data=${qrPairingCode}
`
      ])
    );
  }
  /**
   * Obtain pairing codes for a node.
   */
  static pairingCodesFor(node) {
    const bi = node.stateOf(BasicInformationBehavior);
    const comm = node.stateOf(CommissioningServer);
    const net = node.stateOf(NetworkServer);
    const qrPairingCode = QrPairingCodeCodec.encode([
      {
        version: 0,
        vendorId: bi.vendorId,
        productId: bi.productId,
        flowType: comm.flowType,
        discriminator: comm.discriminator,
        passcode: comm.passcode,
        discoveryCapabilities: DiscoveryCapabilitiesSchema.encode(net.discoveryCapabilities)
      }
    ]);
    return {
      manualPairingCode: ManualPairingCodeCodec.encode({
        discriminator: comm.discriminator,
        passcode: comm.passcode
      }),
      qrPairingCode
    };
  }
  /**
   * Define logical schema to make passcode and discriminator persistent.
   */
  static schema = new DatatypeModel({
    name: "CommissioningState",
    type: "struct",
    children: [
      FieldElement({ name: "passcode", type: "uint32", quality: "N" }),
      FieldElement({ name: "discriminator", type: "uint16", quality: "N" })
    ]
  });
  #nodeOnline() {
    if (this.state.enabled && !this.env.get(FabricManager).fabrics.length) {
      this.initiateCommissioning();
    }
  }
  #initializeNode() {
    this.state.commissioned = !!this.agent.get(OperationalCredentialsBehavior).state.commissionedFabrics;
    this.endpoint.lifecycle.initialized.emit(this.state.commissioned);
  }
}
((CommissioningServer2) => {
  class Internal {
    unregisterFailsafeListener = void 0;
  }
  CommissioningServer2.Internal = Internal;
  class State {
    enabled;
    commissioned = false;
    fabrics = {};
    passcode = -1;
    discriminator = -1;
    flowType = CommissioningFlowType.Standard;
    additionalBleAdvertisementData = void 0;
    pairingCodes = {};
    [Val.properties](endpoint) {
      return {
        get pairingCodes() {
          return CommissioningServer2.pairingCodesFor(endpoint);
        },
        get fabrics() {
          const exposedFabrics = {};
          endpoint.env.get(FabricManager).fabrics.forEach(
            ({ fabricIndex, externalInformation }) => exposedFabrics[fabricIndex] = externalInformation
          );
          return exposedFabrics;
        }
      };
    }
  }
  CommissioningServer2.State = State;
  class Events extends EventEmitter {
    commissioned = Observable();
    decommissioned = Observable();
    fabricsChanged = Observable();
    enabled$Changed = AsyncObservable();
  }
  CommissioningServer2.Events = Events;
})(CommissioningServer || (CommissioningServer = {}));
export {
  CommissioningServer
};
//# sourceMappingURL=CommissioningServer.js.map
