/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { PeerAddress } from "#protocol";
import { DeviceTypeId, VendorId } from "#types";
var RemoteDescriptor;
((RemoteDescriptor2) => {
  function is(subject, object) {
    if (object.peerAddress !== void 0 && subject.peerAddress !== void 0) {
      return PeerAddress.is(subject.peerAddress, object.peerAddress);
    }
    if (object.deviceIdentifier !== void 0) {
      return subject.deviceIdentifier === object.deviceIdentifier;
    }
    return false;
  }
  RemoteDescriptor2.is = is;
  function fromLongForm(long) {
    const result = {};
    const {
      addresses,
      discoveredAt,
      ttl,
      deviceIdentifier,
      discriminator,
      commissioningMode,
      vendorId,
      productId,
      deviceType,
      deviceName,
      rotatingIdentifier,
      pairingHint,
      pairingInstructions,
      sessionParameters,
      tcpSupport,
      longIdleTimeOperatingMode
    } = long;
    if (discoveredAt !== void 0) {
      result.discoveredAt = discoveredAt;
    }
    if (ttl !== void 0) {
      result.ttl = ttl;
    }
    if (deviceIdentifier !== void 0) {
      result.deviceIdentifier = deviceIdentifier;
    }
    if (vendorId !== void 0) {
      if (productId !== void 0) {
        result.VP = `${vendorId}+${productId}`;
      } else {
        result.VP = `${vendorId}`;
      }
    }
    if (deviceType !== void 0) {
      result.DT = deviceType;
    }
    if (deviceName !== void 0) {
      result.DN = deviceName;
    }
    if (rotatingIdentifier !== void 0) {
      result.RI = rotatingIdentifier;
    }
    if (pairingHint !== void 0) {
      result.PH = pairingHint;
    }
    if (pairingInstructions !== void 0) {
      result.PI = pairingInstructions;
    }
    if (sessionParameters !== void 0) {
      const { idleIntervalMs, activeIntervalMs, activeThresholdMs } = sessionParameters;
      if (idleIntervalMs !== void 0) {
        result.SII = idleIntervalMs;
      }
      if (activeIntervalMs !== void 0) {
        result.SAI = activeIntervalMs;
      }
      if (activeThresholdMs !== void 0) {
        result.SAT = activeThresholdMs;
      }
    }
    if (tcpSupport !== void 0) {
      result.T = tcpSupport;
    }
    if (longIdleTimeOperatingMode !== void 0) {
      result.ICD = 1;
    }
    const isOperational = long.peerAddress !== void 0;
    if (isOperational) {
      if (addresses !== void 0) {
        result.addresses = addresses?.filter((address) => address.type === "udp");
      }
    } else {
      if (addresses !== void 0) {
        result.addresses = addresses.map((address) => ({ ...address }));
      }
      if (discriminator !== void 0) {
        result.D = discriminator;
      }
      if (commissioningMode !== void 0) {
        result.CM = commissioningMode;
      }
    }
    return result;
  }
  RemoteDescriptor2.fromLongForm = fromLongForm;
  function toLongForm(descriptor, long) {
    if (!descriptor) {
      descriptor = {};
    }
    const { addresses, discoveredAt, ttl, deviceIdentifier, VP, DT, DN, RI, PH, PI, SII, SAI, SAT, T, ICD } = descriptor;
    if (discoveredAt !== void 0) {
      long.discoveredAt = discoveredAt;
    }
    if (ttl !== void 0) {
      long.ttl = ttl;
    }
    if (addresses?.length) {
      long.addresses = addresses;
    }
    if (deviceIdentifier !== void 0) {
      long.deviceIdentifier = deviceIdentifier;
    }
    if (VP !== void 0) {
      const [vendor, product] = VP.split("+").map(Number.parseInt);
      long.vendorId = Number.isNaN(vendor) ? void 0 : VendorId(vendor);
      long.productId = Number.isNaN(product) ? void 0 : VendorId(vendor);
    }
    let sessionParameters;
    if (SII !== void 0) {
      (sessionParameters ??= {}).idleIntervalMs = SII;
    }
    if (SAI !== void 0) {
      (sessionParameters ??= {}).activeIntervalMs = SAI;
    }
    if (SAT !== void 0) {
      (sessionParameters ??= {}).activeThresholdMs = SAT;
    }
    long.sessionParameters = sessionParameters;
    long.deviceType = DT === void 0 ? void 0 : DeviceTypeId(DT);
    long.deviceName = DN;
    long.rotatingIdentifier = RI;
    long.pairingHint = PH;
    long.pairingInstructions = PI;
    long.tcpSupport = T;
    long.longIdleTimeOperatingMode = ICD === void 0 ? void 0 : ICD === 1;
    if ("D" in descriptor) {
      long.discriminator = descriptor.D;
    }
    if ("CM" in descriptor) {
      long.commissioningMode = descriptor.CM;
    }
  }
  RemoteDescriptor2.toLongForm = toLongForm;
})(RemoteDescriptor || (RemoteDescriptor = {}));
export {
  RemoteDescriptor
};
//# sourceMappingURL=RemoteDescriptor.js.map
