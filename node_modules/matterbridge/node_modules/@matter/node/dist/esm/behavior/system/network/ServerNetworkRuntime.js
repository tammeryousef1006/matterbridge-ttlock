/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { SubscriptionBehavior } from "#behavior/system/subscription/index.js";
import {
  Construction,
  InterfaceType,
  Logger,
  NetInterfaceSet,
  Network,
  NoAddressAvailableError,
  ObserverGroup,
  TransportInterfaceSet,
  UdpInterface
} from "#general";
import { NodePeerAddressStore } from "#node/index.js";
import { TransactionalInteractionServer } from "#node/server/TransactionalInteractionServer.js";
import {
  Ble,
  ChannelManager,
  CommissioningConfigProvider,
  DeviceAdvertiser,
  DeviceCommissioner,
  ExchangeManager,
  InteractionServer,
  MdnsService,
  PeerAddressStore,
  PeerSet,
  ScannerSet,
  SecureChannelProtocol,
  SessionManager
} from "#protocol";
import { CommissioningServer } from "../commissioning/CommissioningServer.js";
import { ProductDescriptionServer } from "../product-description/ProductDescriptionServer.js";
import { SessionsBehavior } from "../sessions/SessionsBehavior.js";
import { NetworkRuntime } from "./NetworkRuntime.js";
const logger = Logger.get("ServerNetworkRuntime");
function convertNetworkEnvironmentType(type) {
  const convertedType = typeof type === "string" ? InterfaceType[type] : type;
  if (typeof convertedType !== "number" || convertedType < 1 || convertedType > 4) {
    return void 0;
  }
  return convertedType;
}
class ServerNetworkRuntime extends NetworkRuntime {
  #mdnsBroadcaster;
  #bleBroadcaster;
  #bleTransport;
  #observers = new ObserverGroup(this);
  #formerSubscriptionsHandled = false;
  get owner() {
    return super.owner;
  }
  /**
   * Access the MDNS broadcaster for the node.
   */
  get mdnsBroadcaster() {
    if (!this.#mdnsBroadcaster) {
      this.#mdnsBroadcaster = this.owner.env.get(MdnsService).createInstanceBroadcaster(this.owner.state.network.operationalPort);
    }
    return this.#mdnsBroadcaster;
  }
  get networkInterfaceConfiguration() {
    const interfaceConfig = this.owner.env.vars.get(
      "network.interface",
      {}
    );
    return Object.entries(interfaceConfig).map(([name, { type }]) => ({
      name,
      type: convertNetworkEnvironmentType(type)
    }));
  }
  async getNetworkInterfaces() {
    const network = this.owner.env.get(Network);
    const interfaces = await network.getNetInterfaces(this.networkInterfaceConfiguration);
    const interfaceDetails = new Array();
    for (const { name, type } of interfaces) {
      const details = await network.getIpMac(name);
      if (details !== void 0) {
        interfaceDetails.push({ name, type, ...details });
      }
    }
    return interfaceDetails;
  }
  async openAdvertisementWindow() {
    if (!this.#formerSubscriptionsHandled) {
      await this.#reestablishFormerSubscriptions();
    }
    await this.owner.env.get(DeviceAdvertiser).startAdvertising();
  }
  advertiseNow() {
    return this.owner.env.get(DeviceAdvertiser).advertise(true);
  }
  /**
   * A BLE broadcaster.
   */
  get bleBroadcaster() {
    if (this.#bleBroadcaster === void 0) {
      const bleData = this.owner.state.commissioning.additionalBleAdvertisementData;
      this.#bleBroadcaster = Ble.get().getBleBroadcaster(bleData);
    }
    return this.#bleBroadcaster;
  }
  /**
   * A BLE transport.
   */
  get bleTransport() {
    if (this.#bleTransport === void 0) {
      this.#bleTransport = Ble.get().getBlePeripheralInterface();
    }
    return this.#bleTransport;
  }
  /**
   * Add transports to the {@link TransportInterfaceSet}.
   */
  async addTransports(interfaces) {
    const netconf = this.owner.state.network;
    const port = this.owner.state.network.port;
    try {
      const ipv6Intf = await UdpInterface.create(
        this.owner.env.get(Network),
        "udp6",
        port ? port : void 0,
        netconf.listeningAddressIpv6
      );
      interfaces.add(ipv6Intf);
      await this.owner.set({ network: { operationalPort: ipv6Intf.port } });
    } catch (error) {
      NoAddressAvailableError.accept(error);
      logger.info(`IPv6 UDP interface not created because IPv6 is not available, but required my Matter.`);
      throw error;
    }
    if (netconf.ipv4) {
      try {
        interfaces.add(
          await UdpInterface.create(
            this.owner.env.get(Network),
            "udp4",
            netconf.port,
            netconf.listeningAddressIpv4
          )
        );
      } catch (error) {
        NoAddressAvailableError.accept(error);
        logger.info(`IPv4 UDP interface not created because IPv4 is not available`);
      }
    }
    if (netconf.ble) {
      interfaces.add(this.bleTransport);
    }
  }
  /**
   * Add broadcasters to the {@link DeviceAdvertiser}.
   */
  async addBroadcasters(advertiser) {
    await advertiser.clearBroadcasters();
    const isCommissioned = !!this.#commissionedFabrics;
    let discoveryCapabilities = this.owner.state.network.discoveryCapabilities;
    if (isCommissioned) {
      discoveryCapabilities = { onIpNetwork: true };
    }
    if (discoveryCapabilities.onIpNetwork) {
      advertiser.addBroadcaster(this.mdnsBroadcaster);
    }
    if (discoveryCapabilities.ble) {
      advertiser.addBroadcaster(this.bleBroadcaster);
    }
  }
  /**
   * When the first Fabric gets added we need to enable MDNS broadcasting.
   */
  enableMdnsBroadcasting() {
    const advertiser = this.owner.env.get(DeviceAdvertiser);
    const mdnsBroadcaster = this.mdnsBroadcaster;
    if (!advertiser.hasBroadcaster(mdnsBroadcaster)) {
      logger.debug("Enabling MDNS broadcasting");
      advertiser.addBroadcaster(mdnsBroadcaster);
    }
  }
  /**
   * On commission we turn off bluetooth and join the IP network if we haven't already.
   *
   * On decommission we're destroyed so don't need to handle that case.
   */
  endUncommissionedMode() {
    this.enableMdnsBroadcasting();
    if (this.#bleBroadcaster) {
      this.owner.env.runtime.add(this.#removeBleBroadcaster(this.#bleBroadcaster));
      this.#bleBroadcaster = void 0;
    }
    if (this.#bleTransport) {
      this.owner.env.runtime.add(this.#removeBleTransport(this.#bleTransport));
      this.#bleTransport = void 0;
    }
  }
  async #removeBleBroadcaster(bleBroadcaster) {
    const advertiser = this.owner.env.get(DeviceAdvertiser);
    await advertiser.deleteBroadcaster(bleBroadcaster);
    await bleBroadcaster.close();
  }
  async #removeBleTransport(bleTransport) {
    const transportInterfaces = this.owner.env.get(TransportInterfaceSet);
    transportInterfaces.delete(bleTransport);
    await bleTransport.close();
  }
  get #commissionedFabrics() {
    return this.owner.state.operationalCredentials.commissionedFabrics;
  }
  endCommissioning() {
    return this.owner.env.get(DeviceCommissioner).endCommissioning();
  }
  async start() {
    const { owner } = this;
    const { env } = owner;
    await env.load(MdnsService);
    const advertiser = env.get(DeviceAdvertiser);
    const interfaces = env.get(TransportInterfaceSet);
    await this.addTransports(interfaces);
    env.set(NetInterfaceSet, interfaces);
    await this.addBroadcasters(advertiser);
    await owner.act("start-network", (agent) => agent.load(ProductDescriptionServer));
    env.get(ChannelManager).caseSessionsPerFabricAndNode = // Note that this is "sessions per fabric and node", so we support more than indicated by capabilityMinima
    owner.state.basicInformation.capabilityMinima.caseSessionsPerFabric;
    env.get(SessionManager).sessionParameters = {
      maxPathsPerInvoke: this.owner.state.basicInformation.maxPathsPerInvoke
    };
    const interactionServer = await TransactionalInteractionServer.create(this.owner, env.get(SessionManager));
    env.set(InteractionServer, interactionServer);
    env.get(ExchangeManager).addProtocolHandler(interactionServer);
    await this.owner.act("load-sessions", (agent) => agent.load(SessionsBehavior));
    this.#observers.on(this.owner.eventsOf(CommissioningServer).commissioned, this.endUncommissionedMode);
    this.#observers.on(advertiser.operationalModeEnabled, this.enableMdnsBroadcasting);
    if (owner.state.commissioning.enabled === void 0) {
      await owner.set({
        commissioning: { enabled: true }
      });
    }
    if (!env.has(CommissioningConfigProvider)) {
      env.set(
        CommissioningConfigProvider,
        new class extends CommissioningConfigProvider {
          get values() {
            const config = {
              ...owner.state.commissioning,
              productDescription: owner.state.productDescription,
              ble: !!owner.state.network.ble
            };
            return config;
          }
        }()
      );
    }
    await this.configureCommissioning();
    this.#observers.on(this.owner.eventsOf(CommissioningServer).enabled$Changed, this.configureCommissioning);
  }
  async [Construction.construct]() {
    await super[Construction.construct]();
    this.owner.env.get(ScannerSet).add((await this.owner.env.load(MdnsService)).scanner);
    this.owner.env.set(PeerAddressStore, new NodePeerAddressStore(this.owner));
    await this.owner.env.load(PeerSet);
    await this.openAdvertisementWindow();
  }
  async stop() {
    this.blockNewActivity();
    this.#observers.close();
    await this.owner.env.close(DeviceCommissioner);
    const advertisementShutdown = this.owner.env.has(DeviceAdvertiser) ? this.owner.env.close(DeviceAdvertiser) : this.#mdnsBroadcaster?.close();
    this.#mdnsBroadcaster = void 0;
    await this.owner.prepareRuntimeShutdown();
    await advertisementShutdown;
    await this.owner.env.close(ExchangeManager);
    await this.owner.env.close(SecureChannelProtocol);
    await this.owner.env.close(TransportInterfaceSet);
    await this.owner.env.close(InteractionServer);
  }
  blockNewActivity() {
    this.owner.env.maybeGet(InteractionServer)?.blockNewActivity();
  }
  async configureCommissioning() {
    if (this.owner.state.commissioning.enabled) {
      this.owner.env.get(DeviceCommissioner);
    } else if (this.owner.env.has(DeviceCommissioner)) {
      await this.owner.env.close(DeviceCommissioner);
    }
  }
  async #reestablishFormerSubscriptions() {
    const { env } = this.owner;
    if (!env.has(InteractionServer)) {
      return;
    }
    this.#formerSubscriptionsHandled = true;
    await this.owner.act(
      (agent) => agent.get(SubscriptionBehavior).reestablishFormerSubscriptions(env.get(InteractionServer))
    );
  }
}
export {
  ServerNetworkRuntime
};
//# sourceMappingURL=ServerNetworkRuntime.js.map
