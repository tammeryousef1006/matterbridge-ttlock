/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { IndexBehavior } from "#behavior/system/index/IndexBehavior.js";
import { EndpointLifecycle } from "#endpoint/properties/EndpointLifecycle.js";
import { ImplementationError, isDeepEqual } from "#general";
import { DeviceTypeModel, MatterModel } from "#model";
import { DeviceTypeId } from "#types";
import { DescriptorBehavior } from "./DescriptorBehavior.js";
class DescriptorServer extends DescriptorBehavior {
  static dependencies = [IndexBehavior];
  async initialize() {
    if (this.endpoint.behaviors.has(IndexBehavior)) {
      this.reactTo(this.agent.get(IndexBehavior).events.change, this.#updatePartsList);
    } else if (this.endpoint.hasParts) {
      for (const endpoint of this.endpoint.parts) {
        this.#monitorDestruction(endpoint);
      }
    }
    await this.#updatePartsList();
    this.reactTo(this.endpoint.lifecycle.changed, this.#updateDescriptor);
    this.state.serverList = this.#serverList;
    this.#initializeDeviceTypeList();
  }
  /** Initialize device type list when it is not already initialized. */
  #initializeDeviceTypeList() {
    if (!this.state.deviceTypeList.length) {
      const partType = this.endpoint.type;
      this.state.deviceTypeList = [
        {
          deviceType: partType.deviceType,
          revision: partType.deviceRevision
        }
      ];
    }
  }
  /**
   * Extend device type metadata.  This is a shortcut for deduped insert into the deviceTypeList cluster attribute.
   *
   * @param deviceTypes an array of objects or named device types as defined in {@link MatterModel.standard}
   */
  addDeviceTypes(...deviceTypes) {
    this.#initializeDeviceTypeList();
    const list = this.state.deviceTypeList;
    nextInput: for (let newDeviceType of deviceTypes) {
      if (typeof newDeviceType === "string") {
        const dt = MatterModel.standard.get(DeviceTypeModel, newDeviceType);
        if (dt === void 0) {
          throw new ImplementationError(`Device type ${newDeviceType} not found`);
        }
        newDeviceType = { deviceType: DeviceTypeId(dt.id), revision: dt.revision };
      }
      for (const existingDeviceType of list) {
        if (isDeepEqual(newDeviceType, existingDeviceType)) {
          continue nextInput;
        }
      }
      list.push(newDeviceType);
    }
  }
  /**
   * Add semantic tags.  This is a shortcut for deduped insert into the tagList cluster attribute.
   *
   * You must enable the "TagList" feature to use this method.
   */
  addTags(...tags) {
    if (!this.features.tagList) {
      throw new ImplementationError('You must enable the descriptor "TagList" feature to set tags');
    }
    const list = this.state.tagList;
    nextInput: for (const newTag of tags) {
      for (const existingTag of list) {
        if (existingTag.mfgCode === newTag.mfgCode && existingTag.namespaceId === newTag.namespaceId && existingTag.tag === newTag.tag) {
          if (existingTag.label !== newTag.label && newTag.label !== null && newTag.label !== void 0) {
            existingTag.label = newTag.label;
            continue nextInput;
          }
        }
      }
      list.push(newTag);
    }
  }
  /**
   * Check for presence of a device type.
   */
  hasDeviceType(type) {
    return this.state.deviceTypeList.findIndex((dt) => dt.deviceType === type) !== -1;
  }
  /**
   * Process a structure change event and trigger state updates if necessary.
   */
  async #updateDescriptor(type, endpoint) {
    switch (type) {
      case EndpointLifecycle.Change.Ready:
        if (!this.endpoint.parts.has(endpoint)) {
          return;
        }
        await this.#updatePartsList();
        if (!this.endpoint.behaviors.has(IndexBehavior)) {
          this.#monitorDestruction(endpoint);
        }
        break;
      case EndpointLifecycle.Change.ServersChanged:
        if (endpoint !== this.endpoint) {
          return;
        }
        await this.context.transaction.addResources(this);
        await this.context.transaction.begin();
        this.state.serverList = this.#serverList;
        break;
      case EndpointLifecycle.Change.Destroying:
        if (endpoint !== this.endpoint) {
          return;
        }
        await this.stopReacting({ reactor: this.#updatePartsList });
        break;
    }
  }
  /**
   * Monitor endpoint for removal.
   */
  #monitorDestruction(endpoint) {
    this.reactTo(endpoint.lifecycle.destroyed, this.#updatePartsList);
  }
  /**
   * Update the parts list.
   */
  async #updatePartsList() {
    const endpoint = this.endpoint;
    let numbers;
    if (this.agent.has(IndexBehavior)) {
      const index = this.agent.get(IndexBehavior);
      numbers = Object.keys(index.partsByNumber).map((n) => Number.parseInt(n));
      const pos = numbers.indexOf(this.endpoint.number);
      if (pos !== -1) {
        numbers.splice(pos, 1);
      }
    } else if (endpoint.hasParts) {
      numbers = [...endpoint.parts].map((endpoint2) => endpoint2.lifecycle.hasNumber ? endpoint2.number : void 0).filter((n) => n !== void 0);
    } else {
      numbers = [];
    }
    numbers.sort();
    if (this.state.partsList.length === numbers.length) {
      let i = numbers.length;
      for (; i < numbers.length; i++) {
        if (this.state.partsList[i] !== numbers[i]) {
          break;
        }
      }
      if (i === numbers.length) {
        return;
      }
    }
    await this.context.transaction.addResources(this);
    await this.context.transaction.begin();
    this.state.partsList = numbers;
  }
  /**
   * Computed current server list.
   */
  get #serverList() {
    const list = new Array();
    for (const type of Object.values(this.endpoint.behaviors.supported)) {
      const clusterId = type.cluster?.id;
      if (clusterId) {
        list.push(clusterId);
      }
    }
    return list;
  }
}
export {
  DescriptorServer
};
//# sourceMappingURL=DescriptorServer.js.map
