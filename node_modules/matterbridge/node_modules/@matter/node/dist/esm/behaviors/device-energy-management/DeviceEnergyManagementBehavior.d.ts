/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
/*** THIS FILE IS GENERATED, DO NOT EDIT ***/
import { DeviceEnergyManagement } from "#clusters/device-energy-management";
import { ClusterBehavior } from "../../behavior/cluster/ClusterBehavior.js";
import { DeviceEnergyManagementInterface } from "./DeviceEnergyManagementInterface.js";
import { ClusterType } from "#types";
/**
 * DeviceEnergyManagementBehavior is the base class for objects that support interaction with
 * {@link DeviceEnergyManagement.Cluster}.
 *
 * DeviceEnergyManagement.Cluster requires you to enable one or more optional features. You can do so using
 * {@link DeviceEnergyManagementBehavior.with}.
 */
export declare const DeviceEnergyManagementBehavior: ClusterBehavior.Type<ClusterType.Of<{
    readonly id: 152;
    readonly name: "DeviceEnergyManagement";
    readonly revision: 4;
    readonly features: {
        readonly powerAdjustment: import("#types").BitFlag;
        readonly powerForecastReporting: import("#types").BitFlag;
        readonly stateForecastReporting: import("#types").BitFlag;
        readonly startTimeAdjustment: import("#types").BitFlag;
        readonly pausable: import("#types").BitFlag;
        readonly forecastAdjustment: import("#types").BitFlag;
        readonly constraintBasedAdjustment: import("#types").BitFlag;
    };
    readonly attributes: {
        readonly esaType: import("#types").FixedAttribute<DeviceEnergyManagement.EsaType, any>;
        readonly esaCanGenerate: import("#types").FixedAttribute<boolean, any>;
        readonly esaState: import("#types").Attribute<DeviceEnergyManagement.EsaState, any>;
        readonly absMinPower: import("#types").Attribute<number | bigint, any>;
        readonly absMaxPower: import("#types").Attribute<number | bigint, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly powerAdjustment: true;
        };
        readonly component: {
            readonly attributes: {
                readonly powerAdjustmentCapability: import("#types").Attribute<import("#types").TypeFromFields<{
                    powerAdjustCapability: import("#types").FieldType<import("#types").TypeFromFields<{
                        minPower: import("#types").FieldType<number | bigint>;
                        maxPower: import("#types").FieldType<number | bigint>;
                        minDuration: import("#types").FieldType<number>;
                        maxDuration: import("#types").FieldType<number>;
                    }>[] | null>;
                    cause: import("#types").FieldType<DeviceEnergyManagement.PowerAdjustReason>;
                }> | null, any>;
            };
            readonly commands: {
                readonly powerAdjustRequest: import("#types").Command<import("#types").TypeFromFields<{
                    power: import("#types").FieldType<number | bigint>;
                    duration: import("#types").FieldType<number>;
                    cause: import("#types").FieldType<DeviceEnergyManagement.AdjustmentCause>;
                }>, void, any>;
                readonly cancelPowerAdjustRequest: import("#types").Command<void, void, any>;
            };
            readonly events: {
                readonly powerAdjustStart: import("#types").Event<void, any>;
                readonly powerAdjustEnd: import("#types").Event<import("#types").TypeFromFields<{
                    cause: import("#types").FieldType<DeviceEnergyManagement.Cause>;
                    duration: import("#types").FieldType<number>;
                    energyUse: import("#types").FieldType<number | bigint>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly powerForecastReporting: true;
        };
        readonly component: {
            readonly attributes: {
                readonly forecast: import("#types").Attribute<import("#types").TypeFromFields<{
                    forecastId: import("#types").FieldType<number>;
                    activeSlotNumber: import("#types").FieldType<number | null>;
                    startTime: import("#types").FieldType<number>;
                    endTime: import("#types").FieldType<number>;
                    earliestStartTime: import("#types").OptionalFieldType<number | null>;
                    latestEndTime: import("#types").OptionalFieldType<number>;
                    isPausable: import("#types").FieldType<boolean>;
                    slots: import("#types").FieldType<import("#types").TypeFromFields<{
                        minDuration: import("#types").FieldType<number>;
                        maxDuration: import("#types").FieldType<number>;
                        defaultDuration: import("#types").FieldType<number>;
                        elapsedSlotTime: import("#types").FieldType<number>;
                        remainingSlotTime: import("#types").FieldType<number>;
                        slotIsPausable: import("#types").OptionalFieldType<boolean>;
                        minPauseDuration: import("#types").OptionalFieldType<number>;
                        maxPauseDuration: import("#types").OptionalFieldType<number>;
                        manufacturerEsaState: import("#types").OptionalFieldType<number>;
                        nominalPower: import("#types").OptionalFieldType<number | bigint>;
                        minPower: import("#types").OptionalFieldType<number | bigint>;
                        maxPower: import("#types").OptionalFieldType<number | bigint>;
                        nominalEnergy: import("#types").OptionalFieldType<number | bigint>;
                        costs: import("#types").OptionalFieldType<import("#types").TypeFromFields<{
                            costType: import("#types").FieldType<DeviceEnergyManagement.CostType>;
                            value: import("#types").FieldType<number>;
                            decimalPoints: import("#types").FieldType<number>;
                            currency: import("#types").OptionalFieldType<number>;
                        }>[]>;
                        minPowerAdjustment: import("#types").OptionalFieldType<number | bigint>;
                        maxPowerAdjustment: import("#types").OptionalFieldType<number | bigint>;
                        minDurationAdjustment: import("#types").OptionalFieldType<number>;
                        maxDurationAdjustment: import("#types").OptionalFieldType<number>;
                    }>[]>;
                    forecastUpdateReason: import("#types").FieldType<DeviceEnergyManagement.ForecastUpdateReason>;
                }> | null, any>;
            };
        };
    }, {
        readonly flags: {
            readonly stateForecastReporting: true;
        };
        readonly component: {
            readonly attributes: {
                readonly forecast: import("#types").Attribute<import("#types").TypeFromFields<{
                    forecastId: import("#types").FieldType<number>;
                    activeSlotNumber: import("#types").FieldType<number | null>;
                    startTime: import("#types").FieldType<number>;
                    endTime: import("#types").FieldType<number>;
                    earliestStartTime: import("#types").OptionalFieldType<number | null>;
                    latestEndTime: import("#types").OptionalFieldType<number>;
                    isPausable: import("#types").FieldType<boolean>;
                    slots: import("#types").FieldType<import("#types").TypeFromFields<{
                        minDuration: import("#types").FieldType<number>;
                        maxDuration: import("#types").FieldType<number>;
                        defaultDuration: import("#types").FieldType<number>;
                        elapsedSlotTime: import("#types").FieldType<number>;
                        remainingSlotTime: import("#types").FieldType<number>;
                        slotIsPausable: import("#types").OptionalFieldType<boolean>;
                        minPauseDuration: import("#types").OptionalFieldType<number>;
                        maxPauseDuration: import("#types").OptionalFieldType<number>;
                        manufacturerEsaState: import("#types").OptionalFieldType<number>;
                        nominalPower: import("#types").OptionalFieldType<number | bigint>;
                        minPower: import("#types").OptionalFieldType<number | bigint>;
                        maxPower: import("#types").OptionalFieldType<number | bigint>;
                        nominalEnergy: import("#types").OptionalFieldType<number | bigint>;
                        costs: import("#types").OptionalFieldType<import("#types").TypeFromFields<{
                            costType: import("#types").FieldType<DeviceEnergyManagement.CostType>;
                            value: import("#types").FieldType<number>;
                            decimalPoints: import("#types").FieldType<number>;
                            currency: import("#types").OptionalFieldType<number>;
                        }>[]>;
                        minPowerAdjustment: import("#types").OptionalFieldType<number | bigint>;
                        maxPowerAdjustment: import("#types").OptionalFieldType<number | bigint>;
                        minDurationAdjustment: import("#types").OptionalFieldType<number>;
                        maxDurationAdjustment: import("#types").OptionalFieldType<number>;
                    }>[]>;
                    forecastUpdateReason: import("#types").FieldType<DeviceEnergyManagement.ForecastUpdateReason>;
                }> | null, any>;
            };
        };
    }, {
        readonly flags: {
            readonly powerAdjustment: true;
        };
        readonly component: {
            readonly attributes: {
                readonly optOutState: import("#types").Attribute<DeviceEnergyManagement.OptOutState, any>;
            };
        };
    }, {
        readonly flags: {
            readonly startTimeAdjustment: true;
        };
        readonly component: {
            readonly attributes: {
                readonly optOutState: import("#types").Attribute<DeviceEnergyManagement.OptOutState, any>;
            };
        };
    }, {
        readonly flags: {
            readonly pausable: true;
        };
        readonly component: {
            readonly attributes: {
                readonly optOutState: import("#types").Attribute<DeviceEnergyManagement.OptOutState, any>;
            };
        };
    }, {
        readonly flags: {
            readonly forecastAdjustment: true;
        };
        readonly component: {
            readonly attributes: {
                readonly optOutState: import("#types").Attribute<DeviceEnergyManagement.OptOutState, any>;
            };
        };
    }, {
        readonly flags: {
            readonly constraintBasedAdjustment: true;
        };
        readonly component: {
            readonly attributes: {
                readonly optOutState: import("#types").Attribute<DeviceEnergyManagement.OptOutState, any>;
            };
        };
    }, {
        readonly flags: {
            readonly pausable: true;
        };
        readonly component: {
            readonly commands: {
                readonly pauseRequest: import("#types").Command<import("#types").TypeFromFields<{
                    duration: import("#types").FieldType<number>;
                    cause: import("#types").FieldType<DeviceEnergyManagement.AdjustmentCause>;
                }>, void, any>;
                readonly resumeRequest: import("#types").Command<void, void, any>;
            };
            readonly events: {
                readonly paused: import("#types").Event<void, any>;
                readonly resumed: import("#types").Event<import("#types").TypeFromFields<{
                    cause: import("#types").FieldType<DeviceEnergyManagement.Cause>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly startTimeAdjustment: true;
        };
        readonly component: {
            readonly commands: {
                readonly startTimeAdjustRequest: import("#types").Command<import("#types").TypeFromFields<{
                    requestedStartTime: import("#types").FieldType<number>;
                    cause: import("#types").FieldType<DeviceEnergyManagement.AdjustmentCause>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly forecastAdjustment: true;
        };
        readonly component: {
            readonly commands: {
                readonly modifyForecastRequest: import("#types").Command<import("#types").TypeFromFields<{
                    forecastId: import("#types").FieldType<number>;
                    slotAdjustments: import("#types").FieldType<import("#types").TypeFromFields<{
                        slotIndex: import("#types").FieldType<number>;
                        nominalPower: import("#types").OptionalFieldType<number | bigint>;
                        duration: import("#types").FieldType<number>;
                    }>[]>;
                    cause: import("#types").FieldType<DeviceEnergyManagement.AdjustmentCause>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly constraintBasedAdjustment: true;
        };
        readonly component: {
            readonly commands: {
                readonly requestConstraintBasedForecast: import("#types").Command<import("#types").TypeFromFields<{
                    constraints: import("#types").FieldType<import("#types").TypeFromFields<{
                        startTime: import("#types").FieldType<number>;
                        duration: import("#types").FieldType<number>;
                        nominalPower: import("#types").OptionalFieldType<number | bigint>;
                        maximumEnergy: import("#types").OptionalFieldType<number | bigint>;
                        loadControl: import("#types").OptionalFieldType<number>;
                    }>[]>;
                    cause: import("#types").FieldType<DeviceEnergyManagement.AdjustmentCause>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly startTimeAdjustment: true;
        };
        readonly component: {
            readonly commands: {
                readonly cancelRequest: import("#types").Command<void, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly forecastAdjustment: true;
        };
        readonly component: {
            readonly commands: {
                readonly cancelRequest: import("#types").Command<void, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly constraintBasedAdjustment: true;
        };
        readonly component: {
            readonly commands: {
                readonly cancelRequest: import("#types").Command<void, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly staTrue: true;
            readonly pauTrue: false;
            readonly faTrue: false;
            readonly conTrue: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly powerForecastReporting: true;
            readonly stateForecastReporting: true;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly powerForecastReporting: false;
            readonly stateForecastReporting: false;
        };
        readonly component: false;
    }];
}>, ClusterBehavior.Type<ClusterType.Of<{
    readonly id: 0;
    readonly revision: 0;
    readonly name: "Unknown";
    readonly attributes: {};
    readonly commands: {};
    readonly events: {};
}>, typeof ClusterBehavior, DeviceEnergyManagementInterface>, DeviceEnergyManagementInterface>;
type DeviceEnergyManagementBehaviorType = InstanceType<typeof DeviceEnergyManagementBehavior>;
export interface DeviceEnergyManagementBehavior extends DeviceEnergyManagementBehaviorType {
}
type StateType = InstanceType<typeof DeviceEnergyManagementBehavior.State>;
export declare namespace DeviceEnergyManagementBehavior {
    interface State extends StateType {
    }
}
export {};
//# sourceMappingURL=DeviceEnergyManagementBehavior.d.ts.map