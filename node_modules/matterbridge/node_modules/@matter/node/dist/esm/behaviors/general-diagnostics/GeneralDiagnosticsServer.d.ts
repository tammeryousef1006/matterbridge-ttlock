/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { ValueSupervisor } from "#behavior/supervision/ValueSupervisor.js";
import { GeneralDiagnostics } from "#clusters/general-diagnostics";
import { Endpoint } from "#endpoint/Endpoint.js";
import { MaybePromise, Timer } from "#general";
import { Val } from "#protocol";
declare const Base: import("../../index.js").ClusterBehavior.Type<import("#types").ClusterComposer.WithFeatures<GeneralDiagnostics.Cluster, readonly [GeneralDiagnostics.Feature]>, import("../../index.js").ClusterBehavior.Type<GeneralDiagnostics.Cluster, import("../../index.js").ClusterBehavior.Type<import("#types").ClusterType.Of<{
    readonly id: 0;
    readonly revision: 0;
    readonly name: "Unknown";
    readonly attributes: {};
    readonly commands: {};
    readonly events: {};
}>, typeof import("../../index.js").ClusterBehavior, import("./GeneralDiagnosticsInterface.js").GeneralDiagnosticsInterface>, import("./GeneralDiagnosticsInterface.js").GeneralDiagnosticsInterface>, import("./GeneralDiagnosticsInterface.js").GeneralDiagnosticsInterface>;
/**
 * This is the default server implementation of GeneralDiagnosticsBehavior.
 *
 * The implementation provides convenience methods to register and clear hardware, radio, and network faults and to
 * handle test Event triggers.
 *
 * To handle test Event triggers please override the triggerTestEvent method. If these test events are used in
 * certification please also set the EnableKey in the enhanced state as `deviceTestEnableKey`.
 *
 * To register or clear hardware, radio, and network faults, please use the provided convenience methods:
 * * registerHardwareFault and clearHardwareFault
 * * registerRadioFault and clearRadioFault
 * * registerNetworkFault and clearNetworkFault
 * If you want to send events when faults are registered or cleared you need to enable these events when the Root
 * Endpoint gets initialized.
 */
export declare class GeneralDiagnosticsServer extends Base {
    #private;
    protected internal: GeneralDiagnosticsServer.Internal;
    state: GeneralDiagnosticsServer.State;
    schema: import("#model").Schema;
    initialize(): MaybePromise;
    testEventTrigger({ eventTrigger, enableKey }: GeneralDiagnostics.TestEventTriggerRequest): MaybePromise;
    protected triggerTestEvent(eventTrigger: number | bigint): void;
    timeSnapshot(): MaybePromise<GeneralDiagnostics.TimeSnapshotResponse>;
    payloadTestRequest({ enableKey, value, count, }: GeneralDiagnostics.PayloadTestRequest): MaybePromise<GeneralDiagnostics.PayloadTestResponse>;
    /**
     * Register a hardware fault. This convenience method updates the activeHardwareFaults attribute and sends out the
     * HardwareFaultChanged event. Make sure to clear the fault when it is resolved.
     * This method requires that the activeHardwareFaults attribute is activated when the cluster gets initialized.
     *
     * @param faultType The hardware fault to register.
     */
    registerHardwareFault(faultType: GeneralDiagnostics.HardwareFault): void;
    /**
     * Clear a hardware fault. This convenience method updates the activeHardwareFaults attribute and sends out the
     * HardwareFaultChanged event.
     *
     * @param faultType The hardware fault to clear.
     */
    clearHardwareFault(faultType: GeneralDiagnostics.HardwareFault): void;
    /**
     * Register a radio fault. This convenience method updates the activeRadioFaults attribute and sends out the
     * RadioFaultChanged event. Make sure to clear the fault when it is resolved.
     * This method requires that the activeRadioFaults attribute is activated when the cluster gets initialized.
     *
     * @param faultType The radio fault to register.
     */
    registerRadioFault(faultType: GeneralDiagnostics.RadioFault): void;
    /**
     * Clear a radio fault. This convenience method updates the activeRadioFaults attribute and sends out the
     * RadioFaultChanged event.
     *
     * @param faultType The radio fault to clear.
     */
    clearRadioFault(faultType: GeneralDiagnostics.RadioFault): void;
    /**
     * Register a network fault. This convenience method updates the activeNetworkFaults attribute and sends out the
     * NetworkFaultChanged event. Make sure to clear the fault when it is resolved.
     * This method requires that the activeNetworkFaults attribute is activated when the cluster gets initialized.
     *
     * @param faultType The network fault to register.
     */
    registerNetworkFault(faultType: GeneralDiagnostics.NetworkFault): void;
    /**
     * Clear a network fault. This convenience method updates the activeNetworkFaults attribute and sends out the
     * NetworkFaultChanged event.
     *
     * @param faultType The network fault to clear.
     */
    clearNetworkFault(faultType: GeneralDiagnostics.NetworkFault): void;
}
export declare namespace GeneralDiagnosticsServer {
    class Internal {
        /** Last time the total operational hours counter was updated. */
        lastTotalOperationalHoursCounterUpdateTime: number;
        /** Timer to update the total operational hours counter every 5 minutes. */
        lastTotalOperationalHoursTimer: Timer | undefined;
    }
    class State extends Base.State {
        /** Internal counter of the total operational hours, counted in seconds, updated every 5 minutes. */
        totalOperationalHoursCounter: number;
        /** The TestEnableKey set for this device for the test commands. Default means "not enabled"." */
        deviceTestEnableKey: Uint8Array<ArrayBuffer>;
        [Val.properties](endpoint: Endpoint, _session: ValueSupervisor.Session): {
            /**
             * Report uptime
             *
             * This value is not available for subscription so we compute dynamically.
             *
             * As of 1.4 the spec does not specify what should be considered the "start time" for computing uptime.
             * They just say "since the device's last reboot".  This could be from power on, or from when the device
             * is first usable by a user, when it's first available online, etc.
             *
             * The tests however expect uptime to reset after factory reset.  So we consider "time brought online"
             * our boot time.
             */
            readonly upTime: number;
            /**
             * Dynamically calculate the operating Hours from our internal counter. This is ok because the attribute
             * is not send out via subscriptions anyway.
             */
            readonly totalOperationalHours: number;
        };
    }
    const ExtensionInterface: {
        triggerTestEvent: (eventTrigger: number | bigint) => void;
        registerHardwareFault: (current: GeneralDiagnostics.HardwareFault[], previous: GeneralDiagnostics.HardwareFault[]) => void;
        registerRadioFault: (current: GeneralDiagnostics.RadioFault[], previous: GeneralDiagnostics.RadioFault[]) => void;
        registerNetworkFault: (current: GeneralDiagnostics.NetworkFault[], previous: GeneralDiagnostics.NetworkFault[]) => void;
        clearHardwareFault: (faultType: GeneralDiagnostics.HardwareFault) => void;
        clearRadioFault: (faultType: GeneralDiagnostics.RadioFault) => void;
        clearNetworkFault: (faultType: GeneralDiagnostics.NetworkFault) => void;
    };
}
export {};
//# sourceMappingURL=GeneralDiagnosticsServer.d.ts.map