/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { ValueSupervisor } from "#behavior/supervision/ValueSupervisor.js";
import { OperationalCredentials } from "#clusters/operational-credentials";
import { Endpoint } from "#endpoint/Endpoint.js";
import { MaybePromise } from "#general";
import { DeviceCertification, Val } from "#protocol";
import { FabricIndex } from "#types";
import { OperationalCredentialsBehavior } from "./OperationalCredentialsBehavior.js";
/**
 * This is the default server implementation of OperationalCredentialsBehavior.
 *
 * TODO - currently "source of truth" for fabric data is persisted by FabricManager.  If we remove some legacy code
 * paths we can move source of truth to here.  Right now we just sync fabrics with FabricManager.  This sync is only as
 * comprehensive as required by current use cases.  If fabrics are mutated directly on FabricManager then this code will
 * require update.
 */
export declare class OperationalCredentialsServer extends OperationalCredentialsBehavior {
    #private;
    internal: OperationalCredentialsServer.Internal;
    state: OperationalCredentialsServer.State;
    initialize(): MaybePromise;
    attestationRequest({ attestationNonce }: OperationalCredentials.AttestationRequest): Promise<{
        attestationElements: Uint8Array<ArrayBufferLike>;
        attestationSignature: Uint8Array<ArrayBufferLike>;
    }>;
    csrRequest({ csrNonce, isForUpdateNoc }: OperationalCredentials.CsrRequest): Promise<{
        nocsrElements: Uint8Array<ArrayBufferLike>;
        attestationSignature: Uint8Array<ArrayBufferLike>;
    }>;
    certificateChainRequest({ certificateType }: OperationalCredentials.CertificateChainRequest): Promise<{
        certificate: Uint8Array<ArrayBufferLike>;
    }>;
    addNoc({ nocValue, icacValue, ipkValue, caseAdminSubject, adminVendorId, }: OperationalCredentials.AddNocRequest): Promise<OperationalCredentials.NocResponse>;
    updateNoc({ nocValue, icacValue }: OperationalCredentials.UpdateNocRequest): Promise<OperationalCredentials.NocResponse>;
    updateFabricLabel({ label }: OperationalCredentials.UpdateFabricLabelRequest): Promise<{
        statusCode: OperationalCredentials.NodeOperationalCertStatus;
        debugText: string;
        fabricIndex?: undefined;
    } | {
        statusCode: OperationalCredentials.NodeOperationalCertStatus;
        fabricIndex: FabricIndex;
        debugText?: undefined;
    }>;
    removeFabric({ fabricIndex }: OperationalCredentials.RemoveFabricRequest): Promise<{
        statusCode: OperationalCredentials.NodeOperationalCertStatus;
        debugText: string;
        fabricIndex?: undefined;
    } | {
        statusCode: OperationalCredentials.NodeOperationalCertStatus;
        fabricIndex: FabricIndex;
        debugText?: undefined;
    }>;
    addTrustedRootCertificate({ rootCaCertificate, }: OperationalCredentials.AddTrustedRootCertificateRequest): MaybePromise;
    getCertification(): Promise<DeviceCertification>;
}
export declare namespace OperationalCredentialsServer {
    class Internal {
        certification?: DeviceCertification;
        commissionedFabric?: FabricIndex;
    }
    class State extends OperationalCredentialsBehavior.State {
        /**
         * Device certification information.
         *
         * Device certification provides a cryptographic certificate that asserts the official status of a device.
         * Production consumer-facing devices are certified by the CSA.
         *
         * Development devices and those intended for personal use may use a development certificate.  This is the
         * default if you do not provide an official certification in {@link ServerOptions.certification}.
         */
        certification?: DeviceCertification.Definition;
        [Val.properties](_endpoint: Endpoint, session: ValueSupervisor.Session): {
            readonly currentFabricIndex: FabricIndex;
        };
    }
}
//# sourceMappingURL=OperationalCredentialsServer.d.ts.map