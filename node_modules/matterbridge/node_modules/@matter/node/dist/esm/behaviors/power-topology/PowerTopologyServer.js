/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { DescriptorServer } from "#behaviors/descriptor";
import { ElectricalEnergyMeasurementBehavior } from "#behaviors/electrical-energy-measurement";
import { ElectricalPowerMeasurementBehavior } from "#behaviors/electrical-power-measurement";
import { PowerTopology } from "#clusters/power-topology";
import { ImplementationError } from "#general";
import { ClusterType } from "#types";
import { PowerTopologyBehavior } from "./PowerTopologyBehavior.js";
const PowerTopologyBase = PowerTopologyBehavior.with(
  PowerTopology.Feature.SetTopology,
  PowerTopology.Feature.DynamicPowerFlow
);
class PowerTopologyBaseServer extends PowerTopologyBase {
  async initialize() {
    if (this.agent.has(ElectricalPowerMeasurementBehavior) || this.agent.has(ElectricalEnergyMeasurementBehavior)) {
      (await this.agent.load(DescriptorServer)).addDeviceTypes("ElectricalSensor");
    }
    if (this.state.activeEndpoints !== void 0) {
      this.#assertActiveEndpointsAllowed(this.state.activeEndpoints);
      this.reactTo(this.events.activeEndpoints$Changing, this.#assertActiveEndpointsAllowed);
    }
  }
  #assertActiveEndpointsAllowed(list) {
    const availableEndpoints = this.state.availableEndpoints;
    list.forEach((endpoint) => {
      if (!availableEndpoints.includes(endpoint)) {
        throw new ImplementationError(`Endpoint ${endpoint} is not in the list of available endpoints`);
      }
    });
  }
}
class PowerTopologyServer extends PowerTopologyBaseServer.for(ClusterType(PowerTopology.Base)) {
}
export {
  PowerTopologyBaseServer,
  PowerTopologyServer
};
//# sourceMappingURL=PowerTopologyServer.js.map
