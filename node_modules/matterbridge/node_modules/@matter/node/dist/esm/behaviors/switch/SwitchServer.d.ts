/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { ActionContext } from "#behavior/context/ActionContext.js";
import { Switch } from "#clusters/switch";
import { MaybePromise, Observable, Timer } from "#general";
import { ClusterType } from "#types";
declare const SwitchServerBase: import("../../index.js").ClusterBehavior.Type<import("#types").ClusterComposer.WithFeatures<Switch.Complete, readonly [Switch.Feature.LatchingSwitch, Switch.Feature.MomentarySwitch, Switch.Feature.MomentarySwitchRelease, Switch.Feature.MomentarySwitchLongPress, Switch.Feature.MomentarySwitchMultiPress, Switch.Feature.ActionSwitch]>, import("../../index.js").ClusterBehavior.Type<Switch.Complete, import("../../index.js").ClusterBehavior.Type<ClusterType.Of<{
    readonly id: 59;
    readonly name: "Switch";
    readonly revision: 2;
    readonly features: {
        readonly latchingSwitch: import("#types").BitFlag;
        readonly momentarySwitch: import("#types").BitFlag;
        readonly momentarySwitchRelease: import("#types").BitFlag;
        readonly momentarySwitchLongPress: import("#types").BitFlag;
        readonly momentarySwitchMultiPress: import("#types").BitFlag;
        readonly actionSwitch: import("#types").BitFlag;
    };
    readonly attributes: {
        readonly numberOfPositions: import("#types").FixedAttribute<number, any>;
        readonly currentPosition: import("#types").Attribute<number, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly momentarySwitchMultiPress: true;
        };
        readonly component: {
            readonly attributes: {
                readonly multiPressMax: import("#types").FixedAttribute<number, any>;
            };
            readonly events: {
                readonly multiPressComplete: import("#types").Event<import("#types").TypeFromFields<{
                    previousPosition: import("#types").FieldType<number>;
                    totalNumberOfPressesCounted: import("#types").FieldType<number>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly latchingSwitch: true;
        };
        readonly component: {
            readonly events: {
                readonly switchLatched: import("#types").Event<import("#types").TypeFromFields<{
                    newPosition: import("#types").FieldType<number>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly momentarySwitch: true;
        };
        readonly component: {
            readonly events: {
                readonly initialPress: import("#types").Event<import("#types").TypeFromFields<{
                    newPosition: import("#types").FieldType<number>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly momentarySwitchLongPress: true;
        };
        readonly component: {
            readonly events: {
                readonly longPress: import("#types").Event<import("#types").TypeFromFields<{
                    newPosition: import("#types").FieldType<number>;
                }>, any>;
                readonly longRelease: import("#types").Event<import("#types").TypeFromFields<{
                    previousPosition: import("#types").FieldType<number>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly momentarySwitchRelease: true;
        };
        readonly component: {
            readonly events: {
                readonly shortRelease: import("#types").Event<import("#types").TypeFromFields<{
                    previousPosition: import("#types").FieldType<number>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly momentarySwitchMultiPress: true;
            readonly actionSwitch: false;
        };
        readonly component: {
            readonly events: {
                readonly multiPressOngoing: import("#types").Event<import("#types").TypeFromFields<{
                    newPosition: import("#types").FieldType<number>;
                    currentNumberOfPressesCounted: import("#types").FieldType<number>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly momentarySwitchRelease: true;
            readonly momentarySwitch: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly momentarySwitchRelease: true;
            readonly actionSwitch: true;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly momentarySwitchLongPress: true;
            readonly momentarySwitch: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly momentarySwitchLongPress: true;
            readonly momentarySwitchRelease: false;
            readonly actionSwitch: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly actionSwitch: true;
            readonly momentarySwitchMultiPress: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly actionSwitch: false;
            readonly momentarySwitchMultiPress: true;
            readonly momentarySwitch: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly actionSwitch: false;
            readonly momentarySwitchMultiPress: true;
            readonly momentarySwitchRelease: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly actionSwitch: true;
            readonly momentarySwitch: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly latchingSwitch: true;
            readonly momentarySwitch: true;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly latchingSwitch: false;
            readonly momentarySwitch: false;
        };
        readonly component: false;
    }];
}>, typeof import("../../index.js").ClusterBehavior, {
    components: never[];
}>, {
    components: never[];
}>, {
    components: never[];
}>;
/**
 * This is the default server implementation of {@link SwitchBehavior}.
 *
 * This implementation includes all features of {@link Switch.Cluster} and implements all mandatory commands.
 * You should use {@link SwitchServer.with} to specialize the class for the features your implementation
 * supports.
 *
 * To support all features and events the implementation adds some custom state attributes that can - or are required
 * to - be used. These are:
 * * `rawPosition` - The raw position of the switch. This is the position as reported by the device and is not yet
 *  debounced. If the position is already debounced, just set the `currentPosition` attribute. The debouncing uses the
 *  `debounceDelay` attribute value as timeframe in milliseconds and sets the `currentPosition` attribute when the value
 *  is stable for this timeframe.
 * * `debounceDelay` - The timeframe in milliseconds to wait until a newly reported position is considered stable.
 * * `longPressDelay` - The timeframe in milliseconds to wait until a position is considered "long" pressed. This
 *  attribute is REQUIRED if the device supports the Momentary Switch LongPress (MSL) feature.
 * * `multiPressDelay` - The timeframe in milliseconds starting with a stable release to detect multi-presses. This
 *  attribute is REQUIRED if the device supports the Momentary Switch MultiPress (MSM) feature.
 * * `momentaryNeutralPosition` - The number of the position considered as the neutral position for the momentary switch.
 *  This defaults to position 0 but can be changed by settings this attribute. it is available as soon as the Momentary
 *  Switch (MS) feature is used.
 */
export declare class SwitchBaseServer extends SwitchServerBase {
    #private;
    protected internal: SwitchBaseServer.Internal;
    state: SwitchBaseServer.State;
    events: SwitchBaseServer.Events;
    schema: import("#model").Schema;
    initialize(): MaybePromise;
    /** Method to reset the state of the Switch to start a clean new cycle. Mainly relevant for automated testing. */
    resetState(): void;
    [Symbol.asyncDispose](): Promise<void>;
}
export declare namespace SwitchBaseServer {
    class Internal {
        /** Timer to debounce the raw position. */
        debounceTimer?: Timer;
        /** Timer to detect a long press. */
        longPressTimer?: Timer;
        /** Timer to detect multi presses. */
        multiPressTimer?: Timer;
        /** Counter to count the number of presses. */
        currentNumberOfPressesCounter: number;
        /** Indicator if the multi press sequence was aborted. */
        multiPressReportingAborted: boolean;
        /** Position previously reported in events. */
        previouslyReportedPosition: number;
        /** Position of the previous multi press. */
        previousMultiPressPosition: number | null;
        /** Position of the current long press. */
        currentLongPressPosition: number | null;
        /** Flag to indicate if the current press is a long press. */
        currentIsLongPress: boolean;
        /** Position of the current unstable position which is debounced */
        currentUnstablePosition: number;
    }
    class State extends SwitchServerBase.State {
        /** Raw position of the switch. Set this to debounce the value. */
        rawPosition: number;
        /**
         * Debounce Delay to wait until a newly reported raw position is considered stable and written to the
         * currentPosition attribue.
         */
        debounceDelay: number;
        /** Time to wait until a value is considered "long" pressed */
        longPressDelay: number;
        /** Timeframe starting with a stable release to detect multi-presses. */
        multiPressDelay: number;
        /** Number of the position considered as the neutral position for the momentary switch. */
        momentaryNeutralPosition: number;
    }
    /** Enhance the relevant events for rawPosition attribute. */
    class Events extends SwitchServerBase.Events {
        rawPosition$Changed: Observable<[value: number, oldValue: number, context?: ActionContext | undefined], void>;
        rawPosition$Changing: Observable<[value: number, oldValue: number, context?: ActionContext | undefined], void>;
    }
}
declare const SwitchServer_base: import("../../index.js").ClusterBehavior.Type<ClusterType.Of<{
    readonly id: 59;
    readonly name: "Switch";
    readonly revision: 2;
    readonly features: {
        readonly latchingSwitch: import("#types").BitFlag;
        readonly momentarySwitch: import("#types").BitFlag;
        readonly momentarySwitchRelease: import("#types").BitFlag;
        readonly momentarySwitchLongPress: import("#types").BitFlag;
        readonly momentarySwitchMultiPress: import("#types").BitFlag;
        readonly actionSwitch: import("#types").BitFlag;
    };
    readonly attributes: {
        readonly numberOfPositions: import("#types").FixedAttribute<number, any>;
        readonly currentPosition: import("#types").Attribute<number, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly momentarySwitchMultiPress: true;
        };
        readonly component: {
            readonly attributes: {
                readonly multiPressMax: import("#types").FixedAttribute<number, any>;
            };
            readonly events: {
                readonly multiPressComplete: import("#types").Event<import("#types").TypeFromFields<{
                    previousPosition: import("#types").FieldType<number>;
                    totalNumberOfPressesCounted: import("#types").FieldType<number>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly latchingSwitch: true;
        };
        readonly component: {
            readonly events: {
                readonly switchLatched: import("#types").Event<import("#types").TypeFromFields<{
                    newPosition: import("#types").FieldType<number>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly momentarySwitch: true;
        };
        readonly component: {
            readonly events: {
                readonly initialPress: import("#types").Event<import("#types").TypeFromFields<{
                    newPosition: import("#types").FieldType<number>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly momentarySwitchLongPress: true;
        };
        readonly component: {
            readonly events: {
                readonly longPress: import("#types").Event<import("#types").TypeFromFields<{
                    newPosition: import("#types").FieldType<number>;
                }>, any>;
                readonly longRelease: import("#types").Event<import("#types").TypeFromFields<{
                    previousPosition: import("#types").FieldType<number>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly momentarySwitchRelease: true;
        };
        readonly component: {
            readonly events: {
                readonly shortRelease: import("#types").Event<import("#types").TypeFromFields<{
                    previousPosition: import("#types").FieldType<number>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly momentarySwitchMultiPress: true;
            readonly actionSwitch: false;
        };
        readonly component: {
            readonly events: {
                readonly multiPressOngoing: import("#types").Event<import("#types").TypeFromFields<{
                    newPosition: import("#types").FieldType<number>;
                    currentNumberOfPressesCounted: import("#types").FieldType<number>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly momentarySwitchRelease: true;
            readonly momentarySwitch: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly momentarySwitchRelease: true;
            readonly actionSwitch: true;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly momentarySwitchLongPress: true;
            readonly momentarySwitch: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly momentarySwitchLongPress: true;
            readonly momentarySwitchRelease: false;
            readonly actionSwitch: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly actionSwitch: true;
            readonly momentarySwitchMultiPress: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly actionSwitch: false;
            readonly momentarySwitchMultiPress: true;
            readonly momentarySwitch: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly actionSwitch: false;
            readonly momentarySwitchMultiPress: true;
            readonly momentarySwitchRelease: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly actionSwitch: true;
            readonly momentarySwitch: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly latchingSwitch: true;
            readonly momentarySwitch: true;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly latchingSwitch: false;
            readonly momentarySwitch: false;
        };
        readonly component: false;
    }];
}>, typeof SwitchBaseServer, {
    components: never[];
}>;
export declare class SwitchServer extends SwitchServer_base {
}
export {};
//# sourceMappingURL=SwitchServer.d.ts.map