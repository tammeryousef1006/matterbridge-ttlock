/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Switch } from "#clusters/switch";
import { Logger, Observable, Time } from "#general";
import { FieldElement } from "#model";
import { ClusterType, StatusCode, StatusResponseError } from "#types";
import { SwitchBehavior } from "./SwitchBehavior.js";
const logger = Logger.get("SwitchServer");
const SwitchServerBase = SwitchBehavior.for(Switch.Complete).with(
  Switch.Feature.LatchingSwitch,
  Switch.Feature.MomentarySwitch,
  Switch.Feature.MomentarySwitchRelease,
  Switch.Feature.MomentarySwitchLongPress,
  Switch.Feature.MomentarySwitchMultiPress,
  Switch.Feature.ActionSwitch
);
const schema = SwitchServerBase.schema.extend({
  children: [
    FieldElement({ name: "longPressDelay", type: "uint32", quality: "M", conformance: "MSL" }),
    FieldElement({ name: "multiPressDelay", type: "uint32", quality: "M", conformance: "MSM" }),
    FieldElement({ name: "momentaryNeutralPosition", type: "uint8", quality: "O", conformance: "MS" })
  ]
});
class SwitchBaseServer extends SwitchServerBase {
  schema = schema;
  initialize() {
    this.state.rawPosition = this.state.currentPosition;
    this.internal.currentUnstablePosition = this.state.currentPosition;
    this.internal.previouslyReportedPosition = this.state.currentPosition;
    this.reactTo(this.events.rawPosition$Changing, this.#assertPositionInRange);
    this.reactTo(this.events.currentPosition$Changing, this.#assertPositionInRange);
    this.reactTo(this.events.rawPosition$Changed, this.#debounceRawPosition);
    this.reactTo(this.events.currentPosition$Changed, this.#handleSwitchPositionChange);
  }
  /** Method to reset the state of the Switch to start a clean new cycle. Mainly relevant for automated testing. */
  resetState() {
    const neutralPosition = this.state.momentaryNeutralPosition;
    this.internal.currentUnstablePosition = neutralPosition;
    this.internal.previouslyReportedPosition = neutralPosition;
    this.internal.multiPressReportingAborted = false;
    this.internal.currentNumberOfPressesCounter = 1;
    this.internal.previousMultiPressPosition = null;
    this.internal.currentLongPressPosition = null;
    this.internal.currentIsLongPress = false;
    this.internal.multiPressTimer?.stop();
    this.internal.longPressTimer?.stop();
    logger.info("State of Switch got reset");
  }
  // TODO remove when Validator logic can assess that with 1.3 introduction
  #assertPositionInRange(position) {
    if (position < 0 || position >= this.state.numberOfPositions) {
      throw new StatusResponseError(`Position ${position} invalid`, StatusCode.ConstraintError);
    }
  }
  #debounceRawPosition(newPosition) {
    if (this.state.debounceDelay !== 0) {
      this.internal.debounceTimer?.stop();
      this.internal.currentUnstablePosition = newPosition;
      this.internal.debounceTimer = Time.getTimer(
        "debounce",
        this.state.debounceDelay,
        this.callback(this.#setCurrentPositionAfterDebounce, { lock: true })
      ).start();
    } else {
      this.state.currentPosition = newPosition;
    }
  }
  #setCurrentPositionAfterDebounce() {
    this.state.currentPosition = this.internal.currentUnstablePosition;
  }
  #handleSwitchPositionChange(newPosition) {
    if (this.features.latchingSwitch) {
      this.events.switchLatched?.emit({ newPosition }, this.context);
      return;
    }
    let pressSequenceFinished = false;
    if (newPosition !== this.state.momentaryNeutralPosition && !this.internal.multiPressReportingAborted && (!this.features.actionSwitch || !this.internal.multiPressTimer?.isRunning)) {
      this.events.initialPress?.emit({ newPosition }, this.context);
    }
    if (this.features.momentarySwitchLongPress) {
      if (newPosition === this.state.momentaryNeutralPosition) {
        if (this.internal.longPressTimer?.isRunning) {
          if (!this.features.actionSwitch) {
            this.events.shortRelease?.emit(
              { previousPosition: this.internal.previouslyReportedPosition },
              this.context
            );
          }
        } else if (this.internal.currentIsLongPress) {
          this.events.longRelease?.emit(
            { previousPosition: this.internal.previouslyReportedPosition },
            this.context
          );
          this.internal.multiPressTimer?.stop();
          pressSequenceFinished = true;
        }
      }
      this.internal.longPressTimer?.stop();
      this.internal.currentIsLongPress = false;
      this.internal.currentLongPressPosition = null;
      if (newPosition !== this.state.momentaryNeutralPosition) {
        this.internal.currentLongPressPosition = newPosition;
        this.internal.longPressTimer = Time.getTimer(
          "longPress",
          this.state.longPressDelay,
          this.callback(this.#handleLongPress, { lock: true })
        ).start();
      }
    } else if (this.features.momentarySwitchRelease && newPosition === this.state.momentaryNeutralPosition) {
      this.events.shortRelease?.emit(
        { previousPosition: this.internal.previouslyReportedPosition },
        this.context
      );
    }
    if (this.features.momentarySwitchMultiPress) {
      if (this.internal.multiPressTimer?.isRunning && newPosition !== this.state.momentaryNeutralPosition && !this.internal.multiPressReportingAborted && !this.internal.currentIsLongPress && !pressSequenceFinished) {
        this.internal.currentNumberOfPressesCounter++;
        if (!this.features.actionSwitch) {
          this.events.multiPressOngoing?.emit(
            {
              newPosition,
              currentNumberOfPressesCounted: this.internal.currentNumberOfPressesCounter
            },
            this.context
          );
        }
        if (this.state.multiPressMax !== void 0 && this.internal.currentNumberOfPressesCounter > this.state.multiPressMax) {
          this.internal.multiPressReportingAborted = true;
          this.events.multiPressComplete?.emit(
            {
              previousPosition: newPosition,
              totalNumberOfPressesCounted: 0
            },
            this.context
          );
          pressSequenceFinished = true;
        }
      }
      this.internal.multiPressTimer?.stop();
      if (!pressSequenceFinished) {
        this.internal.multiPressTimer = Time.getTimer(
          "multiPress",
          this.state.multiPressDelay,
          this.callback(this.#handleMultiPressComplete, { lock: true })
        ).start();
      }
      if (this.internal.previouslyReportedPosition !== this.state.momentaryNeutralPosition) {
        this.internal.previousMultiPressPosition = this.internal.previouslyReportedPosition;
      }
    }
    this.internal.previouslyReportedPosition = newPosition;
  }
  // Method is called by a timer, so no change to the position for longPressDelay
  #handleLongPress() {
    if (this.internal.currentLongPressPosition === null || this.internal.currentNumberOfPressesCounter > 1) {
      return;
    }
    this.events.longPress?.emit({ newPosition: this.internal.currentLongPressPosition }, this.context);
    this.internal.currentIsLongPress = true;
    this.internal.multiPressTimer?.stop();
  }
  #handleMultiPressComplete() {
    if (this.internal.previousMultiPressPosition === null || this.internal.longPressTimer?.isRunning) {
      return;
    }
    if (!this.internal.multiPressReportingAborted) {
      this.events.multiPressComplete?.emit(
        {
          previousPosition: this.internal.previousMultiPressPosition,
          totalNumberOfPressesCounted: this.internal.currentNumberOfPressesCounter
        },
        this.context
      );
    }
    this.internal.currentNumberOfPressesCounter = 1;
    this.internal.multiPressReportingAborted = false;
    this.internal.previousMultiPressPosition = null;
  }
  async [Symbol.asyncDispose]() {
    this.internal.debounceTimer?.stop();
    this.internal.longPressTimer?.stop();
    this.internal.multiPressTimer?.stop();
    await super[Symbol.asyncDispose]?.();
  }
}
((SwitchBaseServer2) => {
  class Internal {
    /** Timer to debounce the raw position. */
    debounceTimer;
    /** Timer to detect a long press. */
    longPressTimer;
    /** Timer to detect multi presses. */
    multiPressTimer;
    /** Counter to count the number of presses. */
    currentNumberOfPressesCounter = 1;
    /** Indicator if the multi press sequence was aborted. */
    multiPressReportingAborted = false;
    /** Position previously reported in events. */
    previouslyReportedPosition = 0;
    /** Position of the previous multi press. */
    previousMultiPressPosition = null;
    /** Position of the current long press. */
    currentLongPressPosition = null;
    /** Flag to indicate if the current press is a long press. */
    currentIsLongPress = false;
    /** Position of the current unstable position which is debounced */
    currentUnstablePosition = 0;
  }
  SwitchBaseServer2.Internal = Internal;
  class State extends SwitchServerBase.State {
    /** Raw position of the switch. Set this to debounce the value. */
    rawPosition = 0;
    /**
     * Debounce Delay to wait until a newly reported raw position is considered stable and written to the
     * currentPosition attribue.
     */
    debounceDelay = 0;
    /** Time to wait until a value is considered "long" pressed */
    longPressDelay = 0;
    /** Timeframe starting with a stable release to detect multi-presses. */
    multiPressDelay = 0;
    /** Number of the position considered as the neutral position for the momentary switch. */
    momentaryNeutralPosition = 0;
  }
  SwitchBaseServer2.State = State;
  class Events extends SwitchServerBase.Events {
    rawPosition$Changed = Observable();
    rawPosition$Changing = Observable();
  }
  SwitchBaseServer2.Events = Events;
})(SwitchBaseServer || (SwitchBaseServer = {}));
class SwitchServer extends SwitchBaseServer.for(ClusterType(Switch.Base)) {
}
export {
  SwitchBaseServer,
  SwitchServer
};
//# sourceMappingURL=SwitchServer.js.map
