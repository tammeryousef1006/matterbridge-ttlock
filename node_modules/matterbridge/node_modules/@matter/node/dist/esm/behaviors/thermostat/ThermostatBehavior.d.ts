/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
/*** THIS FILE IS GENERATED, DO NOT EDIT ***/
import { Thermostat } from "#clusters/thermostat";
import { ClusterBehavior } from "../../behavior/cluster/ClusterBehavior.js";
import { ThermostatInterface } from "./ThermostatInterface.js";
import { ClusterType } from "#types";
/**
 * ThermostatBehavior is the base class for objects that support interaction with {@link Thermostat.Cluster}.
 *
 * Thermostat.Cluster requires you to enable one or more optional features. You can do so using
 * {@link ThermostatBehavior.with}.
 */
export declare const ThermostatBehavior: ClusterBehavior.Type<ClusterType.Of<{
    readonly id: 513;
    readonly name: "Thermostat";
    readonly revision: 8;
    readonly features: {
        readonly heating: import("#types").BitFlag;
        readonly cooling: import("#types").BitFlag;
        readonly occupancy: import("#types").BitFlag;
        readonly scheduleConfiguration: import("#types").BitFlag;
        readonly setback: import("#types").BitFlag;
        readonly autoMode: import("#types").BitFlag;
        readonly localTemperatureNotExposed: import("#types").BitFlag;
        readonly matterScheduleConfiguration: import("#types").BitFlag;
        readonly presets: import("#types").BitFlag;
    };
    readonly attributes: {
        readonly localTemperature: import("#types").Attribute<number | null, any>;
        readonly outdoorTemperature: import("#types").OptionalAttribute<number | null, any>;
        readonly hvacSystemTypeConfiguration: import("#types").OptionalWritableAttribute<import("#types").TypeFromPartialBitSchema<{
            coolingStage: import("#types").BitField;
            heatingStage: import("#types").BitField;
            heatingIsHeatPump: import("#types").BitFlag;
            heatingUsesFuel: import("#types").BitFlag;
        }>, any>;
        readonly remoteSensing: import("#types").OptionalWritableAttribute<import("#types").TypeFromPartialBitSchema<{
            localTemperature: import("#types").BitFlag;
            outdoorTemperature: import("#types").BitFlag;
            occupancy: import("#types").BitFlag;
        }>, any>;
        readonly controlSequenceOfOperation: import("#types").WritableAttribute<Thermostat.ControlSequenceOfOperation, any>;
        readonly systemMode: import("#types").WritableAttribute<Thermostat.SystemMode, any>;
        readonly temperatureSetpointHold: import("#types").OptionalWritableAttribute<Thermostat.TemperatureSetpointHold, any>;
        readonly temperatureSetpointHoldDuration: import("#types").OptionalWritableAttribute<number | null, any>;
        readonly thermostatProgrammingOperationMode: import("#types").OptionalWritableAttribute<import("#types").TypeFromPartialBitSchema<{
            scheduleActive: import("#types").BitFlag;
            autoRecovery: import("#types").BitFlag;
            economy: import("#types").BitFlag;
        }>, any>;
        readonly thermostatRunningState: import("#types").OptionalAttribute<import("#types").TypeFromPartialBitSchema<{
            heat: import("#types").BitFlag;
            cool: import("#types").BitFlag;
            fan: import("#types").BitFlag;
            heatStage2: import("#types").BitFlag;
            coolStage2: import("#types").BitFlag;
            fanStage2: import("#types").BitFlag;
            fanStage3: import("#types").BitFlag;
        }>, any>;
        readonly setpointChangeSource: import("#types").OptionalAttribute<Thermostat.SetpointChangeSource, any>;
        readonly setpointChangeAmount: import("#types").OptionalAttribute<number | null, any>;
        readonly setpointChangeSourceTimestamp: import("#types").OptionalAttribute<number, any>;
        readonly emergencyHeatDelta: import("#types").OptionalWritableAttribute<number, any>;
        readonly acType: import("#types").OptionalWritableAttribute<Thermostat.AcType, any>;
        readonly acCapacity: import("#types").OptionalWritableAttribute<number, any>;
        readonly acRefrigerantType: import("#types").OptionalWritableAttribute<Thermostat.AcRefrigerantType, any>;
        readonly acCompressorType: import("#types").OptionalWritableAttribute<Thermostat.AcCompressorType, any>;
        readonly acErrorCode: import("#types").OptionalWritableAttribute<import("#types").TypeFromPartialBitSchema<{
            compressorFail: import("#types").BitFlag;
            roomSensorFail: import("#types").BitFlag;
            outdoorSensorFail: import("#types").BitFlag;
            coilSensorFail: import("#types").BitFlag;
            fanFail: import("#types").BitFlag;
        }>, any>;
        readonly acLouverPosition: import("#types").OptionalWritableAttribute<Thermostat.AcLouverPosition, any>;
        readonly acCoilTemperature: import("#types").OptionalAttribute<number | null, any>;
        readonly acCapacityFormat: import("#types").OptionalWritableAttribute<Thermostat.AcCapacityFormat, any>;
        readonly setpointHoldExpiryTimestamp: import("#types").OptionalAttribute<number | null, any>;
    };
    readonly commands: {
        readonly setpointRaiseLower: import("#types").Command<import("#types").TypeFromFields<{
            mode: import("#types").FieldType<Thermostat.SetpointRaiseLowerMode>;
            amount: import("#types").FieldType<number>;
        }>, void, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly occupancy: true;
        };
        readonly component: {
            readonly attributes: {
                readonly occupancy: import("#types").Attribute<import("#types").TypeFromPartialBitSchema<{
                    occupied: import("#types").BitFlag;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly heating: true;
        };
        readonly component: {
            readonly attributes: {
                readonly absMinHeatSetpointLimit: import("#types").OptionalFixedAttribute<number, any>;
                readonly absMaxHeatSetpointLimit: import("#types").OptionalFixedAttribute<number, any>;
                readonly piHeatingDemand: import("#types").OptionalAttribute<number, any>;
                readonly occupiedHeatingSetpoint: import("#types").WritableAttribute<number, any>;
                readonly minHeatSetpointLimit: import("#types").OptionalWritableAttribute<number, any>;
                readonly maxHeatSetpointLimit: import("#types").OptionalWritableAttribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly cooling: true;
        };
        readonly component: {
            readonly attributes: {
                readonly absMinCoolSetpointLimit: import("#types").OptionalFixedAttribute<number, any>;
                readonly absMaxCoolSetpointLimit: import("#types").OptionalFixedAttribute<number, any>;
                readonly piCoolingDemand: import("#types").OptionalAttribute<number, any>;
                readonly occupiedCoolingSetpoint: import("#types").WritableAttribute<number, any>;
                readonly minCoolSetpointLimit: import("#types").OptionalWritableAttribute<number, any>;
                readonly maxCoolSetpointLimit: import("#types").OptionalWritableAttribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly localTemperatureNotExposed: false;
        };
        readonly component: {
            readonly attributes: {
                readonly localTemperatureCalibration: import("#types").OptionalWritableAttribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly cooling: true;
            readonly occupancy: true;
        };
        readonly component: {
            readonly attributes: {
                readonly unoccupiedCoolingSetpoint: import("#types").WritableAttribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly heating: true;
            readonly occupancy: true;
        };
        readonly component: {
            readonly attributes: {
                readonly unoccupiedHeatingSetpoint: import("#types").WritableAttribute<number, any>;
            };
        };
    }, {
        readonly flags: {
            readonly autoMode: true;
        };
        readonly component: {
            readonly attributes: {
                readonly minSetpointDeadBand: import("#types").WritableAttribute<number, any>;
                readonly thermostatRunningMode: import("#types").OptionalAttribute<Thermostat.ThermostatRunningMode, any>;
            };
        };
    }, {
        readonly flags: {
            readonly scheduleConfiguration: true;
        };
        readonly component: {
            readonly attributes: {
                readonly startOfWeek: import("#types").FixedAttribute<Thermostat.StartOfWeek, any>;
                readonly numberOfWeeklyTransitions: import("#types").FixedAttribute<number, any>;
                readonly numberOfDailyTransitions: import("#types").FixedAttribute<number, any>;
            };
            readonly commands: {
                readonly setWeeklySchedule: import("#types").Command<import("#types").TypeFromFields<{
                    numberOfTransitionsForSequence: import("#types").FieldType<number>;
                    dayOfWeekForSequence: import("#types").FieldType<import("#types").TypeFromPartialBitSchema<{
                        sunday: import("#types").BitFlag;
                        monday: import("#types").BitFlag;
                        tuesday: import("#types").BitFlag;
                        wednesday: import("#types").BitFlag;
                        thursday: import("#types").BitFlag;
                        friday: import("#types").BitFlag;
                        saturday: import("#types").BitFlag;
                        away: import("#types").BitFlag;
                    }>>;
                    modeForSequence: import("#types").FieldType<import("#types").TypeFromPartialBitSchema<{
                        heatSetpointPresent: import("#types").BitFlag;
                        coolSetpointPresent: import("#types").BitFlag;
                    }>>;
                    transitions: import("#types").FieldType<import("#types").TypeFromFields<{
                        transitionTime: import("#types").FieldType<number>;
                        heatSetpoint: import("#types").FieldType<number | null>;
                        coolSetpoint: import("#types").FieldType<number | null>;
                    }>[]>;
                }>, void, any>;
                readonly getWeeklySchedule: import("#types").Command<import("#types").TypeFromFields<{
                    daysToReturn: import("#types").FieldType<import("#types").TypeFromPartialBitSchema<{
                        sunday: import("#types").BitFlag;
                        monday: import("#types").BitFlag;
                        tuesday: import("#types").BitFlag;
                        wednesday: import("#types").BitFlag;
                        thursday: import("#types").BitFlag;
                        friday: import("#types").BitFlag;
                        saturday: import("#types").BitFlag;
                        away: import("#types").BitFlag;
                    }>>;
                    modeToReturn: import("#types").FieldType<import("#types").TypeFromPartialBitSchema<{
                        heatSetpointPresent: import("#types").BitFlag;
                        coolSetpointPresent: import("#types").BitFlag;
                    }>>;
                }>, import("#types").TypeFromFields<{
                    numberOfTransitionsForSequence: import("#types").FieldType<number>;
                    dayOfWeekForSequence: import("#types").FieldType<import("#types").TypeFromPartialBitSchema<{
                        sunday: import("#types").BitFlag;
                        monday: import("#types").BitFlag;
                        tuesday: import("#types").BitFlag;
                        wednesday: import("#types").BitFlag;
                        thursday: import("#types").BitFlag;
                        friday: import("#types").BitFlag;
                        saturday: import("#types").BitFlag;
                        away: import("#types").BitFlag;
                    }>>;
                    modeForSequence: import("#types").FieldType<import("#types").TypeFromPartialBitSchema<{
                        heatSetpointPresent: import("#types").BitFlag;
                        coolSetpointPresent: import("#types").BitFlag;
                    }>>;
                    transitions: import("#types").FieldType<import("#types").TypeFromFields<{
                        transitionTime: import("#types").FieldType<number>;
                        heatSetpoint: import("#types").FieldType<number | null>;
                        coolSetpoint: import("#types").FieldType<number | null>;
                    }>[]>;
                }>, any>;
                readonly clearWeeklySchedule: import("#types").Command<void, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly setback: true;
        };
        readonly component: {
            readonly attributes: {
                readonly occupiedSetback: import("#types").WritableAttribute<number | null, any>;
                readonly occupiedSetbackMin: import("#types").FixedAttribute<number | null, any>;
                readonly occupiedSetbackMax: import("#types").FixedAttribute<number | null, any>;
            };
        };
    }, {
        readonly flags: {
            readonly setback: true;
            readonly occupancy: true;
        };
        readonly component: {
            readonly attributes: {
                readonly unoccupiedSetback: import("#types").WritableAttribute<number | null, any>;
                readonly unoccupiedSetbackMin: import("#types").FixedAttribute<number | null, any>;
                readonly unoccupiedSetbackMax: import("#types").FixedAttribute<number | null, any>;
            };
        };
    }, {
        readonly flags: {
            readonly presets: true;
        };
        readonly component: {
            readonly attributes: {
                readonly presetTypes: import("#types").FixedAttribute<import("#types").TypeFromFields<{
                    presetScenario: import("#types").FieldType<Thermostat.PresetScenario>;
                    numberOfPresets: import("#types").FieldType<number>;
                    presetTypeFeatures: import("#types").FieldType<import("#types").TypeFromPartialBitSchema<{
                        automatic: import("#types").BitFlag;
                        supportsNames: import("#types").BitFlag;
                    }>>;
                }>[], any>;
                readonly numberOfPresets: import("#types").FixedAttribute<number, any>;
                readonly activePresetHandle: import("#types").Attribute<Uint8Array<ArrayBufferLike> | null, any>;
                readonly presets: import("#types").WritableAttribute<import("#types").TypeFromFields<{
                    presetHandle: import("#types").FieldType<Uint8Array<ArrayBufferLike> | null>;
                    presetScenario: import("#types").FieldType<Thermostat.PresetScenario>;
                    name: import("#types").OptionalFieldType<string | null>;
                    coolingSetpoint: import("#types").OptionalFieldType<number>;
                    heatingSetpoint: import("#types").OptionalFieldType<number>;
                    builtIn: import("#types").FieldType<boolean | null>;
                }>[], any>;
            };
            readonly commands: {
                readonly setActivePresetRequest: import("#types").Command<import("#types").TypeFromFields<{
                    presetHandle: import("#types").FieldType<Uint8Array<ArrayBufferLike> | null>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly matterScheduleConfiguration: true;
        };
        readonly component: {
            readonly attributes: {
                readonly scheduleTypes: import("#types").FixedAttribute<import("#types").TypeFromFields<{
                    systemMode: import("#types").FieldType<Thermostat.SystemMode>;
                    numberOfSchedules: import("#types").FieldType<number>;
                    scheduleTypeFeatures: import("#types").FieldType<import("#types").TypeFromPartialBitSchema<{
                        supportsPresets: import("#types").BitFlag;
                        supportsSetpoints: import("#types").BitFlag;
                        supportsNames: import("#types").BitFlag;
                        supportsOff: import("#types").BitFlag;
                    }>>;
                }>[], any>;
                readonly numberOfSchedules: import("#types").FixedAttribute<number, any>;
                readonly numberOfScheduleTransitions: import("#types").FixedAttribute<number, any>;
                readonly numberOfScheduleTransitionPerDay: import("#types").FixedAttribute<number | null, any>;
                readonly activeScheduleHandle: import("#types").Attribute<Uint8Array<ArrayBufferLike> | null, any>;
                readonly schedules: import("#types").WritableAttribute<import("#types").TypeFromFields<{
                    scheduleHandle: import("#types").FieldType<Uint8Array<ArrayBufferLike> | null>;
                    systemMode: import("#types").FieldType<Thermostat.SystemMode>;
                    name: import("#types").OptionalFieldType<string>;
                    presetHandle: import("#types").OptionalFieldType<Uint8Array<ArrayBufferLike>>;
                    transitions: import("#types").FieldType<import("#types").TypeFromFields<{
                        dayOfWeek: import("#types").FieldType<import("#types").TypeFromPartialBitSchema<{
                            sunday: import("#types").BitFlag;
                            monday: import("#types").BitFlag;
                            tuesday: import("#types").BitFlag;
                            wednesday: import("#types").BitFlag;
                            thursday: import("#types").BitFlag;
                            friday: import("#types").BitFlag;
                            saturday: import("#types").BitFlag;
                            away: import("#types").BitFlag;
                        }>>;
                        transitionTime: import("#types").FieldType<number>;
                        presetHandle: import("#types").OptionalFieldType<Uint8Array<ArrayBufferLike>>;
                        systemMode: import("#types").OptionalFieldType<Thermostat.SystemMode>;
                        coolingSetpoint: import("#types").OptionalFieldType<number>;
                        heatingSetpoint: import("#types").OptionalFieldType<number>;
                    }>[]>;
                    builtIn: import("#types").FieldType<boolean | null>;
                }>[], any>;
            };
            readonly commands: {
                readonly setActiveScheduleRequest: import("#types").Command<import("#types").TypeFromFields<{
                    scheduleHandle: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
                }>, void, any>;
            };
        };
    }, {
        readonly flags: {
            readonly autoMode: true;
            readonly heating: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly autoMode: true;
            readonly cooling: false;
        };
        readonly component: false;
    }, {
        readonly flags: {
            readonly heating: false;
            readonly cooling: false;
        };
        readonly component: false;
    }];
}>, ClusterBehavior.Type<ClusterType.Of<{
    readonly id: 0;
    readonly revision: 0;
    readonly name: "Unknown";
    readonly attributes: {};
    readonly commands: {};
    readonly events: {};
}>, typeof ClusterBehavior, ThermostatInterface>, ThermostatInterface>;
type ThermostatBehaviorType = InstanceType<typeof ThermostatBehavior>;
export interface ThermostatBehavior extends ThermostatBehaviorType {
}
type StateType = InstanceType<typeof ThermostatBehavior.State>;
export declare namespace ThermostatBehavior {
    interface State extends StateType {
    }
}
export {};
//# sourceMappingURL=ThermostatBehavior.d.ts.map