/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { BasicSet, decamelize, Diagnostic } from "#general";
import { IdentityConflictError } from "#node/server/IdentityService.js";
class EndpointContainer {
  #children = new BasicSet();
  #owner;
  constructor(endpoint) {
    this.#owner = endpoint;
  }
  get(id) {
    for (const child of this) {
      if (child.maybeId === id) {
        return child;
      }
    }
  }
  add(endpoint) {
    if (endpoint.lifecycle.hasId) {
      this.assertIdAvailable(endpoint.id, endpoint);
    }
    this.#children.add(endpoint);
    endpoint.owner = this.#owner;
    endpoint.lifecycle.destroyed.once(() => {
      this.delete(endpoint);
    });
    this.#children.add(endpoint);
  }
  delete(endpoint) {
    return this.#children.delete(endpoint);
  }
  clear() {
    this.#children.clear();
  }
  has(endpoint) {
    return this.#children.has(endpoint);
  }
  get added() {
    return this.#children.added;
  }
  get deleted() {
    return this.#children.deleted;
  }
  get size() {
    return this.#children.size;
  }
  map(fn) {
    return this.#children.map(fn);
  }
  filter(predicate) {
    return this.#children.filter(predicate);
  }
  find(predicate) {
    return this.#children.find(predicate);
  }
  forEach(fn) {
    [...this.#children].forEach(fn);
  }
  [Symbol.iterator]() {
    return this.#children[Symbol.iterator]();
  }
  /**
   * Soft-reset all parts.  Invoked automatically by the owner on reset.
   */
  async reset() {
    for (const endpoint of this) {
      await endpoint.reset();
    }
  }
  /**
   * Destroy all parts.  Invoked automatically by the owner on destroy.
   */
  async close() {
    for (const endpoint of this) {
      await endpoint.close();
    }
  }
  /**
   * Confirm availability of an ID amongst the endpoint's children.
   */
  assertIdAvailable(id, endpoint) {
    const other = this.get(id);
    if (other && other !== endpoint) {
      throw new IdentityConflictError(`${other} is already defined; endpoint IDs must be unique within parent`);
    }
  }
  get owner() {
    return this.#owner;
  }
  get [Diagnostic.value]() {
    return Diagnostic.list([decamelize(this.constructor.name), ...this]);
  }
}
export {
  EndpointContainer
};
//# sourceMappingURL=EndpointContainer.js.map
