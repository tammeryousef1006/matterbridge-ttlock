/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Contextual } from "#behavior/context/Contextual.js";
import { StructManager } from "#behavior/state/managed/values/StructManager.js";
import {
  camelize,
  Diagnostic,
  ImplementationError,
  InternalError,
  isObject,
  Logger,
  MaybePromise,
  ObserverGroup,
  Transaction
} from "#general";
import { ElementTag } from "#model";
import {
  AccessControl,
  AttributeServer,
  CommandServer,
  createAttributeServer as ConstructAttributeServer,
  EventServer,
  FabricManager,
  OccurrenceManager,
  SecureSession
} from "#protocol";
const logger = Logger.get("BehaviorServer");
function BehaviorServer(endpointServer, type) {
  const { id, name, attributes, commands, events } = type.cluster;
  const { endpoint } = endpointServer;
  const datasource = createClusterDatasource(endpoint, type);
  const observers = new ObserverGroup();
  const clusterServer = {
    id,
    name,
    datasource,
    attributes: {},
    commands: {},
    events: {},
    close() {
      observers.close();
    }
  };
  const stateView = endpoint.stateOf(type);
  const observables = endpoint.eventsOf(type);
  const elements = endpointServer.endpoint.behaviors.elementsOf(type);
  for (const name2 of elements.attributes) {
    const attribute = attributes[name2];
    const server = createAttributeServer(
      name2,
      attribute,
      endpoint,
      type,
      datasource,
      stateView,
      observables,
      observers
    );
    clusterServer.attributes[name2] = server;
    server.assignToEndpoint(endpointServer);
  }
  for (const name2 of elements.commands) {
    const command = commands[name2];
    clusterServer.commands[name2] = createCommandServer(name2, command, endpoint, type);
  }
  for (const name2 of elements.events) {
    const server = createEventServer(name2, events[name2], endpoint, type, observables, observers);
    clusterServer.events[name2] = server;
    server.assignToEndpoint(endpointServer);
  }
  return clusterServer;
}
function createClusterDatasource(endpoint, type) {
  const env = endpoint.env;
  return {
    get version() {
      return endpoint.behaviors.versionOf(type);
    },
    get eventHandler() {
      return env.get(OccurrenceManager);
    },
    get fabrics() {
      return env.get(FabricManager).fabrics;
    },
    // We handle change management ourselves
    changed() {
    },
    // We handle version management ourselves
    increaseVersion() {
      return this.version;
    }
  };
}
function createAttributeServer(name, definition, endpoint, type, datasource, stateView, observables, observers) {
  function getter(_session, _endpoint, _isFabricFiltered, message) {
    if (!message) {
      return stateView[name];
    }
    const behavior = behaviorFor(endpoint, type, message);
    behavior.context.activity?.frame(`read ${name}`);
    const trace = behavior.context.trace;
    if (trace) {
      trace.path = endpoint.path.at(name);
    }
    const state = behavior.state;
    StructManager.assertDirectReadAuthorized(state, definition.id);
    if (trace) {
      trace.output = state[name];
    }
    return state[name];
  }
  function setter(value, _session, _endpoint, message) {
    const behavior = behaviorFor(endpoint, type, message);
    behavior.context.activity?.frame(`write ${name}`);
    logger.info("Write", Diagnostic.strong(`${endpoint}.state.${name}`), "via", behavior.context.transaction.via);
    const trace = behavior.context.trace;
    if (trace) {
      trace.path = endpoint.path.at(name);
      trace.input = value;
    }
    const state = behavior.state;
    state[name] = value;
    return behavior.context.transaction?.status === Transaction.Status.Exclusive;
  }
  const server = ConstructAttributeServer(
    type.cluster,
    definition,
    name,
    stateView[name],
    datasource,
    getter,
    setter
  );
  if (server instanceof AttributeServer) {
    const observable = observables[`${name}$Changed`]?.online;
    if (observable !== void 0) {
      observers.on(observable, (_value, _oldValue, context) => {
        const session = context.session;
        if (session instanceof SecureSession) {
          server.updated(session);
        } else {
          server.updatedLocal();
        }
      });
    }
  }
  return server;
}
function createCommandServer(name, definition, endpoint, type) {
  const schema = type.schema?.member(camelize(name, true), [ElementTag.Command]);
  if (schema === void 0) {
    throw new ImplementationError(`There is no metadata for command ${name}`);
  }
  const access = AccessControl(schema);
  const handler = (request, _session, message) => {
    let requestDiagnostic;
    if (isObject(request)) {
      requestDiagnostic = Diagnostic.dict(request);
    } else if (request !== void 0) {
      requestDiagnostic = request;
    } else {
      requestDiagnostic = Diagnostic.weak("(no payload)");
    }
    const behavior = behaviorFor(endpoint, type, message);
    const path = endpoint.path.at(name);
    const trace = behavior.context.trace;
    if (trace) {
      trace.path = endpoint.path.at(name);
      trace.input = request;
    }
    logger.info("Invoke", Diagnostic.strong(path.toString()), behavior.context.transaction.via, requestDiagnostic);
    access.authorizeInvoke(behavior.context, {
      path,
      endpoint: endpoint.number,
      cluster: behavior.cluster.id
    });
    let isAsync = false;
    let activity;
    let result;
    try {
      activity = behavior.context?.activity?.frame(`invoke ${name}`);
      const invoke = behavior[name].bind(behavior);
      if (behavior.constructor.lockOnInvoke) {
        const tx = behavior.context.transaction;
        if (Transaction.Resource.isLocked(behavior)) {
          result = async function invokeAsync() {
            await tx.addResources(behavior);
            await tx.begin();
            return invoke(request);
          }();
        } else {
          tx.addResourcesSync(behavior);
          tx.beginSync();
          result = invoke(request);
        }
      } else {
        result = invoke(request);
      }
      if (MaybePromise.is(result)) {
        isAsync = true;
        result = Promise.resolve(result).then((result2) => {
          if (trace) {
            trace.output = result2;
          }
          return result2;
        }).finally(() => activity?.[Symbol.dispose]());
      } else if (trace) {
        trace.output = result;
      }
    } finally {
      if (!isAsync) {
        activity?.[Symbol.dispose]();
      }
    }
    return result;
  };
  const server = new CommandServer(
    definition.requestId,
    definition.responseId,
    name,
    definition.requestSchema,
    definition.responseSchema,
    definition.timed,
    definition.invokeAcl,
    handler
  );
  server.debug = () => {
  };
  return server;
}
function createEventServer(name, definition, endpoint, type, observables, observers) {
  const observable = observables[name];
  const server = new EventServer(
    definition.id,
    type.cluster.id,
    name,
    definition.schema,
    definition.priority,
    definition.readAcl
  );
  if (observable !== void 0) {
    observers.on(observable.online, (payload, _context) => {
      const maybePromise = server.triggerEvent(payload);
      if (MaybePromise.is(maybePromise)) {
        endpoint.env.runtime.add(maybePromise);
      }
    });
  }
  const promise = server.bindToEventHandler(endpoint.env.get(OccurrenceManager));
  if (MaybePromise.is(promise)) {
    throw new InternalError("Event handler binding returned a promise");
  }
  return server;
}
function behaviorFor(endpoint, type, message) {
  const context = Contextual.contextOf(message);
  if (!context) {
    throw new InternalError("Message context not installed");
  }
  const agent = context.agentFor(endpoint);
  return agent.get(type);
}
export {
  BehaviorServer
};
//# sourceMappingURL=BehaviorServer.js.map
