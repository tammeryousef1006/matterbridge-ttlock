/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { DatasourceStore } from "#endpoint/storage/DatasourceStore.js";
import { Construction, ImplementationError } from "#general";
const NUMBER_KEY = "__number__";
class EndpointStore {
  #storage;
  initialValues = {};
  #number;
  #construction;
  #childStorage;
  #childStores = {};
  #knownBehaviors = /* @__PURE__ */ new Set();
  /**
   * Description used in diagnostic messages.
   */
  toString() {
    return `storage:${this.#storage.thisContexts.join(".")}`;
  }
  get construction() {
    return this.#construction;
  }
  get number() {
    this.#construction.assert();
    return this.#number;
  }
  set number(number) {
    this.#construction.assert();
    if (this.#number !== number) {
      this.#number = number;
    }
  }
  constructor(storage, load = true) {
    this.#storage = storage;
    this.#childStorage = storage.createContext("parts");
    this.#construction = Construction(this, () => {
      if (!load) {
        return;
      }
      return this.#load();
    });
  }
  async #load() {
    this.#knownBehaviors = new Set(await this.#storage.contexts());
    for (const behaviorId of this.#knownBehaviors) {
      const behaviorValues = this.initialValues[behaviorId] = {};
      const behaviorStorage = this.#storage.createContext(behaviorId);
      const storedValues = await behaviorStorage.values();
      for (const [key, value] of Object.entries(storedValues)) {
        if (value !== void 0) {
          behaviorValues[key] = value;
        }
      }
    }
    const number = await this.#storage.get(NUMBER_KEY, -1);
    if (number !== -1) {
      this.#number = number;
    }
    await this.#loadSubparts();
  }
  /**
   * Invoke a function on this store and the stores of descendant parts.
   */
  visit(fn) {
    fn(this);
    for (const child of Object.values(this.#childStores)) {
      child.visit(fn);
    }
  }
  /**
   * Obtain a {@link Datasource.Store} for a behavior.
   */
  storeForBehavior(behaviorId) {
    this.#construction.assert();
    const initialValues = this.initialValues[behaviorId];
    if (initialValues !== void 0) {
      delete this.initialValues[behaviorId];
    }
    return DatasourceStore(this, behaviorId, initialValues);
  }
  childStoreFor(endpoint) {
    if (!endpoint.lifecycle.hasId) {
      throw new ImplementationError("Cannot access endpoint storage because endpoint has no assigned ID");
    }
    return this.storeForPartId(endpoint.id);
  }
  storeForPartId(partId) {
    this.#construction.assert();
    let store = this.#childStores[partId];
    if (store === void 0) {
      store = this.#childStores[partId] = new EndpointStore(this.#childStorage.createContext(partId), false);
    }
    return store;
  }
  async saveNumber() {
    await this.#construction;
    await this.#storage.set(NUMBER_KEY, this.number);
  }
  /**
   * Patch values.  Keyed by {@link Behavior.id} then property name.
   *
   * See {@link Datasource.Store.set} for the patch semantics the individual structs use.
   */
  async set(values) {
    await this.#construction;
    for (const behaviorId in values) {
      const behaviorValues = values[behaviorId];
      const behaviorStorage = this.#storage.createContext(behaviorId);
      if (behaviorValues === void 0) {
        if (this.#knownBehaviors.has(behaviorId)) {
          await behaviorStorage.clearAll();
          this.#knownBehaviors.delete(behaviorId);
        }
        continue;
      }
      if (!this.#knownBehaviors.has(behaviorId)) {
        this.#knownBehaviors.add(behaviorId);
      }
      const toSave = {};
      let keysToSave = 0;
      for (const key in behaviorValues) {
        const value = behaviorValues[key];
        if (value === void 0) {
          await behaviorStorage.delete(key);
        } else {
          toSave[key] = value;
          keysToSave++;
        }
      }
      if (keysToSave > 0) {
        await behaviorStorage.set(toSave);
      }
    }
  }
  /**
   * Remove all persisted information for the {@link Endpoint}
   */
  async erase() {
    await this.#construction;
    await this.#storage.clearAll();
  }
  /**
   * Erase the child storage for one part
   */
  async eraseChildStoreFor(endpoint) {
    await this.#construction;
    const partId = endpoint.id;
    const store = this.#childStores[partId];
    await store.erase();
    delete this.#childStores[partId];
  }
  async #loadSubparts() {
    const knownParts = await this.#childStorage.contexts();
    for (const partId of knownParts) {
      await this.#loadKnownChildStores(partId);
    }
  }
  async #loadKnownChildStores(partId) {
    const endpointStore = new EndpointStore(this.#childStorage.createContext(partId));
    this.#childStores[partId] = endpointStore;
    await endpointStore.construction;
  }
}
export {
  EndpointStore
};
//# sourceMappingURL=EndpointStore.js.map
