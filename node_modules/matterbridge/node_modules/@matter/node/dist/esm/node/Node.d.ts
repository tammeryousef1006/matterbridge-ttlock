/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { ActionContext } from "#behavior/context/ActionContext.js";
import { IndexBehavior } from "#behavior/system/index/IndexBehavior.js";
import { NetworkRuntime } from "#behavior/system/network/NetworkRuntime.js";
import { PartsBehavior } from "#behavior/system/parts/PartsBehavior.js";
import { Endpoint } from "#endpoint/Endpoint.js";
import { MutableEndpoint } from "#endpoint/index.js";
import { EndpointType } from "#endpoint/type/EndpointType.js";
import { Construction, Diagnostic, Environment, Identity, RuntimeService } from "#general";
import { Interactable } from "#protocol";
import { RootEndpoint } from "../endpoints/root.js";
import { NodeLifecycle } from "./NodeLifecycle.js";
/**
 * A Matter Node.
 *
 * In Matter, a "node" is an individually addressable top-level network resource.
 */
export declare abstract class Node<T extends Node.CommonRootEndpoint = Node.CommonRootEndpoint> extends Endpoint<T> {
    #private;
    constructor(config: Node.Configuration<T>);
    get env(): Environment;
    /**
     * The optimized view that supports local Matter protocol implementation.
     */
    get protocol(): import("#protocol").NodeProtocol;
    get lifecycle(): NodeLifecycle;
    /**
     * Bring the node online.
     */
    start(): Promise<void>;
    protected startWithMutex(): Promise<void>;
    /**
     * @deprecated use {@link start}
     */
    bringOnline(): Promise<void>;
    /**
     * Run the node in standalone mode.  Returns when the node is closed.
     */
    run(): Promise<void>;
    /**
     * Take the node offline but leave state and structure intact.  Happens automatically on close.
     *
     * Once the node is offline you may use {@link start} to bring the node online again.
     */
    cancel(): Promise<void>;
    protected cancelWithMutex(): Promise<void>;
    close(): Promise<void>;
    protected closeWithMutex(): Promise<void>;
    reset(): Promise<void>;
    protected resetWithMutex(): Promise<void>;
    /**
     * Create the network runtime.
     */
    protected abstract createRuntime(): NetworkRuntime;
    /**
     * An {@link Interactable} that allows for execution of Matter interactions against this node.
     */
    abstract interaction: Interactable<ActionContext>;
    protected abstract prepareRuntimeShutdown(): Promise<void>;
    get [RuntimeService.label](): (string | Diagnostic)[];
    get [Diagnostic.value](): unknown;
    protected createLifecycle(): NodeLifecycle;
    protected statusUpdate(message: string): void;
    [Construction.destruct](): Promise<void>;
}
export declare namespace Node {
    interface NodeOptions extends Endpoint.EndpointOptions {
        environment?: Environment;
    }
    type Options<T extends Node.CommonRootEndpoint = Node.CommonRootEndpoint> = Endpoint.Options<T, NodeOptions>;
    type Configuration<T extends Node.CommonRootEndpoint = Node.CommonRootEndpoint> = Endpoint.Configuration<T, NodeOptions>;
    function nodeConfigFor<T extends RootEndpoint>(defaultType: T, configuration: undefined | T | Configuration<T>, options?: Options<T>): Node.Configuration<T>;
    function forEndpoint(endpoint: Endpoint): Node;
    /**
     * Common root endpoint definition for all nodes.
     */
    const CommonRootEndpoint: MutableEndpoint.With<EndpointType.For<{
        readonly name: "RootNode";
        readonly deviceType: import("@matter/types").DeviceTypeId;
        readonly deviceRevision: number;
        readonly deviceClass: import("@matter/model").DeviceClassification;
        readonly requirements: typeof import("../endpoints/root.js").RootRequirements;
        readonly behaviors: {
            readonly parts: typeof PartsBehavior;
            readonly index: typeof IndexBehavior;
        };
    }>, {
        readonly parts: typeof PartsBehavior;
        readonly index: typeof IndexBehavior;
    }>;
    interface CommonRootEndpoint extends Identity<typeof CommonRootEndpoint> {
    }
}
//# sourceMappingURL=Node.d.ts.map