/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { CommissioningServer } from "#behavior/system/commissioning/CommissioningServer.js";
import { ControllerBehavior } from "#behavior/system/controller/ControllerBehavior.js";
import { EventsBehavior } from "#behavior/system/events/EventsBehavior.js";
import { NetworkServer } from "#behavior/system/network/NetworkServer.js";
import { ServerNetworkRuntime } from "#behavior/system/network/ServerNetworkRuntime.js";
import { ProductDescriptionServer } from "#behavior/system/product-description/ProductDescriptionServer.js";
import { SessionsBehavior } from "#behavior/system/sessions/SessionsBehavior.js";
import { SubscriptionBehavior } from "#behavior/system/subscription/index.js";
import { Construction, DiagnosticSource, MatterError, asyncNew, errorOf } from "#general";
import { FabricManager, OccurrenceManager, ServerInteraction, SessionManager } from "#protocol";
import { RootEndpoint as BaseRootEndpoint } from "../endpoints/root.js";
import { Node } from "./Node.js";
import { ClientNodes } from "./client/ClientNodes.js";
import { ServerEnvironment } from "./server/ServerEnvironment.js";
import { ServerNodeStore } from "./storage/ServerNodeStore.js";
class FactoryResetError extends MatterError {
  constructor(message, cause) {
    super(message);
    this.cause = errorOf(cause);
  }
}
class ServerNode extends Node {
  #nodes;
  #interaction;
  constructor(definition, options) {
    super(Node.nodeConfigFor(ServerNode.RootEndpoint, definition, options));
    this.env.set(ServerNode, this);
    DiagnosticSource.add(this);
    this.construction.start();
  }
  static async create(definition, options) {
    return await asyncNew(this, definition, options);
  }
  createRuntime() {
    return new ServerNetworkRuntime(this);
  }
  async [Construction.destruct]() {
    await super[Construction.destruct]();
    await ServerEnvironment.close(this);
  }
  async prepareRuntimeShutdown() {
    const sessions = this.env.get(SessionManager);
    await sessions.close();
  }
  /**
   * Perform a factory reset of the node.
   */
  async erase() {
    await this.lifecycle.mutex.produce(this.eraseWithMutex.bind(this));
  }
  async eraseWithMutex() {
    try {
      await this.construction;
      const isOnline = this.lifecycle.isOnline;
      if (isOnline) {
        await this.cancelWithMutex();
      }
      this.statusUpdate("resetting to factory defaults");
      await this.resetWithMutex();
      await this.resetStorage();
      this.construction.start();
      if (isOnline) {
        await this.startWithMutex();
      } else {
        await this.construction.ready;
      }
    } catch (e) {
      this.construction.crash();
      throw new FactoryResetError(`Error during factory reset of ${this}`, e);
    }
  }
  /**
   * Access other nodes on the fabric.
   */
  get nodes() {
    if (!this.#nodes) {
      this.#nodes = new ClientNodes(this);
      this.#nodes.initialize();
    }
    return this.#nodes;
  }
  get interaction() {
    if (this.#interaction === void 0) {
      this.#interaction = new ServerInteraction(this.protocol);
    }
    return this.#interaction;
  }
  async advertiseNow() {
    await this.act(`advertiseNow<${this}>`, (agent) => agent.get(NetworkServer).advertiseNow());
  }
  async initialize() {
    await ServerEnvironment.initialize(this);
    await super.initialize();
  }
  /**
   * By default on factory reset we erase all stored data.
   *
   * If this is inappropriate for your application you may override to alter the behavior.   Matter requires that all
   * "security- and privacy-related data and key material" is removed on factory reset.
   *
   * @see {@link MatterSpecification.v12.Core} ยง 13.4
   */
  async resetStorage() {
    await this.env.get(SessionManager).clear();
    await this.env.get(FabricManager).clear();
    await this.env.get(OccurrenceManager).clear();
    await this.env.get(ServerNodeStore).erase();
  }
  /**
   * Normal endpoints must have an owner to complete construction but server nodes have no such precondition for
   * construction.
   */
  assertConstructable() {
  }
}
((ServerNode2) => {
  ServerNode2.RootEndpoint = BaseRootEndpoint.with(
    CommissioningServer,
    NetworkServer,
    ProductDescriptionServer,
    SubscriptionBehavior,
    SessionsBehavior,
    EventsBehavior,
    ControllerBehavior
  );
})(ServerNode || (ServerNode = {}));
export {
  ServerNode
};
//# sourceMappingURL=ServerNode.js.map
