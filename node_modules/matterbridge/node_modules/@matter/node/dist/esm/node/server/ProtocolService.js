/**
 * @license
 * Copyright 2022-2025 Project CHIP Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { ImplementationError } from "#general";
import { AcceptedCommandList, AttributeList, ElementTag, GeneratedCommandList, Matter } from "#model";
import { FabricManager } from "#protocol";
import { DescriptorBehavior } from "../../behaviors/descriptor/DescriptorBehavior.js";
class ProtocolService {
  #state;
  constructor(node) {
    this.#state = new NodeState(node);
  }
  addCluster(backing) {
    const { schema } = backing.type;
    if (schema?.tag !== ElementTag.Cluster || schema.id === void 0) {
      return;
    }
    this.#state.stateFor(backing.endpoint).addCluster(backing);
  }
  deleteCluster(backing) {
    if (this.#state.hasEndpoint(backing.endpoint)) {
      this.#state.stateFor(backing.endpoint).deleteCluster(backing);
    }
  }
  get protocol() {
    return this.#state.protocol;
  }
}
const WildcardPathFlags = {
  skipRootNode: 1,
  skipGlobalAttributes: 1 << 1,
  skipAttributeList: 1 << 2,
  skipCommandLists: 1 << 3,
  skipCustomElements: 1 << 4,
  skipFixedAttributes: 1 << 5,
  skipChangesOmittedAttributes: 1 << 6,
  skipDiagnosticsClusters: 1 << 7
};
class NodeState {
  protocol;
  #endpoints = /* @__PURE__ */ new Set();
  #endpointStates = {};
  constructor(node) {
    let fabrics;
    this.protocol = {
      matter: Matter,
      nodeIdFor(index) {
        if (!fabrics) {
          fabrics = node.env.get(FabricManager);
        }
        return fabrics.findByIndex(index)?.nodeId;
      },
      [Symbol.iterator]: this.#endpoints[Symbol.iterator].bind(this.#endpoints),
      toString() {
        return `node-proto#${node.id}`;
      },
      inspect() {
        return this.toString();
      }
    };
  }
  stateFor(endpoint) {
    const { number } = endpoint;
    let state = this.#endpointStates[number];
    if (state !== void 0) {
      return state;
    }
    state = new EndpointState(this, endpoint);
    this.protocol[number] = state.protocol;
    this.#endpoints.add(state.protocol);
    this.#endpointStates[number] = state;
    return state;
  }
  hasEndpoint(endpoint) {
    return endpoint.number in this.#endpointStates;
  }
  deleteEndpoint(endpoint) {
    delete this.protocol[endpoint.id];
    this.#endpoints.delete(endpoint);
    delete this.#endpointStates[endpoint.id];
  }
}
class EndpointState {
  protocol;
  #node;
  #activeClusters = /* @__PURE__ */ new Set();
  #clusters = /* @__PURE__ */ new Set();
  constructor(node, endpoint) {
    this.#node = node;
    this.protocol = {
      id: endpoint.number,
      wildcardPathFlags: endpoint.number === 0 ? WildcardPathFlags.skipRootNode : 0,
      path: endpoint.path,
      deviceTypes: [],
      toString() {
        return `endpoint-proto#${this.id}`;
      },
      inspect() {
        return this.toString();
      },
      [Symbol.iterator]: this.#clusters[Symbol.iterator].bind(this.#clusters)
    };
  }
  addCluster(backing) {
    const type = clusterTypeProtocolOf(backing.type);
    if (!type) {
      return;
    }
    const cluster = new ClusterState(type, backing.datasource, this.protocol.id);
    if (backing.type.id === DescriptorBehavior.id) {
      this.#updateDeviceTypes(backing.endpoint.state.descriptor.deviceTypeList);
      backing.events.deviceTypeList$Changed.on(
        this.#updateDeviceTypes.bind(this)
      );
    }
    this.protocol[cluster.type.id] = cluster;
    this.#activeClusters.add(cluster.type.id);
    this.#clusters.add(cluster);
  }
  deleteCluster(backing) {
    const { schema } = backing.type;
    if (schema === void 0) {
      return;
    }
    const { tag, id } = schema;
    if (tag !== ElementTag.Cluster || id === void 0) {
      return;
    }
    const protocol = this.protocol[id];
    if (protocol) {
      this.#clusters.delete(protocol);
      delete this.protocol[id];
    }
    this.#activeClusters.delete(id);
    if (!this.#activeClusters.size) {
      this.#node.deleteEndpoint(this.protocol);
    }
  }
  #updateDeviceTypes(deviceTypeList) {
    this.protocol.deviceTypes = deviceTypeList.map((dt) => dt.deviceType);
  }
}
class ClusterState {
  type;
  #datasource;
  #endpointId;
  get version() {
    return this.#datasource.version;
  }
  get location() {
    return this.#datasource.location;
  }
  open(session) {
    if (!("transaction" in session)) {
      throw new ImplementationError("Cluster protocol must be opened with a supervisor session");
    }
    return this.#datasource.reference(session);
  }
  toString() {
    return `cluster-proto#${this.#endpointId}:${this.type.id}`;
  }
  inspect() {
    return this.toString();
  }
  constructor(type, datasource, endpointId) {
    this.type = type;
    this.#datasource = datasource;
    this.#endpointId = endpointId;
  }
}
const behaviorCache = /* @__PURE__ */ new WeakMap();
function clusterTypeProtocolOf(behavior) {
  if (behaviorCache.has(behavior)) {
    return behaviorCache.get(behavior);
  }
  const { cluster, schema } = behavior;
  if (cluster === void 0 || schema?.id === void 0) {
    return;
  }
  const tlvs = {};
  for (const attr of Object.values(cluster.attributes)) {
    tlvs[attr.id] = attr.schema;
  }
  let wildcardPathFlags = schema.effectiveQuality.diagnostics ? WildcardPathFlags.skipDiagnosticsClusters : 0;
  if (schema.id & 4294901760) {
    wildcardPathFlags |= WildcardPathFlags.skipCustomElements;
  }
  const attrList = Array();
  const attributes = {
    [Symbol.iterator]: attrList[Symbol.iterator].bind(attrList)
  };
  for (const member of behavior.supervisor.membersOf(schema)) {
    const { id, tag, effectiveQuality: quality } = member;
    if (tag !== "attribute" || id === void 0) {
      continue;
    }
    const tlv = tlvs[id];
    if (tlv === void 0) {
      continue;
    }
    let wildcardPathFlags2;
    switch (id) {
      case GeneratedCommandList.id:
      case AcceptedCommandList.id:
        wildcardPathFlags2 = WildcardPathFlags.skipGlobalAttributes | WildcardPathFlags.skipCommandLists;
        break;
      case AttributeList.id:
        wildcardPathFlags2 = WildcardPathFlags.skipGlobalAttributes | WildcardPathFlags.skipAttributeList;
        break;
      default:
        wildcardPathFlags2 = 0;
        break;
    }
    if (id & 4294901760) {
      wildcardPathFlags2 |= WildcardPathFlags.skipGlobalAttributes;
    }
    if (quality.fixed) {
      wildcardPathFlags2 |= WildcardPathFlags.skipFixedAttributes;
    }
    if (quality.changesOmitted) {
      wildcardPathFlags2 |= WildcardPathFlags.skipChangesOmittedAttributes;
    }
    const {
      access: { limits }
    } = behavior.supervisor.get(member);
    const attr = { id, tlv, wildcardPathFlags: wildcardPathFlags2, limits };
    attrList.push(attr);
    attributes[id] = attr;
  }
  const descriptor = {
    id: schema.id,
    attributes,
    wildcardPathFlags
  };
  behaviorCache.set(behavior, descriptor);
  return descriptor;
}
export {
  ProtocolService
};
//# sourceMappingURL=ProtocolService.js.map
