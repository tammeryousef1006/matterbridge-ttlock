/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { AnyAttributeServer, AnyEventServer, AttributePath, AttributeServer, CommandPath, CommandServer, EndpointInterface, EventPath, InteractionContext, InteractionServer, Message, MessageExchange, SessionManager, WriteRequest, WriteResponse } from "#protocol";
import { StatusCode, TlvEventFilter, TypeFromSchema } from "#types";
import { AccessControlServer } from "../../behaviors/access-control/AccessControlServer.js";
import { ServerNode } from "../ServerNode.js";
/**
 * Wire up an InteractionServer that initializes an InvocationContext earlier than the cluster API supports.
 *
 * This is necessary for attributes because the ClusterServer attribute APIs are synchronous while transaction
 * management is asynchronous.
 *
 * It's not necessary for command handling because that API is entirely async.  We do it here, however, just for the
 * sake of consistency.
 *
 * This could be integrated directly into InteractionServer but this further refactoring is probably warranted there
 * regardless.  This keeps the touch light for now.
 */
export declare class TransactionalInteractionServer extends InteractionServer {
    #private;
    static create(node: ServerNode, sessions: SessionManager): Promise<TransactionalInteractionServer>;
    constructor(node: ServerNode, context: InteractionContext);
    [Symbol.asyncDispose](): Promise<void>;
    blockNewActivity(): void;
    onNewExchange(exchange: MessageExchange, message: Message): Promise<void>;
    get aclServer(): AccessControlServer;
    protected readAttribute(path: AttributePath, attribute: AnyAttributeServer<any>, exchange: MessageExchange, fabricFiltered: boolean, message: Message, offline?: boolean): {
        version: number;
        value: any;
    };
    /**
     * Reads the attributes for the given endpoint.
     * This can currently only be used for subscriptions because errors are ignored!
     */
    protected readEndpointAttributesForSubscription(attributes: {
        path: AttributePath;
        attribute: AnyAttributeServer<any>;
    }[], exchange: MessageExchange, fabricFiltered: boolean, message: Message, offline?: boolean): {
        path: AttributePath;
        attribute: AnyAttributeServer<unknown>;
        value: any;
        version: number;
    }[];
    protected readEvent(path: EventPath, eventFilters: TypeFromSchema<typeof TlvEventFilter>[] | undefined, event: AnyEventServer<any, any>, exchange: MessageExchange, fabricFiltered: boolean, message: Message): Promise<import("#protocol").NumberedOccurrence[]>;
    handleWriteRequest(exchange: MessageExchange, writeRequest: WriteRequest, message: Message): Promise<WriteResponse>;
    protected writeAttribute(path: AttributePath, attribute: AttributeServer<any>, value: any, exchange: MessageExchange, message: Message, endpoint: EndpointInterface, timed?: boolean, isListWrite?: boolean): Promise<void>;
    protected invokeCommand(path: CommandPath, command: CommandServer<any, any>, exchange: MessageExchange, commandFields: any, message: Message, endpoint: EndpointInterface, timed?: boolean): Promise<{
        code: StatusCode;
        clusterCode?: number;
        responseId: import("#types").CommandId;
        response: import("#types").TlvStream;
    }>;
}
//# sourceMappingURL=TransactionalInteractionServer.d.ts.map