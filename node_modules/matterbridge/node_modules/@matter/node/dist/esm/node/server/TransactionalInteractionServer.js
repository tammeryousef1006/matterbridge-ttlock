var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __using = (stack, value, async) => {
  if (value != null) {
    if (typeof value !== "object" && typeof value !== "function") __typeError("Object expected");
    var dispose, inner;
    if (async) dispose = value[__knownSymbol("asyncDispose")];
    if (dispose === void 0) {
      dispose = value[__knownSymbol("dispose")];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") __typeError("Object not disposable");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    stack.push([async, dispose, value]);
  } else if (async) {
    stack.push([async]);
  }
  return value;
};
var __callDispose = (stack, error, hasError) => {
  var E = typeof SuppressedError === "function" ? SuppressedError : function(e, s, m, _) {
    return _ = Error(m), _.name = "SuppressedError", _.error = e, _.suppressed = s, _;
  };
  var fail = (e) => error = hasError ? new E(e, error, "An error was suppressed during disposal") : (hasError = true, e);
  var next = (it) => {
    while (it = stack.pop()) {
      try {
        var result = it[1] && it[1].call(it[2]);
        if (it[0]) return Promise.resolve(result).then(next, (e) => (fail(e), next()));
      } catch (e) {
        fail(e);
      }
    }
    if (hasError) throw error;
  };
  return next();
};
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { ActionTracer } from "#behavior/context/ActionTracer.js";
import { NodeActivity } from "#behavior/context/NodeActivity.js";
import { OfflineContext } from "#behavior/context/server/OfflineContext.js";
import { OnlineContext } from "#behavior/context/server/OnlineContext.js";
import { AccessControlCluster } from "#clusters/access-control";
import { EndpointLifecycle } from "#endpoint/properties/EndpointLifecycle.js";
import { EndpointServer } from "#endpoint/server/EndpointServer.js";
import { Diagnostic, InternalError, Logger, MaybePromise } from "#general";
import {
  AccessControl,
  AccessDeniedError,
  ExchangeManager,
  InteractionEndpointStructure,
  InteractionServer,
  InteractionServerMessenger,
  MessageType
} from "#protocol";
import { StatusCode, StatusResponseError } from "#types";
import { AccessControlServer } from "../../behaviors/access-control/AccessControlServer.js";
const logger = Logger.get("TransactionalInteractionServer");
const activityKey = Symbol("activity");
const AclClusterId = AccessControlCluster.id;
const AclAttributeId = AccessControlCluster.attributes.acl.id;
class TransactionalInteractionServer extends InteractionServer {
  #endpointStructure;
  #changeListener;
  #node;
  #activity;
  #newActivityBlocked = false;
  #aclServer;
  #aclUpdateIsDelayedInExchange = /* @__PURE__ */ new Set();
  static async create(node, sessions) {
    const structure = new InteractionEndpointStructure();
    return new TransactionalInteractionServer(node, {
      sessions,
      structure,
      subscriptionOptions: node.state.network.subscriptionOptions,
      maxPathsPerInvoke: node.state.basicInformation.maxPathsPerInvoke,
      initiateExchange: (address, protocolId) => node.env.get(ExchangeManager).initiateExchange(address, protocolId)
    });
  }
  constructor(node, context) {
    super(context);
    const { structure } = context;
    this.#activity = node.env.get(NodeActivity);
    this.#node = node;
    this.#endpointStructure = structure;
    this.#updateStructure();
    this.#changeListener = (type, endpoint) => {
      switch (type) {
        case EndpointLifecycle.Change.ServersChanged:
          EndpointServer.forEndpoint(endpoint).updateServers();
          this.#updateStructure();
          break;
        case EndpointLifecycle.Change.PartsReady:
        case EndpointLifecycle.Change.ClientsChanged:
        case EndpointLifecycle.Change.Destroyed:
          this.#updateStructure();
          break;
      }
    };
    node.lifecycle.changed.on(this.#changeListener);
  }
  async [Symbol.asyncDispose]() {
    this.#node.lifecycle.changed.off(this.#changeListener);
    await this.close();
    this.#endpointStructure.close();
    await EndpointServer.forEndpoint(this.#node)[Symbol.asyncDispose]();
  }
  blockNewActivity() {
    this.#newActivityBlocked = true;
  }
  async onNewExchange(exchange, message) {
    var _stack = [];
    try {
      if (this.#newActivityBlocked || this.isClosing) {
        return;
      }
      if (message.payloadHeader.messageType === MessageType.ReportData && this.clientHandler) {
        return this.clientHandler.onNewExchange(exchange, message);
      }
      const activity = __using(_stack, this.#activity.begin(`session#${exchange.session.id.toString(16)}`));
      exchange[activityKey] = activity;
      return new InteractionServerMessenger(exchange).handleRequest(this).finally(() => delete exchange[activityKey]);
    } catch (_) {
      var _error = _, _hasError = true;
    } finally {
      __callDispose(_stack, _error, _hasError);
    }
  }
  get aclServer() {
    if (this.#aclServer !== void 0) {
      return this.#aclServer;
    }
    const aclServer = this.#node.act((agent) => agent.get(AccessControlServer));
    if (MaybePromise.is(aclServer)) {
      throw new InternalError("AccessControlServer should already be initialized.");
    }
    return this.#aclServer = aclServer;
  }
  readAttribute(path, attribute, exchange, fabricFiltered, message, offline = false) {
    const readAttribute = () => super.readAttribute(path, attribute, exchange, fabricFiltered, message, offline);
    const endpoint = this.#endpointStructure.getEndpoint(path.endpointId);
    if (!endpoint) {
      throw new InternalError("Endpoint not found for ACL check. This should never happen.");
    }
    const result = offline ? OfflineContext.act("offline-read", this.#activity, readAttribute) : OnlineContext({
      activity: exchange[activityKey],
      fabricFiltered,
      message,
      exchange,
      tracer: this.#tracer,
      actionType: ActionTracer.ActionType.Read,
      node: this.#node
    }).act(readAttribute);
    if (MaybePromise.is(result)) {
      throw new InternalError("Reads should not return a promise.");
    }
    return result;
  }
  /**
   * Reads the attributes for the given endpoint.
   * This can currently only be used for subscriptions because errors are ignored!
   */
  readEndpointAttributesForSubscription(attributes, exchange, fabricFiltered, message, offline = false) {
    const readAttributes = () => {
      const result2 = new Array();
      for (const { path, attribute } of attributes) {
        try {
          const value = super.readAttribute(path, attribute, exchange, fabricFiltered, message, offline);
          result2.push({ path, attribute, value: value.value, version: value.version });
        } catch (error) {
          if (StatusResponseError.is(error, StatusCode.UnsupportedAccess)) {
            logger.warn(
              `Permission denied reading attribute ${this.#endpointStructure.resolveAttributeName(path)}`
            );
          } else {
            logger.warn(
              `Error reading attribute ${this.#endpointStructure.resolveAttributeName(path)}:`,
              error
            );
          }
        }
      }
      return result2;
    };
    const result = offline ? OfflineContext.act("offline-read", this.#activity, readAttributes) : OnlineContext({
      activity: exchange[activityKey],
      fabricFiltered,
      message,
      exchange,
      tracer: this.#tracer,
      actionType: ActionTracer.ActionType.Read,
      node: this.#node
    }).act(readAttributes);
    if (MaybePromise.is(result)) {
      throw new InternalError("Online read should not return a promise.");
    }
    return result;
  }
  async readEvent(path, eventFilters, event, exchange, fabricFiltered, message) {
    const readEvent = (context) => {
      if (context.authorityAt(event.readAcl, {
        endpoint: path.endpointId,
        cluster: path.clusterId
      }) !== AccessControl.Authority.Granted) {
        throw new AccessDeniedError(
          `Access to ${path.endpointId}/${Diagnostic.hex(path.clusterId)} denied on ${exchange.session.name}.`
        );
      }
      return super.readEvent(path, eventFilters, event, exchange, fabricFiltered, message);
    };
    return OnlineContext({
      activity: exchange[activityKey],
      fabricFiltered,
      message,
      exchange,
      tracer: this.#tracer,
      actionType: ActionTracer.ActionType.Read,
      node: this.#node
    }).act(readEvent);
  }
  async handleWriteRequest(exchange, writeRequest, message) {
    let result;
    try {
      result = await super.handleWriteRequest(exchange, writeRequest, message);
    } catch (error) {
      if (this.#aclUpdateIsDelayedInExchange.has(exchange)) {
        this.#aclUpdateIsDelayedInExchange.delete(exchange);
        if (this.#aclUpdateIsDelayedInExchange.size === 0) {
          this.aclServer.resetDelayedAccessControlList();
        } else {
          logger.error("One of multiple concurrent ACL writes failed, unhandled case for now.");
        }
      }
      throw error;
    }
    if (this.#aclUpdateIsDelayedInExchange.has(exchange)) {
      this.#aclUpdateIsDelayedInExchange.delete(exchange);
      if (this.#aclUpdateIsDelayedInExchange.size === 0) {
        this.aclServer.aclUpdateDelayed = false;
      } else {
        logger.info("Multiple concurrent ACL writes, waiting for all to finish.");
      }
    }
    return result;
  }
  async writeAttribute(path, attribute, value, exchange, message, endpoint, timed = false, isListWrite) {
    const writeAttribute = () => super.writeAttribute(path, attribute, value, exchange, message, endpoint, timed, isListWrite);
    if (path.endpointId === 0 && path.clusterId === AclClusterId && path.attributeId === AclAttributeId) {
      this.aclServer.aclUpdateDelayed = true;
      this.#aclUpdateIsDelayedInExchange.add(exchange);
    } else {
      if (this.#aclUpdateIsDelayedInExchange.has(exchange)) {
        this.#aclUpdateIsDelayedInExchange.delete(exchange);
        if (this.#aclUpdateIsDelayedInExchange.size === 0) {
          this.aclServer.aclUpdateDelayed = false;
        } else {
          logger.info("Multiple concurrent ACL writes, waiting for all to finish.");
        }
      }
    }
    return OnlineContext({
      activity: exchange[activityKey],
      timed,
      message,
      exchange,
      fabricFiltered: true,
      tracer: this.#tracer,
      actionType: ActionTracer.ActionType.Write,
      node: this.#node
    }).act(writeAttribute);
  }
  async invokeCommand(path, command, exchange, commandFields, message, endpoint, timed = false) {
    const invokeCommand = (context) => {
      if (context.authorityAt(command.invokeAcl, {
        endpoint: endpoint.number,
        cluster: path.clusterId
      }) !== AccessControl.Authority.Granted) {
        throw new AccessDeniedError(
          `Access to ${endpoint.number}/${Diagnostic.hex(path.clusterId)} denied on ${exchange.session.name}.`
        );
      }
      return super.invokeCommand(path, command, exchange, commandFields, message, endpoint, timed);
    };
    return OnlineContext({
      activity: exchange[activityKey],
      command: true,
      timed,
      message,
      exchange,
      tracer: this.#tracer,
      actionType: ActionTracer.ActionType.Invoke,
      node: this.#node
    }).act(invokeCommand);
  }
  get #tracer() {
    if (this.#node.env.has(ActionTracer)) {
      return this.#node.env.get(ActionTracer);
    }
  }
  #updateStructure() {
    if (this.#node.lifecycle.isPartsReady) {
      const server = EndpointServer.forEndpoint(this.#node);
      this.#endpointStructure.initializeFromEndpoint(server);
    }
  }
}
export {
  TransactionalInteractionServer
};
//# sourceMappingURL=TransactionalInteractionServer.js.map
