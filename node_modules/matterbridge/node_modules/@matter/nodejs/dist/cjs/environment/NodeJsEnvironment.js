"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var NodeJsEnvironment_exports = {};
__export(NodeJsEnvironment_exports, {
  NodeJsEnvironment: () => NodeJsEnvironment,
  getDefaults: () => getDefaults,
  loadConfigFile: () => loadConfigFile
});
module.exports = __toCommonJS(NodeJsEnvironment_exports);
var import_config = require("#config.js");
var import_general = require("#general");
var import_node_fs = require("node:fs");
var import_promises = require("node:fs/promises");
var import_node_path = require("node:path");
var import_NodeJsNetwork = require("../net/NodeJsNetwork.js");
var import_StorageBackendDisk = require("../storage/StorageBackendDisk.js");
var import_NodeJsActionTracer = require("./NodeJsActionTracer.js");
var import_ProcessManager = require("./ProcessManager.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
function NodeJsEnvironment() {
  const env = new import_general.Environment("default");
  loadVariables(env);
  configureRuntime(env);
  configureStorage(env);
  configureNetwork(env);
  if (!env.vars.has("logger.format") && import_general.Logger.format === import_general.LogFormat.PLAIN && process.stdin?.isTTY) {
    env.vars.set("logger.format", import_general.LogFormat.ANSI);
  }
  import_NodeJsActionTracer.NodeJsActionTracer.configure(env);
  import_config.config.isInitialized = true;
  return env;
}
function loadVariables(env) {
  const vars = env.vars;
  vars.addConfigStyle(getDefaults(vars));
  if (import_config.config.loadProcessArgv) {
    vars.addUnixEnvStyle(process.env);
  }
  if (import_config.config.loadProcessEnv) {
    vars.addArgvStyle(process.argv);
  }
  const { configPath, configVars } = loadConfigFile(vars);
  if (import_config.config.loadConfigFile) {
    vars.addConfigStyle(configVars);
  }
  if (import_config.config.loadProcessArgv) {
    vars.addUnixEnvStyle(process.env);
  }
  if (import_config.config.loadProcessEnv) {
    vars.addArgvStyle(process.argv);
  }
  vars.persistConfigValue = async (name, value) => {
    if (value === void 0) {
      delete configVars[name];
    }
    configVars[name] = value;
    await (0, import_promises.writeFile)(configPath, JSON.stringify(configVars, void 0, 4));
  };
}
function configureRuntime(env) {
  const processManager = new import_ProcessManager.ProcessManager(env);
  env.set(import_ProcessManager.ProcessManager, processManager);
}
function configureStorage(env) {
  if (!import_config.config.initializeStorage) {
    return;
  }
  const service = env.get(import_general.StorageService);
  env.vars.use(() => {
    service.location = env.vars.get("storage.path", env.vars.get("path.root", "."));
  });
  service.factory = (namespace) => new import_StorageBackendDisk.StorageBackendDisk((0, import_node_path.resolve)(service.location ?? ".", namespace), env.vars.get("storage.clear", false));
}
function configureNetwork(env) {
  env.set(import_general.Network, new import_NodeJsNetwork.NodeJsNetwork());
}
function loadConfigFile(vars) {
  const configPath = vars.get("path.config", "config.json");
  if (!(0, import_node_fs.existsSync)(configPath)) {
    return { configPath, configVars: {} };
  }
  let configJson;
  try {
    configJson = (0, import_node_fs.readFileSync)(configPath).toString();
  } catch (e) {
    throw new import_general.ImplementationError(`Error reading configuration file ${configPath}: ${(0, import_general.asError)(e).message}`);
  }
  let configVars;
  try {
    configVars = JSON.parse(configJson);
  } catch (e) {
    throw new import_general.ImplementationError(`Error parsing configuration file ${configPath}: ${(0, import_general.asError)(e).message}`);
  }
  return { configPath, configVars };
}
function getDefaultRoot(envName) {
  if (import_config.config.defaultStoragePath !== void 0) {
    return import_config.config.defaultStoragePath;
  }
  let matterDir;
  if (process.platform === "win32") {
    matterDir = (0, import_node_path.resolve)(process.env.APPDATA ?? ".", "matter");
  } else {
    matterDir = (0, import_node_path.resolve)(process.env.HOME ?? ".", ".matter");
  }
  if (envName !== "default") {
    matterDir = `${matterDir}-${envName}`;
  }
  return matterDir;
}
function getDefaults(vars) {
  const envName = vars.get("environment", import_config.config.defaultEnvironmentName);
  const rootPath = vars.get("path.root", getDefaultRoot(envName));
  const configPath = (0, import_node_path.resolve)(rootPath, vars.get("path.config", import_config.config.defaultConfigFilePath));
  return {
    environment: envName,
    path: {
      root: rootPath,
      config: configPath
    },
    runtime: {
      signals: import_config.config.trapProcessSignals,
      exitcode: import_config.config.setProcessExitCodeOnError,
      unhandlederrors: import_config.config.trapUnhandledErrors
    }
  };
}
//# sourceMappingURL=NodeJsEnvironment.js.map
