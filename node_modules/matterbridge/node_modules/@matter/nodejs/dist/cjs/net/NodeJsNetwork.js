"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var NodeJsNetwork_exports = {};
__export(NodeJsNetwork_exports, {
  NodeJsNetwork: () => NodeJsNetwork
});
module.exports = __toCommonJS(NodeJsNetwork_exports);
var import_general = require("#general");
var import_node_os = require("node:os");
var import_NodeJsUdpChannel = require("./NodeJsUdpChannel.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("NetworkNode");
class NodeJsNetwork extends import_general.Network {
  static getMulticastInterfaceIpv4(netInterface) {
    const netInterfaceInfo = (0, import_node_os.networkInterfaces)()[netInterface];
    if (netInterfaceInfo === void 0) throw new import_general.NetworkError(`Unknown interface: ${netInterface}`);
    for (const info of netInterfaceInfo) {
      if (familyIs(4, info)) {
        return info.address;
      }
    }
    return void 0;
  }
  static getMembershipMulticastInterfaces(netInterface, ipv4) {
    if (ipv4) {
      return [void 0];
    } else {
      let networkInterfaceEntries = Object.entries((0, import_node_os.networkInterfaces)());
      if (netInterface !== void 0) {
        networkInterfaceEntries = networkInterfaceEntries.filter(([name]) => name === netInterface);
      }
      const multicastInterfaces = networkInterfaceEntries.flatMap(([netInterface2, netInterfaceInfo]) => {
        if (netInterfaceInfo === void 0) return [];
        const zone = this.getNetInterfaceZoneIpv6Internal(netInterface2, netInterfaceInfo);
        return zone === void 0 ? [] : [`::%${zone}`];
      });
      if (multicastInterfaces.length === 0) {
        logger.warn(
          `No IPv6 multicast interface found${netInterface !== void 0 ? ` for interface ${netInterface}` : ""}.`
        );
      }
      return multicastInterfaces;
    }
  }
  static getNetInterfaceZoneIpv6(netInterface) {
    const netInterfaceInfo = (0, import_node_os.networkInterfaces)()[netInterface];
    if (netInterfaceInfo === void 0) throw new import_general.NetworkError(`Unknown interface: ${netInterface}`);
    return this.getNetInterfaceZoneIpv6Internal(netInterface, netInterfaceInfo);
  }
  static getNetInterfaceForIp(ip) {
    return this.netInterfaces.get(ip);
  }
  static netInterfaces = new import_general.Cache(
    "Network interface",
    (ip) => this.getNetInterfaceForRemoteAddress(ip),
    5 * 60 * 1e3
  );
  async close() {
    await NodeJsNetwork.netInterfaces.close();
  }
  static getNetInterfaceForRemoteAddress(ip) {
    if (ip.includes("%")) {
      return ip.split("%")[1];
    } else {
      const interfaces = (0, import_node_os.networkInterfaces)();
      for (const name in interfaces) {
        const netInterfaces = interfaces[name];
        for (const { address, netmask } of netInterfaces) {
          if ((0, import_general.onSameNetwork)(ip, address, netmask)) {
            return this.getNetInterfaceZoneIpv6Internal(name, netInterfaces);
          }
        }
      }
      if ((0, import_general.isIPv6)(ip)) {
        if (ip.startsWith("fd")) {
          return "";
        }
      }
      return void 0;
    }
  }
  static getNetInterfaceZoneIpv6Internal(netInterface, netInterfaceInfos) {
    if (process.platform !== "win32") {
      return netInterface;
    }
    if (netInterfaceInfos === void 0) return void 0;
    return netInterfaceInfos.find((info) => familyIs(6, info) && info.address.startsWith("fe80::"))?.scopeid?.toString();
  }
  /**
   * Get all network interfaces.
   * The optional configuration parameter allows to map interface names to types if this mapping is known.
   * Each network interface which has no mapped type is returned as Ethernet for now.
   *
   * @param configuration - An array of objects with the name and type properties.
   */
  getNetInterfaces(configuration = []) {
    const result = new Array();
    const interfaces = (0, import_node_os.networkInterfaces)();
    for (const name in interfaces) {
      const netInterfaces = interfaces[name];
      if (netInterfaces.length === 0) continue;
      if (netInterfaces[0].internal) continue;
      let type = import_general.InterfaceType.Ethernet;
      if (configuration.length > 0) {
        const nameType = configuration.find(({ name: mapName }) => name === mapName);
        if (nameType !== void 0 && nameType.type !== void 0) {
          type = nameType.type;
        }
      }
      result.push({ name, type });
    }
    return result;
  }
  getIpMac(netInterface) {
    const netInterfaceInfo = (0, import_node_os.networkInterfaces)()[netInterface];
    if (netInterfaceInfo === void 0) return void 0;
    const ipV4 = netInterfaceInfo.filter((info) => familyIs(4, info)).map(({ address }) => address);
    const ipV6 = netInterfaceInfo.filter((info) => familyIs(6, info)).map(({ address }) => address);
    return { mac: netInterfaceInfo[0].mac, ipV4, ipV6 };
  }
  createUdpChannel(options) {
    return import_NodeJsUdpChannel.NodeJsUdpChannel.create(options);
  }
}
function familyIs(version, { family }) {
  return family === `IPv${version}` || `${family}` === `${version}`;
}
//# sourceMappingURL=NodeJsNetwork.js.map
