"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var NodeJsUdpChannel_exports = {};
__export(NodeJsUdpChannel_exports, {
  NodeJsUdpChannel: () => NodeJsUdpChannel
});
module.exports = __toCommonJS(NodeJsUdpChannel_exports);
var import_general = require("#general");
var import_protocol = require("#protocol");
var dgram = __toESM(require("node:dgram"), 1);
var import_NodeJsNetwork = require("./NodeJsNetwork.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("NodejsChannel");
const UDP_SEND_TIMEOUT_CHECK_INTERVAL_MS = 1e3;
function createDgramSocket(host, port, options) {
  const socket = dgram.createSocket(options);
  return new Promise((resolve, reject) => {
    const handleBindError = (error) => {
      try {
        socket.close();
      } catch (error2) {
        logger.debug("Error closing socket", error2);
      }
      reject(error);
    };
    socket.on("error", handleBindError);
    socket.bind(port, host, () => {
      const { address: localHost, port: localPort } = socket.address();
      logger.debug(
        "Socket created and bound ",
        import_general.Diagnostic.dict({
          remoteAddress: `${host}:${port}`,
          localAddress: `${localHost}:${localPort}`
        })
      );
      socket.removeListener("error", handleBindError);
      socket.on("error", (error) => logger.error(error));
      resolve(socket);
    });
  });
}
class NodeJsUdpChannel {
  constructor(type, socket, netInterface) {
    this.type = type;
    this.socket = socket;
    this.netInterface = netInterface;
  }
  static async create({
    listeningPort,
    type,
    listeningAddress,
    netInterface,
    membershipAddresses
  }) {
    const socketOptions = { type, reuseAddr: true };
    if (type === "udp6") {
      socketOptions.ipv6Only = true;
    }
    const socket = await createDgramSocket(listeningAddress, listeningPort, socketOptions);
    socket.setBroadcast(true);
    let netInterfaceZone;
    if (netInterface !== void 0) {
      netInterfaceZone = import_NodeJsNetwork.NodeJsNetwork.getNetInterfaceZoneIpv6(netInterface);
      let multicastInterface;
      if (type === "udp4") {
        multicastInterface = import_NodeJsNetwork.NodeJsNetwork.getMulticastInterfaceIpv4(netInterface);
        if (multicastInterface === void 0) {
          throw new import_general.NoAddressAvailableError(`No IPv4 addresses on interface "${netInterface}"`);
        }
      } else {
        if (netInterfaceZone === void 0) {
          throw new import_general.NoAddressAvailableError(`No IPv6 addresses on interface "${netInterface}"`);
        }
        multicastInterface = `::%${netInterfaceZone}`;
      }
      logger.debug(
        "Initialize multicast",
        import_general.Diagnostic.dict({
          address: `${multicastInterface}:${listeningPort}`,
          interface: netInterface,
          type
        })
      );
      socket.setMulticastInterface(multicastInterface);
    }
    if (membershipAddresses !== void 0) {
      const multicastInterfaces = import_NodeJsNetwork.NodeJsNetwork.getMembershipMulticastInterfaces(netInterface, type === "udp4");
      for (const address of membershipAddresses) {
        for (const multicastInterface of multicastInterfaces) {
          try {
            socket.addMembership(address, multicastInterface);
          } catch (error) {
            logger.warn(
              `Error adding membership for address ${address}${multicastInterface ? ` with interface ${multicastInterface}` : ""}: ${error}`
            );
          }
        }
      }
    }
    return new NodeJsUdpChannel(type, socket, netInterfaceZone);
  }
  maxPayloadSize = import_general.MAX_UDP_MESSAGE_SIZE;
  /**
   * Timer for a maximum interval to check for dangling send calls that are not completed.
   * The way it is implemented we ensure that any "send" is rejected latest after < 2s
   */
  #sendTimer = import_general.Time.getTimer(
    "UDPChannel.send timeout check",
    UDP_SEND_TIMEOUT_CHECK_INTERVAL_MS,
    () => this.#rejectDanglingSends()
  );
  #sendsInProgress = /* @__PURE__ */ new Map();
  onData(listener) {
    const messageListener = (data, { address, port }) => {
      const netInterface = this.netInterface ?? import_NodeJsNetwork.NodeJsNetwork.getNetInterfaceForIp(address);
      listener(netInterface, address, port, data);
    };
    this.socket.on("message", messageListener);
    return {
      close: async () => {
        this.socket.removeListener("message", messageListener);
      }
    };
  }
  /**
   * At minimum once every second we check for dangling sends that are not completed. That means that a dangling send
   * is removed very latest after <2s.
   */
  #rejectDanglingSends() {
    if (this.#sendsInProgress.size === 0) {
      return;
    }
    const now = import_general.Time.nowMs();
    for (const [promise, { sendMs, rejecter }] of this.#sendsInProgress) {
      const elapsed = now - sendMs;
      if (elapsed >= UDP_SEND_TIMEOUT_CHECK_INTERVAL_MS) {
        this.#sendsInProgress.delete(promise);
        rejecter(new import_general.NetworkError("UDP send timeout"));
      }
    }
    if (this.#sendsInProgress.size > 0) {
      this.#sendTimer.start();
    }
  }
  async send(host, port, data) {
    const { promise, resolver, rejecter } = (0, import_general.createPromise)();
    const rejectOrResolve = (error) => {
      if (!this.#sendsInProgress.has(promise)) {
        return;
      }
      this.#sendsInProgress.delete(promise);
      if (!error) {
        resolver();
      } else {
        const netError = "code" in error && error.code === "EHOSTUNREACH" ? (0, import_general.repackErrorAs)(
          error,
          // TODO - this is a routing error; current error indicates timeout and is defined
          //        in higher-level module (MessageExchange)
          import_protocol.RetransmissionLimitReachedError
        ) : (0, import_general.repackErrorAs)(error, import_general.NetworkError);
        rejecter(netError);
      }
    };
    this.#sendsInProgress.set(promise, { sendMs: import_general.Time.nowMs(), rejecter });
    if (!this.#sendTimer.isRunning) {
      this.#sendTimer.start();
    }
    try {
      this.socket.send(data, port, host, (error) => rejectOrResolve(error));
    } catch (error) {
      rejectOrResolve((0, import_general.repackErrorAs)(error, import_general.NetworkError));
    }
    return promise;
  }
  async close() {
    try {
      this.socket.close();
    } catch (error) {
      if (!(error instanceof Error) || error.message !== "Not running") {
        logger.debug("Error on closing socket", error);
      }
    }
  }
  get port() {
    return this.socket.address().port;
  }
  supports(type, address) {
    if (type !== import_general.ChannelType.UDP) {
      return false;
    }
    if (address === void 0) {
      return true;
    }
    if (this.type === "udp4") {
      return (0, import_general.isIPv4)(address);
    }
    return (0, import_general.isIPv6)(address);
  }
}
//# sourceMappingURL=NodeJsUdpChannel.js.map
