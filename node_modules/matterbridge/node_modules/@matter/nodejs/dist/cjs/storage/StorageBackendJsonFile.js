"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var StorageBackendJsonFile_exports = {};
__export(StorageBackendJsonFile_exports, {
  StorageBackendJsonFile: () => StorageBackendJsonFile
});
module.exports = __toCommonJS(StorageBackendJsonFile_exports);
var import_general = require("#general");
var import_node_fs = require("node:fs");
var import_promises = require("node:fs/promises");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
class StorageBackendJsonFile extends import_general.StorageBackendMemory {
  constructor(path) {
    super();
    this.path = path;
  }
  /** We store changes after a value was set to the storage, but not more often than this setting (in ms). */
  static commitDelay = 1e3;
  committed = Promise.resolve();
  commitTimer = import_general.Time.getTimer(
    "Storage commit",
    StorageBackendJsonFile.commitDelay,
    () => this.commit()
  );
  closed = false;
  resolveCommitted;
  static async create(path) {
    const storage = new this(path);
    storage.initialize();
    return storage;
  }
  initialize() {
    if (this.initialized) throw new import_general.StorageError("Storage already initialized!");
    super.initialize();
    try {
      this.store = this.fromJson((0, import_node_fs.readFileSync)(this.path, "utf-8"));
    } catch (error) {
      if (error.code !== "ENOENT") {
        throw error;
      }
    }
    this.isInitialized = true;
  }
  triggerCommit() {
    if (!this.commitTimer.isRunning) {
      this.committed = new Promise((resolve) => {
        this.resolveCommitted = resolve;
      });
      this.commitTimer.start();
    }
  }
  set(contexts, keyOrValues, value) {
    super.set(contexts, keyOrValues, value);
    this.triggerCommit();
  }
  delete(contexts, key) {
    super.delete(contexts, key);
    this.triggerCommit();
  }
  clear() {
    super.clear();
    this.triggerCommit();
  }
  async commit() {
    if (!this.initialized || this.closed) return;
    if (this.commitTimer.isRunning) {
      this.commitTimer.stop();
    }
    try {
      await (0, import_promises.writeFile)(this.path, this.toJson(this.store), "utf-8");
    } finally {
      if (this.resolveCommitted !== void 0) {
        this.resolveCommitted?.();
      }
    }
  }
  async close() {
    this.commitTimer.stop();
    await this.commit();
    await super.close();
    this.closed = true;
    this.isInitialized = false;
  }
  toJson(object) {
    return (0, import_general.toJson)(object, 1);
  }
  fromJson(json) {
    return (0, import_general.fromJson)(json);
  }
}
//# sourceMappingURL=StorageBackendJsonFile.js.map
