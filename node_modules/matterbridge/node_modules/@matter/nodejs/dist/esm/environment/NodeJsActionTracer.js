/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { MaybePromise, serialize } from "#general";
import { ActionTracer } from "#node";
import { open } from "node:fs/promises";
import { resolve } from "node:path";
class NodeJsActionTracer extends ActionTracer {
  #path;
  #output;
  #write;
  constructor(path) {
    super();
    this.#path = path;
  }
  static configure(env) {
    env.vars.use(() => {
      if (env.has(ActionTracer)) {
        env.delete(env.get(ActionTracer).constructor);
      }
      if (!env.vars.boolean("trace.enable")) {
        return;
      }
      const path = resolve(env.vars.get("path.root", "."), env.vars.get("trace.path", "trace.jsonl"));
      const tracer = new NodeJsActionTracer(path);
      env.set(ActionTracer, tracer);
      env.runtime.add(tracer);
    });
  }
  [Symbol.asyncDispose]() {
    MaybePromise.then(this.#write, () => this.#output?.close());
  }
  record(action) {
    const raw = {
      ...action,
      path: action.path?.toString(false),
      mutations: action.mutations ? action.mutations.map((m) => ({ ...m, path: m.path.toString(false) })) : void 0
    };
    this.#write = MaybePromise.then(this.#write, () => this.#record(raw));
  }
  async #record(action) {
    if (this.#output === void 0) {
      this.#output = await open(this.#path, "w");
    }
    await this.#output.write(JSON.stringify(action, replacer));
    await this.#output.write("\n");
  }
}
function replacer(_key, value) {
  if (typeof value === "bigint" || ArrayBuffer.isView(value)) {
    return serialize(value);
  }
  return value;
}
export {
  NodeJsActionTracer
};
//# sourceMappingURL=NodeJsActionTracer.js.map
