/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { config } from "#config.js";
import {
  asError,
  Environment,
  ImplementationError,
  LogFormat,
  Logger,
  Network,
  StorageService
} from "#general";
import { existsSync, readFileSync } from "node:fs";
import { writeFile } from "node:fs/promises";
import { resolve } from "node:path";
import { NodeJsNetwork } from "../net/NodeJsNetwork.js";
import { StorageBackendDisk } from "../storage/StorageBackendDisk.js";
import { NodeJsActionTracer } from "./NodeJsActionTracer.js";
import { ProcessManager } from "./ProcessManager.js";
function NodeJsEnvironment() {
  const env = new Environment("default");
  loadVariables(env);
  configureRuntime(env);
  configureStorage(env);
  configureNetwork(env);
  if (!env.vars.has("logger.format") && Logger.format === LogFormat.PLAIN && process.stdin?.isTTY) {
    env.vars.set("logger.format", LogFormat.ANSI);
  }
  NodeJsActionTracer.configure(env);
  config.isInitialized = true;
  return env;
}
function loadVariables(env) {
  const vars = env.vars;
  vars.addConfigStyle(getDefaults(vars));
  if (config.loadProcessArgv) {
    vars.addUnixEnvStyle(process.env);
  }
  if (config.loadProcessEnv) {
    vars.addArgvStyle(process.argv);
  }
  const { configPath, configVars } = loadConfigFile(vars);
  if (config.loadConfigFile) {
    vars.addConfigStyle(configVars);
  }
  if (config.loadProcessArgv) {
    vars.addUnixEnvStyle(process.env);
  }
  if (config.loadProcessEnv) {
    vars.addArgvStyle(process.argv);
  }
  vars.persistConfigValue = async (name, value) => {
    if (value === void 0) {
      delete configVars[name];
    }
    configVars[name] = value;
    await writeFile(configPath, JSON.stringify(configVars, void 0, 4));
  };
}
function configureRuntime(env) {
  const processManager = new ProcessManager(env);
  env.set(ProcessManager, processManager);
}
function configureStorage(env) {
  if (!config.initializeStorage) {
    return;
  }
  const service = env.get(StorageService);
  env.vars.use(() => {
    service.location = env.vars.get("storage.path", env.vars.get("path.root", "."));
  });
  service.factory = (namespace) => new StorageBackendDisk(resolve(service.location ?? ".", namespace), env.vars.get("storage.clear", false));
}
function configureNetwork(env) {
  env.set(Network, new NodeJsNetwork());
}
function loadConfigFile(vars) {
  const configPath = vars.get("path.config", "config.json");
  if (!existsSync(configPath)) {
    return { configPath, configVars: {} };
  }
  let configJson;
  try {
    configJson = readFileSync(configPath).toString();
  } catch (e) {
    throw new ImplementationError(`Error reading configuration file ${configPath}: ${asError(e).message}`);
  }
  let configVars;
  try {
    configVars = JSON.parse(configJson);
  } catch (e) {
    throw new ImplementationError(`Error parsing configuration file ${configPath}: ${asError(e).message}`);
  }
  return { configPath, configVars };
}
function getDefaultRoot(envName) {
  if (config.defaultStoragePath !== void 0) {
    return config.defaultStoragePath;
  }
  let matterDir;
  if (process.platform === "win32") {
    matterDir = resolve(process.env.APPDATA ?? ".", "matter");
  } else {
    matterDir = resolve(process.env.HOME ?? ".", ".matter");
  }
  if (envName !== "default") {
    matterDir = `${matterDir}-${envName}`;
  }
  return matterDir;
}
function getDefaults(vars) {
  const envName = vars.get("environment", config.defaultEnvironmentName);
  const rootPath = vars.get("path.root", getDefaultRoot(envName));
  const configPath = resolve(rootPath, vars.get("path.config", config.defaultConfigFilePath));
  return {
    environment: envName,
    path: {
      root: rootPath,
      config: configPath
    },
    runtime: {
      signals: config.trapProcessSignals,
      exitcode: config.setProcessExitCodeOnError,
      unhandlederrors: config.trapUnhandledErrors
    }
  };
}
export {
  NodeJsEnvironment,
  getDefaults,
  loadConfigFile
};
//# sourceMappingURL=NodeJsEnvironment.js.map
