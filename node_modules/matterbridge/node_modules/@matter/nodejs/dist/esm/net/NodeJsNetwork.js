/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import {
  Cache,
  InterfaceType,
  isIPv6,
  Logger,
  Network,
  NetworkError,
  onSameNetwork
} from "#general";
import { networkInterfaces } from "node:os";
import { NodeJsUdpChannel } from "./NodeJsUdpChannel.js";
const logger = Logger.get("NetworkNode");
class NodeJsNetwork extends Network {
  static getMulticastInterfaceIpv4(netInterface) {
    const netInterfaceInfo = networkInterfaces()[netInterface];
    if (netInterfaceInfo === void 0) throw new NetworkError(`Unknown interface: ${netInterface}`);
    for (const info of netInterfaceInfo) {
      if (familyIs(4, info)) {
        return info.address;
      }
    }
    return void 0;
  }
  static getMembershipMulticastInterfaces(netInterface, ipv4) {
    if (ipv4) {
      return [void 0];
    } else {
      let networkInterfaceEntries = Object.entries(networkInterfaces());
      if (netInterface !== void 0) {
        networkInterfaceEntries = networkInterfaceEntries.filter(([name]) => name === netInterface);
      }
      const multicastInterfaces = networkInterfaceEntries.flatMap(([netInterface2, netInterfaceInfo]) => {
        if (netInterfaceInfo === void 0) return [];
        const zone = this.getNetInterfaceZoneIpv6Internal(netInterface2, netInterfaceInfo);
        return zone === void 0 ? [] : [`::%${zone}`];
      });
      if (multicastInterfaces.length === 0) {
        logger.warn(
          `No IPv6 multicast interface found${netInterface !== void 0 ? ` for interface ${netInterface}` : ""}.`
        );
      }
      return multicastInterfaces;
    }
  }
  static getNetInterfaceZoneIpv6(netInterface) {
    const netInterfaceInfo = networkInterfaces()[netInterface];
    if (netInterfaceInfo === void 0) throw new NetworkError(`Unknown interface: ${netInterface}`);
    return this.getNetInterfaceZoneIpv6Internal(netInterface, netInterfaceInfo);
  }
  static getNetInterfaceForIp(ip) {
    return this.netInterfaces.get(ip);
  }
  static netInterfaces = new Cache(
    "Network interface",
    (ip) => this.getNetInterfaceForRemoteAddress(ip),
    5 * 60 * 1e3
  );
  async close() {
    await NodeJsNetwork.netInterfaces.close();
  }
  static getNetInterfaceForRemoteAddress(ip) {
    if (ip.includes("%")) {
      return ip.split("%")[1];
    } else {
      const interfaces = networkInterfaces();
      for (const name in interfaces) {
        const netInterfaces = interfaces[name];
        for (const { address, netmask } of netInterfaces) {
          if (onSameNetwork(ip, address, netmask)) {
            return this.getNetInterfaceZoneIpv6Internal(name, netInterfaces);
          }
        }
      }
      if (isIPv6(ip)) {
        if (ip.startsWith("fd")) {
          return "";
        }
      }
      return void 0;
    }
  }
  static getNetInterfaceZoneIpv6Internal(netInterface, netInterfaceInfos) {
    if (process.platform !== "win32") {
      return netInterface;
    }
    if (netInterfaceInfos === void 0) return void 0;
    return netInterfaceInfos.find((info) => familyIs(6, info) && info.address.startsWith("fe80::"))?.scopeid?.toString();
  }
  /**
   * Get all network interfaces.
   * The optional configuration parameter allows to map interface names to types if this mapping is known.
   * Each network interface which has no mapped type is returned as Ethernet for now.
   *
   * @param configuration - An array of objects with the name and type properties.
   */
  getNetInterfaces(configuration = []) {
    const result = new Array();
    const interfaces = networkInterfaces();
    for (const name in interfaces) {
      const netInterfaces = interfaces[name];
      if (netInterfaces.length === 0) continue;
      if (netInterfaces[0].internal) continue;
      let type = InterfaceType.Ethernet;
      if (configuration.length > 0) {
        const nameType = configuration.find(({ name: mapName }) => name === mapName);
        if (nameType !== void 0 && nameType.type !== void 0) {
          type = nameType.type;
        }
      }
      result.push({ name, type });
    }
    return result;
  }
  getIpMac(netInterface) {
    const netInterfaceInfo = networkInterfaces()[netInterface];
    if (netInterfaceInfo === void 0) return void 0;
    const ipV4 = netInterfaceInfo.filter((info) => familyIs(4, info)).map(({ address }) => address);
    const ipV6 = netInterfaceInfo.filter((info) => familyIs(6, info)).map(({ address }) => address);
    return { mac: netInterfaceInfo[0].mac, ipV4, ipV6 };
  }
  createUdpChannel(options) {
    return NodeJsUdpChannel.create(options);
  }
}
function familyIs(version, { family }) {
  return family === `IPv${version}` || `${family}` === `${version}`;
}
export {
  NodeJsNetwork
};
//# sourceMappingURL=NodeJsNetwork.js.map
