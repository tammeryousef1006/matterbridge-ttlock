"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Read_exports = {};
__export(Read_exports, {
  Read: () => Read
});
module.exports = __toCommonJS(Read_exports);
var import_Session = require("#session/Session.js");
var import_general = require("@matter/general");
var import_MalformedRequestError = require("./MalformedRequestError.js");
var import_Specifier = require("./Specifier.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
function Read(optionsOrSelector, ...selectors) {
  let options;
  if ("kind" in optionsOrSelector) {
    selectors = [optionsOrSelector, ...selectors];
    options = {};
  } else {
    options = optionsOrSelector;
  }
  let { attributes: attributeRequests, versionFilters, events: eventRequests, eventFilters } = options;
  const result = {
    isFabricFiltered: options.fabricFilter ?? true,
    interactionModelRevision: options.interactionModelRevision ?? import_Session.FALLBACK_INTERACTIONMODEL_REVISION
  };
  for (const selector of selectors) {
    reifySelector(selector);
  }
  if (!attributeRequests?.length && !eventRequests?.length) {
    throw new import_MalformedRequestError.MalformedRequestError(`Read action designates no attributes or events`);
  }
  if (attributeRequests) {
    result.attributeRequests = attributeRequests;
  }
  if (versionFilters) {
    result.dataVersionFilters = versionFilters;
  }
  if (eventRequests) {
    result.eventRequests = eventRequests;
  }
  if (eventFilters !== void 0) {
    result.eventFilters = eventFilters;
  }
  return result;
  function reifySelector(selector) {
    switch (selector.kind) {
      case "attribute":
        reifyAttributeSelector(selector);
        break;
      case "event":
        reifyEventSelector(selector);
        break;
      default:
        throw new import_MalformedRequestError.MalformedRequestError(`Invalid selector kind "${selector.kind}"`);
    }
  }
  function reifyAttributeSelector(selector) {
    const cluster = import_Specifier.Specifier.clusterOf(selector);
    const { endpoint } = selector;
    if (typeof endpoint === "object" && endpoint?.versions && typeof cluster === "object" && cluster !== null) {
      const version = endpoint.versions?.[(0, import_general.camelize)(cluster.name)];
      if (version !== void 0) {
        const filter = {
          path: { endpointId: endpoint.number, clusterId: cluster.id },
          dataVersion: version
        };
        if (versionFilters === void 0) {
          versionFilters = [filter];
        } else if (versionFilters.find(
          ({ path: { endpointId, clusterId } }) => endpointId === endpoint.number && clusterId === cluster.id
        ) === void 0) {
          versionFilters.push(filter);
        }
      }
    }
    if (attributeRequests === void 0) {
      attributeRequests = [];
    }
    const prototype = {};
    if (endpoint !== void 0) {
      prototype.endpointId = import_Specifier.Specifier.endpointIdOf(selector);
    }
    if (cluster !== void 0) {
      prototype.clusterId = cluster.id;
    }
    let { attributes } = selector;
    if (attributes === void 0) {
      attributeRequests.push(prototype);
      return;
    }
    if (!Array.isArray(attributes)) {
      attributes = [attributes];
    }
    for (const specifier of attributes) {
      attributeRequests.push({ ...prototype, attributeId: import_Specifier.Specifier.attributeFor(cluster, specifier).id });
    }
  }
  function reifyEventSelector(selector) {
    const cluster = import_Specifier.Specifier.clusterOf(selector);
    const { endpoint } = selector;
    if (typeof endpoint === "object" && endpoint.minEvent !== void 0) {
      if (eventFilters === void 0) {
        eventFilters = [{ eventMin: endpoint.minEvent }];
      }
    }
    if (eventRequests === void 0) {
      eventRequests = [];
    }
    const prototype = {};
    if (endpoint !== void 0) {
      prototype.endpointId = import_Specifier.Specifier.endpointIdOf(selector);
    }
    if (cluster !== void 0) {
      prototype.clusterId = cluster.id;
    }
    let { events } = selector;
    if (events === void 0) {
      eventRequests.push(prototype);
      return;
    }
    if (!Array.isArray(events)) {
      events = [events];
    }
    for (const specifier of events) {
      eventRequests.push({ ...prototype, eventId: import_Specifier.Specifier.eventFor(cluster, specifier).id });
    }
  }
}
((Read2) => {
  function isAttribute(request) {
    return !!request.attributeRequests?.length;
  }
  Read2.isAttribute = isAttribute;
  function isEvent(request) {
    return !!request.eventRequests?.length;
  }
  Read2.isEvent = isEvent;
  function Attribute(selector) {
    return {
      kind: "attribute",
      ...selector
    };
  }
  Read2.Attribute = Attribute;
  function Event(selector) {
    return {
      kind: "event",
      ...selector
    };
  }
  Read2.Event = Event;
})(Read || (Read = {}));
//# sourceMappingURL=Read.js.map
