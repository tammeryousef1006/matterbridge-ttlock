"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var AccessControl_exports = {};
__export(AccessControl_exports, {
  AccessControl: () => AccessControl
});
module.exports = __toCommonJS(AccessControl_exports);
var import_model = require("#model");
var import_types = require("#types");
var import_errors = require("../errors.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const cache = /* @__PURE__ */ new WeakMap();
function AccessControl(schema) {
  let enforcer = cache.get(schema);
  if (enforcer === void 0) {
    enforcer = enforcerFor(schema);
  }
  return enforcer;
}
((AccessControl2) => {
  let Authority;
  ((Authority2) => {
    Authority2[Authority2["Granted"] = 1] = "Granted";
    Authority2[Authority2["Unauthorized"] = 2] = "Unauthorized";
    Authority2[Authority2["Restricted"] = 3] = "Restricted";
  })(Authority = AccessControl2.Authority || (AccessControl2.Authority = {}));
})(AccessControl || (AccessControl = {}));
Object.freeze(AccessControl);
Object.freeze(AccessControl.Authority);
function enforcerFor(schema) {
  if (schema.tag === import_model.ElementTag.Command) {
    return commandEnforcerFor(schema);
  }
  return dataEnforcerFor(schema);
}
function dataEnforcerFor(schema) {
  const limits = limitsFor(schema);
  let mayRead = (session, location) => {
    if (session.offline || session.command) {
      return true;
    }
    return session.authorityAt(limits.readLevel, location) === 1 /* Granted */;
  };
  let mayWrite = (session, location) => {
    if (session.offline || session.command) {
      return true;
    }
    return session.authorityAt(limits.writeLevel, location) === 1 /* Granted */;
  };
  let authorizeRead = (session, location) => {
    if (session.offline || session.command) {
      return;
    }
    if (session.authorityAt(limits.readLevel, location) === 1 /* Granted */) {
      return;
    }
    throw new import_errors.ReadError(location, "Permission denied", import_types.StatusCode.UnsupportedAccess);
  };
  let authorizeWrite = (session, location) => {
    if (session.offline || session.command) {
      return;
    }
    if (session.authorityAt(limits.writeLevel, location) === 1 /* Granted */) {
      return;
    }
    throw new import_errors.WriteError(location, "Permission denied", import_types.StatusCode.UnsupportedAccess);
  };
  if (limits.timed) {
    const wrappedAuthorizeWrite = authorizeWrite;
    const wrappedMayWrite = mayWrite;
    authorizeWrite = (session, location) => {
      if (!session.offline && !session.timed) {
        throw new import_errors.WriteError(
          location,
          "Permission denied because interaction is not timed",
          import_types.StatusCode.NeedsTimedInteraction
        );
      }
      wrappedAuthorizeWrite?.(session, location);
    };
    mayWrite = (session, location) => {
      if (!session.offline && !session.timed) {
        return false;
      }
      return wrappedMayWrite(session, location);
    };
  }
  if (limits.fabricSensitive) {
    const wrappedAuthorizeRead = authorizeRead;
    const wrappedMayRead = mayRead;
    const wrappedAuthorizeWrite = authorizeWrite;
    const wrappedMayWrite = mayWrite;
    authorizeRead = (session, location) => {
      if (session.offline || session.command) {
        return;
      }
      if (session.fabricFiltered) {
        if (session.fabric === void 0) {
          throw new import_errors.ReadError(
            location,
            "Permission denied: No accessing fabric",
            import_types.StatusCode.UnsupportedAccess
          );
        }
        if (location?.owningFabric && location.owningFabric !== session.fabric) {
          throw new import_errors.ReadError(
            location,
            "Permission denied: Owning/accessing fabric mismatch",
            import_types.StatusCode.UnsupportedAccess
          );
        }
      }
      wrappedAuthorizeRead(session, location);
    };
    mayRead = (session, location) => {
      if (session.offline || session.command) {
        return true;
      }
      if (session.fabric === void 0) {
        return false;
      }
      if (location?.owningFabric && location.owningFabric !== session.fabric) {
        return false;
      }
      return wrappedMayRead(session, location);
    };
    authorizeWrite = (session, location) => {
      if (session.offline || session.command) {
        return;
      }
      if (session.fabric === void 0) {
        throw new import_errors.WriteError(location, "Permission denied: No accessing fabric", import_types.StatusCode.UnsupportedAccess);
      }
      if (location?.owningFabric && location.owningFabric !== session.fabric) {
        throw new import_errors.WriteError(location, "Permission denied: Owning/accessing fabric mismatch");
      }
      wrappedAuthorizeWrite(session, location);
    };
    mayWrite = (session, location) => {
      if (session.offline || session.command) {
        return true;
      }
      if (session.fabric === void 0) {
        return false;
      }
      if (location?.owningFabric && location.owningFabric !== session.fabric) {
        return false;
      }
      return wrappedMayWrite(session, location);
    };
  }
  if (!limits.readable) {
    authorizeRead = (session, location) => {
      if (session.offline || session.command) {
        return;
      }
      throw new import_errors.ReadError(location, "Permission defined: Value is write-only");
    };
    mayRead = (session) => {
      return !!session.offline || !!session.command;
    };
  }
  if (!limits.writable) {
    authorizeWrite = (session, location) => {
      if (session.offline || session.command) {
        return;
      }
      throw new import_errors.WriteError(location, "Permission denied: Value is read-only");
    };
    mayWrite = (session) => {
      return !!session.offline || !!session.command;
    };
  }
  return Object.freeze({
    limits,
    authorizeRead,
    mayRead,
    authorizeWrite,
    mayWrite,
    authorizeInvoke(_session, location) {
      throw new import_errors.SchemaImplementationError(location, "Permission denied: Invoke request but non-command schema");
    },
    mayInvoke() {
      return false;
    }
  });
}
function commandEnforcerFor(schema) {
  const limits = limitsFor(schema);
  const timed = schema.effectiveAccess.timed;
  const fabric = schema.effectiveAccess.fabric;
  return {
    limits,
    authorizeRead(_session, location) {
      throw new import_errors.SchemaImplementationError(location, "Permission denied: Read request but command schema");
    },
    mayRead() {
      return false;
    },
    authorizeWrite(_session, location) {
      throw new import_errors.SchemaImplementationError(location, "Permission denied: Write request but command schema");
    },
    mayWrite() {
      return false;
    },
    authorizeInvoke(session, location) {
      if (session.offline) {
        return;
      }
      if (!session.command) {
        throw new import_errors.InvokeError(location, "Invoke attempt without command context");
      }
      if (timed && !session.timed) {
        throw new import_errors.InvokeError(
          location,
          "Invoke attempt without required timed context",
          import_types.StatusCode.TimedRequestMismatch
        );
      }
      if (fabric && session.fabric === void 0) {
        throw new import_errors.WriteError(location, "Permission denied: No accessing fabric", import_types.StatusCode.UnsupportedAccess);
      }
      if (session.authorityAt(limits.writeLevel, location) === 1 /* Granted */) {
        return;
      }
      throw new import_errors.InvokeError(location, "Permission denied", import_types.StatusCode.UnsupportedAccess);
    },
    mayInvoke(session, location) {
      if (session.offline) {
        return true;
      }
      if (!session.command) {
        return false;
      }
      if (timed && !session.timed) {
        return false;
      }
      if (fabric && session.fabric === void 0) {
        return false;
      }
      return session.authorityAt(limits.writeLevel, location) === 1 /* Granted */;
    }
  };
}
function limitsFor(schema) {
  const access = schema.effectiveAccess;
  const quality = schema instanceof import_model.ValueModel ? schema.effectiveQuality : void 0;
  let fixed = quality?.fixed;
  for (let s = schema.parent; !fixed && s instanceof import_model.ValueModel; s = s.parent) {
    if (s.effectiveQuality.fixed) {
      fixed = true;
    }
  }
  const limits = Object.freeze({
    readable: access.readable,
    writable: access.writable && !fixed,
    fabricScoped: access.fabric === import_model.Access.Fabric.Scoped || access.fabric === import_model.Access.Fabric.Sensitive,
    fabricSensitive: access.fabric === import_model.Access.Fabric.Sensitive,
    timed: access.timed === true,
    // Official Matter defaults are View for read and Operate for write. However, the schema's effective access
    // should already have these defaults.  Here we just adopt minimum needed rights as a safe fallback access level.
    readLevel: access.readPriv === void 0 ? import_model.AccessLevel.View : import_model.Access.PrivilegeLevel[access.readPriv],
    writeLevel: access.writePriv === void 0 ? import_model.AccessLevel.Operate : import_model.Access.PrivilegeLevel[access.writePriv]
  });
  return limits;
}
//# sourceMappingURL=AccessControl.js.map
