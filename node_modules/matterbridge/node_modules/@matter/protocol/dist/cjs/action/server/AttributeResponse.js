"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var AttributeResponse_exports = {};
__export(AttributeResponse_exports, {
  AttributeResponse: () => AttributeResponse,
  FallbackLimits: () => FallbackLimits,
  GlobalAttrIds: () => GlobalAttrIds,
  WildcardPathFlagsCodec: () => WildcardPathFlagsCodec
});
module.exports = __toCommonJS(AttributeResponse_exports);
var import_AccessControl = require("#action/server/AccessControl.js");
var import_general = require("#general");
var import_model = require("#model");
var import_types = require("#types");
/**
 * @license
 * Copyright 2022-2025 Project CHIP Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const GlobalAttrIds = new Set(Object.values(import_types.GlobalAttributes).map((attr) => attr.id));
const WildcardPathFlagsCodec = (0, import_types.BitmapSchema)(import_types.WildcardPathFlagsBitmap);
const FallbackLimits = {
  fabricScoped: false,
  fabricSensitive: false,
  readable: true,
  readLevel: import_model.AccessLevel.View,
  timed: false,
  writable: true,
  writeLevel: import_model.AccessLevel.Administer
};
class AttributeResponse {
  // Configuration
  #session;
  #node;
  #versions;
  // Each input AttributePathIB that does not have an error installs a producer.  Producers run after validation and
  // generate actual attribute data
  #dataProducers;
  // The initial "chunk" may be a list of errors.  As producers execute it is a set of records associated with the
  // most recently touched endpoint.  When the endpoint changes the previous chunk emits
  #chunk;
  // The following state updates as data producers execute.  This serves both to convey state between functions and as
  // a cache between producers that touch the same endpoint and/or cluster
  #currentEndpoint;
  #currentCluster;
  #currentState;
  #wildcardPathFlags = 0;
  // The node ID may be expensive to retrieve and is invariant so we cache it here
  #cachedNodeId;
  constructor(node, session, { dataVersionFilters, attributeRequests }) {
    this.#node = node;
    this.#session = session;
    const nodeId = session.fabric === void 0 ? import_types.NodeId.UNSPECIFIED_NODE_ID : this.#nodeId;
    if (dataVersionFilters?.length) {
      this.#versions = {};
      for (const {
        path: { nodeId: filterNodeId, endpointId, clusterId },
        dataVersion
      } of dataVersionFilters) {
        if (filterNodeId !== void 0 && filterNodeId !== nodeId) {
          continue;
        }
        if (typeof endpointId !== "number") {
          continue;
        }
        (this.#versions[endpointId] ?? (this.#versions[endpointId] = {}))[clusterId] = dataVersion;
      }
    }
    for (const path of attributeRequests) {
      if (path.endpointId === void 0 || path.clusterId === void 0 || path.attributeId === void 0) {
        this.#addWildcard(path);
      } else {
        this.#addConcrete(path);
      }
    }
  }
  /**
   * Emits chunks produced by paths added via {@link #addWildcard} and {@link #addConcrete}.
   */
  *[Symbol.iterator]() {
    if (this.#dataProducers) {
      for (const producer of this.#dataProducers) {
        yield* producer.apply(this);
      }
    }
    if (this.#chunk !== void 0) {
      yield this.#chunk;
    }
  }
  /**
   * Validate a wildcard path and update internal state.
   */
  #addWildcard(path) {
    const { nodeId, endpointId, clusterId, attributeId, wildcardPathFlags } = path;
    if (nodeId !== void 0 && nodeId !== this.#nodeId) {
      return;
    }
    const wpf = wildcardPathFlags ? WildcardPathFlagsCodec.encode(wildcardPathFlags) : 0;
    if (clusterId === void 0 && attributeId !== void 0 && !GlobalAttrIds.has(attributeId)) {
      throw new import_types.StatusResponseError(
        `Illegal read of wildcard cluster with non-global attribute #${attributeId}`,
        import_types.Status.InvalidAction
      );
    }
    if (endpointId === void 0) {
      this.#addProducer(function* () {
        this.#wildcardPathFlags = wpf;
        for (const endpoint2 of this.#node) {
          yield* this.#readEndpointForWildcard(endpoint2, path);
        }
      });
      return;
    }
    const endpoint = this.#node[endpointId];
    if (endpoint) {
      this.#addProducer(function() {
        this.#wildcardPathFlags = wpf;
        return this.#readEndpointForWildcard(endpoint, path);
      });
    }
  }
  /**
   * Validate a concrete path and update internal state.
   */
  #addConcrete(path) {
    const { nodeId, endpointId, clusterId, attributeId } = path;
    if (nodeId !== void 0 && this.#nodeId !== nodeId) {
      this.#addStatus(path, import_types.Status.UnsupportedNode);
    }
    const endpoint = this.#node[endpointId];
    const cluster = endpoint?.[clusterId];
    const attribute = cluster?.type.attributes[attributeId];
    let limits;
    if (attribute === void 0) {
      const modelAttr = this.#node.matter.member(path.clusterId, [import_model.ElementTag.Cluster])?.member(path.attributeId, [import_model.ElementTag.Attribute]);
      if (modelAttr) {
        limits = (0, import_AccessControl.AccessControl)(modelAttr).limits;
      } else {
        limits = FallbackLimits;
      }
    } else {
      limits = attribute.limits;
    }
    switch (this.#session.authorityAt(limits.readLevel)) {
      case import_AccessControl.AccessControl.Authority.Granted:
        break;
      case import_AccessControl.AccessControl.Authority.Unauthorized:
        this.#addStatus(path, import_types.Status.UnsupportedAccess);
        return;
      case import_AccessControl.AccessControl.Authority.Restricted:
        this.#addStatus(path, import_types.Status.AccessRestricted);
        return;
      default:
        throw new import_general.InternalError(
          `Unsupported authorization state ${this.#session.authorityAt(limits.readLevel)}`
        );
    }
    if (endpoint === void 0) {
      this.#addStatus(path, import_types.Status.UnsupportedEndpoint);
      return;
    }
    if (cluster === void 0) {
      this.#addStatus(path, import_types.Status.UnsupportedCluster);
      return;
    }
    if (attribute === void 0) {
      this.#addStatus(path, import_types.Status.UnsupportedAttribute);
      return;
    }
    if (!limits.readable) {
      this.#addStatus(path, import_types.Status.UnsupportedRead);
      return;
    }
    const skipVersion = this.#versions?.[path.endpointId]?.[path.clusterId];
    if (skipVersion !== void 0 && skipVersion === cluster.version) {
      return;
    }
    this.#addProducer(function* () {
      if (this.#currentEndpoint !== endpoint) {
        if (this.#chunk) {
          yield this.#chunk;
          this.#chunk = void 0;
        }
        this.#currentEndpoint = endpoint;
        this.#currentCluster = cluster;
        this.#currentState = cluster.open(this.#session);
      } else if (this.#currentCluster !== cluster) {
        this.#currentCluster = cluster;
        this.#currentState = cluster.open(this.#session);
      } else if (this.#currentState === void 0) {
        this.#currentState = cluster.open(this.#session);
      }
      this.#addValue(path, this.#currentState);
    });
  }
  /**
   * Starts new chunk or adds to current chunk all values from {@link endpoint} selected by {@link path}.
   *
   * Emits previous chunk if it exists and was not for this endpoint.  This means that our chunk size is one endpoint
   * worth of data, except for the initial error chunk if there are path errors.
   *
   * {@link this.#wildcardPathFlags} to numeric bitmap must be set prior to invocation.
   *
   * TODO - skip endpoints for which subject is unauthorized
   */
  *#readEndpointForWildcard(endpoint, path) {
    if (endpoint.wildcardPathFlags & this.#wildcardPathFlags) {
      return;
    }
    if (this.#currentEndpoint !== endpoint) {
      if (this.#chunk) {
        yield this.#chunk;
        this.#chunk = void 0;
      }
      this.#currentEndpoint = endpoint;
      this.#currentCluster = void 0;
    }
    const { clusterId } = path;
    if (clusterId === void 0) {
      for (const cluster of endpoint) {
        this.#readClusterForWildcard(cluster, path);
      }
    } else {
      const cluster = endpoint[clusterId];
      if (cluster !== void 0) {
        this.#readClusterForWildcard(cluster, path);
      }
    }
  }
  /**
   * Read values from a specific {@link cluster} for a wildcard path.
   *
   * Depends on state initialized by {@link #readEndpointForWildcard}.
   *
   * TODO - skip clusters for which subject is unauthorized
   */
  #readClusterForWildcard(cluster, path) {
    if (cluster.type.wildcardPathFlags & this.#wildcardPathFlags) {
      return;
    }
    if (this.#currentCluster !== cluster) {
      this.#currentCluster = cluster;
      this.#currentState = void 0;
    }
    const skipVersion = this.#versions?.[this.#currentEndpoint.id]?.[cluster.type.id];
    if (skipVersion !== void 0 && skipVersion === cluster.version) {
      return;
    }
    const { attributeId } = path;
    if (attributeId === void 0) {
      for (const attribute of cluster.type.attributes) {
        this.#readAttributeForWildcard(attribute, path);
      }
    } else {
      const attribute = cluster.type.attributes[attributeId];
      if (attribute !== void 0) {
        this.#readAttributeForWildcard(attribute, path);
      }
    }
  }
  /**
   * Read values from a specific {@link attribute} for a wildcard path.
   *
   * Depends on state initialized by {@link #readClusterForWildcard}.
   */
  #readAttributeForWildcard(attribute, path) {
    if (attribute.wildcardPathFlags & this.#wildcardPathFlags) {
      return;
    }
    if (!attribute.limits.readable || this.#session.authorityAt(attribute.limits.readLevel, this.#currentCluster.location) !== import_AccessControl.AccessControl.Authority.Granted) {
      return;
    }
    if (this.#currentState === void 0) {
      this.#currentState = this.#currentCluster.open(this.#session);
    }
    this.#addValue(
      {
        ...path,
        endpointId: this.#currentEndpoint?.id,
        clusterId: this.#currentCluster?.type.id,
        attributeId: attribute.id
      },
      this.#currentState[attribute.id]
    );
  }
  /**
   * Add a function that produces data.  These functions are run after validation of input paths.
   */
  #addProducer(producer) {
    if (this.#dataProducers) {
      this.#dataProducers.push(producer);
    } else {
      this.#dataProducers = [producer];
    }
  }
  /**
   * Add a status value.
   */
  #addStatus(path, status) {
    const report = {
      kind: "attr-status",
      path,
      status
    };
    if (this.#chunk) {
      this.#chunk.push(report);
    } else {
      this.#chunk = [report];
    }
  }
  /**
   * Add an attribute value.
   */
  #addValue(path, value) {
    const report = {
      kind: "attr-value",
      path,
      value
    };
    if (this.#chunk) {
      this.#chunk.push(report);
    } else {
      this.#chunk = [report];
    }
  }
  /**
   * The node ID used to filter paths with node ID specified.  Unsure if this is ever actually used.
   */
  get #nodeId() {
    if (this.#cachedNodeId === void 0) {
      this.#cachedNodeId = (this.#session.fabric && this.#node.nodeIdFor(this.#session.fabric)) ?? import_types.NodeId.UNSPECIFIED_NODE_ID;
    }
    return this.#cachedNodeId;
  }
}
//# sourceMappingURL=AttributeResponse.js.map
