/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Key, MatterError } from "#general";
import { BitFlag, CaseAuthenticatedTag, FabricId, NodeId, TypeFromPartialBitSchema, TypeFromSchema, VendorId } from "#types";
export declare class CertificateError extends MatterError {
}
export declare function matterToJsDate(date: number): Date;
export declare function jsToMatterDate(date: Date, addYears?: number): number;
/** matter-node-id = ASN.1 OID 1.3.6.1.4.1.37244.1.1 */
export declare const NodeId_Matter: (value: NodeId) => any[];
/** matter-firmware-signing-id = ASN.1 OID 1.3.6.1.4.1.37244.1.2 */
export declare const FirmwareSigningId_Matter: (value: number) => any[];
/** matter-icac-id = ASN.1 OID 1.3.6.1.4.1.37244.1.3 */
export declare const IcacId_Matter: (value: number | bigint) => any[];
/** matter-rcac-id = ASN.1 OID 1.3.6.1.4.1.37244.1.4 */
export declare const RcacId_Matter: (value: number | bigint) => any[];
/** matter-fabric-id = ASN.1 OID 1.3.6.1.4.1.37244.1.5 */
export declare const FabricId_Matter: (value: FabricId) => any[];
/** matter-noc-cat = ASN.1 OID 1.3.6.1.4.1.37244.1.6 */
export declare const NocCat_Matter: (value: number) => any[];
/** matter-oid-vid = ASN.1 OID 1.3.6.1.4.1.37244.2.1 */
export declare const VendorId_Matter: (value: VendorId) => any[];
/** matter-oid-pid = ASN.1 OID 1.3.6.1.4.1.37244.2.2 */
export declare const ProductId_Matter: (value: number) => any[];
declare const ExtensionKeyUsageBitmap: {
    digitalSignature: BitFlag;
    nonRepudiation: BitFlag;
    keyEncipherment: BitFlag;
    dataEncipherment: BitFlag;
    keyAgreement: BitFlag;
    keyCertSign: BitFlag;
    cRLSign: BitFlag;
    encipherOnly: BitFlag;
    decipherOnly: BitFlag;
};
export declare const TlvRootCertificate: import("#types").ObjectSchemaWithMaxSize<{
    serialNumber: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
    signatureAlgorithm: import("#types").FieldType<number>;
    issuer: import("#types").FieldType<import("#types").TypeFromFields<{
        commonName: import("#types").OptionalFieldType<string>;
        sureName: import("#types").OptionalFieldType<string>;
        serialNum: import("#types").OptionalFieldType<string>;
        countryName: import("#types").OptionalFieldType<string>;
        localityName: import("#types").OptionalFieldType<string>;
        stateOrProvinceName: import("#types").OptionalFieldType<string>;
        orgName: import("#types").OptionalFieldType<string>;
        orgUnitName: import("#types").OptionalFieldType<string>;
        title: import("#types").OptionalFieldType<string>;
        name: import("#types").OptionalFieldType<string>;
        givenName: import("#types").OptionalFieldType<string>;
        initials: import("#types").OptionalFieldType<string>;
        genQualifier: import("#types").OptionalFieldType<string>;
        dnQualifier: import("#types").OptionalFieldType<string>;
        pseudonym: import("#types").OptionalFieldType<string>;
        domainComponent: import("#types").OptionalFieldType<string>;
    } & {
        nodeId: import("#types").OptionalFieldType<NodeId>;
        firmwareSigningId: import("#types").OptionalFieldType<number>;
        icacId: import("#types").OptionalFieldType<number | bigint>;
        rcacId: import("#types").OptionalFieldType<number | bigint>;
        fabricId: import("#types").OptionalFieldType<FabricId>;
        caseAuthenticatedTags: import("#types").OptionalRepeatedFieldType<CaseAuthenticatedTag[]>;
    } & {
        commonNamePs: import("#types").OptionalFieldType<string>;
        sureNamePs: import("#types").OptionalFieldType<string>;
        serialNumPs: import("#types").OptionalFieldType<string>;
        countryNamePs: import("#types").OptionalFieldType<string>;
        localityNamePs: import("#types").OptionalFieldType<string>;
        stateOrProvinceNamePs: import("#types").OptionalFieldType<string>;
        orgNamePs: import("#types").OptionalFieldType<string>;
        orgUnitNamePs: import("#types").OptionalFieldType<string>;
        titlePs: import("#types").OptionalFieldType<string>;
        namePs: import("#types").OptionalFieldType<string>;
        givenNamePs: import("#types").OptionalFieldType<string>;
        initialsPs: import("#types").OptionalFieldType<string>;
        genQualifierPs: import("#types").OptionalFieldType<string>;
        dnQualifierPs: import("#types").OptionalFieldType<string>;
        pseudonymPs: import("#types").OptionalFieldType<string>;
    }>>;
    notBefore: import("#types").FieldType<number>;
    notAfter: import("#types").FieldType<number>;
    subject: import("#types").FieldType<import("#types").TypeFromFields<{
        commonName: import("#types").OptionalFieldType<string>;
        sureName: import("#types").OptionalFieldType<string>;
        serialNum: import("#types").OptionalFieldType<string>;
        countryName: import("#types").OptionalFieldType<string>;
        localityName: import("#types").OptionalFieldType<string>;
        stateOrProvinceName: import("#types").OptionalFieldType<string>;
        orgName: import("#types").OptionalFieldType<string>;
        orgUnitName: import("#types").OptionalFieldType<string>;
        title: import("#types").OptionalFieldType<string>;
        name: import("#types").OptionalFieldType<string>;
        givenName: import("#types").OptionalFieldType<string>;
        initials: import("#types").OptionalFieldType<string>;
        genQualifier: import("#types").OptionalFieldType<string>;
        dnQualifier: import("#types").OptionalFieldType<string>;
        pseudonym: import("#types").OptionalFieldType<string>;
        domainComponent: import("#types").OptionalFieldType<string>;
    } & {
        rcacId: import("#types").FieldType<number | bigint>;
        fabricId: import("#types").OptionalFieldType<FabricId>;
    } & {
        commonNamePs: import("#types").OptionalFieldType<string>;
        sureNamePs: import("#types").OptionalFieldType<string>;
        serialNumPs: import("#types").OptionalFieldType<string>;
        countryNamePs: import("#types").OptionalFieldType<string>;
        localityNamePs: import("#types").OptionalFieldType<string>;
        stateOrProvinceNamePs: import("#types").OptionalFieldType<string>;
        orgNamePs: import("#types").OptionalFieldType<string>;
        orgUnitNamePs: import("#types").OptionalFieldType<string>;
        titlePs: import("#types").OptionalFieldType<string>;
        namePs: import("#types").OptionalFieldType<string>;
        givenNamePs: import("#types").OptionalFieldType<string>;
        initialsPs: import("#types").OptionalFieldType<string>;
        genQualifierPs: import("#types").OptionalFieldType<string>;
        dnQualifierPs: import("#types").OptionalFieldType<string>;
        pseudonymPs: import("#types").OptionalFieldType<string>;
    }>>;
    publicKeyAlgorithm: import("#types").FieldType<number>;
    ellipticCurveIdentifier: import("#types").FieldType<number>;
    ellipticCurvePublicKey: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
    extensions: import("#types").FieldType<import("#types").TypeFromFields<{
        basicConstraints: import("#types").FieldType<import("#types").TypeFromFields<{
            isCa: import("#types").FieldType<boolean>;
            pathLen: import("#types").OptionalFieldType<number>;
        }>>;
        keyUsage: import("#types").FieldType<TypeFromPartialBitSchema<{
            digitalSignature: BitFlag;
            nonRepudiation: BitFlag;
            keyEncipherment: BitFlag;
            dataEncipherment: BitFlag;
            keyAgreement: BitFlag;
            keyCertSign: BitFlag;
            cRLSign: BitFlag;
            encipherOnly: BitFlag;
            decipherOnly: BitFlag;
        }>>;
        extendedKeyUsage: import("#types").OptionalFieldType<number[]>;
        subjectKeyIdentifier: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
        authorityKeyIdentifier: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
        futureExtension: import("#types").OptionalRepeatedFieldType<Uint8Array<ArrayBufferLike>[]>;
    }>>;
    signature: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
}>;
export declare const TlvOperationalCertificate: import("#types").ObjectSchemaWithMaxSize<{
    serialNumber: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
    signatureAlgorithm: import("#types").FieldType<number>;
    issuer: import("#types").FieldType<import("#types").TypeFromFields<{
        commonName: import("#types").OptionalFieldType<string>;
        sureName: import("#types").OptionalFieldType<string>;
        serialNum: import("#types").OptionalFieldType<string>;
        countryName: import("#types").OptionalFieldType<string>;
        localityName: import("#types").OptionalFieldType<string>;
        stateOrProvinceName: import("#types").OptionalFieldType<string>;
        orgName: import("#types").OptionalFieldType<string>;
        orgUnitName: import("#types").OptionalFieldType<string>;
        title: import("#types").OptionalFieldType<string>;
        name: import("#types").OptionalFieldType<string>;
        givenName: import("#types").OptionalFieldType<string>;
        initials: import("#types").OptionalFieldType<string>;
        genQualifier: import("#types").OptionalFieldType<string>;
        dnQualifier: import("#types").OptionalFieldType<string>;
        pseudonym: import("#types").OptionalFieldType<string>;
        domainComponent: import("#types").OptionalFieldType<string>;
    } & {
        nodeId: import("#types").OptionalFieldType<NodeId>;
        firmwareSigningId: import("#types").OptionalFieldType<number>;
        icacId: import("#types").OptionalFieldType<number | bigint>;
        rcacId: import("#types").OptionalFieldType<number | bigint>;
        fabricId: import("#types").OptionalFieldType<FabricId>;
        caseAuthenticatedTags: import("#types").OptionalRepeatedFieldType<CaseAuthenticatedTag[]>;
    } & {
        commonNamePs: import("#types").OptionalFieldType<string>;
        sureNamePs: import("#types").OptionalFieldType<string>;
        serialNumPs: import("#types").OptionalFieldType<string>;
        countryNamePs: import("#types").OptionalFieldType<string>;
        localityNamePs: import("#types").OptionalFieldType<string>;
        stateOrProvinceNamePs: import("#types").OptionalFieldType<string>;
        orgNamePs: import("#types").OptionalFieldType<string>;
        orgUnitNamePs: import("#types").OptionalFieldType<string>;
        titlePs: import("#types").OptionalFieldType<string>;
        namePs: import("#types").OptionalFieldType<string>;
        givenNamePs: import("#types").OptionalFieldType<string>;
        initialsPs: import("#types").OptionalFieldType<string>;
        genQualifierPs: import("#types").OptionalFieldType<string>;
        dnQualifierPs: import("#types").OptionalFieldType<string>;
        pseudonymPs: import("#types").OptionalFieldType<string>;
    }>>;
    notBefore: import("#types").FieldType<number>;
    notAfter: import("#types").FieldType<number>;
    subject: import("#types").FieldType<import("#types").TypeFromFields<{
        commonName: import("#types").OptionalFieldType<string>;
        sureName: import("#types").OptionalFieldType<string>;
        serialNum: import("#types").OptionalFieldType<string>;
        countryName: import("#types").OptionalFieldType<string>;
        localityName: import("#types").OptionalFieldType<string>;
        stateOrProvinceName: import("#types").OptionalFieldType<string>;
        orgName: import("#types").OptionalFieldType<string>;
        orgUnitName: import("#types").OptionalFieldType<string>;
        title: import("#types").OptionalFieldType<string>;
        name: import("#types").OptionalFieldType<string>;
        givenName: import("#types").OptionalFieldType<string>;
        initials: import("#types").OptionalFieldType<string>;
        genQualifier: import("#types").OptionalFieldType<string>;
        dnQualifier: import("#types").OptionalFieldType<string>;
        pseudonym: import("#types").OptionalFieldType<string>;
        domainComponent: import("#types").OptionalFieldType<string>;
    } & {
        nodeId: import("#types").FieldType<NodeId>;
        fabricId: import("#types").FieldType<FabricId>;
        caseAuthenticatedTags: import("#types").OptionalRepeatedFieldType<CaseAuthenticatedTag[]>;
    } & {
        commonNamePs: import("#types").OptionalFieldType<string>;
        sureNamePs: import("#types").OptionalFieldType<string>;
        serialNumPs: import("#types").OptionalFieldType<string>;
        countryNamePs: import("#types").OptionalFieldType<string>;
        localityNamePs: import("#types").OptionalFieldType<string>;
        stateOrProvinceNamePs: import("#types").OptionalFieldType<string>;
        orgNamePs: import("#types").OptionalFieldType<string>;
        orgUnitNamePs: import("#types").OptionalFieldType<string>;
        titlePs: import("#types").OptionalFieldType<string>;
        namePs: import("#types").OptionalFieldType<string>;
        givenNamePs: import("#types").OptionalFieldType<string>;
        initialsPs: import("#types").OptionalFieldType<string>;
        genQualifierPs: import("#types").OptionalFieldType<string>;
        dnQualifierPs: import("#types").OptionalFieldType<string>;
        pseudonymPs: import("#types").OptionalFieldType<string>;
    }>>;
    publicKeyAlgorithm: import("#types").FieldType<number>;
    ellipticCurveIdentifier: import("#types").FieldType<number>;
    ellipticCurvePublicKey: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
    extensions: import("#types").FieldType<import("#types").TypeFromFields<{
        basicConstraints: import("#types").FieldType<import("#types").TypeFromFields<{
            isCa: import("#types").FieldType<boolean>;
            pathLen: import("#types").OptionalFieldType<number>;
        }>>;
        keyUsage: import("#types").FieldType<TypeFromPartialBitSchema<{
            digitalSignature: BitFlag;
            nonRepudiation: BitFlag;
            keyEncipherment: BitFlag;
            dataEncipherment: BitFlag;
            keyAgreement: BitFlag;
            keyCertSign: BitFlag;
            cRLSign: BitFlag;
            encipherOnly: BitFlag;
            decipherOnly: BitFlag;
        }>>;
        extendedKeyUsage: import("#types").OptionalFieldType<number[]>;
        subjectKeyIdentifier: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
        authorityKeyIdentifier: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
        futureExtension: import("#types").OptionalRepeatedFieldType<Uint8Array<ArrayBufferLike>[]>;
    }>>;
    signature: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
}>;
export declare const TlvIntermediateCertificate: import("#types").ObjectSchemaWithMaxSize<{
    serialNumber: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
    signatureAlgorithm: import("#types").FieldType<number>;
    issuer: import("#types").FieldType<import("#types").TypeFromFields<{
        commonName: import("#types").OptionalFieldType<string>;
        sureName: import("#types").OptionalFieldType<string>;
        serialNum: import("#types").OptionalFieldType<string>;
        countryName: import("#types").OptionalFieldType<string>;
        localityName: import("#types").OptionalFieldType<string>;
        stateOrProvinceName: import("#types").OptionalFieldType<string>;
        orgName: import("#types").OptionalFieldType<string>;
        orgUnitName: import("#types").OptionalFieldType<string>;
        title: import("#types").OptionalFieldType<string>;
        name: import("#types").OptionalFieldType<string>;
        givenName: import("#types").OptionalFieldType<string>;
        initials: import("#types").OptionalFieldType<string>;
        genQualifier: import("#types").OptionalFieldType<string>;
        dnQualifier: import("#types").OptionalFieldType<string>;
        pseudonym: import("#types").OptionalFieldType<string>;
        domainComponent: import("#types").OptionalFieldType<string>;
    } & {
        nodeId: import("#types").OptionalFieldType<NodeId>;
        firmwareSigningId: import("#types").OptionalFieldType<number>;
        icacId: import("#types").OptionalFieldType<number | bigint>;
        rcacId: import("#types").OptionalFieldType<number | bigint>;
        fabricId: import("#types").OptionalFieldType<FabricId>;
        caseAuthenticatedTags: import("#types").OptionalRepeatedFieldType<CaseAuthenticatedTag[]>;
    } & {
        commonNamePs: import("#types").OptionalFieldType<string>;
        sureNamePs: import("#types").OptionalFieldType<string>;
        serialNumPs: import("#types").OptionalFieldType<string>;
        countryNamePs: import("#types").OptionalFieldType<string>;
        localityNamePs: import("#types").OptionalFieldType<string>;
        stateOrProvinceNamePs: import("#types").OptionalFieldType<string>;
        orgNamePs: import("#types").OptionalFieldType<string>;
        orgUnitNamePs: import("#types").OptionalFieldType<string>;
        titlePs: import("#types").OptionalFieldType<string>;
        namePs: import("#types").OptionalFieldType<string>;
        givenNamePs: import("#types").OptionalFieldType<string>;
        initialsPs: import("#types").OptionalFieldType<string>;
        genQualifierPs: import("#types").OptionalFieldType<string>;
        dnQualifierPs: import("#types").OptionalFieldType<string>;
        pseudonymPs: import("#types").OptionalFieldType<string>;
    }>>;
    notBefore: import("#types").FieldType<number>;
    notAfter: import("#types").FieldType<number>;
    subject: import("#types").FieldType<import("#types").TypeFromFields<{
        commonName: import("#types").OptionalFieldType<string>;
        sureName: import("#types").OptionalFieldType<string>;
        serialNum: import("#types").OptionalFieldType<string>;
        countryName: import("#types").OptionalFieldType<string>;
        localityName: import("#types").OptionalFieldType<string>;
        stateOrProvinceName: import("#types").OptionalFieldType<string>;
        orgName: import("#types").OptionalFieldType<string>;
        orgUnitName: import("#types").OptionalFieldType<string>;
        title: import("#types").OptionalFieldType<string>;
        name: import("#types").OptionalFieldType<string>;
        givenName: import("#types").OptionalFieldType<string>;
        initials: import("#types").OptionalFieldType<string>;
        genQualifier: import("#types").OptionalFieldType<string>;
        dnQualifier: import("#types").OptionalFieldType<string>;
        pseudonym: import("#types").OptionalFieldType<string>;
        domainComponent: import("#types").OptionalFieldType<string>;
    } & {
        icacId: import("#types").FieldType<number | bigint>;
        fabricId: import("#types").OptionalFieldType<FabricId>;
    } & {
        commonNamePs: import("#types").OptionalFieldType<string>;
        sureNamePs: import("#types").OptionalFieldType<string>;
        serialNumPs: import("#types").OptionalFieldType<string>;
        countryNamePs: import("#types").OptionalFieldType<string>;
        localityNamePs: import("#types").OptionalFieldType<string>;
        stateOrProvinceNamePs: import("#types").OptionalFieldType<string>;
        orgNamePs: import("#types").OptionalFieldType<string>;
        orgUnitNamePs: import("#types").OptionalFieldType<string>;
        titlePs: import("#types").OptionalFieldType<string>;
        namePs: import("#types").OptionalFieldType<string>;
        givenNamePs: import("#types").OptionalFieldType<string>;
        initialsPs: import("#types").OptionalFieldType<string>;
        genQualifierPs: import("#types").OptionalFieldType<string>;
        dnQualifierPs: import("#types").OptionalFieldType<string>;
        pseudonymPs: import("#types").OptionalFieldType<string>;
    }>>;
    publicKeyAlgorithm: import("#types").FieldType<number>;
    ellipticCurveIdentifier: import("#types").FieldType<number>;
    ellipticCurvePublicKey: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
    extensions: import("#types").FieldType<import("#types").TypeFromFields<{
        basicConstraints: import("#types").FieldType<import("#types").TypeFromFields<{
            isCa: import("#types").FieldType<boolean>;
            pathLen: import("#types").OptionalFieldType<number>;
        }>>;
        keyUsage: import("#types").FieldType<TypeFromPartialBitSchema<{
            digitalSignature: BitFlag;
            nonRepudiation: BitFlag;
            keyEncipherment: BitFlag;
            dataEncipherment: BitFlag;
            keyAgreement: BitFlag;
            keyCertSign: BitFlag;
            cRLSign: BitFlag;
            encipherOnly: BitFlag;
            decipherOnly: BitFlag;
        }>>;
        extendedKeyUsage: import("#types").OptionalFieldType<number[]>;
        subjectKeyIdentifier: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
        authorityKeyIdentifier: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
        futureExtension: import("#types").OptionalRepeatedFieldType<Uint8Array<ArrayBufferLike>[]>;
    }>>;
    signature: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
}>;
declare const TlvBaseCertificate: import("#types").ObjectSchemaWithMaxSize<{
    serialNumber: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
    signatureAlgorithm: import("#types").FieldType<number>;
    issuer: import("#types").FieldType<import("#types").TypeFromFields<{
        commonName: import("#types").OptionalFieldType<string>;
        sureName: import("#types").OptionalFieldType<string>;
        serialNum: import("#types").OptionalFieldType<string>;
        countryName: import("#types").OptionalFieldType<string>;
        localityName: import("#types").OptionalFieldType<string>;
        stateOrProvinceName: import("#types").OptionalFieldType<string>;
        orgName: import("#types").OptionalFieldType<string>;
        orgUnitName: import("#types").OptionalFieldType<string>;
        title: import("#types").OptionalFieldType<string>;
        name: import("#types").OptionalFieldType<string>;
        givenName: import("#types").OptionalFieldType<string>;
        initials: import("#types").OptionalFieldType<string>;
        genQualifier: import("#types").OptionalFieldType<string>;
        dnQualifier: import("#types").OptionalFieldType<string>;
        pseudonym: import("#types").OptionalFieldType<string>;
        domainComponent: import("#types").OptionalFieldType<string>;
    } & {
        commonNamePs: import("#types").OptionalFieldType<string>;
        sureNamePs: import("#types").OptionalFieldType<string>;
        serialNumPs: import("#types").OptionalFieldType<string>;
        countryNamePs: import("#types").OptionalFieldType<string>;
        localityNamePs: import("#types").OptionalFieldType<string>;
        stateOrProvinceNamePs: import("#types").OptionalFieldType<string>;
        orgNamePs: import("#types").OptionalFieldType<string>;
        orgUnitNamePs: import("#types").OptionalFieldType<string>;
        titlePs: import("#types").OptionalFieldType<string>;
        namePs: import("#types").OptionalFieldType<string>;
        givenNamePs: import("#types").OptionalFieldType<string>;
        initialsPs: import("#types").OptionalFieldType<string>;
        genQualifierPs: import("#types").OptionalFieldType<string>;
        dnQualifierPs: import("#types").OptionalFieldType<string>;
        pseudonymPs: import("#types").OptionalFieldType<string>;
    }>>;
    notBefore: import("#types").FieldType<number>;
    notAfter: import("#types").FieldType<number>;
    subject: import("#types").FieldType<import("#types").TypeFromFields<{
        commonName: import("#types").OptionalFieldType<string>;
        sureName: import("#types").OptionalFieldType<string>;
        serialNum: import("#types").OptionalFieldType<string>;
        countryName: import("#types").OptionalFieldType<string>;
        localityName: import("#types").OptionalFieldType<string>;
        stateOrProvinceName: import("#types").OptionalFieldType<string>;
        orgName: import("#types").OptionalFieldType<string>;
        orgUnitName: import("#types").OptionalFieldType<string>;
        title: import("#types").OptionalFieldType<string>;
        name: import("#types").OptionalFieldType<string>;
        givenName: import("#types").OptionalFieldType<string>;
        initials: import("#types").OptionalFieldType<string>;
        genQualifier: import("#types").OptionalFieldType<string>;
        dnQualifier: import("#types").OptionalFieldType<string>;
        pseudonym: import("#types").OptionalFieldType<string>;
        domainComponent: import("#types").OptionalFieldType<string>;
    } & {
        commonNamePs: import("#types").OptionalFieldType<string>;
        sureNamePs: import("#types").OptionalFieldType<string>;
        serialNumPs: import("#types").OptionalFieldType<string>;
        countryNamePs: import("#types").OptionalFieldType<string>;
        localityNamePs: import("#types").OptionalFieldType<string>;
        stateOrProvinceNamePs: import("#types").OptionalFieldType<string>;
        orgNamePs: import("#types").OptionalFieldType<string>;
        orgUnitNamePs: import("#types").OptionalFieldType<string>;
        titlePs: import("#types").OptionalFieldType<string>;
        namePs: import("#types").OptionalFieldType<string>;
        givenNamePs: import("#types").OptionalFieldType<string>;
        initialsPs: import("#types").OptionalFieldType<string>;
        genQualifierPs: import("#types").OptionalFieldType<string>;
        dnQualifierPs: import("#types").OptionalFieldType<string>;
        pseudonymPs: import("#types").OptionalFieldType<string>;
    }>>;
    publicKeyAlgorithm: import("#types").FieldType<number>;
    ellipticCurveIdentifier: import("#types").FieldType<number>;
    ellipticCurvePublicKey: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
    extensions: import("#types").FieldType<import("#types").TypeFromFields<{
        basicConstraints: import("#types").FieldType<import("#types").TypeFromFields<{
            isCa: import("#types").FieldType<boolean>;
            pathLen: import("#types").OptionalFieldType<number>;
        }>>;
        keyUsage: import("#types").FieldType<TypeFromPartialBitSchema<{
            digitalSignature: BitFlag;
            nonRepudiation: BitFlag;
            keyEncipherment: BitFlag;
            dataEncipherment: BitFlag;
            keyAgreement: BitFlag;
            keyCertSign: BitFlag;
            cRLSign: BitFlag;
            encipherOnly: BitFlag;
            decipherOnly: BitFlag;
        }>>;
        extendedKeyUsage: import("#types").OptionalFieldType<number[]>;
        subjectKeyIdentifier: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
        authorityKeyIdentifier: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
        futureExtension: import("#types").OptionalRepeatedFieldType<Uint8Array<ArrayBufferLike>[]>;
    }>>;
    signature: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
}>;
interface AttestationCertificateBase {
    serialNumber: Uint8Array;
    signatureAlgorithm: number;
    issuer: {};
    notBefore: number;
    notAfter: number;
    subject: {};
    publicKeyAlgorithm: number;
    ellipticCurveIdentifier: number;
    ellipticCurvePublicKey: Uint8Array;
    extensions: {
        basicConstraints: {
            isCa: boolean;
            pathLen?: number;
        };
        keyUsage: TypeFromPartialBitSchema<typeof ExtensionKeyUsageBitmap>;
        extendedKeyUsage?: number[];
        subjectKeyIdentifier: Uint8Array;
        authorityKeyIdentifier: Uint8Array;
        futureExtension?: Uint8Array[];
    };
    signature: Uint8Array;
}
export interface DeviceAttestationCertificate extends AttestationCertificateBase {
    issuer: {
        commonName: string;
        productId?: number;
        vendorId: VendorId;
    };
    subject: {
        commonName: string;
        productId: number;
        vendorId: VendorId;
    };
}
export interface ProductAttestationIntermediateCertificate extends AttestationCertificateBase {
    issuer: {
        commonName: string;
        vendorId?: VendorId;
    };
    subject: {
        commonName: string;
        productId?: number;
        vendorId: VendorId;
    };
}
export interface ProductAttestationAuthorityCertificate extends AttestationCertificateBase {
    issuer: {
        commonName: string;
        vendorId?: VendorId;
    };
    subject: {
        commonName: string;
        vendorId?: VendorId;
    };
}
export declare const TlvCertificationDeclaration: import("#types").ObjectSchema<{
    formatVersion: import("#types").FieldType<number>;
    vendorId: import("#types").FieldType<VendorId>;
    produceIdArray: import("#types").FieldType<number[]>;
    deviceTypeId: import("#types").FieldType<number>;
    certificateId: import("#types").FieldType<string>;
    securityLevel: import("#types").FieldType<number>;
    securityInformation: import("#types").FieldType<number>;
    versionNumber: import("#types").FieldType<number>;
    certificationType: import("#types").FieldType<number>;
    dacOriginVendorId: import("#types").OptionalFieldType<VendorId>;
    dacOriginProductId: import("#types").OptionalFieldType<number>;
    authorizedPaaList: import("#types").OptionalFieldType<Uint8Array<ArrayBufferLike>[]>;
}>;
export type BaseCertificate = TypeFromSchema<typeof TlvBaseCertificate>;
export type RootCertificate = TypeFromSchema<typeof TlvRootCertificate>;
export type IntermediateCertificate = TypeFromSchema<typeof TlvIntermediateCertificate>;
export type OperationalCertificate = TypeFromSchema<typeof TlvOperationalCertificate>;
export type Unsigned<Type> = {
    [Property in keyof Type as Exclude<Property, "signature">]: Type[Property];
};
export declare namespace CertificateManager {
    function rootCertToAsn1(cert: Unsigned<RootCertificate>): Uint8Array<ArrayBufferLike>;
    function intermediateCaCertToAsn1(cert: Unsigned<IntermediateCertificate>): Uint8Array<ArrayBufferLike>;
    function nodeOperationalCertToAsn1(cert: Unsigned<OperationalCertificate>): Uint8Array<ArrayBufferLike>;
    function deviceAttestationCertToAsn1(cert: Unsigned<DeviceAttestationCertificate>, key: Key): Uint8Array<ArrayBufferLike>;
    function productAttestationIntermediateCertToAsn1(cert: Unsigned<ProductAttestationIntermediateCertificate>, key: Key): Uint8Array<ArrayBufferLike>;
    function productAttestationAuthorityCertToAsn1(cert: Unsigned<ProductAttestationAuthorityCertificate>, key: Key): Uint8Array<ArrayBufferLike>;
    function certificationDeclarationToAsn1(eContent: Uint8Array, subjectKeyIdentifier: Uint8Array, privateKey: JsonWebKey): Uint8Array<ArrayBufferLike>;
    /**
     * Validate general requirements a Matter certificate fields must fulfill.
     * Rules for this are listed in @see {@link MatterSpecification.v12.Core} §6.5.x
     */
    function validateGeneralCertificateFields(cert: RootCertificate | OperationalCertificate | IntermediateCertificate): void;
    /**
     * Verify requirements a Matter Root certificate must fulfill.
     * Rules for this are listed in @see {@link MatterSpecification.v12.Core} §6.5.x
     */
    function verifyRootCertificate(rootCert: RootCertificate): void;
    /**
     * Verify requirements a Matter Node Operational certificate must fulfill.
     * Rules for this are listed in @see {@link MatterSpecification.v12.Core} §6.5.x
     */
    function verifyNodeOperationalCertificate(nocCert: OperationalCertificate, rootCert: RootCertificate, icaCert?: IntermediateCertificate): void;
    /**
     * Verify requirements a Matter Intermediate CA certificate must fulfill.
     * Rules for this are listed in @see {@link MatterSpecification.v12.Core} §6.5.x
     */
    function verifyIntermediateCaCertificate(rootCert: RootCertificate, icaCert: IntermediateCertificate): void;
    function createCertificateSigningRequest(key: Key): Uint8Array<ArrayBufferLike>;
    function getPublicKeyFromCsr(csr: Uint8Array): Uint8Array<ArrayBufferLike>;
}
export {};
//# sourceMappingURL=CertificateManager.d.ts.map