"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var AttributeClient_exports = {};
__export(AttributeClient_exports, {
  AttributeClient: () => AttributeClient,
  SupportedAttributeClient: () => SupportedAttributeClient,
  UnknownSupportedAttributeClient: () => UnknownSupportedAttributeClient,
  createAttributeClient: () => createAttributeClient
});
module.exports = __toCommonJS(AttributeClient_exports);
var import_general = require("#general");
var import_model = require("#model");
var import_types = require("#types");
var import_SecureSession = require("../../session/SecureSession.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
function createAttributeClient(attribute, name, endpointId, clusterId, interactionClient, present = false) {
  if (attribute.unknown) {
    return new UnknownSupportedAttributeClient(attribute, name, endpointId, clusterId, interactionClient);
  }
  if (present) {
    return new SupportedAttributeClient(attribute, name, endpointId, clusterId, interactionClient);
  }
  return new AttributeClient(attribute, name, endpointId, clusterId, interactionClient);
}
class AttributeClient {
  constructor(attribute, name, endpointId, clusterId, interactionClient) {
    this.attribute = attribute;
    this.name = name;
    this.endpointId = endpointId;
    this.clusterId = clusterId;
    const { schema, writable, fabricScoped, id, omitChanges } = attribute;
    this.schema = schema;
    this.#isWritable = writable;
    this.#isFabricScoped = fabricScoped;
    this.#updatedBySubscriptions = !omitChanges;
    this.id = id;
    this.#interactionClient = interactionClient;
  }
  #isWritable;
  #isFabricScoped;
  #updatedBySubscriptions;
  schema;
  #listeners = new Array();
  id;
  #interactionClient;
  /**
   * Set the value of the attribute. When dataVersion parameter is provided the value is only set when the
   * cluster dataVersion of the server matches. If it does not match it is rejected with an Error.
   */
  async set(value, dataVersion) {
    if (!this.#isWritable) throw new import_types.AttributeError(`Attribute ${this.name} is not writable`);
    value = this.schema.injectField(
      value,
      import_model.FabricIndex.id,
      import_types.FabricIndex.OMIT_FABRIC,
      (existingFieldIndex) => existingFieldIndex === void 0
    );
    this.schema.validate(value);
    if (this.#isFabricScoped) {
      value = this.schema.removeField(
        value,
        import_model.FabricIndex.id,
        (existingFieldIndex) => existingFieldIndex === import_types.FabricIndex.OMIT_FABRIC
      );
      try {
        const sessionFabric = this.#interactionClient.session.associatedFabric;
        value = this.schema.removeField(
          value,
          import_model.FabricIndex.id,
          (existingFieldIndex) => existingFieldIndex.index === sessionFabric.fabricIndex
        );
      } catch (e) {
        import_SecureSession.NoAssociatedFabricError.accept(e);
      }
    }
    return await this.#interactionClient.setAttribute({
      attributeData: {
        endpointId: this.endpointId,
        clusterId: this.clusterId,
        attribute: this.attribute,
        value,
        dataVersion
      }
    });
  }
  /**
   * Get the value of the attribute. Fabric scoped reads are always done with the remote.
   * The `requestFromRemote` parameter allowed to force or prevent remote reads:
   * - `true` forces a remote read
   * - `false` forces a local read, return undefined if no value is available
   * - `undefined` returns local values if available or if the read is fabric filtered, otherwise remote read
   */
  async get(requestFromRemote, isFabricFiltered = true) {
    if (requestFromRemote === void 0) {
      requestFromRemote = this.#isFabricScoped || !this.#updatedBySubscriptions ? true : void 0;
    } else if (!requestFromRemote && this.#isFabricScoped) {
      requestFromRemote = true;
    }
    return await this.#interactionClient.getAttribute({
      endpointId: this.endpointId,
      clusterId: this.clusterId,
      attribute: this.attribute,
      isFabricFiltered,
      requestFromRemote
    });
  }
  /**
   * Get the value with version of the attribute. Fabric scoped reads are always done with the remote.
   * The `requestFromRemote` parameter allowed to force or prevent remote reads:
   * - `true` forces a remote read
   * - `false` forces a local read, return undefined if no value is available
   * - `undefined` returns local values if available or if the read is fabric filtered, otherwise remote read
   */
  async getWithVersion(requestFromRemote, isFabricFiltered = true) {
    if (requestFromRemote === void 0) {
      requestFromRemote = this.#isFabricScoped || !this.#updatedBySubscriptions ? true : void 0;
    } else if (!requestFromRemote && this.#isFabricScoped) {
      requestFromRemote = true;
    }
    return await this.#interactionClient.getAttributeWithVersion({
      endpointId: this.endpointId,
      clusterId: this.clusterId,
      attribute: this.attribute,
      isFabricFiltered,
      requestFromRemote
    });
  }
  /** Subscribe to the attribute. */
  async subscribe(minIntervalFloorSeconds, maxIntervalCeilingSeconds, knownDataVersion, isFabricFiltered = true) {
    if (!this.#updatedBySubscriptions) {
      throw new import_general.ImplementationError(`Attribute ${this.name} is not updated by subscriptions.`);
    }
    return this.#interactionClient.subscribeAttribute({
      endpointId: this.endpointId,
      clusterId: this.clusterId,
      attribute: this.attribute,
      minIntervalFloorSeconds,
      maxIntervalCeilingSeconds,
      isFabricFiltered,
      knownDataVersion,
      listener: this.update.bind(this)
    });
  }
  /**
   * Update the value of the attribute. Just internally used!
   * @private
   */
  update(value) {
    this.#listeners.forEach((listener) => listener(value));
  }
  /** Add a listener to the attribute. */
  addListener(listener) {
    this.#listeners.push(listener);
  }
  /** Remove a listener from the attribute. */
  removeListener(listener) {
    const entryIndex = this.#listeners.indexOf(listener);
    if (entryIndex !== -1) {
      this.#listeners.splice(entryIndex, 1);
    }
  }
}
class SupportedAttributeClient extends AttributeClient {
}
class UnknownSupportedAttributeClient extends SupportedAttributeClient {
}
//# sourceMappingURL=AttributeClient.js.map
