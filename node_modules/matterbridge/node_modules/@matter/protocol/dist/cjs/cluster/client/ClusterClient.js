"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ClusterClient_exports = {};
__export(ClusterClient_exports, {
  ClusterClient: () => ClusterClient
});
module.exports = __toCommonJS(ClusterClient_exports);
var import_general = require("#general");
var import_types = require("#types");
var import_AttributeClient = require("./AttributeClient.js");
var import_EventClient = require("./EventClient.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("ClusterClient");
function ClusterClient(clusterDef, endpointId, interactionClient, globalAttributeValues = {}) {
  function addAttributeToResult(attribute, attributeName) {
    attributes[attributeName] = (0, import_AttributeClient.createAttributeClient)(
      attribute,
      attributeName,
      endpointId,
      clusterId,
      interactionClient,
      !!globalAttributeValues?.attributeList?.includes(attribute.id)
    );
    attributes[attribute.id] = attributes[attributeName];
    attributeToId[attribute.id] = attributeName;
    const capitalizedAttributeName = (0, import_general.capitalize)(attributeName);
    result[`get${capitalizedAttributeName}Attribute`] = async (requestFromRemote, isFabricFiltered = true) => {
      try {
        return await attributes[attributeName].get(requestFromRemote, isFabricFiltered);
      } catch (e) {
        if (import_types.StatusResponseError.is(e, import_types.StatusCode.UnsupportedAttribute)) {
          return void 0;
        }
        throw e;
      }
    };
    result[`set${capitalizedAttributeName}Attribute`] = async (value, dataVersion) => attributes[attributeName].set(value, dataVersion);
    result[`subscribe${capitalizedAttributeName}Attribute`] = async (listener, minIntervalS, maxIntervalS, knownDataVersion, isFabricFiltered) => {
      attributes[attributeName].addListener(listener);
      return attributes[attributeName].subscribe(
        minIntervalS,
        maxIntervalS,
        knownDataVersion,
        isFabricFiltered
      );
    };
    result[`add${capitalizedAttributeName}AttributeListener`] = (listener) => {
      attributes[attributeName].addListener(listener);
    };
    result[`remove${capitalizedAttributeName}AttributeListener`] = (listener) => {
      attributes[attributeName].removeListener(listener);
    };
  }
  function addEventToResult(event, eventName) {
    events[eventName] = (0, import_EventClient.createEventClient)(event, eventName, endpointId, clusterId, interactionClient);
    events[event.id] = events[eventName];
    eventToId[event.id] = eventName;
    const capitalizedEventName = (0, import_general.capitalize)(eventName);
    result[`get${capitalizedEventName}Event`] = async (minimumEventNumber, isFabricFiltered) => {
      try {
        return await events[eventName].get(minimumEventNumber, isFabricFiltered);
      } catch (e) {
        if (import_types.StatusResponseError.is(e, import_types.StatusCode.UnsupportedEvent)) {
          return void 0;
        }
        throw e;
      }
    };
    result[`subscribe${capitalizedEventName}Event`] = async (listener, minIntervalS, maxIntervalS, isUrgent, minimumEventNumber, isFabricFiltered) => {
      events[eventName].addListener(listener);
      return events[eventName].subscribe(
        minIntervalS,
        maxIntervalS,
        isUrgent,
        minimumEventNumber,
        isFabricFiltered
      );
    };
    result[`add${capitalizedEventName}EventListener`] = (listener) => {
      events[eventName].addListener(listener);
    };
    result[`remove${capitalizedEventName}EventListener`] = (listener) => {
      events[eventName].removeListener(listener);
    };
  }
  const {
    id: clusterId,
    name,
    commands: commandDef,
    attributes: attributeDef,
    events: eventDef,
    features,
    supportedFeatures,
    revision,
    unknown
  } = clusterDef;
  const attributes = {};
  const events = {};
  const commands = {};
  let reportedFeatures = void 0;
  if (globalAttributeValues !== void 0) {
    if (globalAttributeValues.featureMap !== void 0) {
      reportedFeatures = globalAttributeValues.featureMap;
    }
  }
  const result = {
    id: clusterId,
    name,
    revision: globalAttributeValues?.clusterRevision ?? revision,
    _type: "ClusterClient",
    supportedFeatures: reportedFeatures ?? supportedFeatures ?? {},
    isUnknown: unknown,
    endpointId,
    attributes,
    events,
    commands,
    subscribeAllAttributes: async (options) => {
      const {
        minIntervalFloorSeconds,
        maxIntervalCeilingSeconds,
        keepSubscriptions,
        isFabricFiltered,
        eventFilters,
        dataVersionFilters
      } = options;
      return interactionClient.subscribeMultipleAttributesAndEvents({
        attributes: [{ endpointId, clusterId }],
        events: [{ endpointId, clusterId }],
        minIntervalFloorSeconds,
        maxIntervalCeilingSeconds,
        keepSubscriptions,
        isFabricFiltered,
        eventFilters,
        dataVersionFilters,
        attributeListener: (attributeData) => {
          const { path, value } = attributeData;
          result._triggerAttributeUpdate(path.attributeId, value);
        },
        eventListener: (eventData) => {
          const { path, events: newEvents } = eventData;
          result._triggerEventUpdate(path.eventId, newEvents);
        }
      });
    },
    /** Trigger a value change for an Attributed, used by subscriptions. */
    _triggerAttributeUpdate(attributeId, value) {
      const attributeName = attributeToId[attributeId];
      if (attributeName === void 0) {
        logger.warn("Unknown attribute id", attributeId);
        return;
      }
      if (attributes[attributeName] !== void 0) {
        attributes[attributeName].update(value);
      } else {
        logger.warn("Attribute not found", attributeName, "in list", Object.keys(attributes));
      }
    },
    /** Trigger a value change for an Event, used by subscriptions. */
    _triggerEventUpdate(eventId, eventData) {
      const eventName = eventToId[eventId];
      if (eventName === void 0) {
        logger.warn("Unknown event id", eventId);
        return;
      }
      if (events[eventName] !== void 0) {
        const event = events[eventName];
        eventData.forEach((data) => event.update(data));
      } else {
        logger.warn("Event not found", eventName, "in list", Object.keys(events));
      }
    },
    isAttributeSupported: (attributeId) => {
      return !!globalAttributeValues?.attributeList?.includes(attributeId);
    },
    isAttributeSupportedByName: (attributeName) => {
      const attribute = attributes[attributeName];
      if (attribute === void 0) {
        return false;
      }
      return !!globalAttributeValues?.attributeList?.includes(attribute.id);
    },
    isCommandSupported: (commandId) => {
      return !!globalAttributeValues?.acceptedCommandList?.includes(commandId);
    },
    isCommandSupportedByName: (commandName) => {
      const command = commandDef[commandName];
      if (command === void 0) {
        return false;
      }
      return !!globalAttributeValues?.acceptedCommandList?.includes(command.requestId);
    }
  };
  const attributeToId = {};
  const allAttributeDefs = (0, import_general.Merge)(
    attributeDef,
    (0, import_types.GlobalAttributes)(features)
  );
  for (const attributeName in allAttributeDefs) {
    addAttributeToResult(allAttributeDefs[attributeName], attributeName);
  }
  if (globalAttributeValues?.attributeList !== void 0) {
    for (const attributeId of globalAttributeValues.attributeList) {
      if (attributeToId[attributeId] === void 0) {
        const attribute = (0, import_types.UnknownAttribute)(attributeId);
        addAttributeToResult(attribute, `unknownAttribute_${import_general.Diagnostic.hex(attributeId)}`);
        logger.info(
          `Added unknown attribute ${import_general.Diagnostic.hex(attributeId)} to cluster ${import_general.Diagnostic.hex(clusterId)}`
        );
      }
    }
  }
  const eventToId = {};
  for (const eventName in eventDef) {
    addEventToResult(eventDef[eventName], eventName);
  }
  const commandToId = {};
  for (const commandName in commandDef) {
    const { requestId } = commandDef[commandName];
    commandToId[requestId] = commandName;
    commands[commandName] = async (request, options = {}) => {
      const { asTimedRequest, timedRequestTimeoutMs, useExtendedFailSafeMessageResponseTimeout } = options;
      return interactionClient.invoke({
        endpointId,
        clusterId,
        command: commandDef[commandName],
        request,
        asTimedRequest,
        timedRequestTimeoutMs,
        useExtendedFailSafeMessageResponseTimeout
      });
    };
    commands[requestId] = commands[commandName];
    result[commandName] = result.commands[commandName];
  }
  if (globalAttributeValues?.acceptedCommandList !== void 0) {
    for (const requestId of globalAttributeValues.acceptedCommandList) {
      if (commandToId[requestId] === void 0) {
        logger.info(`Ignoring unknown command ${requestId} at cluster ${import_general.Diagnostic.hex(clusterId)}`);
      }
    }
  }
  return result;
}
//# sourceMappingURL=ClusterClient.js.map
