/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { MatterError } from "#general";
import { AccessLevel } from "#model";
import { Attribute, AttributeId, Attributes, BitSchema, Cluster, Commands, Events, TlvSchema, TypeFromPartialBitSchema } from "#types";
import { Message } from "../../codec/MessageCodec.js";
import { EndpointInterface } from "../../endpoint/EndpointInterface.js";
import { Fabric } from "../../fabric/Fabric.js";
import { SecureSession } from "../../session/SecureSession.js";
import { Session } from "../../session/Session.js";
import { ClusterDatasource } from "./ClusterDatasource.js";
/**
 * Thrown when an operation cannot complete because fabric information is
 * unavailable.
 */
export declare class FabricScopeError extends MatterError {
}
export type AnyAttributeServer<T = any> = AttributeServer<T> | FabricScopedAttributeServer<T> | FixedAttributeServer<T>;
type DelayedChangeData = {
    oldValue: any;
    newValue: any;
    changed: boolean;
};
/**
 * Factory function to create an attribute server.
 */
export declare function createAttributeServer<T, F extends BitSchema, SF extends TypeFromPartialBitSchema<F>, A extends Attributes, C extends Commands, E extends Events>(clusterDef: Cluster<F, SF, A, C, E>, attributeDef: Attribute<T, F>, attributeName: string, initValue: T, datasource: ClusterDatasource, getter?: (session?: Session, endpoint?: EndpointInterface, isFabricFiltered?: boolean, message?: Message) => T, setter?: (value: T, session?: Session, endpoint?: EndpointInterface, message?: Message) => boolean, validator?: (value: T, session?: Session, endpoint?: EndpointInterface) => void): FixedAttributeServer<T>;
/**
 * Base class for all attribute servers.
 */
export declare abstract class BaseAttributeServer<T> {
    #private;
    readonly id: AttributeId;
    readonly name: string;
    readonly schema: TlvSchema<T>;
    readonly isWritable: boolean;
    readonly isSubscribable: boolean;
    readonly requiresTimedInteraction: boolean;
    /**
     * The value is undefined when getter/setter are used. But we still handle the version number here.
     */
    protected value: T | undefined;
    protected endpoint?: EndpointInterface;
    readonly defaultValue: T;
    constructor(id: AttributeId, name: string, readAcl: AccessLevel | undefined, writeAcl: AccessLevel | undefined, schema: TlvSchema<T>, isWritable: boolean, isSubscribable: boolean, requiresTimedInteraction: boolean, initValue: T, defaultValue: T | undefined);
    get hasFabricSensitiveData(): boolean;
    validateWithSchema(value: T): void;
    assignToEndpoint(endpoint: EndpointInterface): void;
    /**
     * Initialize the value of the attribute, used when a persisted value is set initially or when values needs to be
     * adjusted before the Device gets announced. Do not use this method to change values when the device is in use!
     */
    abstract init(value: T | undefined): void;
    get writeAcl(): AccessLevel;
    get readAcl(): AccessLevel;
}
/**
 * Attribute server class that handled fixed attribute values that never change and is the base class for other
 * Attribute server types.
 */
export declare class FixedAttributeServer<T> extends BaseAttributeServer<T> {
    protected readonly datasource: ClusterDatasource;
    readonly isFixed: boolean;
    protected readonly getter: (session?: Session, endpoint?: EndpointInterface, isFabricFiltered?: boolean, message?: Message) => T;
    constructor(id: AttributeId, name: string, readAcl: AccessLevel | undefined, writeAcl: AccessLevel | undefined, schema: TlvSchema<T>, isWritable: boolean, isSubscribable: boolean, requiresTimedInteraction: boolean, initValue: T, defaultValue: T | undefined, datasource: ClusterDatasource, 
    /**
     * Optional getter function to handle special requirements or the data are stored in different places.
     *
     * @param session the session that is requesting the value (if any)
     * @param endpoint the endpoint the cluster server of this attribute is assigned to
     * @param isFabricFiltered whether the read request is fabric scoped or not
     * @param message the wire message that initiated the request (if any)
     */
    getter?: (session?: Session, endpoint?: EndpointInterface, isFabricFiltered?: boolean, message?: Message) => T);
    /**
     * Get the value of the attribute. This method is used by the Interaction model to read the value of the attribute
     * and includes the ACL check. It should not be used locally in the code!
     *
     * If a getter is defined the value is determined by that getter method.
     */
    get(session: Session, isFabricFiltered: boolean, message?: Message): T;
    /**
     * Get the value of the attribute including the version number. This method is used by the Interaction model to read
     * the value of the attribute and includes the ACL check. It should not be used locally in the code!
     *
     * If a getter is defined the value is determined by that getter method. The version number is always 0 for fixed
     * attributes.
     */
    getWithVersion(session: Session, isFabricFiltered: boolean, message?: Message): {
        version: number;
        value: T;
    };
    /**
     * Get the value of the attribute locally. This method should be used locally in the code and does not include the
     * ACL check.
     * If a getter is defined the value is determined by that getter method.
     */
    getLocal(): T;
    /**
     * Initialize the value of the attribute, used when a persisted value is set initially or when values needs to be
     * adjusted before the Device gets announced. Do not use this method to change values when the device is in use!
     * If a getter or setter is defined the value must be undefined The version number must also be undefined.
     */
    init(value: T | undefined): void;
    /**
     * Add an internal listener that is called when the value of the attribute changes. The listener is called with the
     * new value and the version number.
     */
    addValueChangeListener(_listener: (value: T, version: number) => void): void;
    /**
     * Remove an internal listener.
     */
    removeValueChangeListener(_listener: (value: T, version: number) => void): void;
    /**
     * Add an external listener that is called when the value of the attribute changes. The listener is called with the
     * new value and the old value.
     */
    addValueSetListener(_listener: (newValue: T, oldValue: T) => void): void;
    /**
     * Add an external listener that is called when the value of the attribute changes. The listener is called with the
     * new value and the old value. This method is a convenient alias for addValueSetListener.
     */
    subscribe(_listener: (newValue: T, oldValue: T) => void): void;
    /**
     * Remove an external listener.
     */
    removeValueSetListener(_listener: (newValue: T, oldValue: T) => void): void;
}
/**
 * Attribute server for normal attributes that can be read and written.
 */
export declare class AttributeServer<T> extends FixedAttributeServer<T> {
    readonly isFixed = false;
    protected readonly valueChangeListeners: ((value: T, version: number) => void)[];
    protected readonly valueSetListeners: ((newValue: T, oldValue: T) => void)[];
    protected readonly setter: (value: T, session?: Session, endpoint?: EndpointInterface, message?: Message) => boolean;
    protected readonly validator: (value: T, session?: Session, endpoint?: EndpointInterface) => void;
    protected delayedChangeData?: DelayedChangeData;
    constructor(id: AttributeId, name: string, readAcl: AccessLevel | undefined, writeAcl: AccessLevel | undefined, schema: TlvSchema<T>, isWritable: boolean, isSubscribable: boolean, requiresTimedInteraction: boolean, initValue: T, defaultValue: T | undefined, datasource: ClusterDatasource, getter?: (session?: Session, endpoint?: EndpointInterface, isFabricFiltered?: boolean, message?: Message) => T, 
    /**
     * Optional setter function to handle special requirements or the data are stored in different places. If a
     * setter method is used for a writable attribute, the getter method must be implemented as well. The method
     * needs to return if the stored value has changed or not.
     *
     * @param value the value to be set.
     * @param session the session that is requesting the value (if any).
     * @param endpoint the endpoint the cluster server of this attribute is assigned to.
     * @returns true if the value has changed, false otherwise.
     */
    setter?: (value: T, session?: Session, endpoint?: EndpointInterface, message?: Message) => boolean, 
    /**
     * Optional Validator function to handle special requirements for verification of stored data. The method should
     * throw an error if the value is not valid. If a StatusResponseError is thrown this one is also returned to the
     * client.
     *
     * If a setter is used then no validator should be used as the setter should handle the validation itself!
     *
     * @param value the value to be set.
     * @param session the session that is requesting the value (if any).
     * @param endpoint the endpoint the cluster server of this attribute is assigned to.
     */
    validator?: (value: T, session?: Session, endpoint?: EndpointInterface) => void);
    /**
     * Initialize the value of the attribute, used when a persisted value is set initially or when values needs to be
     * adjusted before the Device gets announced. Do not use this method to change values when the device is in use!
     */
    init(value: T | undefined): void;
    /**
     * Set the value of the attribute. This method is used by the Interaction model to write the value of the attribute
     * and includes the ACL check. It should not be used locally in the code!
     *
     * If a setter is defined this setter method is called to store the value.
     *
     * Listeners are called when the value changes (internal listeners) or in any case (external listeners).
     */
    set(value: T, session: Session, message?: Message, delayChangeEvents?: boolean): void;
    /**
     * Method that contains the logic to set a value "from remote" (e.g. from a client).
     */
    protected setRemote(value: T, session: Session, message?: Message, delayChangeEvents?: boolean): void;
    /**
     * Set the value of the attribute locally. This method should be used locally in the code and does not include the
     * ACL check.
     *
     * If a setter is defined this setter method is called to validate and store the value.
     *
     * Else if a validator is defined the value is validated before it is stored.
     *
     * Listeners are called when the value changes (internal listeners) or in any case (external listeners).
     */
    setLocal(value: T): void;
    /**
     * Helper Method to process the set of a value in a generic way. This method is used internally.
     */
    protected processSet(value: T, session?: Session, message?: Message, delayChangeEvents?: boolean): void;
    triggerDelayedChangeEvents(): void;
    /**
     * Helper Method to handle needed version increases and trigger the relevant listeners. This method is used
     * internally.
     */
    protected handleVersionAndTriggerListeners(value: T, oldValue: T | undefined, considerVersionChanged: boolean): void;
    /**
     * When the value is handled by getter or setter methods and is changed by other processes this method can be used
     * to notify the attribute server that the value has changed. This will increase the version number and trigger the
     * listeners.
     *
     * ACL checks needs to be performed before calling this method.
     */
    updated(session: SecureSession): void;
    /**
     * When the value is handled by getter or setter methods and is changed by other processes and no session from the
     * originating process is known this method can be used to notify the attribute server that the value has changed.
     * This will increase the version number and trigger the listeners.
     *
     * ACL checks needs to be performed before calling this method.
     */
    updatedLocal(): void;
    /**
     * Add an internal listener that is called when the value of the attribute changes. The listener is called with the
     * new value and the version number.
     */
    addValueChangeListener(listener: (value: T, version: number) => void): void;
    /**
     * Remove an internal listener.
     */
    removeValueChangeListener(listener: (value: T, version: number) => void): void;
    /**
     * Add an external listener that is called when the value of the attribute changes. The listener is called with the
     * new value and the old value.
     */
    addValueSetListener(listener: (newValue: T, oldValue: T) => void): void;
    /**
     * Add an external listener that is called when the value of the attribute changes. The listener is called with the
     * new value and the old value. This method is a convenient alias for addValueSetListener.
     */
    subscribe(listener: (newValue: T, oldValue: T) => void): void;
    /**
     * Remove an external listener.
     */
    removeValueSetListener(listener: (newValue: T, oldValue: T) => void): void;
}
export declare function genericFabricScopedAttributeGetterFromFabric<T>(fabric: Fabric, cluster: Cluster<any, any, any, any, any>, attributeName: string, defaultValue: T): T;
export declare function genericFabricScopedAttributeGetter<T>(session: Session | undefined, isFabricFiltered: boolean, cluster: Cluster<any, any, any, any, any>, attributeName: string, defaultValue: T, fabrics: Fabric[]): T;
export declare function genericFabricScopedAttributeSetterForFabric<T>(fabric: Fabric, cluster: Cluster<any, any, any, any, any>, attributeName: string, value: T, defaultValue?: T): boolean;
export declare function genericFabricScopedAttributeSetter<T>(value: T, session: Session | undefined, cluster: Cluster<any, any, any, any, any>, attributeName: string, defaultValue?: T): boolean;
/**
 * Attribute server which is getting and setting the value for a defined fabric. The values are automatically persisted
 * on fabric level if no custom getter or setter is defined.
 */
export declare class FabricScopedAttributeServer<T> extends AttributeServer<T> {
    #private;
    readonly cluster: Cluster<any, any, any, any, any>;
    private readonly isCustomGetter;
    private readonly isCustomSetter;
    private readonly fabricSensitiveElementsToRemove;
    constructor(id: AttributeId, name: string, readAcl: AccessLevel | undefined, writeAcl: AccessLevel | undefined, schema: TlvSchema<T>, isWritable: boolean, isSubscribable: boolean, requiresTimedInteraction: boolean, initValue: T, defaultValue: T | undefined, cluster: Cluster<any, any, any, any, any>, datasource: ClusterDatasource, getter?: (session?: Session, endpoint?: EndpointInterface, isFabricFiltered?: boolean) => T, setter?: (value: T, session?: Session, endpoint?: EndpointInterface, message?: Message) => boolean, validator?: (value: T, session?: Session, endpoint?: EndpointInterface) => void);
    get hasFabricSensitiveData(): boolean;
    /**
     * Sanitize the value of the attribute by removing fabric sensitive fields that do not belong to the
     * associated fabric
     */
    sanitizeFabricSensitiveFields(value: T, associatedFabric?: Fabric): any[] | T;
    /**
     * Initialize the attribute with a value. Because the value is stored on fabric level this method only initializes
     * the version number.
     */
    init(value: T | undefined): void;
    /**
     * Fabric scoped enhancement of set to allow setting special fabricindex locally.
     */
    set(value: T, session: Session, message: Message, delayChangeEvents?: boolean, preserveFabricIndex?: boolean): void;
    /**
     * Method that contains the logic to set a value "from remote" (e.g. from a client). For Fabric scoped attributes
     * we need to inject the fabric index into the value.
     */
    protected setRemote(value: T, session: Session, message: Message, delayChangeEvents?: boolean, preserveFabricIndex?: boolean): void;
    /**
     * Set Local is not allowed for fabric scoped attributes. Use setLocalForFabric instead.
     */
    setLocal(_value: T): void;
    /**
     * Set the value of the attribute locally for a fabric. This method should be used locally in the code and does not
     * include the ACL check.
     * If a setter is defined this method cannot be used!
     * If a validator is defined the value is validated before it is stored.
     * Listeners are called when the value changes (internal listeners) or in any case (external listeners).
     */
    setLocalForFabric(value: T, fabric: Fabric): void;
    /**
     * When the value is handled by getter or setter methods and is changed by other processes and no session from the
     * originating process is known this method can be used to notify the attribute server that the value has changed.
     * This will increase the version number and trigger the listeners.
     * ACL checks needs to be performed before calling this method.
     */
    updatedLocalForFabric(fabric: Fabric): void;
    /**
     * Get the value of the attribute locally for a special Fabric. This method should be used locally in the code and
     * does not include the ACL check.
     * If a getter is defined this method returns an error and the value should be retrieved directly internally.
     */
    getLocalForFabric(fabric: Fabric): T;
}
export {};
//# sourceMappingURL=AttributeServer.d.ts.map