"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var EventServer_exports = {};
__export(EventServer_exports, {
  EventServer: () => EventServer,
  FabricSensitiveEventServer: () => FabricSensitiveEventServer,
  createEventServer: () => createEventServer
});
module.exports = __toCommonJS(EventServer_exports);
var import_general = require("#general");
var import_model = require("#model");
var import_types = require("#types");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
function createEventServer(clusterDef, eventDef, eventName, schema, priority, readAcl) {
  let fabricSensitive = false;
  const clusterFromModel = import_model.MatterModel.standard.get(import_model.ClusterModel, clusterDef.id);
  if (clusterFromModel !== void 0) {
    const eventModel = clusterFromModel.get(import_model.EventModel, eventDef.id);
    if (eventModel !== void 0) {
      fabricSensitive = eventModel.fabricSensitive;
    }
  }
  if (fabricSensitive) {
    return new FabricSensitiveEventServer(eventDef.id, clusterDef.id, eventName, schema, priority, readAcl);
  }
  return new EventServer(eventDef.id, clusterDef.id, eventName, schema, priority, readAcl);
}
class EventServer {
  constructor(id, clusterId, name, schema, priority, readAcl) {
    this.id = id;
    this.clusterId = clusterId;
    this.name = name;
    this.schema = schema;
    this.priority = priority;
    this.#readAcl = readAcl;
  }
  eventList = new Array();
  listeners = new Array();
  endpoint;
  eventHandler;
  #readAcl;
  hasFabricSensitiveData = false;
  get readAcl() {
    return this.#readAcl ?? import_model.AccessLevel.View;
  }
  assignToEndpoint(endpoint) {
    this.endpoint = endpoint;
  }
  // TODO Try to get rid of that late binding and simply things again
  //      potentially with refactoring out MatterDevice and MatterController
  bindToEventHandler(eventHandler) {
    this.eventHandler = eventHandler;
    const promises = new Array();
    for (const event of this.eventList) {
      const finalEvent = this.eventHandler.add(event);
      if (finalEvent !== void 0 && import_general.MaybePromise.is(finalEvent)) {
        promises.push(finalEvent.then((e) => this.listeners.forEach((listener) => listener(e))));
      } else {
        this.listeners.forEach((listener) => listener(finalEvent));
      }
    }
    this.eventList = [];
    if (promises.length > 0) {
      return import_general.MatterAggregateError.allSettled(promises, "Error binding events to the event handlers").then(
        () => {
        }
      );
    }
    return void 0;
  }
  triggerEvent(data) {
    if (this.endpoint === void 0 || this.endpoint.number === void 0) {
      throw new import_general.InternalError("Endpoint not assigned");
    }
    const occurrence = {
      eventId: this.id,
      clusterId: this.clusterId,
      endpointId: this.endpoint.number,
      epochTimestamp: import_general.Time.nowMs(),
      priority: this.priority,
      payload: data
    };
    if (this.eventHandler === void 0) {
      this.eventList.push(occurrence);
    } else {
      const finalEvent = this.eventHandler.add(occurrence);
      return import_general.MaybePromise.then(finalEvent, (e) => {
        this.listeners.forEach((listener) => listener(e));
      });
    }
    return void 0;
  }
  addListener(listener) {
    this.listeners.push(listener);
  }
  removeListener(listener) {
    const entryIndex = this.listeners.indexOf(listener);
    if (entryIndex !== -1) {
      this.listeners.splice(entryIndex, 1);
    }
  }
  get(session, isFabricFiltered, _message, filters) {
    if (this.eventHandler === void 0) {
      throw new import_general.InternalError("EventServer not bound to OccurrenceManager");
    }
    if (this.endpoint === void 0) {
      throw new import_general.InternalError("EventServer not bound to Endpoint");
    }
    return this.eventHandler.query(
      { endpointId: this.endpoint.number, clusterId: this.clusterId, eventId: this.id },
      filters,
      // When request is fabric filtered or the event is Fabric sensitive then filter the events for the fabrics
      isFabricFiltered ? session.fabric?.fabricIndex ?? import_types.FabricIndex.NO_FABRIC : void 0
    );
  }
}
class FabricSensitiveEventServer extends EventServer {
  hasFabricSensitiveData = true;
  get(session, _isFabricFiltered, message, filters) {
    return super.get(session, true, message, filters);
  }
  triggerEvent(data) {
    if (!(0, import_general.isObject)(data) || data === null) {
      throw new import_general.ImplementationError("FabricSensitive events need to have an object as data.");
    }
    if (!("fabricIndex" in data)) {
      throw new import_general.InternalError("FabricSensitive events requires fabricIndex in data.");
    }
    return super.triggerEvent(data);
  }
}
//# sourceMappingURL=EventServer.js.map
