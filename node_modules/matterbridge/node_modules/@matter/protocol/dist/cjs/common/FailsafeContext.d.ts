/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { AsyncObservable, Construction, MatterFlowError } from "#general";
import { NodeId, VendorId } from "#types";
import { Fabric } from "../fabric/Fabric.js";
import { FabricManager } from "../fabric/FabricManager.js";
import { SessionManager } from "../session/SessionManager.js";
import { FailsafeTimer } from "./FailsafeTimer.js";
export declare class MatterFabricInvalidAdminSubjectError extends MatterFlowError {
}
/**
 * A "timed operation" is a command or sequence of commands that operate with a failsafe timer that will abort the
 * operation if it does not complete within a specific window.
 *
 * FailsafeContext maintains the failsafe timer and tracks information required to rollback state if the operation
 * aborts.
 *
 * Timed operations are exclusive for a node.
 */
export declare abstract class FailsafeContext {
    #private;
    constructor(options: FailsafeContext.Options);
    extend(fabric: Fabric | undefined, expiryLengthSeconds: number): Promise<void>;
    get fabricIndex(): import("#types").FabricIndex | undefined;
    get construction(): Construction<FailsafeContext>;
    get commissioned(): AsyncObservable<[], void>;
    get associatedFabric(): Fabric | undefined;
    get csrSessionId(): number | undefined;
    get forUpdateNoc(): boolean | undefined;
    get rootCertSet(): boolean;
    get hasRootCert(): boolean;
    get rootCert(): Uint8Array<ArrayBufferLike> | undefined;
    completeCommission(): Promise<void>;
    getFailSafeContext(): FailsafeTimer;
    getNextFabricIndex(): import("#types").FabricIndex;
    addFabric(fabric: Fabric): Promise<import("#types").FabricIndex>;
    updateFabric(fabric: Fabric): Promise<void>;
    /**
     * Handles a CSR from OperationalCredentials cluster and stores additional internal information for further
     * validity checks.
     */
    createCertificateSigningRequest(isForUpdateNoc: boolean, sessionId: number): Uint8Array<ArrayBufferLike>;
    removePaseSession(): Promise<void>;
    close(): Promise<void>;
    /** Handles adding a trusted root certificate from Operational Credentials cluster. */
    setRootCert(rootCert: Uint8Array): void;
    /**
     * Build a new Fabric object based on an existing fabric for the "UpdateNoc" case of the Operational Credentials
     * cluster.
     */
    buildUpdatedFabric(nocValue: Uint8Array, icacValue: Uint8Array | undefined): Promise<Fabric>;
    /** Build a new Fabric object for a new fabric for the "AddNoc" case of the Operational Credentials cluster. */
    buildFabric(nocData: {
        nocValue: Uint8Array;
        icacValue: Uint8Array | undefined;
        adminVendorId: VendorId;
        ipkValue: Uint8Array;
        caseAdminSubject: NodeId;
    }): Promise<Fabric>;
    protected rollback(): Promise<void>;
    abstract storeEndpointState(): Promise<void>;
    /** Restore Cluster data when the FailSafe context expired. */
    abstract restoreNetworkState(): Promise<void>;
    restoreFabric(fabric: Fabric): Promise<void>;
    abstract revokeFabric(fabric: Fabric): Promise<void>;
    abstract restoreBreadcrumb(): Promise<void>;
}
export declare namespace FailsafeContext {
    interface Options {
        sessions: SessionManager;
        fabrics: FabricManager;
        expiryLengthSeconds: number;
        maxCumulativeFailsafeSeconds: number;
        associatedFabric: Fabric | undefined;
    }
}
//# sourceMappingURL=FailsafeContext.d.ts.map