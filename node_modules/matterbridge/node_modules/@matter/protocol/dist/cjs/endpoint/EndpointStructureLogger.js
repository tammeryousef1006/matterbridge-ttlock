"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var EndpointStructureLogger_exports = {};
__export(EndpointStructureLogger_exports, {
  logEndpoint: () => logEndpoint
});
module.exports = __toCommonJS(EndpointStructureLogger_exports);
var import_general = require("#general");
var import_types = require("#types");
var import_AttributeClient = require("../cluster/client/AttributeClient.js");
var import_AttributeServer = require("../cluster/server/AttributeServer.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("EndpointStructureLogger");
function getAttributeServerValue(attribute, options = {}) {
  let value = "";
  try {
    const attributeValue = attribute.getLocal();
    const attributeValueType = typeof attributeValue;
    if ((attributeValueType !== "object" || attributeValue === null) && options.logAttributePrimitiveValues !== false) {
      value = attributeValue === null ? "null" : attributeValue.toString();
    } else if (attributeValueType === "object" && attributeValue !== null && options.logAttributeObjectValues !== false) {
      value = import_general.Diagnostic.json(attributeValue);
    }
  } catch (error) {
    if (error instanceof import_AttributeServer.FabricScopeError) {
      value = "Fabric-Scoped";
    } else {
      value = `Error: ${error.message}`;
    }
  }
  return value;
}
function logClusterServer(endpoint, clusterServer, options = {}) {
  if (options.clusterServerFilter !== void 0 && !options.clusterServerFilter(endpoint, clusterServer)) return;
  const featureMap = clusterServer.attributes.featureMap?.getLocal() ?? {};
  const globalAttributes = (0, import_types.GlobalAttributes)(featureMap);
  const supportedFeatures = new Array();
  for (const featureName in featureMap) {
    if (featureMap[featureName] === true) supportedFeatures.push(featureName);
  }
  logger.info(
    `Cluster-Server "${clusterServer.name}" (${import_general.Diagnostic.hex(clusterServer.id)}) ${supportedFeatures.length ? `(Features: ${supportedFeatures.join(", ")})` : ""}`
  );
  if (options.logClusterGlobalAttributes !== false) {
    import_general.Logger.nest(() => {
      logger.info("Global-Attributes:");
      import_general.Logger.nest(() => {
        for (const attributeName in globalAttributes) {
          const attribute = clusterServer.attributes[attributeName];
          if (attribute === void 0) continue;
          const value = getAttributeServerValue(attribute, options);
          logger.info(
            `"${attribute.name}" (${import_general.Diagnostic.hex(attribute.id)})${value !== "" ? `: value = ${value}` : ""}`
          );
        }
      });
    });
  }
  if (options.logClusterAttributes !== false) {
    import_general.Logger.nest(() => {
      logger.info("Attributes:");
      import_general.Logger.nest(() => {
        for (const attributeName in clusterServer.attributes) {
          if (attributeName in globalAttributes) continue;
          const attribute = clusterServer.attributes[attributeName];
          if (attribute === void 0) continue;
          const value = getAttributeServerValue(attribute, options);
          logger.info(
            `"${attribute.name}" (${import_general.Diagnostic.hex(attribute.id)})${value !== "" ? `: value = ${value}` : ""}`
          );
        }
      });
    });
  }
  if (options.logClusterCommands !== false) {
    import_general.Logger.nest(() => {
      logger.info("Commands:");
      import_general.Logger.nest(() => {
        const commands = clusterServer.commands;
        for (const commandName in commands) {
          const command = commands[commandName];
          if (command === void 0) continue;
          logger.info(
            `"${command.name}" (${import_general.Diagnostic.hex(command.invokeId)}/${import_general.Diagnostic.hex(command.responseId)})`
          );
        }
      });
    });
  }
  if (options.logClusterEvents !== false) {
    import_general.Logger.nest(() => {
      logger.info("Events:");
      import_general.Logger.nest(() => {
        const events = clusterServer.events;
        for (const eventName in events) {
          const event = events[eventName];
          if (event === void 0) continue;
          logger.info(`"${event.name}" (${import_general.Diagnostic.hex(event.id)})`);
        }
      });
    });
  }
}
function logClusterClient(endpoint, clusterClient, options = {}) {
  if (options.clusterClientFilter !== void 0 && !options.clusterClientFilter(endpoint, clusterClient)) return;
  const { supportedFeatures: features } = clusterClient;
  const globalAttributes = (0, import_types.GlobalAttributes)(features);
  const supportedFeatures = new Array();
  for (const featureName in features) {
    if (features[featureName] === true) supportedFeatures.push(featureName);
  }
  logger.info(
    `Cluster-Client "${clusterClient.name}" (${import_general.Diagnostic.hex(clusterClient.id)}) ${supportedFeatures.length ? `(Features: ${supportedFeatures.join(", ")})` : ""}`
  );
  if (options.logClusterGlobalAttributes !== false) {
    import_general.Logger.nest(() => {
      logger.info("Global-Attributes:");
      import_general.Logger.nest(() => {
        for (const attributeName in globalAttributes) {
          const attribute = clusterClient.attributes[attributeName];
          if (attribute === void 0) continue;
          logger.info(`"${attribute.name}" (${import_general.Diagnostic.hex(attribute.id)})`);
        }
      });
    });
  }
  if (options.logClusterAttributes !== false) {
    import_general.Logger.nest(() => {
      logger.info("Attributes:");
      import_general.Logger.nest(() => {
        for (const attributeName in clusterClient.attributes) {
          if (attributeName in globalAttributes) continue;
          const attribute = clusterClient.attributes[attributeName];
          if (attribute === void 0) continue;
          const supported = attribute instanceof import_AttributeClient.SupportedAttributeClient;
          if (!supported && options.logNotSupportedClusterAttributes === false) continue;
          const unknown = attribute instanceof import_AttributeClient.UnknownSupportedAttributeClient;
          let info = "";
          if (!supported) info += " (Not Supported)";
          if (unknown) info += " (Unknown)";
          logger.info(`"${attribute.name}" (${import_general.Diagnostic.hex(attribute.id)})${info}`);
        }
      });
    });
  }
  if (options.logClusterCommands !== false) {
    import_general.Logger.nest(() => {
      logger.info("Commands:");
      import_general.Logger.nest(() => {
        for (const commandName in clusterClient.commands) {
          if (commandName.match(/^\d+$/)) continue;
          const supported = clusterClient.isCommandSupportedByName(commandName);
          if (!supported && options.logNotSupportedClusterCommands === false) continue;
          logger.info(`"${commandName}"${supported ? "" : " (Not Supported)"}`);
        }
      });
    });
  }
  if (options.logClusterEvents !== false) {
    import_general.Logger.nest(() => {
      logger.info("Events:");
      import_general.Logger.nest(() => {
        for (const eventName in clusterClient.events) {
          const event = clusterClient.events[eventName];
          if (event === void 0) continue;
          logger.info(`"${event.name}" (${import_general.Diagnostic.hex(event.id)})`);
        }
      });
    });
  }
}
function logEndpoint(endpoint, options = {
  logNotSupportedClusterAttributes: false,
  logNotSupportedClusterEvents: false,
  logNotSupportedClusterCommands: false
}) {
  if (options.endpointFilter !== void 0 && !options.endpointFilter(endpoint)) return;
  logger.info(`Endpoint ${endpoint.number} (${endpoint.name}):`);
  if (options.logClusterServers !== false) {
    import_general.Logger.nest(() => {
      logger.info("Cluster-Servers:");
      import_general.Logger.nest(() => {
        for (const clusterServer of endpoint.getAllClusterServers()) {
          logClusterServer(endpoint, clusterServer, options);
        }
      });
    });
  }
  if (options.logClusterClients !== false) {
    import_general.Logger.nest(() => {
      logger.info("Cluster-Clients:");
      import_general.Logger.nest(() => {
        for (const clusterClient of endpoint.getAllClusterClients()) {
          logClusterClient(endpoint, clusterClient, options);
        }
      });
    });
  }
  if (options.logChildEndpoints !== false) {
    import_general.Logger.nest(() => {
      logger.info("Child-Endpoints:");
      import_general.Logger.nest(() => {
        for (const childEndpoint of endpoint.getChildEndpoints()) {
          logEndpoint(childEndpoint, options);
        }
      });
    });
  }
}
//# sourceMappingURL=EndpointStructureLogger.js.map
