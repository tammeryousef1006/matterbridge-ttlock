"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var NonvolatileEventStore_exports = {};
__export(NonvolatileEventStore_exports, {
  NonvolatileEventStore: () => NonvolatileEventStore
});
module.exports = __toCommonJS(NonvolatileEventStore_exports);
var import_general = require("#general");
var import_BaseEventStore = require("./BaseEventStore.js");
var import_EventStore = require("./EventStore.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("NonvolatileEventStore");
class NonvolatileEventStore extends import_BaseEventStore.BaseEventStore {
  #removeNumberReservation = false;
  #iops = /* @__PURE__ */ new Set();
  /**
   * Create new store that persistes events into {@link storage}.
   */
  constructor(storage) {
    super(storage);
  }
  async load() {
    const { reservationEnd, eventIds: eventNumbers } = await this.loadInitialState();
    if (reservationEnd !== void 0) {
      logger.warn("Converting volatile state store to non-volatile");
      this.#removeNumberReservation = true;
    }
    const index = Array();
    for (const number of eventNumbers) {
      const occurrence = await this.eventStorage.get(number.toString());
      if (typeof occurrence !== "object" || occurrence === null) {
        logger.warn("Ignoring invalid stored event occurrence");
        continue;
      }
      index.push((0, import_EventStore.OccurrenceSummary)(number, occurrence));
    }
    this.logLoad("non-volatile");
    return index;
  }
  add(occurrence) {
    const number = this.allocateNumber();
    const result = import_general.MaybePromise.then(this.eventStorage.set(number.toString(), occurrence), () => {
      const summary = (0, import_EventStore.OccurrenceSummary)(number, occurrence);
      if (this.#removeNumberReservation) {
        this.#removeNumberReservation = false;
        const conversion = this.storage.delete(import_BaseEventStore.BaseEventStore.LAST_RESERVED_NUMBER_KEY);
        return import_general.MaybePromise.then(
          conversion,
          () => summary,
          (error) => {
            console.warn("Error clearing volatile event number reservation", error);
            return summary;
          }
        );
      }
      return summary;
    });
    return this.#trackIop(result);
  }
  get(number) {
    return this.#trackIop(this.eventStorage.get(number.toString()));
  }
  delete(number) {
    return this.#trackIop(this.eventStorage.delete(number.toString()));
  }
  clear() {
    this.#removeNumberReservation = false;
    return super.clear();
  }
  close() {
    if (this.#iops.size) {
      return import_general.MatterAggregateError.allSettled(this.#iops, "Error closing event store").then(() => {
      }).catch((error) => logger.error(error));
    }
  }
  /**
   * All operations may be async depending on storage so we track them in a set so we can ensure we don't close until
   * they complete.  This should happen at higher levels so this is just for completeness.
   */
  #trackIop(result) {
    if (import_general.MaybePromise.is(result)) {
      logger.warn("Waiting on ongoing write before event store closure");
      result = Promise.resolve(result).finally(() => this.#iops.delete(result));
      this.#iops.add(result);
    }
    return result;
  }
}
//# sourceMappingURL=NonvolatileEventStore.js.map
