/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Construction, MaybePromise } from "#general";
import { FabricIndex, TlvEventFilter, TlvEventPath, TypeFromSchema } from "#types";
import { EventStore } from "./EventStore.js";
import { NumberedOccurrence, Occurrence } from "./Occurrence.js";
export interface OccurrenceManagerContext {
    store: EventStore;
    bufferConfig?: OccurrenceManager.BufferConfig;
}
/**
 * Manages event occurrences.
 *
 * Each time an event is triggered it is stored as an {@link Occurrence} in this manager.  Occurrences are persisted in
 * an {@link EventStore} and may be retrieved using Matter query semantics.
 *
 * Drops occurrences when the store becomes too full as configured by {@link OccurrenceManager.BufferConfig}.
 *
 * TODO - query is extremely inefficient.  For new code paths should build internal index and bypass EventServer to
 * deliver query in wire form directly here
 */
export declare class OccurrenceManager {
    #private;
    get construction(): Construction<OccurrenceManager>;
    static create(context: OccurrenceManagerContext): Promise<OccurrenceManager>;
    constructor({ store, bufferConfig }: OccurrenceManagerContext);
    clear(): Promise<void>;
    query(eventPath: TypeFromSchema<typeof TlvEventPath>, filters?: TypeFromSchema<typeof TlvEventFilter>[], filterForFabricIndex?: FabricIndex): MaybePromise<NumberedOccurrence[]>;
    close(): MaybePromise<void>;
    add(occurrence: Occurrence): MaybePromise<NumberedOccurrence>;
}
export declare namespace OccurrenceManager {
    /**
     * Buffer management configuration.  Controls
     */
    interface BufferConfig {
        /**
         * The minimum number of events that will be buffered.
         */
        minEventAllowance: number;
        /**
         * The maximum number of events that will be buffered.
         *
         * When the buffer hits this size the manager discard events to reduce the buffer size to
         * {@link minimumEventAllowance}.
         */
        maxEventAllowance: number;
        /**
         * Minimum allowances by priority.  This ensures a minimum number of events for each priority avoid LRU
         * harvesting.
         */
        minPriorityEventAllowance: {
            critical: number;
            info: number;
            debug: number;
        };
    }
    const DefaultBufferConfig: BufferConfig;
}
//# sourceMappingURL=OccurrenceManager.d.ts.map