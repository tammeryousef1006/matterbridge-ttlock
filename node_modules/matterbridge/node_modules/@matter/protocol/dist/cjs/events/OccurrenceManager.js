"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var OccurrenceManager_exports = {};
__export(OccurrenceManager_exports, {
  OccurrenceManager: () => OccurrenceManager
});
module.exports = __toCommonJS(OccurrenceManager_exports);
var import_general = require("#general");
var import_types = require("#types");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("OccurrenceManager");
class OccurrenceManager {
  #store;
  #storedEventCount = 0;
  #bufferConfig;
  #cull;
  // As we don't (yet) have storage with secondary indices we currently maintain indices in memory regardless of
  // whether underlying store is volatile
  #occurrences = {
    [import_types.EventPriority.Critical]: new Array(),
    [import_types.EventPriority.Info]: new Array(),
    [import_types.EventPriority.Debug]: new Array()
  };
  #construction;
  get construction() {
    return this.#construction;
  }
  static async create(context) {
    return (0, import_general.asyncNew)(OccurrenceManager, context);
  }
  constructor({ store, bufferConfig }) {
    if (bufferConfig === void 0) {
      bufferConfig = OccurrenceManager.DefaultBufferConfig;
    }
    const { minEventAllowance, maxEventAllowance } = bufferConfig;
    if (maxEventAllowance < minEventAllowance) {
      throw new import_general.ImplementationError(
        `Maximum allowance ${maxEventAllowance} is less than minimum allowance ${minEventAllowance}`
      );
    }
    const totalPriorityAllowance = Object.values(bufferConfig.minPriorityEventAllowance).reduce(
      (sum, value) => sum + value,
      0
    );
    if (totalPriorityAllowance > minEventAllowance) {
      throw new import_general.ImplementationError(
        `Total priority allowance ${totalPriorityAllowance} is greater than minimum allowance of ${minEventAllowance}`
      );
    }
    this.#store = store;
    this.#bufferConfig = bufferConfig;
    this.#construction = (0, import_general.Construction)(this, () => {
      return import_general.MaybePromise.then(this.#store.load(), (index) => {
        this.#storedEventCount = index.length;
        for (const entry of index) {
          this.#occurrences[entry.priority].push(entry);
        }
      });
    });
  }
  async clear() {
    await this.construction;
    await this.#store.clear();
    this.#storedEventCount = 0;
    for (const list of Object.values(this.#occurrences)) {
      list.length = 0;
    }
  }
  query(eventPath, filters, filterForFabricIndex) {
    const entryFilter = filters !== void 0 && filters.length > 0 ? (event) => filters.some(
      (filter) => filter.eventMin !== void 0 && event.number >= (0, import_types.EventNumber)(filter.eventMin)
    ) : void 0;
    let isAsyncLoad = false;
    const occurrences = new Array();
    const { endpointId, clusterId, eventId } = eventPath;
    for (const priority of [import_types.EventPriority.Critical, import_types.EventPriority.Info, import_types.EventPriority.Debug]) {
      const entriesToCheck = this.#occurrences[priority];
      for (const entry of entriesToCheck) {
        if (endpointId === entry.endpointId && clusterId === entry.clusterId && eventId === entry.eventId) {
          if (entryFilter?.(entry) !== false) {
            let occurrence = this.#store.get(entry.number);
            occurrence = import_general.MaybePromise.then(occurrence, (occurrence2) => {
              occurrence2.number = entry.number;
              return occurrence2;
            });
            occurrences.push(occurrence);
            if (import_general.MaybePromise.is(occurrence)) {
              isAsyncLoad = true;
            }
          }
        }
      }
    }
    logger.debug(
      `Got ${occurrences.length} events for ${(0, import_types.resolveEventName)(eventPath)} with filters: ${import_general.Diagnostic.json(filters)}`
    );
    let result;
    if (isAsyncLoad) {
      result = Promise.all(occurrences);
    } else {
      result = occurrences;
    }
    if (filterForFabricIndex !== void 0) {
      result = import_general.MaybePromise.then(
        result,
        (occurrences2) => occurrences2.filter(({ payload }) => {
          if (!(0, import_general.isObject)(payload)) {
            return true;
          }
          const { fabricIndex } = payload;
          return fabricIndex === void 0 || fabricIndex === filterForFabricIndex;
        })
      );
    }
    result = import_general.MaybePromise.then(result, (occurrences2) => {
      let filterDesc;
      if (filters?.length) {
        filterDesc = filters.map(({ nodeId, eventMin }) => `${nodeId}:${eventMin}`).join(",");
      }
      if (filterForFabricIndex) {
        if (filterDesc !== void 0) {
          filterDesc = `${filterDesc} and fabric #${filterForFabricIndex}`;
        } else {
          filterDesc = `fabric #${filterForFabricIndex}`;
        }
      }
      if (filterDesc) {
        filterDesc = ` (filters: ${filterDesc})`;
      } else {
        filterDesc = "";
      }
      logger.debug(
        `Loaded ${occurrences2.length} occurrence${occurrences2.length === 1 ? "" : "s"} for ${(0, import_types.resolveEventName)(eventPath)}${filterDesc}`
      );
      return occurrences2;
    });
    return result;
  }
  close() {
    import_general.MaybePromise.then(this.#cull, () => this.#store.close());
  }
  add(occurrence) {
    return import_general.MaybePromise.then(this.#store.add(occurrence), (entry) => {
      logger.debug(`Recorded event #${entry.number}: ${import_general.Diagnostic.json(occurrence)}`);
      this.#occurrences[occurrence.priority].push(entry);
      this.#storedEventCount++;
      if (this.#storedEventCount > this.#bufferConfig.maxEventAllowance) {
        this.#startCull();
      }
      return {
        number: entry.number,
        ...occurrence
      };
    });
  }
  #startCull() {
    if (this.#cull) {
      return;
    }
    const cull = this.#dropOldOccurrences();
    if (import_general.MaybePromise.is(cull)) {
      this.#cull = Promise.resolve(cull).finally(() => this.#cull = void 0);
    }
  }
  #dropOldOccurrences() {
    let count = this.#storedEventCount - this.#bufferConfig.minEventAllowance;
    if (count <= 0) {
      return;
    }
    logger.debug(`Event store is full; dropping ${count} old occurrence${count === 1 ? "s" : ""}`);
    const asyncDrops = Array();
    let totalCulled = 0;
    for (const priority of [import_types.EventPriority.Debug, import_types.EventPriority.Info, import_types.EventPriority.Critical]) {
      const occurrences = this.#occurrences[priority];
      const reservation = this.#bufferConfig.minPriorityEventAllowance[PriorityNames[priority]];
      let countThisPriority = 0;
      while (count && occurrences.length > reservation) {
        count--;
        countThisPriority++;
      }
      totalCulled += countThisPriority;
      for (const entry of occurrences.splice(0, countThisPriority)) {
        const drop = import_general.MaybePromise.catch(
          this.#store.delete(entry.number),
          (error) => logger.warn(`Error dropping occurrence #${entry}: ${error}`)
        );
        if (import_general.MaybePromise.is(drop)) {
          asyncDrops.push(drop);
        }
      }
      if (!count) {
        break;
      }
    }
    this.#storedEventCount -= totalCulled;
    if (asyncDrops.length) {
      return import_general.MatterAggregateError.allSettled(asyncDrops, "Error dropping occurrences").then(() => {
      }).catch((error) => logger.error(error));
    }
  }
}
const PriorityNames = {
  [import_types.EventPriority.Critical]: "critical",
  [import_types.EventPriority.Info]: "info",
  [import_types.EventPriority.Debug]: "debug"
};
((OccurrenceManager2) => {
  OccurrenceManager2.DefaultBufferConfig = {
    minEventAllowance: 1e4,
    maxEventAllowance: 11e3,
    minPriorityEventAllowance: {
      critical: 2e3,
      info: 2e3,
      debug: 2e3
    }
  };
})(OccurrenceManager || (OccurrenceManager = {}));
//# sourceMappingURL=OccurrenceManager.js.map
