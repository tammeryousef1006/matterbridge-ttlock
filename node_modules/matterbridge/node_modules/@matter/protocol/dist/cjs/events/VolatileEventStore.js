"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var VolatileEventStore_exports = {};
__export(VolatileEventStore_exports, {
  VolatileEventStore: () => VolatileEventStore
});
module.exports = __toCommonJS(VolatileEventStore_exports);
var import_general = require("#general");
var import_BaseEventStore = require("./BaseEventStore.js");
var import_EventStore = require("./EventStore.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("EphemeralEventStore");
class VolatileEventStore extends import_BaseEventStore.BaseEventStore {
  #numbersReservedTo;
  #numberBlockSize = 1e3;
  #events = /* @__PURE__ */ new Map();
  #reservationWrite;
  /**
   * Uses {@link storage} for persistence of "next" event number across restarts.
   *
   * {@link numberBlockSize} specifies how often storage is update with a new starting point.  A larger number reduces
   * writes but must remain small enough to avoid exhausting the full 64-bit even numbering space.
   */
  constructor(storage, numberBlockSize = 1e3) {
    super(storage);
    this.#numberBlockSize = numberBlockSize;
  }
  async load() {
    const { reservationEnd, eventIds } = await this.loadInitialState();
    if (eventIds.length) {
      logger.warn("Converting non-volatile state store to volatile");
      await this.eventStorage.clear();
    }
    this.#numbersReservedTo = reservationEnd;
    this.logLoad("volatile");
    return [];
  }
  get(number) {
    const event = this.#events.get(number);
    if (event === void 0) {
      throw new import_general.InternalError(`Invalid event occurrence #${number}`);
    }
    return event;
  }
  delete(number) {
    return this.storage.delete(number.toString());
  }
  add(occurrence) {
    if (this.#reservationWrite) {
      let write = void 0;
      const whenReady = () => {
        if (this.#reservationWrite === write) {
          this.#reservationWrite = void 0;
        }
        return this.add(occurrence);
      };
      write = this.#reservationWrite.then(whenReady, whenReady);
    }
    const number = this.allocateNumber();
    const key = (0, import_EventStore.OccurrenceSummary)(number, occurrence);
    const reservedTo = this.#numbersReservedTo ?? 1n;
    if (number >= reservedTo) {
      const reserveTo = reservedTo + BigInt(this.#numberBlockSize);
      let write = void 0;
      write = import_general.MaybePromise.then(this.storage.set(import_BaseEventStore.BaseEventStore.LAST_RESERVED_NUMBER_KEY, reserveTo), () => {
        this.#numbersReservedTo = reserveTo;
        this.#events.set(number, occurrence);
        if (write !== void 0 && this.#reservationWrite === write) {
          this.#reservationWrite = void 0;
        }
        return key;
      });
    }
    this.#events.set(number, occurrence);
    return key;
  }
  clear() {
    return import_general.MaybePromise.then(super.clear(), () => {
      this.#events = /* @__PURE__ */ new Map();
      this.#numbersReservedTo = void 0;
    });
  }
  close() {
    if (this.#reservationWrite) {
      return this.#reservationWrite?.then(
        () => {
        },
        () => {
        }
      );
    }
  }
}
//# sourceMappingURL=VolatileEventStore.js.map
