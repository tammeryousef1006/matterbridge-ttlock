"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var AccessControlManager_exports = {};
__export(AccessControlManager_exports, {
  AccessControlManager: () => AccessControlManager,
  AccessDeniedError: () => AccessDeniedError
});
module.exports = __toCommonJS(AccessControlManager_exports);
var import_access_control = require("#clusters/access-control");
var import_general = require("#general");
var import_model = require("#model");
var import_types = require("#types");
/**
 * @license
 * Copyright 2022-2023 Project CHIP Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("AccessControlManager");
const ImplicitDefaultPaseAclEntry = {
  fabricIndex: import_types.FabricIndex.NO_FABRIC,
  // not fabric-specific
  privilege: import_model.AccessLevel.Administer,
  authMode: import_access_control.AccessControl.AccessControlEntryAuthMode.Pase,
  subjects: [],
  targets: []
  // entire node
};
var AuthModeNone = /* @__PURE__ */ ((AuthModeNone2) => {
  AuthModeNone2[AuthModeNone2["None"] = 0] = "None";
  return AuthModeNone2;
})(AuthModeNone || {});
class AccessDeniedError extends import_types.StatusResponseError {
  constructor(message) {
    super(message ?? "Unauthorized", import_types.StatusCode.UnsupportedAccess);
  }
}
class AccessControlManager {
  #aclList;
  #extensionEntryAccessCheck = () => true;
  constructor(aclList = [], extensionEntryAccessCheck) {
    this.#aclList = aclList;
    if (extensionEntryAccessCheck !== void 0) {
      this.#extensionEntryAccessCheck = extensionEntryAccessCheck;
    }
  }
  /**
   * Public method used to update the Access Control List on changes.
   */
  updateAccessControlList(aclList = []) {
    this.#aclList = [...aclList];
  }
  /**
   * Get the Access Control List for a given fabric.
   */
  #getAccessControlEntriesForFabric(fabric) {
    return this.#aclList.filter((entry) => entry.fabricIndex === fabric.fabricIndex);
  }
  /**
   * Subjects must match exactly, or both are CAT with matching CAT ID and acceptable CAT version
   */
  #subjectMatches(aclSubject, isdSubject) {
    if (aclSubject === isdSubject) {
      return true;
    }
    if (!import_types.NodeId.isCaseAuthenticatedTag(aclSubject) || !import_types.NodeId.isCaseAuthenticatedTag(isdSubject)) {
      return false;
    }
    const aclSubjectCat = import_types.NodeId.extractAsCaseAuthenticatedTag(aclSubject);
    const isdSubjectCat = import_types.NodeId.extractAsCaseAuthenticatedTag(isdSubject);
    return import_types.CaseAuthenticatedTag.getIdentifyValue(aclSubjectCat) === import_types.CaseAuthenticatedTag.getIdentifyValue(isdSubjectCat) && import_types.CaseAuthenticatedTag.getVersion(isdSubjectCat) >= import_types.CaseAuthenticatedTag.getVersion(aclSubjectCat);
  }
  /**
   * Add the new privilege to the granted privileges set and also add any privileges subsumed by the new privilege.
   */
  #addGrantedPrivilege(grantedPrivileges, privilege) {
    grantedPrivileges.add(privilege);
    switch (privilege) {
      case import_model.AccessLevel.ProxyView:
        grantedPrivileges.add(import_model.AccessLevel.View);
        break;
      case import_model.AccessLevel.Operate:
        grantedPrivileges.add(import_model.AccessLevel.View);
        break;
      case import_model.AccessLevel.Manage:
        grantedPrivileges.add(import_model.AccessLevel.Operate);
        grantedPrivileges.add(import_model.AccessLevel.View);
        break;
      case import_model.AccessLevel.Administer:
        grantedPrivileges.add(import_model.AccessLevel.Manage);
        grantedPrivileges.add(import_model.AccessLevel.Operate);
        grantedPrivileges.add(import_model.AccessLevel.ProxyView);
        grantedPrivileges.add(import_model.AccessLevel.View);
        break;
    }
  }
  /**
   * Check if the given ACL entry is allowed to be used for the given subject descriptor, endpoint, and cluster ID.
   */
  allowsPrivilege(session, endpoint, clusterId, privilege) {
    const grantedPrivileges = this.getGrantedPrivileges(session, endpoint, clusterId);
    if (grantedPrivileges.includes(privilege)) {
      return true;
    }
    logger.notice(
      `Failed access control check for ${endpoint.id}/0x${(0, import_general.toHex)(clusterId)} and fabricIndex ${session.associatedFabric.fabricIndex}, acl=`,
      this.#getAccessControlEntriesForFabric(session.associatedFabric),
      "with ISD=",
      this.#getIsdFromMessage(session),
      "granted privileges=",
      grantedPrivileges,
      "not contains",
      privilege
    );
    return false;
  }
  /**
   * Determines the granted privileges for the given session, endpoint, and cluster ID and returns them.
   */
  getGrantedPrivileges(session, endpoint, clusterId) {
    const endpointId = endpoint.id;
    const fabric = session.fabric;
    const subjectDesc = this.#getIsdFromMessage(session);
    const acl = fabric ? this.#getAccessControlEntriesForFabric(fabric) : [ImplicitDefaultPaseAclEntry];
    const grantedPrivileges = /* @__PURE__ */ new Set();
    if (subjectDesc.authMode === import_access_control.AccessControl.AccessControlEntryAuthMode.Pase && subjectDesc.isCommissioning) {
      this.#addGrantedPrivilege(grantedPrivileges, import_model.AccessLevel.Administer);
    }
    for (const aclEntry of acl) {
      if (grantedPrivileges.has(import_model.AccessLevel.Administer)) {
        break;
      }
      if (aclEntry.fabricIndex === import_types.FabricIndex.NO_FABRIC || aclEntry.fabricIndex !== subjectDesc.fabricIndex) {
        logger.debug(
          "Skipping ACL entry with mismatched fabric index",
          aclEntry.fabricIndex,
          subjectDesc.fabricIndex
        );
        continue;
      }
      if (aclEntry.authMode !== subjectDesc.authMode) {
        logger.debug("Skipping ACL entry with mismatched auth mode", aclEntry.authMode, subjectDesc.authMode);
        continue;
      }
      if (aclEntry.subjects === null || aclEntry.subjects.length === 0) {
        if (aclEntry.authMode !== import_access_control.AccessControl.AccessControlEntryAuthMode.Case && aclEntry.authMode !== import_access_control.AccessControl.AccessControlEntryAuthMode.Group) {
          throw new import_general.MatterFlowError("ACL error: only CASE and Group auth can have empty subjects");
        }
      } else {
        let matchedSubject = false;
        subjectLoop: for (const aclSubject of aclEntry.subjects) {
          for (const isdSubject of subjectDesc.subjects) {
            if (this.#subjectMatches(aclSubject, isdSubject)) {
              matchedSubject = true;
              break subjectLoop;
            }
          }
        }
        if (!matchedSubject) {
          continue;
        }
      }
      if (aclEntry.targets === null || aclEntry.targets.length === 0) {
      } else {
        let matchedTarget = false;
        for (const {
          cluster: targetClusterId,
          endpoint: targetEndpointId,
          deviceType: targetDeviceType
        } of aclEntry.targets) {
          if (targetClusterId === null && targetEndpointId === null && targetDeviceType === null) {
            throw new import_general.MatterFlowError("ACL error: target cannot be empty");
          }
          if (targetEndpointId !== null && targetDeviceType !== null) {
            throw new import_general.MatterFlowError("ACL error: target cannot specify both endpoint and device type");
          }
          if (targetClusterId !== null && targetClusterId !== clusterId) {
            continue;
          }
          if (targetEndpointId !== null && targetEndpointId !== endpointId) {
            continue;
          }
          if (targetDeviceType !== null && !endpoint.deviceTypes.includes(targetDeviceType)) {
            continue;
          }
          matchedTarget = true;
          break;
        }
        if (!matchedTarget) {
          continue;
        }
      }
      if (!this.#extensionEntryAccessCheck(acl, aclEntry, subjectDesc, endpoint, clusterId)) {
        continue;
      }
      this.#addGrantedPrivilege(grantedPrivileges, aclEntry.privilege);
    }
    if (subjectDesc.authMode === import_access_control.AccessControl.AccessControlEntryAuthMode.Group && grantedPrivileges.has(import_model.AccessLevel.Administer)) {
      throw new import_general.MatterFlowError("ACL error: should never grant Administer privilege to a Group");
    }
    return [...grantedPrivileges];
  }
  /**
   * Determines the Incoming Subject Descriptor (ISD) from the given session.
   */
  #getIsdFromMessage(session) {
    const fabric = session.fabric;
    const isd = {
      isCommissioning: false,
      authMode: 0 /* None */,
      subjects: new Array(),
      fabricIndex: import_types.FabricIndex.NO_FABRIC
    };
    if (session.isPase) {
      isd.authMode = import_access_control.AccessControl.AccessControlEntryAuthMode.Pase;
      isd.isCommissioning = true;
      isd.subjects.push((0, import_types.NodeId)(0));
      if (fabric) {
        isd.fabricIndex = fabric.fabricIndex;
      }
    } else {
      isd.authMode = import_access_control.AccessControl.AccessControlEntryAuthMode.Case;
      isd.subjects.push(session.peerNodeId);
      session.caseAuthenticatedTags.forEach((cat) => isd.subjects.push(import_types.NodeId.fromCaseAuthenticatedTag(cat)));
      if (fabric === void 0) {
        throw new import_general.MatterFlowError("ACL error: fabric is undefined");
      }
      isd.fabricIndex = fabric.fabricIndex;
    }
    return isd;
  }
}
//# sourceMappingURL=AccessControlManager.js.map
