"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var AttributeDataDecoder_exports = {};
__export(AttributeDataDecoder_exports, {
  decodeAttributeValueWithSchema: () => decodeAttributeValueWithSchema,
  decodeListAttributeValueWithSchema: () => decodeListAttributeValueWithSchema,
  decodeUnknownAttributeValue: () => decodeUnknownAttributeValue,
  expandPathsInAttributeData: () => expandPathsInAttributeData,
  normalizeAndDecodeAttributeData: () => normalizeAndDecodeAttributeData,
  normalizeAndDecodeReadAttributeReport: () => normalizeAndDecodeReadAttributeReport,
  normalizeAttributeData: () => normalizeAttributeData,
  normalizeAttributeStatus: () => normalizeAttributeStatus,
  structureReadAttributeDataToClusterObject: () => structureReadAttributeDataToClusterObject
});
module.exports = __toCommonJS(AttributeDataDecoder_exports);
var import_general = require("#general");
var import_types = require("#types");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("AttributeDataDecoder");
function normalizeAndDecodeReadAttributeReport(data) {
  const dataValues = data.flatMap(({ attributeData }) => attributeData !== void 0 ? attributeData : []);
  const dataStatus = data.flatMap(({ attributeStatus }) => attributeStatus !== void 0 ? attributeStatus : []);
  return {
    attributeData: normalizeAndDecodeAttributeData(dataValues),
    attributeStatus: normalizeAttributeStatus(dataStatus)
  };
}
function expandPathsInAttributeData(data, acceptWildcardPaths = false) {
  let lastPath;
  data.forEach((value) => {
    if (value === void 0) return;
    const { path } = value;
    if (path.enableTagCompression) {
      if (lastPath === void 0) throw new import_general.UnexpectedDataError("Tag compression enabled, but no previous path");
      if (path.nodeId === void 0 && lastPath.nodeId !== void 0) path.nodeId = lastPath.nodeId;
      if (path.endpointId === void 0) path.endpointId = lastPath.endpointId;
      if (path.clusterId === void 0) path.clusterId = lastPath.clusterId;
      if (path.attributeId === void 0) path.attributeId = lastPath.attributeId;
      if (value.dataVersion === void 0 && lastPath.dataVersion !== void 0)
        value.dataVersion = lastPath.dataVersion;
    } else if (path.endpointId !== void 0 && path.clusterId !== void 0 && path.attributeId !== void 0) {
      lastPath = {
        nodeId: path.nodeId,
        endpointId: path.endpointId,
        clusterId: path.clusterId,
        attributeId: path.attributeId,
        dataVersion: value.dataVersion
      };
    } else if (!acceptWildcardPaths) {
      throw new import_general.UnexpectedDataError("Tag compression disabled, but path is incomplete: " + import_general.Diagnostic.json(path));
    }
  });
  return data;
}
function normalizeAttributeData(data, acceptWildcardPaths = false) {
  const expandedData = expandPathsInAttributeData(data, acceptWildcardPaths);
  const responseList = /* @__PURE__ */ new Map();
  expandedData.forEach((value) => {
    if (!value) return;
    const {
      path: { nodeId, endpointId, clusterId, attributeId }
    } = value;
    const mapId = `${nodeId}-${endpointId}-${clusterId}-${attributeId}`;
    const list = responseList.get(mapId) || [];
    list.push(value);
    responseList.set(mapId, list);
  });
  return Array.from(responseList.values());
}
function normalizeAttributeStatus(data) {
  const result = new Array();
  data.forEach((entry) => {
    const {
      path: { nodeId, endpointId, clusterId, attributeId },
      status
    } = entry;
    if (endpointId === void 0 || clusterId === void 0 || attributeId === void 0) {
      throw new import_general.UnexpectedDataError(`Invalid attribute path ${endpointId}/${clusterId}/${attributeId}`);
    }
    const cluster = (0, import_types.getClusterById)(clusterId);
    const attributeDetail = (0, import_types.getClusterAttributeById)(cluster, attributeId);
    if (attributeDetail === void 0) {
      result.push({
        path: {
          nodeId,
          endpointId,
          clusterId,
          attributeId,
          attributeName: `Unknown (${import_general.Diagnostic.hex(attributeId)})`
        },
        status: status.status,
        clusterStatus: status.clusterStatus
      });
      return;
    }
    result.push({
      path: { nodeId, endpointId, clusterId, attributeId, attributeName: attributeDetail.name },
      status: status.status,
      clusterStatus: status.clusterStatus
    });
  });
  return result;
}
function normalizeAndDecodeAttributeData(data) {
  const responseList = normalizeAttributeData(data);
  const result = new Array();
  responseList.forEach((values) => {
    const {
      path: { nodeId, endpointId, clusterId, attributeId },
      dataVersion
    } = values[0];
    if (endpointId === void 0 || clusterId === void 0 || attributeId === void 0) {
      throw new import_general.UnexpectedDataError(`Invalid attribute path ${endpointId}/${clusterId}/${attributeId}`);
    }
    try {
      const cluster = (0, import_types.getClusterById)(clusterId);
      const attributeDetail = (0, import_types.getClusterAttributeById)(cluster, attributeId);
      if (attributeDetail === void 0) {
        logger.debug(
          `Decode unknown attribute ${import_general.Diagnostic.hex(clusterId)}/${import_general.Diagnostic.hex(attributeId)} via the AnySchema.`
        );
        const attributeName = `Unknown (${import_general.Diagnostic.hex(attributeId)})`;
        const value2 = decodeUnknownAttributeValue(values);
        result.push({
          path: { nodeId, endpointId, clusterId, attributeId, attributeName },
          version: dataVersion,
          value: value2
        });
        return;
      }
      const { attribute, name } = attributeDetail;
      const value = decodeValueForAttribute(attribute, values);
      result.push({
        path: { nodeId, endpointId, clusterId, attributeId, attributeName: name },
        version: dataVersion,
        value
      });
    } catch (error) {
      logger.error(
        `Error decoding attribute ${endpointId}/${import_general.Diagnostic.hex(clusterId)}/${import_general.Diagnostic.hex(attributeId)}: ${error.message}`
      );
    }
  });
  return result;
}
function decodeValueForAttribute(attribute, values) {
  const { schema, optional, default: conformanceValue } = attribute;
  if (!values.length) {
    if (optional) return void 0;
    if (conformanceValue === void 0) throw new import_types.AttributeError(`Attribute not found.`);
    return conformanceValue;
  }
  return decodeAttributeValueWithSchema(schema, values);
}
function decodeListAttributeValueWithSchema(schema, values, currentValue) {
  if (!(schema instanceof import_types.ArraySchema)) {
    throw new import_general.UnexpectedDataError(`Attribute is not a list but multiple values were returned.`);
  }
  return schema.decodeFromChunkedArray(
    values.map(({ data, path: { listIndex } }) => ({ listIndex, element: data })),
    currentValue
  );
}
function decodeAttributeValueWithSchema(schema, values, defaultValue) {
  if (!values.length) {
    return defaultValue;
  }
  if (schema instanceof import_types.ArraySchema) {
    return decodeListAttributeValueWithSchema(schema, values, defaultValue);
  }
  if (values.length === 1 && values[0].path.listIndex === void 0) {
    return schema.decodeTlv(values[0].data);
  }
  if (values.some(({ path: { listIndex } }) => listIndex !== void 0)) {
    throw new import_general.UnexpectedDataError(`Attribute is not a list but we got actions with list entries`);
  }
  const bestDataVersionValue = values.sort(({ dataVersion: a }, { dataVersion: b }) => (b ?? 0) - (a ?? 0));
  return schema.decodeTlv(bestDataVersionValue[0].data);
}
function decodeUnknownAttributeValue(values) {
  const schema = import_types.TlvAny;
  if (!values.length) {
    return void 0;
  }
  if (values.length === 1 && values[0].path.listIndex === void 0) {
    const tlvEncoded = schema.decodeTlv(values[0].data);
    return schema.decodeAnyTlvStream(tlvEncoded);
  } else {
    const tlvEncoded = new import_types.ArraySchema(schema).decodeFromChunkedArray(
      values.map(({ data, path: { listIndex } }) => ({ listIndex, element: data }))
    );
    return tlvEncoded.map((element) => schema.decodeAnyTlvStream(element));
  }
}
function structureReadAttributeDataToClusterObject(data) {
  const structure = {};
  for (const {
    path: { endpointId, clusterId, attributeName },
    value
  } of data) {
    if (structure[endpointId] === void 0) {
      if (endpointId === "__proto__") {
        continue;
      }
      structure[endpointId] = {};
    }
    if (structure[endpointId][clusterId] === void 0) {
      if (clusterId === "__proto__") {
        continue;
      }
      structure[endpointId][clusterId] = {};
    }
    structure[endpointId][clusterId][attributeName] = value;
  }
  return structure;
}
//# sourceMappingURL=AttributeDataDecoder.js.map
