"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var AttributeDataEncoder_exports = {};
__export(AttributeDataEncoder_exports, {
  canAttributePayloadBeChunked: () => canAttributePayloadBeChunked,
  chunkAttributePayload: () => chunkAttributePayload,
  compressAttributeDataReportTags: () => compressAttributeDataReportTags,
  encodeAttributePayload: () => encodeAttributePayload,
  encodeAttributePayloadData: () => encodeAttributePayloadData,
  encodeEventPayload: () => encodeEventPayload,
  sortAttributeDataByPath: () => sortAttributeDataByPath
});
module.exports = __toCommonJS(AttributeDataEncoder_exports);
var import_general = require("#general");
var import_types = require("#types");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
function encodeAttributePayloadData(attributePayload, options) {
  const { attributeData } = attributePayload;
  if (attributeData === void 0) {
    throw new import_general.MatterFlowError(
      `Cannot encode Attribute Payload data with just a attributeStatus: ${import_general.Diagnostic.json(attributePayload)}`
    );
  }
  const { schema, payload } = attributeData;
  return schema.encodeTlv(payload, options);
}
function encodeAttributePayload(attributePayload, options) {
  const { attributeData, attributeStatus } = attributePayload;
  if (attributeData === void 0) {
    return import_types.TlvAttributeReport.encodeTlv({ attributeStatus });
  }
  const { path, schema, payload, dataVersion } = attributeData;
  return import_types.TlvAttributeReport.encodeTlv({
    attributeData: { path, data: schema.encodeTlv(payload, options), dataVersion }
  });
}
function encodeEventPayload(eventPayload, options) {
  const { eventData, eventStatus } = eventPayload;
  if (eventData === void 0) {
    return import_types.TlvEventReport.encodeTlv({ eventStatus });
  }
  const {
    path,
    schema,
    payload,
    eventNumber,
    deltaEpochTimestamp,
    epochTimestamp,
    deltaSystemTimestamp,
    systemTimestamp,
    priority
  } = eventData;
  return import_types.TlvEventReport.encodeTlv({
    eventData: {
      path,
      data: schema.encodeTlv(payload, options),
      priority,
      systemTimestamp,
      deltaSystemTimestamp,
      deltaEpochTimestamp,
      epochTimestamp,
      eventNumber
    }
  });
}
function canAttributePayloadBeChunked(attributePayload) {
  const { attributeData } = attributePayload;
  if (attributeData === void 0) {
    return false;
  }
  const {
    schema,
    payload,
    path: { listIndex }
  } = attributeData;
  return schema instanceof import_types.ArraySchema && Array.isArray(payload) && payload.length > 0 && listIndex === void 0;
}
function chunkAttributePayload(attributePayload) {
  const { hasFabricSensitiveData, attributeData } = attributePayload;
  if (attributeData === void 0) {
    throw new import_general.MatterFlowError(
      `Cannot chunk an AttributePayload with just a attributeStatus: ${import_general.Diagnostic.json(attributePayload)}`
    );
  }
  const { schema, path, dataVersion, payload } = attributeData;
  if (!(schema instanceof import_types.ArraySchema) || !Array.isArray(payload)) {
    throw new import_general.MatterFlowError(
      `Cannot chunk an AttributePayload with attributeData that is not an array: ${import_general.Diagnostic.json(
        attributePayload
      )}`
    );
  }
  const chunks = new Array();
  chunks.push({
    hasFabricSensitiveData,
    attributeData: { schema, path: { ...path, listIndex: void 0 }, payload: [], dataVersion }
  });
  payload.forEach((element) => {
    chunks.push({
      hasFabricSensitiveData,
      attributeData: {
        schema: schema.elementSchema,
        path: { ...path, listIndex: null },
        payload: element,
        dataVersion
      }
    });
  });
  return chunks;
}
function sortAttributeDataByPath(data1, data2) {
  const { path: path1 } = data1.attributeData ?? data1.attributeStatus ?? {};
  const { path: path2 } = data2.attributeData ?? data2.attributeStatus ?? {};
  if (path1?.nodeId !== void 0 && path2?.nodeId !== void 0 && path1.nodeId !== path2.nodeId) {
    return path1.nodeId < path2.nodeId ? -1 : 1;
  }
  if (path1?.endpointId !== void 0 && path2?.endpointId !== void 0 && path1.endpointId !== path2.endpointId) {
    return path1.endpointId < path2.endpointId ? -1 : 1;
  }
  if (path1?.clusterId !== void 0 && path2?.clusterId !== void 0 && path1.clusterId !== path2.clusterId) {
    return path1.clusterId < path2.clusterId ? -1 : 1;
  }
  if (path1?.attributeId !== void 0 && path2?.attributeId !== void 0 && path1.attributeId !== path2.attributeId) {
    return path1.attributeId < path2.attributeId ? -1 : 1;
  }
  return 0;
}
function compressAttributeDataReportTags(data) {
  let lastFullPath;
  return data.sort(sortAttributeDataByPath).map(({ hasFabricSensitiveData, attributeData, attributeStatus }) => {
    if (attributeData !== void 0) {
      const { path, dataVersion } = attributeData;
      const compressedPath = compressPath(path, dataVersion, lastFullPath);
      const { enableTagCompression } = compressedPath.path;
      attributeData = {
        ...attributeData,
        path: compressedPath.path,
        dataVersion: enableTagCompression ? void 0 : dataVersion
      };
      lastFullPath = compressedPath.lastFullPath;
    }
    if (attributeStatus !== void 0) {
      const { path } = attributeStatus;
      const compressedPath = compressPath(path, void 0, lastFullPath);
      attributeStatus = { ...attributeStatus, path: compressedPath.path };
      lastFullPath = compressedPath.lastFullPath;
    }
    return { hasFabricSensitiveData, attributeData, attributeStatus };
  });
}
function compressPath(path, dataVersion, lastFullPath) {
  const { nodeId, endpointId, clusterId, attributeId } = path;
  if (endpointId === void 0 || clusterId === void 0 || attributeId === void 0) {
    return { path, lastFullPath };
  }
  const newFullPath = {
    path: { ...path, enableTagCompression: void 0 },
    lastFullPath: { nodeId, endpointId, clusterId, attributeId, dataVersion }
  };
  if (lastFullPath === void 0) {
    return newFullPath;
  }
  if (dataVersion !== void 0 && dataVersion !== lastFullPath.dataVersion) {
    return newFullPath;
  }
  let compressedElements = 0;
  const compressedPath = { ...path, enableTagCompression: true };
  if (endpointId === lastFullPath.endpointId) {
    delete compressedPath.endpointId;
    compressedElements++;
  }
  if (nodeId === lastFullPath.nodeId && nodeId !== void 0) {
    delete compressedPath.nodeId;
    compressedElements++;
  }
  if (compressedElements === 0) {
    return newFullPath;
  }
  return { path: compressedPath, lastFullPath };
}
//# sourceMappingURL=AttributeDataEncoder.js.map
