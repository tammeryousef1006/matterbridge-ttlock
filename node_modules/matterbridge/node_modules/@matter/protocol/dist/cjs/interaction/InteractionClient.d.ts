/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Environment, Environmental, PromiseQueue, ServerAddressIp, Timer } from "#general";
import { PeerAddress } from "#peer/PeerAddress.js";
import { PeerDataStore } from "#peer/PeerAddressStore.js";
import { DiscoveryOptions, PeerSet } from "#peer/PeerSet.js";
import { Attribute, AttributeId, AttributeJsType, ClusterId, Command, EndpointNumber, Event, EventId, EventNumber, NodeId, RequestType, ResponseType, StatusCode, TlvEventFilter, TypeFromSchema } from "#types";
import { MessageChannel } from "../protocol/ExchangeManager.js";
import { ExchangeProvider } from "../protocol/ExchangeProvider.js";
import { DecodedAttributeReportStatus, DecodedAttributeReportValue } from "./AttributeDataDecoder.js";
import { DecodedDataReport } from "./DecodedDataReport.js";
import { DecodedEventData, DecodedEventReportStatus, DecodedEventReportValue } from "./EventDataDecoder.js";
import { SubscriptionClient } from "./SubscriptionClient.js";
export interface AttributeStatus {
    path: {
        nodeId?: NodeId;
        endpointId?: EndpointNumber;
        clusterId?: ClusterId;
        attributeId?: AttributeId;
    };
    status: StatusCode;
}
export declare class InteractionClientProvider {
    #private;
    constructor(peers: PeerSet);
    static [Environmental.create](env: Environment): InteractionClientProvider;
    get peers(): PeerSet;
    connect(address: PeerAddress, options: {
        discoveryOptions: DiscoveryOptions;
        allowUnknownPeer?: boolean;
        operationalAddress?: ServerAddressIp;
    }): Promise<InteractionClient>;
    getInteractionClientForChannel(channel: MessageChannel): Promise<InteractionClient>;
    getInteractionClient(address: PeerAddress, discoveryOptions: DiscoveryOptions): Promise<InteractionClient>;
}
export declare class InteractionClient {
    #private;
    constructor(exchangeProvider: ExchangeProvider, subscriptionClient: SubscriptionClient, address?: PeerAddress, queue?: PromiseQueue, nodeStore?: PeerDataStore);
    get address(): PeerAddress;
    get isReconnectable(): boolean;
    get channelUpdated(): import("#general").Observable<[void], void>;
    removeSubscription(subscriptionId: number): void;
    getAllAttributes(options?: {
        dataVersionFilters?: {
            endpointId: EndpointNumber;
            clusterId: ClusterId;
            dataVersion: number;
        }[];
        enrichCachedAttributeData?: boolean;
        isFabricFiltered?: boolean;
        executeQueued?: boolean;
    }): Promise<DecodedAttributeReportValue<any>[]>;
    getAllEvents(options?: {
        eventFilters?: TypeFromSchema<typeof TlvEventFilter>[];
        isFabricFiltered?: boolean;
        executeQueued?: boolean;
    }): Promise<DecodedEventReportValue<any>[]>;
    getAllAttributesAndEvents(options?: {
        dataVersionFilters?: {
            endpointId: EndpointNumber;
            clusterId: ClusterId;
            dataVersion: number;
        }[];
        enrichCachedAttributeData?: boolean;
        eventFilters?: TypeFromSchema<typeof TlvEventFilter>[];
        isFabricFiltered?: boolean;
        executeQueued?: boolean;
    }): Promise<{
        attributeReports: DecodedAttributeReportValue<any>[];
        eventReports: DecodedEventReportValue<any>[];
    }>;
    getMultipleAttributes(options?: {
        attributes?: {
            endpointId?: EndpointNumber;
            clusterId?: ClusterId;
            attributeId?: AttributeId;
        }[];
        dataVersionFilters?: {
            endpointId: EndpointNumber;
            clusterId: ClusterId;
            dataVersion: number;
        }[];
        enrichCachedAttributeData?: boolean;
        isFabricFiltered?: boolean;
        executeQueued?: boolean;
    }): Promise<DecodedAttributeReportValue<any>[]>;
    getMultipleAttributesAndStatus(options?: {
        attributes?: {
            endpointId?: EndpointNumber;
            clusterId?: ClusterId;
            attributeId?: AttributeId;
        }[];
        dataVersionFilters?: {
            endpointId: EndpointNumber;
            clusterId: ClusterId;
            dataVersion: number;
        }[];
        enrichCachedAttributeData?: boolean;
        isFabricFiltered?: boolean;
        executeQueued?: boolean;
    }): Promise<{
        attributeData: DecodedAttributeReportValue<any>[];
        attributeStatus?: DecodedAttributeReportStatus[];
    }>;
    getMultipleEvents(options?: {
        events?: {
            endpointId?: EndpointNumber;
            clusterId?: ClusterId;
            eventId?: EventId;
        }[];
        eventFilters?: TypeFromSchema<typeof TlvEventFilter>[];
        isFabricFiltered?: boolean;
        executeQueued?: boolean;
    }): Promise<DecodedEventReportValue<any>[]>;
    getMultipleEventsAndStatus(options?: {
        events?: {
            endpointId?: EndpointNumber;
            clusterId?: ClusterId;
            eventId?: EventId;
        }[];
        eventFilters?: TypeFromSchema<typeof TlvEventFilter>[];
        isFabricFiltered?: boolean;
        executeQueued?: boolean;
    }): Promise<{
        eventData: DecodedEventReportValue<any>[];
        eventStatus?: DecodedEventReportStatus[];
    }>;
    getMultipleAttributesAndEvents(options?: {
        attributes?: {
            endpointId?: EndpointNumber;
            clusterId?: ClusterId;
            attributeId?: AttributeId;
        }[];
        dataVersionFilters?: {
            endpointId: EndpointNumber;
            clusterId: ClusterId;
            dataVersion: number;
        }[];
        enrichCachedAttributeData?: boolean;
        events?: {
            endpointId?: EndpointNumber;
            clusterId?: ClusterId;
            eventId?: EventId;
        }[];
        eventFilters?: TypeFromSchema<typeof TlvEventFilter>[];
        isFabricFiltered?: boolean;
        executeQueued?: boolean;
    }): Promise<DecodedDataReport>;
    getAttribute<A extends Attribute<any, any>>(options: {
        endpointId: EndpointNumber;
        clusterId: ClusterId;
        attribute: A;
        isFabricFiltered?: boolean;
        requestFromRemote?: boolean;
        executeQueued?: boolean;
    }): Promise<AttributeJsType<A> | undefined>;
    getAttributeWithVersion<A extends Attribute<any, any>>(options: {
        endpointId: EndpointNumber;
        clusterId: ClusterId;
        attribute: A;
        isFabricFiltered?: boolean;
        requestFromRemote?: boolean;
        executeQueued?: boolean;
    }): Promise<{
        value: AttributeJsType<A>;
        version: number;
    } | undefined>;
    getEvent<T, E extends Event<T, any>>(options: {
        endpointId: EndpointNumber;
        clusterId: ClusterId;
        event: E;
        minimumEventNumber?: EventNumber;
        isFabricFiltered?: boolean;
        executeQueued?: boolean;
    }): Promise<DecodedEventData<T>[] | undefined>;
    private processReadRequest;
    setAttribute<T>(options: {
        attributeData: {
            endpointId: EndpointNumber;
            clusterId: ClusterId;
            attribute: Attribute<T, any>;
            value: T;
            dataVersion?: number;
        };
        asTimedRequest?: boolean;
        timedRequestTimeoutMs?: number;
        suppressResponse?: boolean;
        executeQueued?: boolean;
        chunkLists?: boolean;
    }): Promise<void>;
    setMultipleAttributes(options: {
        attributes: {
            endpointId: EndpointNumber;
            clusterId: ClusterId;
            attribute: Attribute<any, any>;
            value: any;
            dataVersion?: number;
        }[];
        asTimedRequest?: boolean;
        timedRequestTimeoutMs?: number;
        suppressResponse?: boolean;
        executeQueued?: boolean;
        chunkLists?: boolean;
    }): Promise<AttributeStatus[]>;
    subscribeAttribute<A extends Attribute<any, any>>(options: {
        endpointId: EndpointNumber;
        clusterId: ClusterId;
        attribute: A;
        minIntervalFloorSeconds: number;
        maxIntervalCeilingSeconds: number;
        isFabricFiltered?: boolean;
        knownDataVersion?: number;
        keepSubscriptions?: boolean;
        listener?: (value: AttributeJsType<A>, version: number) => void;
        updateTimeoutHandler?: Timer.Callback;
        updateReceived?: () => void;
        executeQueued?: boolean;
    }): Promise<{
        maxInterval: number;
    }>;
    subscribeEvent<T, E extends Event<T, any>>(options: {
        endpointId: EndpointNumber;
        clusterId: ClusterId;
        event: E;
        minIntervalFloorSeconds: number;
        maxIntervalCeilingSeconds: number;
        isUrgent?: boolean;
        minimumEventNumber?: EventNumber;
        isFabricFiltered?: boolean;
        listener?: (value: DecodedEventData<T>) => void;
        updateTimeoutHandler?: Timer.Callback;
        updateReceived?: () => void;
        executeQueued?: boolean;
    }): Promise<{
        maxInterval: number;
    }>;
    subscribeAllAttributesAndEvents(options: {
        minIntervalFloorSeconds: number;
        maxIntervalCeilingSeconds: number;
        attributeListener?: (data: DecodedAttributeReportValue<any>, valueChanged?: boolean, oldValue?: unknown) => void;
        eventListener?: (data: DecodedEventReportValue<any>) => void;
        isUrgent?: boolean;
        keepSubscriptions?: boolean;
        isFabricFiltered?: boolean;
        eventFilters?: TypeFromSchema<typeof TlvEventFilter>[];
        dataVersionFilters?: {
            endpointId: EndpointNumber;
            clusterId: ClusterId;
            dataVersion: number;
        }[];
        enrichCachedAttributeData?: boolean;
        updateTimeoutHandler?: Timer.Callback;
        updateReceived?: () => void;
        executeQueued?: boolean;
    }): Promise<{
        attributeReports?: DecodedAttributeReportValue<any>[];
        eventReports?: DecodedEventReportValue<any>[];
        maxInterval: number;
    }>;
    subscribeMultipleAttributesAndEvents(options: {
        attributes?: {
            endpointId?: EndpointNumber;
            clusterId?: ClusterId;
            attributeId?: AttributeId;
        }[];
        events?: {
            endpointId?: EndpointNumber;
            clusterId?: ClusterId;
            eventId?: EventId;
            isUrgent?: boolean;
        }[];
        minIntervalFloorSeconds: number;
        maxIntervalCeilingSeconds: number;
        keepSubscriptions?: boolean;
        isFabricFiltered?: boolean;
        attributeListener?: (data: DecodedAttributeReportValue<any>, valueChanged?: boolean, oldValue?: any) => void;
        eventListener?: (data: DecodedEventReportValue<any>) => void;
        eventFilters?: TypeFromSchema<typeof TlvEventFilter>[];
        dataVersionFilters?: {
            endpointId: EndpointNumber;
            clusterId: ClusterId;
            dataVersion: number;
        }[];
        enrichCachedAttributeData?: boolean;
        updateTimeoutHandler?: Timer.Callback;
        updateReceived?: () => void;
        executeQueued?: boolean;
    }): Promise<{
        attributeReports?: DecodedAttributeReportValue<any>[];
        eventReports?: DecodedEventReportValue<any>[];
        maxInterval: number;
    }>;
    invoke<C extends Command<any, any, any>>(options: {
        endpointId: EndpointNumber;
        clusterId: ClusterId;
        request: RequestType<C>;
        command: C;
        /** Send as timed request. If no timedRequestTimeoutMs is provided the default of 10s will be used. */
        asTimedRequest?: boolean;
        /** Use this timeout and send the request as Timed Request. If this is specified the above parameter is implied. */
        timedRequestTimeoutMs?: number;
        /** Use an extended Message Response Timeout as defined for FailSafe cases which is 30s. */
        useExtendedFailSafeMessageResponseTimeout?: boolean;
        /** Execute this request queued - mainly used to execute invokes sequentially for thread devices. */
        executeQueued?: boolean;
        /** Skip request data validation. Use this only when you know that your data is correct and validation would return an error. */
        skipValidation?: boolean;
    }): Promise<ResponseType<C>>;
    invokeWithSuppressedResponse<C extends Command<any, any, any>>(options: {
        endpointId: EndpointNumber;
        clusterId: ClusterId;
        request: RequestType<C>;
        command: C;
        asTimedRequest?: boolean;
        timedRequestTimeoutMs?: number;
        executeQueued?: boolean;
    }): Promise<void>;
    private withMessenger;
    removeAllSubscriptions(): void;
    close(): void;
    get session(): import("../index.js").Session;
    get channelType(): import("#general").ChannelType;
    /**
     * Allows to add the data received by e.g. a Read request to the cache
     */
    addAttributesToCache(attributeReports: DecodedAttributeReportValue<any>[]): Promise<void>;
    /**
     * Returns the list (optionally filtered by endpointId and/or clusterId) of the dataVersions of the currently cached
     * values to use them as knownDataVersion for read or subscription requests.
     */
    getCachedClusterDataVersions(filter?: {
        endpointId?: EndpointNumber;
        clusterId?: ClusterId;
    }): {
        endpointId: EndpointNumber;
        clusterId: ClusterId;
        dataVersion: number;
    }[];
    get maxKnownEventNumber(): EventNumber | undefined;
}
//# sourceMappingURL=InteractionClient.d.ts.map