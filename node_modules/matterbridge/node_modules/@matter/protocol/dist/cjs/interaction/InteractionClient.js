"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var InteractionClient_exports = {};
__export(InteractionClient_exports, {
  InteractionClient: () => InteractionClient,
  InteractionClientProvider: () => InteractionClientProvider
});
module.exports = __toCommonJS(InteractionClient_exports);
var import_general = require("#general");
var import_model = require("#model");
var import_PeerAddress = require("#peer/PeerAddress.js");
var import_PeerSet = require("#peer/PeerSet.js");
var import_types = require("#types");
var import_ExchangeProvider = require("../protocol/ExchangeProvider.js");
var import_DecodedDataReport = require("./DecodedDataReport.js");
var import_InteractionMessenger = require("./InteractionMessenger.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("InteractionClient");
const REQUEST_ALL = [{}];
const DEFAULT_TIMED_REQUEST_TIMEOUT_MS = 1e4;
const DEFAULT_MINIMUM_RESPONSE_TIMEOUT_WITH_FAILSAFE_MS = 3e4;
class InteractionClientProvider {
  #peers;
  #clients = new import_PeerAddress.PeerAddressMap();
  constructor(peers) {
    this.#peers = peers;
    this.#peers.deleted.on((peer) => this.#onPeerLoss(peer.address));
    this.#peers.disconnected.on((address) => this.#onPeerLoss(address));
  }
  static [import_general.Environmental.create](env) {
    const instance = new InteractionClientProvider(env.get(import_PeerSet.PeerSet));
    env.set(InteractionClientProvider, instance);
    return instance;
  }
  get peers() {
    return this.#peers;
  }
  async connect(address, options) {
    await this.#peers.ensureConnection(address, options);
    const { discoveryOptions } = options;
    return this.getInteractionClient(address, discoveryOptions);
  }
  async getInteractionClientForChannel(channel) {
    const exchangeProvider = await this.#peers.exchangeProviderFor(channel);
    return new InteractionClient(
      exchangeProvider,
      this.#peers.subscriptionClient,
      void 0,
      this.#peers.interactionQueue
    );
  }
  async getInteractionClient(address, discoveryOptions) {
    let client = this.#clients.get(address);
    if (client !== void 0) {
      return client;
    }
    const nodeStore = this.#peers.get(address)?.dataStore;
    await nodeStore?.construction;
    const exchangeProvider = await this.#peers.exchangeProviderFor(address, discoveryOptions);
    client = new InteractionClient(
      exchangeProvider,
      this.#peers.subscriptionClient,
      address,
      this.#peers.interactionQueue,
      nodeStore
    );
    this.#clients.set(address, client);
    return client;
  }
  #onPeerLoss(address) {
    const client = this.#clients.get(address);
    if (client !== void 0) {
      client.close();
      this.#clients.delete(address);
    }
  }
}
class InteractionClient {
  #exchangeProvider;
  #nodeStore;
  #ownSubscriptionIds = /* @__PURE__ */ new Set();
  #subscriptionClient;
  #queue;
  #address;
  constructor(exchangeProvider, subscriptionClient, address, queue, nodeStore) {
    this.#exchangeProvider = exchangeProvider;
    this.#nodeStore = nodeStore;
    this.#subscriptionClient = subscriptionClient;
    this.#queue = queue;
    this.#address = address;
  }
  get address() {
    if (this.#address === void 0) {
      throw new import_general.ImplementationError("This InteractionClient is not bound to a specific peer.");
    }
    return this.#address;
  }
  get isReconnectable() {
    return this.#exchangeProvider instanceof import_ExchangeProvider.ReconnectableExchangeProvider;
  }
  get channelUpdated() {
    if (this.#exchangeProvider instanceof import_ExchangeProvider.ReconnectableExchangeProvider) {
      return this.#exchangeProvider.channelUpdated;
    }
    throw new import_general.ImplementationError("ExchangeProvider does not support channelUpdated");
  }
  removeSubscription(subscriptionId) {
    this.#ownSubscriptionIds.delete(subscriptionId);
    this.#subscriptionClient.delete(subscriptionId);
  }
  async getAllAttributes(options = {}) {
    return (await this.getMultipleAttributesAndEvents({
      attributes: REQUEST_ALL,
      ...options
    })).attributeReports;
  }
  async getAllEvents(options = {}) {
    return (await this.getMultipleAttributesAndEvents({
      events: REQUEST_ALL,
      ...options
    })).eventReports;
  }
  async getAllAttributesAndEvents(options = {}) {
    return this.getMultipleAttributesAndEvents({
      attributes: REQUEST_ALL,
      events: REQUEST_ALL,
      ...options
    });
  }
  async getMultipleAttributes(options = {}) {
    return (await this.getMultipleAttributesAndEvents(options)).attributeReports;
  }
  async getMultipleAttributesAndStatus(options = {}) {
    const { attributeReports, attributeStatus } = await this.getMultipleAttributesAndEvents(options);
    return { attributeData: attributeReports, attributeStatus };
  }
  async getMultipleEvents(options = {}) {
    return (await this.getMultipleAttributesAndEvents(options)).eventReports;
  }
  async getMultipleEventsAndStatus(options = {}) {
    const { eventReports, eventStatus } = await this.getMultipleAttributesAndEvents(options);
    return { eventData: eventReports, eventStatus };
  }
  async getMultipleAttributesAndEvents(options = {}) {
    const {
      attributes: attributeRequests,
      dataVersionFilters,
      executeQueued,
      events: eventRequests,
      enrichCachedAttributeData,
      eventFilters
    } = options;
    if (attributeRequests === void 0 && eventRequests === void 0) {
      throw new import_general.ImplementationError("When reading attributes and events, at least one must be specified.");
    }
    const readPathsCount = (attributeRequests?.length ?? 0) + (eventRequests?.length ?? 0);
    if (readPathsCount > 9) {
      logger.debug(
        "Read interactions with more then 9 paths might be not allowed by the device. Consider splitting then into several read requests."
      );
    }
    logger.debug(
      `Sending read request: attributes: ${attributeRequests?.map((path) => (0, import_types.resolveAttributeName)(path)).join(", ")} and events: ${eventRequests?.map((path) => (0, import_types.resolveEventName)(path)).join(", ")}`
    );
    if (dataVersionFilters !== void 0 && dataVersionFilters?.length > 0) {
      logger.debug(
        `Using DataVersionFilters: ${dataVersionFilters.map(({ endpointId, clusterId, dataVersion }) => `${endpointId}/${clusterId}=${dataVersion}`).join(", ")}`
      );
    }
    if (eventFilters !== void 0 && eventFilters?.length > 0) {
      logger.debug(
        `Using event filters: ${eventFilters.map(({ nodeId, eventMin }) => `${nodeId}=${eventMin}`).join(", ")}`
      );
    }
    const result = await this.withMessenger(async (messenger) => {
      const { isFabricFiltered = true } = options;
      return await this.processReadRequest(messenger, {
        attributeRequests,
        dataVersionFilters: dataVersionFilters?.map(({ endpointId, clusterId, dataVersion }) => ({
          path: { endpointId, clusterId },
          dataVersion
        })),
        eventRequests,
        eventFilters,
        isFabricFiltered,
        interactionModelRevision: import_model.Specification.INTERACTION_MODEL_REVISION
      });
    }, executeQueued);
    if (dataVersionFilters !== void 0 && dataVersionFilters.length > 0 && enrichCachedAttributeData) {
      this.#enrichCachedAttributeData(result.attributeReports, dataVersionFilters);
    }
    return result;
  }
  async getAttribute(options) {
    const { requestFromRemote } = options;
    const response = await this.getAttributeWithVersion({
      ...options,
      requestFromRemote
    });
    return response?.value;
  }
  async getAttributeWithVersion(options) {
    const { endpointId, clusterId, attribute, requestFromRemote, isFabricFiltered, executeQueued } = options;
    const { id: attributeId } = attribute;
    if (this.#nodeStore !== void 0) {
      if (!requestFromRemote) {
        const { value, version } = this.#nodeStore.retrieveAttribute(endpointId, clusterId, attributeId) ?? {};
        if (value !== void 0 && version !== void 0) {
          return { value, version };
        }
      }
      if (requestFromRemote === false) {
        return void 0;
      }
    }
    const { attributeReports } = await this.getMultipleAttributesAndEvents({
      attributes: [{ endpointId, clusterId, attributeId }],
      isFabricFiltered,
      executeQueued
    });
    if (attributeReports.length === 0) {
      return void 0;
    }
    if (attributeReports.length > 1) {
      throw new import_general.UnexpectedDataError("Unexpected response with more then one attribute");
    }
    return { value: attributeReports[0].value, version: attributeReports[0].version };
  }
  async getEvent(options) {
    const { endpointId, clusterId, event, minimumEventNumber, isFabricFiltered = true, executeQueued } = options;
    const { id: eventId } = event;
    const response = await this.getMultipleAttributesAndEvents({
      events: [{ endpointId, clusterId, eventId }],
      eventFilters: minimumEventNumber !== void 0 ? [{ eventMin: minimumEventNumber }] : void 0,
      isFabricFiltered,
      executeQueued
    });
    return response?.eventReports[0]?.events;
  }
  async processReadRequest(messenger, request) {
    const { attributeRequests, eventRequests } = request;
    logger.debug(
      `Sending read request to ${messenger.getExchangeChannelName()} for attributes ${attributeRequests?.map((path) => (0, import_types.resolveAttributeName)(path)).join(", ")} and events ${eventRequests?.map((path) => (0, import_types.resolveEventName)(path)).join(", ")}`
    );
    const response = await messenger.sendReadRequest(request);
    const normalizedResult = (0, import_DecodedDataReport.DecodedDataReport)(response);
    const { attributeReports, attributeStatus, eventReports, eventStatus } = normalizedResult;
    const logData = Array();
    if (attributeReports.length > 0) {
      logData.push(`attributes ${attributeReports.map(({ path }) => (0, import_types.resolveAttributeName)(path)).join(", ")}`);
    }
    if (eventReports.length > 0) {
      logData.push(`events ${eventReports.map(({ path }) => (0, import_types.resolveEventName)(path)).join(", ")}`);
    }
    if (attributeStatus !== void 0 && attributeStatus.length > 0) {
      logData.push(`attributeErrors ${attributeStatus.map(({ path }) => (0, import_types.resolveAttributeName)(path)).join(", ")}`);
    }
    if (eventStatus !== void 0 && eventStatus.length > 0) {
      logData.push(`eventErrors ${eventStatus.map(({ path }) => (0, import_types.resolveEventName)(path)).join(", ")}`);
    }
    logger.debug(
      logData.length ? `Received read response with ${logData.join(", ")}` : "Received empty read response"
    );
    return normalizedResult;
  }
  async setAttribute(options) {
    const { attributeData, asTimedRequest, timedRequestTimeoutMs, suppressResponse, executeQueued, chunkLists } = options;
    const { endpointId, clusterId, attribute, value, dataVersion } = attributeData;
    const response = await this.setMultipleAttributes({
      attributes: [{ endpointId, clusterId, attribute, value, dataVersion }],
      asTimedRequest,
      timedRequestTimeoutMs,
      suppressResponse,
      executeQueued,
      chunkLists
    });
    if (response.length) {
      const {
        path: { endpointId: endpointId2, clusterId: clusterId2, attributeId },
        status
      } = response[0];
      if (status !== void 0 && status !== import_types.StatusCode.Success) {
        throw new import_types.StatusResponseError(
          `Error setting attribute ${endpointId2}/${clusterId2}/${attributeId}`,
          status
        );
      }
    }
  }
  async setMultipleAttributes(options) {
    const { executeQueued } = options;
    const {
      attributes,
      asTimedRequest,
      timedRequestTimeoutMs = DEFAULT_TIMED_REQUEST_TIMEOUT_MS,
      suppressResponse = false,
      // TODO needs to be TRUE for Group writes
      chunkLists = true
      // Should be true currently to stay in sync with chip sdk
    } = options;
    logger.debug(
      `Sending write request: ${attributes.map(
        ({ endpointId, clusterId, attribute: { id }, value, dataVersion }) => `${(0, import_types.resolveAttributeName)({ endpointId, clusterId, attributeId: id })} = ${import_general.Diagnostic.json(
          value
        )} (version=${dataVersion})`
      ).join(", ")}`
    );
    const writeRequests = attributes.flatMap(
      ({ endpointId, clusterId, attribute: { id, schema }, value, dataVersion }) => {
        if (chunkLists && Array.isArray(value) && schema instanceof import_types.ArraySchema) {
          return schema.encodeAsChunkedArray(value, { forWriteInteraction: true }).map(({ element: data, listIndex }) => ({
            path: { endpointId, clusterId, attributeId: id, listIndex },
            data,
            dataVersion
          }));
        }
        return [
          {
            path: { endpointId, clusterId, attributeId: id },
            data: schema.encodeTlv(value, { forWriteInteraction: true }),
            dataVersion
          }
        ];
      }
    );
    const timedRequest = attributes.some(({ attribute: { timed } }) => timed) || asTimedRequest === true || options.timedRequestTimeoutMs !== void 0;
    const response = await this.withMessenger(
      async (messenger) => {
        if (timedRequest) {
          await messenger.sendTimedRequest(timedRequestTimeoutMs);
        }
        return await messenger.sendWriteCommand({
          suppressResponse,
          timedRequest,
          writeRequests,
          moreChunkedMessages: false,
          interactionModelRevision: import_model.Specification.INTERACTION_MODEL_REVISION
        });
      },
      executeQueued
    );
    if (response === void 0) {
      if (!suppressResponse) {
        throw new import_general.MatterFlowError(`No response received from write interaction but expected.`);
      }
      return [];
    }
    return response.writeResponses.flatMap(({ status: { status, clusterStatus }, path: { nodeId, endpointId, clusterId, attributeId } }) => {
      return {
        path: { nodeId, endpointId, clusterId, attributeId },
        status: status ?? clusterStatus ?? import_types.StatusCode.Failure
      };
    }).filter(({ status }) => status !== import_types.StatusCode.Success);
  }
  async subscribeAttribute(options) {
    const {
      endpointId,
      clusterId,
      attribute,
      minIntervalFloorSeconds,
      maxIntervalCeilingSeconds,
      isFabricFiltered = true,
      listener,
      knownDataVersion,
      keepSubscriptions = true,
      updateTimeoutHandler,
      updateReceived,
      executeQueued
    } = options;
    const { id: attributeId } = attribute;
    if (!keepSubscriptions) {
      for (const subscriptionId2 of this.#ownSubscriptionIds) {
        logger.debug(
          `Removing subscription with ID ${subscriptionId2} from InteractionClient because new subscription replaces it`
        );
        this.removeSubscription(subscriptionId2);
      }
    }
    logger.debug(
      `Sending subscribe request for attribute: ${(0, import_types.resolveAttributeName)({
        endpointId,
        clusterId,
        attributeId
      })}${knownDataVersion !== void 0 ? ` (knownDataVersion=${knownDataVersion})` : ""} with minInterval=${minIntervalFloorSeconds}s/maxInterval=${maxIntervalCeilingSeconds}s`
    );
    const {
      subscribeResponse: { subscriptionId, maxInterval },
      report,
      maximumPeerResponseTime
    } = await this.withMessenger(async (messenger) => {
      const { subscribeResponse, report: report2 } = await messenger.sendSubscribeRequest({
        interactionModelRevision: import_model.Specification.INTERACTION_MODEL_REVISION,
        attributeRequests: [{ endpointId, clusterId, attributeId }],
        dataVersionFilters: knownDataVersion !== void 0 ? [{ path: { endpointId, clusterId }, dataVersion: knownDataVersion }] : void 0,
        keepSubscriptions,
        minIntervalFloorSeconds,
        maxIntervalCeilingSeconds,
        isFabricFiltered
      });
      return {
        subscribeResponse,
        report: report2,
        maximumPeerResponseTime: messenger.calculateMaximumPeerResponseTime()
      };
    }, executeQueued);
    const subscriptionListener = async (dataReport) => {
      updateReceived?.();
      if (!Array.isArray(dataReport.attributeReports) || !dataReport.attributeReports.length) {
        return;
      }
      const { attributeReports } = (0, import_DecodedDataReport.DecodedDataReport)(dataReport);
      if (attributeReports.length === 0) {
        throw new import_general.MatterFlowError("Subscription result reporting undefined/no value not specified");
      }
      if (attributeReports.length > 1) {
        throw new import_general.UnexpectedDataError("Unexpected response with more then one attribute");
      }
      const { value, version } = attributeReports[0];
      if (value === void 0)
        throw new import_general.MatterFlowError("Subscription result reporting undefined value not specified.");
      await this.#nodeStore?.persistAttributes([attributeReports[0]]);
      listener?.(value, version);
    };
    await this.#registerSubscription(
      {
        id: subscriptionId,
        maximumPeerResponseTime,
        maxIntervalS: maxInterval,
        onData: subscriptionListener,
        onTimeout: updateTimeoutHandler
      },
      report
    );
    return { maxInterval };
  }
  async #registerSubscription(subscription, initialReport) {
    this.#ownSubscriptionIds.add(subscription.id);
    this.#subscriptionClient.add(subscription);
    await subscription.onData(initialReport);
  }
  async subscribeEvent(options) {
    const {
      endpointId,
      clusterId,
      event,
      minIntervalFloorSeconds,
      maxIntervalCeilingSeconds,
      isUrgent,
      minimumEventNumber,
      isFabricFiltered = true,
      listener,
      updateTimeoutHandler,
      updateReceived,
      executeQueued
    } = options;
    const { id: eventId } = event;
    logger.debug(
      `Sending subscribe request for event: ${(0, import_types.resolveEventName)({ endpointId, clusterId, eventId })} with minInterval=${minIntervalFloorSeconds}s/maxInterval=${maxIntervalCeilingSeconds}s`
    );
    const {
      report,
      subscribeResponse: { subscriptionId, maxInterval },
      maximumPeerResponseTime
    } = await this.withMessenger(async (messenger) => {
      const { subscribeResponse, report: report2 } = await messenger.sendSubscribeRequest({
        interactionModelRevision: import_model.Specification.INTERACTION_MODEL_REVISION,
        eventRequests: [{ endpointId, clusterId, eventId, isUrgent }],
        eventFilters: minimumEventNumber !== void 0 ? [{ eventMin: minimumEventNumber }] : void 0,
        keepSubscriptions: true,
        minIntervalFloorSeconds,
        maxIntervalCeilingSeconds,
        isFabricFiltered
      });
      return {
        subscribeResponse,
        report: report2,
        maximumPeerResponseTime: messenger.calculateMaximumPeerResponseTime()
      };
    }, executeQueued);
    const subscriptionListener = (dataReport) => {
      updateReceived?.();
      if (!Array.isArray(dataReport.eventReports) || !dataReport.eventReports.length) {
        return;
      }
      const { eventReports } = (0, import_DecodedDataReport.DecodedDataReport)(dataReport);
      if (eventReports.length === 0) {
        throw new import_general.MatterFlowError("Received empty subscription result value.");
      }
      if (eventReports.length > 1) {
        throw new import_general.UnexpectedDataError("Unexpected response with more then one attribute.");
      }
      const { events } = eventReports[0];
      if (events === void 0)
        throw new import_general.MatterFlowError("Subscription result reporting undefined value not specified.");
      events.forEach((event2) => listener?.(event2));
    };
    await this.#registerSubscription(
      {
        id: subscriptionId,
        maximumPeerResponseTime,
        maxIntervalS: maxInterval,
        onData: subscriptionListener,
        onTimeout: updateTimeoutHandler
      },
      report
    );
    return { maxInterval };
  }
  async subscribeAllAttributesAndEvents(options) {
    const { isUrgent } = options;
    return this.subscribeMultipleAttributesAndEvents({
      ...options,
      attributes: REQUEST_ALL,
      events: [{ isUrgent }]
    });
  }
  async subscribeMultipleAttributesAndEvents(options) {
    const {
      attributes: attributeRequests = [],
      events: eventRequests = [],
      executeQueued,
      minIntervalFloorSeconds,
      maxIntervalCeilingSeconds,
      keepSubscriptions = true,
      isFabricFiltered = true,
      attributeListener,
      eventListener,
      eventFilters,
      dataVersionFilters,
      updateTimeoutHandler,
      updateReceived,
      enrichCachedAttributeData
    } = options;
    const subscriptionPathsCount = (attributeRequests?.length ?? 0) + (eventRequests?.length ?? 0);
    if (subscriptionPathsCount > 3) {
      logger.debug("Subscribe interactions with more then 3 paths might be not allowed by the device.");
    }
    if (!keepSubscriptions) {
      for (const subscriptionId2 of this.#ownSubscriptionIds) {
        logger.debug(
          `Removing subscription with ID ${subscriptionId2} from InteractionClient because new subscription replaces it`
        );
        this.removeSubscription(subscriptionId2);
      }
    }
    logger.debug(
      `Sending subscribe request: attributes: ${attributeRequests.map((path) => (0, import_types.resolveAttributeName)(path)).join(
        ", "
      )} and events: ${eventRequests.map((path) => (0, import_types.resolveEventName)(path)).join(", ")}, keepSubscriptions=${keepSubscriptions} with minInterval=${minIntervalFloorSeconds}s/maxInterval=${maxIntervalCeilingSeconds}s`
    );
    if (dataVersionFilters !== void 0 && dataVersionFilters?.length > 0) {
      logger.debug(
        `Using DataVersionFilters: ${dataVersionFilters.map(({ endpointId, clusterId, dataVersion }) => `${endpointId}/${clusterId}=${dataVersion}`).join(", ")}`
      );
    }
    if (eventFilters !== void 0 && eventFilters?.length > 0) {
      logger.debug(
        `Using event filters: ${eventFilters.map(({ nodeId, eventMin }) => `${nodeId}=${eventMin}`).join(", ")}`
      );
    }
    const {
      report,
      subscribeResponse: { subscriptionId, maxInterval },
      maximumPeerResponseTime
    } = await this.withMessenger(async (messenger) => {
      const { subscribeResponse, report: report2 } = await messenger.sendSubscribeRequest({
        interactionModelRevision: import_model.Specification.INTERACTION_MODEL_REVISION,
        attributeRequests,
        eventRequests,
        keepSubscriptions,
        minIntervalFloorSeconds,
        maxIntervalCeilingSeconds,
        isFabricFiltered,
        eventFilters,
        dataVersionFilters: dataVersionFilters?.map(({ endpointId, clusterId, dataVersion }) => ({
          path: { endpointId, clusterId },
          dataVersion
        }))
      });
      return {
        subscribeResponse,
        report: report2,
        maximumPeerResponseTime: messenger.calculateMaximumPeerResponseTime()
      };
    }, executeQueued);
    logger.info(`Subscription successfully initialized with ID ${subscriptionId} and maxInterval ${maxInterval}s.`);
    const subscriptionListener = async (dataReport) => {
      if ((!Array.isArray(dataReport.attributeReports) || !dataReport.attributeReports.length) && (!Array.isArray(dataReport.eventReports) || !dataReport.eventReports.length)) {
        updateReceived?.();
        return;
      }
      const { attributeReports, eventReports } = dataReport;
      if (eventReports !== void 0) {
        let maxEventNumber = this.#nodeStore?.maxEventNumber ?? eventReports[0].events[0].eventNumber;
        eventReports.forEach((data) => {
          logger.debug(
            `Received event update: ${(0, import_types.resolveEventName)(data.path)}: ${import_general.Diagnostic.json(data.events)}`
          );
          const { events } = data;
          maxEventNumber = events.length === 1 ? events[0].eventNumber : events.reduce(
            (max, { eventNumber }) => max < eventNumber ? eventNumber : max,
            maxEventNumber
          );
          eventListener?.(data);
        });
        await this.#nodeStore?.updateLastEventNumber(maxEventNumber);
      }
      if (attributeReports !== void 0) {
        for (const data of attributeReports) {
          const {
            path: { endpointId, clusterId, attributeId },
            value,
            version
          } = data;
          logger.debug(
            `Received attribute update: ${(0, import_types.resolveAttributeName)({
              endpointId,
              clusterId,
              attributeId
            })} = ${import_general.Diagnostic.json(value)} (version=${version})`
          );
          if (value === void 0) throw new import_general.MatterFlowError("Received empty subscription result value.");
          const { value: oldValue } = this.#nodeStore?.retrieveAttribute(endpointId, clusterId, attributeId) ?? {};
          const changed = oldValue !== void 0 ? !(0, import_general.isDeepEqual)(oldValue, value) : void 0;
          if (changed !== false) {
            await this.#nodeStore?.persistAttributes([data]);
          }
          attributeListener?.(data, changed, oldValue);
        }
      }
      updateReceived?.();
    };
    const seedReport = (0, import_DecodedDataReport.DecodedDataReport)(report);
    await this.#registerSubscription(
      {
        id: subscriptionId,
        maximumPeerResponseTime,
        maxIntervalS: maxInterval,
        onData: (dataReport) => subscriptionListener((0, import_DecodedDataReport.DecodedDataReport)(dataReport)),
        onTimeout: updateTimeoutHandler
      },
      seedReport
    );
    if (dataVersionFilters !== void 0 && dataVersionFilters.length > 0 && enrichCachedAttributeData) {
      this.#enrichCachedAttributeData(seedReport.attributeReports ?? [], dataVersionFilters);
    }
    return {
      ...seedReport,
      maxInterval
    };
  }
  async invoke(options) {
    const { executeQueued } = options;
    const {
      endpointId,
      clusterId,
      command: { requestId, requestSchema, responseId, responseSchema, optional, timed },
      asTimedRequest,
      timedRequestTimeoutMs = DEFAULT_TIMED_REQUEST_TIMEOUT_MS,
      useExtendedFailSafeMessageResponseTimeout = false,
      skipValidation
    } = options;
    let { request } = options;
    const timedRequest = timed && !skipValidation || asTimedRequest === true || options.timedRequestTimeoutMs !== void 0;
    if (requestSchema instanceof import_types.ObjectSchema) {
      if (request === void 0) {
        request = {};
      }
      if (requestSchema.isFabricScoped && request.fabricIndex === void 0) {
        request.fabricIndex = import_types.FabricIndex.NO_FABRIC;
      }
    }
    logger.debug(
      `Invoking command: ${(0, import_types.resolveCommandName)({
        endpointId,
        clusterId,
        commandId: requestId
      })} with ${import_general.Diagnostic.json(request)}`
    );
    if (!skipValidation) {
      requestSchema.validate(request);
    }
    const commandFields = requestSchema.encodeTlv(request);
    const invokeResponse = await this.withMessenger(async (messenger) => {
      if (timedRequest) {
        await messenger.sendTimedRequest(timedRequestTimeoutMs);
      }
      const response = await messenger.sendInvokeCommand(
        {
          invokeRequests: [{ commandPath: { endpointId, clusterId, commandId: requestId }, commandFields }],
          timedRequest,
          suppressResponse: false,
          interactionModelRevision: import_model.Specification.INTERACTION_MODEL_REVISION
        },
        useExtendedFailSafeMessageResponseTimeout ? DEFAULT_MINIMUM_RESPONSE_TIMEOUT_WITH_FAILSAFE_MS : void 0
      );
      if (response === void 0) {
        throw new import_general.MatterFlowError("No response received from invoke interaction but expected.");
      }
      return response;
    }, executeQueued);
    const { invokeResponses } = invokeResponse;
    if (invokeResponses.length === 0) {
      throw new import_general.MatterFlowError("Received invoke response with no invoke results.");
    }
    const { command, status } = invokeResponses[0];
    if (status !== void 0) {
      const resultCode = status.status.status;
      if (resultCode !== import_types.StatusCode.Success)
        throw new import_types.StatusResponseError(
          `Received non-success result: ${resultCode}`,
          resultCode ?? import_types.StatusCode.Failure,
          status.status.clusterStatus
        );
      if (responseSchema !== import_types.TlvNoResponse)
        throw new import_general.MatterFlowError("A response was expected for this command.");
      return void 0;
    }
    if (command !== void 0) {
      const {
        commandPath: { commandId },
        commandFields: commandFields2
      } = command;
      if (commandId !== responseId) {
        throw new import_general.MatterFlowError(
          `Received invoke response with unexpected command ID ${commandId}, expected ${responseId}.`
        );
      }
      if (commandFields2 === void 0) {
        if (responseSchema !== import_types.TlvNoResponse)
          throw new import_general.MatterFlowError(`A response was expected for command ${requestId}.`);
        return void 0;
      }
      const response = responseSchema.decodeTlv(commandFields2);
      logger.debug(
        `Received invoke response: ${(0, import_types.resolveCommandName)({
          endpointId,
          clusterId,
          commandId: requestId
        })} with ${import_general.Diagnostic.json(response)})}`
      );
      return response;
    }
    if (optional) {
      return void 0;
    }
    throw new import_general.MatterFlowError("Received invoke response with no result nor response.");
  }
  // TODO Add to ClusterClient when needed/when Group communication is implemented
  async invokeWithSuppressedResponse(options) {
    const { executeQueued } = options;
    const {
      endpointId,
      clusterId,
      request,
      command: { requestId, requestSchema, timed },
      asTimedRequest,
      timedRequestTimeoutMs = DEFAULT_TIMED_REQUEST_TIMEOUT_MS
    } = options;
    const timedRequest = timed || asTimedRequest === true || options.timedRequestTimeoutMs !== void 0;
    logger.debug(
      `Invoking command with suppressedResponse: ${(0, import_types.resolveCommandName)({
        endpointId,
        clusterId,
        commandId: requestId
      })} with ${import_general.Diagnostic.json(request)}`
    );
    const commandFields = requestSchema.encodeTlv(request);
    await this.withMessenger(async (messenger) => {
      if (timedRequest) {
        await messenger.sendTimedRequest(timedRequestTimeoutMs);
      }
      const response = await messenger.sendInvokeCommand({
        invokeRequests: [{ commandPath: { endpointId, clusterId, commandId: requestId }, commandFields }],
        timedRequest,
        suppressResponse: true,
        interactionModelRevision: import_model.Specification.INTERACTION_MODEL_REVISION
      });
      if (response !== void 0) {
        throw new import_general.MatterFlowError(
          "Response received from invoke interaction but none expected because response is suppressed."
        );
      }
    }, executeQueued);
    logger.debug(
      `Invoke successful: ${(0, import_types.resolveCommandName)({
        endpointId,
        clusterId,
        commandId: requestId
      })}`
    );
  }
  async withMessenger(invoke, executeQueued = false) {
    const messenger = await import_InteractionMessenger.InteractionClientMessenger.create(this.#exchangeProvider);
    let result;
    try {
      if (executeQueued) {
        if (this.#queue === void 0) {
          throw new import_general.ImplementationError("Cannot execute queued operation without a queue.");
        }
        return await this.#queue.add(() => invoke(messenger));
      }
      result = await invoke(messenger);
    } finally {
      messenger.close().catch((error) => logger.info(`Error closing messenger: ${error}`));
    }
    return result;
  }
  removeAllSubscriptions() {
    for (const subscriptionId of this.#ownSubscriptionIds) {
      this.removeSubscription(subscriptionId);
    }
  }
  close() {
    this.removeAllSubscriptions();
  }
  get session() {
    return this.#exchangeProvider.session;
  }
  get channelType() {
    return this.#exchangeProvider.channelType;
  }
  /** Enrich cached data to get complete responses when data version filters were used. */
  #enrichCachedAttributeData(attributeReports, dataVersionFilters) {
    if (this.#nodeStore === void 0) {
      return;
    }
    const candidates = /* @__PURE__ */ new Map();
    for (const { endpointId, clusterId, dataVersion } of dataVersionFilters) {
      if (!candidates.has(endpointId)) {
        candidates.set(endpointId, /* @__PURE__ */ new Map());
      }
      candidates.get(endpointId)?.set(clusterId, this.#nodeStore.getClusterDataVersion(endpointId, clusterId) ?? dataVersion);
    }
    attributeReports.forEach(({ path: { endpointId, clusterId } }) => {
      if (candidates.has(endpointId)) {
        candidates.get(endpointId)?.delete(clusterId);
      }
    });
    for (const [endpointId, clusters] of candidates) {
      for (const [clusterId, version] of clusters) {
        const clusterValues = this.#nodeStore.retrieveAttributes(endpointId, clusterId);
        logger.debug(
          `Enriching cached data (${clusterValues.length} attributes) for ${endpointId}/${clusterId} with version=${version}`
        );
        attributeReports.push(...clusterValues);
      }
    }
  }
  /**
   * Allows to add the data received by e.g. a Read request to the cache
   */
  async addAttributesToCache(attributeReports) {
    for (const data of attributeReports) {
      const {
        path: { endpointId, clusterId, attributeId },
        value
      } = data;
      if (value === void 0) continue;
      const { value: oldValue } = this.#nodeStore?.retrieveAttribute(endpointId, clusterId, attributeId) ?? {};
      const changed = oldValue !== void 0 ? !(0, import_general.isDeepEqual)(oldValue, value) : void 0;
      if (changed !== false) {
        await this.#nodeStore?.persistAttributes([data]);
      }
    }
  }
  /**
   * Returns the list (optionally filtered by endpointId and/or clusterId) of the dataVersions of the currently cached
   * values to use them as knownDataVersion for read or subscription requests.
   */
  getCachedClusterDataVersions(filter) {
    if (this.#nodeStore === void 0) {
      return [];
    }
    const { endpointId, clusterId } = filter ?? {};
    return this.#nodeStore.getClusterDataVersions(endpointId, clusterId);
  }
  get maxKnownEventNumber() {
    return this.#nodeStore?.maxEventNumber;
  }
}
//# sourceMappingURL=InteractionClient.js.map
