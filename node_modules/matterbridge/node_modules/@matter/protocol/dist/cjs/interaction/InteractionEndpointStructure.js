"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var InteractionEndpointStructure_exports = {};
__export(InteractionEndpointStructure_exports, {
  InteractionEndpointStructure: () => InteractionEndpointStructure
});
module.exports = __toCommonJS(InteractionEndpointStructure_exports);
var import_general = require("#general");
var import_model = require("#model");
var import_types = require("#types");
var import_InteractionServer = require("./InteractionServer.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const GLOBAL_COMMANDLIST_IDS = [import_model.GeneratedCommandList.id, import_model.AcceptedCommandList.id];
const GLOBAL_ATTRIBUTES_LIST = [...GLOBAL_COMMANDLIST_IDS, import_model.AttributeList.id];
const DIAGNOSTICS_CLUSTER_IDS = import_model.MatterModel.standard.clusters.filter((cluster) => cluster.diagnostics && cluster.id !== void 0).map((cluster) => cluster.id);
class InteractionEndpointStructure {
  endpoints = /* @__PURE__ */ new Map();
  attributes = /* @__PURE__ */ new Map();
  attributePaths = new Array();
  events = /* @__PURE__ */ new Map();
  eventPaths = new Array();
  commands = /* @__PURE__ */ new Map();
  commandPaths = new Array();
  change = (0, import_general.Observable)();
  // TODO adjust to AsyncObservable when we remove legacy API
  clear() {
    this.endpoints.clear();
    this.attributes.clear();
    this.attributePaths.length = 0;
    this.events.clear();
    this.eventPaths.length = 0;
    this.commands.clear();
    this.commandPaths.length = 0;
  }
  close() {
    for (const endpoint of this.endpoints.values()) {
      endpoint.close();
    }
  }
  initializeFromEndpoint(endpoint) {
    this.clear();
    this.verifyAndInitializeStructureElementsFromEndpoint(endpoint);
    this.initializeStructureFromEndpoints(endpoint);
    this.change.emit();
  }
  initializeStructureFromEndpoints(endpoint) {
    const endpoints = endpoint.getChildEndpoints();
    for (let endpointIndex = 0; endpointIndex < endpoints.length; endpointIndex++) {
      this.verifyAndInitializeStructureElementsFromEndpoint(endpoints[endpointIndex]);
      this.initializeStructureFromEndpoints(endpoints[endpointIndex]);
    }
  }
  verifyAndInitializeStructureElementsFromEndpoint(endpoint) {
    if (endpoint.number === void 0) {
      throw new import_general.InternalError(`Endpoint ID is undefined. It needs to be initialized first!`);
    }
    endpoint.verifyRequiredClusters();
    const endpointId = endpoint.number;
    if (this.endpoints.has(endpoint.number)) {
      throw new import_general.ImplementationError(`Endpoint ID ${endpoint.number} exists twice`);
    }
    for (const cluster of endpoint.getAllClusterServers()) {
      const {
        id: clusterId,
        attributes: clusterAttributes,
        events: clusterEvents,
        commands: clusterCommands
      } = cluster;
      for (const name in clusterAttributes) {
        const attribute = clusterAttributes[name];
        const path = { endpointId, clusterId, attributeId: attribute.id };
        this.attributes.set((0, import_InteractionServer.attributePathToId)(path), attribute);
        this.attributePaths.push(path);
      }
      for (const name in clusterEvents) {
        const event = clusterEvents[name];
        const path = { endpointId, clusterId, eventId: event.id };
        this.events.set((0, import_InteractionServer.eventPathToId)(path), event);
        this.eventPaths.push(path);
      }
      for (const name in clusterCommands) {
        const command = clusterCommands[name];
        const path = { endpointId, clusterId, commandId: command.invokeId };
        this.commands.set((0, import_InteractionServer.commandPathToId)(path), command);
        this.commandPaths.push(path);
      }
    }
    this.endpoints.set(endpointId, endpoint);
  }
  toHex(value) {
    return value === void 0 ? "*" : `0x${value.toString(16)}`;
  }
  resolveGenericElementName(nodeId, endpointId, clusterId, elementId, elementMap) {
    const nodeIdPrefix = nodeId === void 0 ? "" : `${this.toHex(nodeId)}/`;
    if (endpointId === void 0) {
      return `${nodeIdPrefix}*/${this.toHex(clusterId)}/${this.toHex(elementId)}`;
    }
    const endpoint = this.endpoints.get(endpointId);
    if (endpoint === void 0) {
      return `${nodeIdPrefix}unknown(${this.toHex(endpointId)})/${this.toHex(clusterId)}/${this.toHex(
        elementId
      )}`;
    }
    const endpointName = `${endpoint.name}(${this.toHex(endpointId)})`;
    if (clusterId === void 0) {
      return `${nodeIdPrefix}${endpointName}/*/${this.toHex(elementId)}`;
    }
    const cluster = endpoint.getClusterServerById(clusterId);
    if (cluster === void 0) {
      return `${nodeIdPrefix}${endpointName}/unknown(${this.toHex(clusterId)})/${this.toHex(elementId)}`;
    }
    const clusterName = `${cluster.name}(${this.toHex(clusterId)})`;
    if (elementId === void 0) {
      return `${nodeIdPrefix}${endpointName}/${clusterName}/*`;
    }
    const element = elementMap.get((0, import_InteractionServer.genericElementPathToId)(endpointId, clusterId, elementId));
    const elementName = `${element?.name ?? "unknown"}(${this.toHex(elementId)})`;
    return `${nodeIdPrefix}${endpointName}/${clusterName}/${elementName}`;
  }
  resolveAttributeName({ nodeId, endpointId, clusterId, attributeId }) {
    return this.resolveGenericElementName(nodeId, endpointId, clusterId, attributeId, this.attributes);
  }
  resolveEventName({ nodeId, endpointId, clusterId, eventId, isUrgent }) {
    return `${isUrgent ? "!" : ""}${this.resolveGenericElementName(
      nodeId,
      endpointId,
      clusterId,
      eventId,
      this.events
    )}`;
  }
  resolveCommandName({ endpointId, clusterId, commandId }) {
    return this.resolveGenericElementName(void 0, endpointId, clusterId, commandId, this.commands);
  }
  getEndpoint(endpointId) {
    return this.endpoints.get(endpointId);
  }
  hasEndpoint(endpointId) {
    return this.endpoints.has(endpointId);
  }
  getClusterServer(endpointId, clusterId) {
    return this.endpoints.get(endpointId)?.getClusterServerById(clusterId);
  }
  hasClusterServer(endpointId, clusterId) {
    return !!this.getClusterServer(endpointId, clusterId);
  }
  getAttribute(endpointId, clusterId, attributeId) {
    return this.attributes.get((0, import_InteractionServer.attributePathToId)({ endpointId, clusterId, attributeId }));
  }
  hasAttribute(endpointId, clusterId, attributeId) {
    return !!this.getAttribute(endpointId, clusterId, attributeId);
  }
  validateConcreteAttributePath(endpointId, clusterId, attributeId) {
    if (!this.hasEndpoint(endpointId)) {
      throw new import_types.StatusResponseError(`Endpoint ${endpointId} does not exist.`, import_types.StatusCode.UnsupportedEndpoint);
    }
    if (!this.hasClusterServer(endpointId, clusterId)) {
      throw new import_types.StatusResponseError(`Cluster ${clusterId} does not exist.`, import_types.StatusCode.UnsupportedCluster);
    }
    if (this.hasAttribute(endpointId, clusterId, attributeId)) return true;
    throw new import_types.StatusResponseError(`Attribute ${attributeId} does not exist`, import_types.StatusCode.UnsupportedAttribute);
  }
  getEvent(endpointId, clusterId, eventId) {
    return this.events.get((0, import_InteractionServer.eventPathToId)({ endpointId, clusterId, eventId }));
  }
  hasEvent(endpointId, clusterId, eventId) {
    return !!this.getEvent(endpointId, clusterId, eventId);
  }
  validateConcreteEventPath(endpointId, clusterId, eventId) {
    if (!this.hasEndpoint(endpointId)) {
      throw new import_types.StatusResponseError(`Endpoint ${endpointId} does not exist.`, import_types.StatusCode.UnsupportedEndpoint);
    }
    if (!this.hasClusterServer(endpointId, clusterId)) {
      throw new import_types.StatusResponseError(`Cluster ${clusterId} does not exist.`, import_types.StatusCode.UnsupportedCluster);
    }
    if (this.hasEvent(endpointId, clusterId, eventId)) return true;
    throw new import_types.StatusResponseError(`Event ${eventId} does not exist`, import_types.StatusCode.UnsupportedEvent);
  }
  getCommand(endpointId, clusterId, commandId) {
    return this.commands.get((0, import_InteractionServer.commandPathToId)({ endpointId, clusterId, commandId }));
  }
  hasCommand(endpointId, clusterId, commandId) {
    return !!this.getCommand(endpointId, clusterId, commandId);
  }
  validateConcreteCommandPath(endpointId, clusterId, commandId) {
    if (!this.hasEndpoint(endpointId)) {
      throw new import_types.StatusResponseError(`Endpoint ${endpointId} does not exist.`, import_types.StatusCode.UnsupportedEndpoint);
    }
    if (!this.hasClusterServer(endpointId, clusterId)) {
      throw new import_types.StatusResponseError(`Cluster ${clusterId} does not exist.`, import_types.StatusCode.UnsupportedCluster);
    }
    if (this.hasCommand(endpointId, clusterId, commandId)) return true;
    throw new import_types.StatusResponseError(`Command ${commandId} does not exist`, import_types.StatusCode.UnsupportedCommand);
  }
  /** Checks if the given attribute matches the wildcard path flags */
  attributePathMatchesWildcardPathFlags({ endpointId, clusterId, attributeId }, wildcardPathFlags) {
    if (wildcardPathFlags === void 0) return false;
    if (wildcardPathFlags.skipRootNode && endpointId === 0) {
      return true;
    }
    if (attributeId >= 65528 && attributeId <= 65531) {
      if (wildcardPathFlags.skipGlobalAttributes && GLOBAL_ATTRIBUTES_LIST.includes(attributeId)) {
        return true;
      }
      if (wildcardPathFlags.skipAttributeList && attributeId === import_model.AttributeList.id) {
        return true;
      }
      if (wildcardPathFlags.skipCommandLists && GLOBAL_COMMANDLIST_IDS.includes(attributeId)) {
        return true;
      }
    }
    if (wildcardPathFlags.skipCustomElements && (import_types.Mei.hasCustomMeiPrefix(clusterId) || import_types.Mei.hasCustomMeiPrefix(attributeId))) {
      return true;
    }
    const cluster = import_model.MatterModel.standard.get(import_model.ClusterModel, clusterId);
    if (cluster !== void 0) {
      const attribute = cluster.get(import_model.AttributeModel, attributeId);
      if (attribute !== void 0) {
        if (wildcardPathFlags.skipFixedAttributes && attribute.fixed) {
          return true;
        }
        if (wildcardPathFlags.skipChangesOmittedAttributes && attribute.changesOmitted) {
          return true;
        }
      }
      if (wildcardPathFlags.skipDiagnosticsClusters && DIAGNOSTICS_CLUSTER_IDS.includes(clusterId)) {
        return true;
      }
    }
    return false;
  }
  getAttributes(filters, onlyWritable = false) {
    const result = new Array();
    filters.forEach(({ endpointId, clusterId, attributeId, wildcardPathFlags }) => {
      this.validateAnyPathDataTypes({ endpointId, clusterId, attributeId });
      if (endpointId !== void 0 && clusterId !== void 0 && attributeId !== void 0) {
        const path = { endpointId, clusterId, attributeId };
        const attribute = this.attributes.get((0, import_InteractionServer.attributePathToId)(path));
        if (attribute === void 0) return;
        if (onlyWritable && !attribute.isWritable) return;
        if (this.attributePathMatchesWildcardPathFlags(path)) return;
        result.push({ path, attribute });
      } else {
        this.attributePaths.filter(
          (path) => (endpointId === void 0 || endpointId === path.endpointId) && (clusterId === void 0 || clusterId === path.clusterId) && (attributeId === void 0 || attributeId === path.attributeId)
        ).forEach((path) => {
          const attribute = this.attributes.get((0, import_InteractionServer.attributePathToId)(path));
          if (attribute === void 0) return;
          if (onlyWritable && !attribute.isWritable) return;
          if (this.attributePathMatchesWildcardPathFlags(path, wildcardPathFlags)) return;
          result.push({ path, attribute });
        });
      }
    });
    return result;
  }
  getEvents(filters) {
    const result = new Array();
    filters.forEach(({ endpointId, clusterId, eventId, isUrgent }) => {
      this.validateAnyPathDataTypes({ endpointId, clusterId, eventId });
      if (endpointId !== void 0 && clusterId !== void 0 && eventId !== void 0) {
        const path = { endpointId, clusterId, eventId, isUrgent };
        const event = this.events.get((0, import_InteractionServer.eventPathToId)(path));
        if (event === void 0) return;
        result.push({ path, event });
      } else {
        this.eventPaths.filter(
          (path) => (endpointId === void 0 || endpointId === path.endpointId) && (clusterId === void 0 || clusterId === path.clusterId) && (eventId === void 0 || eventId === path.eventId)
        ).forEach(({ endpointId: endpointId2, clusterId: clusterId2, eventId: eventId2 }) => {
          const path = { endpointId: endpointId2, clusterId: clusterId2, eventId: eventId2, isUrgent };
          const event = this.events.get((0, import_InteractionServer.eventPathToId)(path));
          if (event === void 0) return;
          result.push({ path, event });
        });
      }
    });
    return result;
  }
  getCommands(filters) {
    const result = new Array();
    filters.forEach(({ endpointId, clusterId, commandId }) => {
      this.validateAnyPathDataTypes({ endpointId, clusterId, commandId });
      if (endpointId !== void 0 && clusterId !== void 0 && commandId !== void 0) {
        const path = { endpointId, clusterId, commandId };
        const command = this.commands.get((0, import_InteractionServer.commandPathToId)(path));
        if (command === void 0) return;
        result.push({ path, command });
      } else {
        this.commandPaths.filter(
          (path) => (endpointId === void 0 || endpointId === path.endpointId) && (clusterId === void 0 || clusterId === path.clusterId) && (commandId === void 0 || commandId === path.commandId)
        ).forEach((path) => {
          const command = this.commands.get((0, import_InteractionServer.commandPathToId)(path));
          if (command === void 0) return;
          result.push({ path, command });
        });
      }
    });
    return result;
  }
  // ValidationError will return ConstraintError ... we need to see if this is correct always
  validateAnyPathDataTypes(data) {
    const { endpointId, clusterId, attributeId, eventId, commandId } = data;
    if (endpointId !== void 0) {
      (0, import_types.EndpointNumber)(endpointId);
    }
    if (clusterId !== void 0) {
      (0, import_types.ClusterId)(clusterId);
    }
    if (attributeId !== void 0) {
      (0, import_types.AttributeId)(attributeId);
    }
    if (eventId !== void 0) {
      (0, import_types.EventId)(eventId);
    }
    if (commandId !== void 0) {
      (0, import_types.CommandId)(commandId);
    }
  }
}
//# sourceMappingURL=InteractionEndpointStructure.js.map
