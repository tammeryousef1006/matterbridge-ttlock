"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var InteractionMessenger_exports = {};
__export(InteractionMessenger_exports, {
  IncomingInteractionClientMessenger: () => IncomingInteractionClientMessenger,
  InteractionClientMessenger: () => InteractionClientMessenger,
  InteractionServerMessenger: () => InteractionServerMessenger,
  MessageType: () => MessageType
});
module.exports = __toCommonJS(InteractionMessenger_exports);
var import_general = require("#general");
var import_model = require("#model");
var import_types = require("#types");
var import_MessageCodec = require("../codec/MessageCodec.js");
var import_ExchangeManager = require("../protocol/ExchangeManager.js");
var import_MessageExchange = require("../protocol/MessageExchange.js");
var import_AttributeDataEncoder = require("./AttributeDataEncoder.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
var MessageType = /* @__PURE__ */ ((MessageType2) => {
  MessageType2[MessageType2["StatusResponse"] = 1] = "StatusResponse";
  MessageType2[MessageType2["ReadRequest"] = 2] = "ReadRequest";
  MessageType2[MessageType2["SubscribeRequest"] = 3] = "SubscribeRequest";
  MessageType2[MessageType2["SubscribeResponse"] = 4] = "SubscribeResponse";
  MessageType2[MessageType2["ReportData"] = 5] = "ReportData";
  MessageType2[MessageType2["WriteRequest"] = 6] = "WriteRequest";
  MessageType2[MessageType2["WriteResponse"] = 7] = "WriteResponse";
  MessageType2[MessageType2["InvokeRequest"] = 8] = "InvokeRequest";
  MessageType2[MessageType2["InvokeResponse"] = 9] = "InvokeResponse";
  MessageType2[MessageType2["TimedRequest"] = 10] = "TimedRequest";
  return MessageType2;
})(MessageType || {});
const logger = import_general.Logger.get("InteractionMessenger");
const DATA_REPORT_MAX_QUEUED_ATTRIBUTE_MESSAGES = 20;
const DATA_REPORT_MIN_AVAILABLE_BYTES_BEFORE_SENDING = 40;
class InteractionMessenger {
  constructor(exchange) {
    this.exchange = exchange;
  }
  calculateMaximumPeerResponseTime(expectedProcessingTimeMs) {
    return this.exchange.calculateMaximumPeerResponseTime(expectedProcessingTimeMs);
  }
  send(messageType, payload, options) {
    return this.exchange.send(messageType, payload, options);
  }
  sendStatus(status, options) {
    return this.send(
      1 /* StatusResponse */,
      import_types.TlvStatusResponse.encode({ status, interactionModelRevision: import_model.Specification.INTERACTION_MODEL_REVISION }),
      {
        ...options,
        logContext: {
          for: options?.logContext?.for ? `I/Status-${options?.logContext?.for}` : void 0,
          status: `${import_types.StatusCode[status] ?? "unknown"}(${import_general.Diagnostic.hex(status)})`,
          ...options?.logContext
        }
      }
    );
  }
  async waitForSuccess(expectedMessageInfo, options) {
    await this.nextMessage(1 /* StatusResponse */, options, `Success-${expectedMessageInfo}`);
  }
  async nextMessage(expectedMessageType, options, expectedMessageInfo) {
    return this.#nextMessage(expectedMessageType, options, expectedMessageInfo);
  }
  async anyNextMessage(expectedMessageInfo, options) {
    return this.#nextMessage(void 0, options, expectedMessageInfo);
  }
  async #nextMessage(expectedMessageType, options, expectedMessageInfo) {
    const { expectedProcessingTimeMs, timeoutMs } = options ?? {};
    const message = await this.exchange.nextMessage({ expectedProcessingTimeMs, timeoutMs });
    const messageType = message.payloadHeader.messageType;
    if (expectedMessageType !== void 0 && expectedMessageInfo === void 0) {
      expectedMessageInfo = MessageType[expectedMessageType];
    }
    this.throwIfErrorStatusMessage(message, expectedMessageInfo);
    if (expectedMessageType !== void 0 && messageType !== expectedMessageType) {
      throw new import_general.UnexpectedDataError(
        `Received unexpected message for ${expectedMessageInfo} type: ${messageType}, expected: ${expectedMessageType}`
      );
    }
    return message;
  }
  async close() {
    await this.exchange.close();
  }
  throwIfErrorStatusMessage(message, logHint) {
    const {
      payloadHeader: { messageType },
      payload
    } = message;
    if (messageType !== 1 /* StatusResponse */) return;
    const { status } = import_types.TlvStatusResponse.decode(payload);
    if (status !== import_types.StatusCode.Success)
      throw new import_types.ReceivedStatusResponseError(
        `Received error status: ${status}${logHint ? ` (${logHint})` : ""}`,
        status
      );
  }
  getExchangeChannelName() {
    return this.exchange.channel.name;
  }
}
class InteractionServerMessenger extends InteractionMessenger {
  async handleRequest(recipient) {
    let continueExchange = true;
    let isGroupSession = false;
    try {
      while (continueExchange) {
        const message = await this.exchange.nextMessage();
        isGroupSession = message.packetHeader.sessionType === import_MessageCodec.SessionType.Group;
        continueExchange = false;
        switch (message.payloadHeader.messageType) {
          case 2 /* ReadRequest */: {
            if (isGroupSession) {
              throw new import_types.StatusResponseError(
                `ReadRequest is not supported in group sessions`,
                import_types.Status.InvalidAction
              );
            }
            const readRequest = import_types.TlvReadRequest.decode(message.payload);
            const { dataReport, payload } = await recipient.handleReadRequest(
              this.exchange,
              readRequest,
              message
            );
            await this.sendDataReport(dataReport, readRequest.isFabricFiltered, payload);
            break;
          }
          case 6 /* WriteRequest */: {
            const writeRequest = import_types.TlvWriteRequest.decode(message.payload);
            const { suppressResponse } = writeRequest;
            const writeResponse = await recipient.handleWriteRequest(this.exchange, writeRequest, message);
            if (!suppressResponse && !isGroupSession) {
              await this.send(7 /* WriteResponse */, import_types.TlvWriteResponse.encode(writeResponse));
            }
            break;
          }
          case 3 /* SubscribeRequest */: {
            const subscribeRequest = import_types.TlvSubscribeRequest.decode(message.payload);
            await recipient.handleSubscribeRequest(this.exchange, subscribeRequest, this, message);
            break;
          }
          case 8 /* InvokeRequest */: {
            const invokeRequest = import_types.TlvInvokeRequest.decode(message.payload);
            await recipient.handleInvokeRequest(this.exchange, invokeRequest, this, message);
            break;
          }
          case 10 /* TimedRequest */: {
            const timedRequest = import_types.TlvTimedRequest.decode(message.payload);
            recipient.handleTimedRequest(this.exchange, timedRequest, message);
            await this.sendStatus(import_types.StatusCode.Success, {
              logContext: { for: "TimedRequest" }
            });
            continueExchange = true;
            break;
          }
          default:
            throw new import_types.StatusResponseError(
              `Unsupported message type ${message.payloadHeader.messageType}`,
              import_types.Status.InvalidAction
            );
        }
      }
    } catch (error) {
      let errorStatusCode = import_types.StatusCode.Failure;
      if (error instanceof import_types.StatusResponseError) {
        logger.info(`Sending status response ${error.code} for interaction error: ${error.message}`);
        errorStatusCode = error.code;
      } else if (error instanceof import_general.NoResponseTimeoutError) {
        logger.info(error);
      } else {
        logger.warn(error);
      }
      if (!isGroupSession && !(error instanceof import_general.NoResponseTimeoutError)) {
        await this.sendStatus(errorStatusCode);
      }
    } finally {
      await this.exchange.close();
    }
  }
  /**
   * Handle a DataReport with a Payload Iterator for a DataReport to send, split them into multiple DataReport
   * messages and send them out based on the size.
   */
  async sendDataReport(baseDataReport, forFabricFilteredRead, payload, waitForAck = true) {
    const { subscriptionId, suppressResponse, interactionModelRevision } = baseDataReport;
    const dataReport = {
      subscriptionId,
      suppressResponse,
      interactionModelRevision,
      attributeReports: void 0,
      eventReports: void 0
    };
    if (payload !== void 0) {
      dataReport.moreChunkedMessages = true;
      const emptyDataReportBytes = import_types.TlvDataReportForSend.encode(dataReport);
      let allDataReceived = false;
      let processQueueFirst = true;
      const sendAndResetReport = async () => {
        await this.sendDataReportMessage(dataReport, waitForAck);
        delete dataReport.attributeReports;
        delete dataReport.eventReports;
        messageSize = emptyDataReportBytes.length;
        processQueueFirst = true;
      };
      let messageSize = emptyDataReportBytes.length;
      const attributeReportsToSend = new Array();
      const eventReportsToSend = new Array();
      while (true) {
        if (!allDataReceived && (attributeReportsToSend.length === 0 && eventReportsToSend.length === 0 || attributeReportsToSend.length <= DATA_REPORT_MAX_QUEUED_ATTRIBUTE_MESSAGES && !processQueueFirst && !attributeReportsToSend[0].needSendNext)) {
          const { done, value } = payload.next();
          if (done) {
            allDataReceived = true;
            if (attributeReportsToSend.length === 0 && eventReportsToSend.length === 0) {
              delete dataReport.moreChunkedMessages;
              break;
            } else {
              for (const attributeReport of attributeReportsToSend) {
                attributeReport.needSendNext = true;
              }
              continue;
            }
          }
          if (value === void 0) {
            continue;
          }
          if ("attributeData" in value || "attributeStatus" in value) {
            const allowMissingFieldsForNonFabricFilteredRead = !forFabricFilteredRead && value.hasFabricSensitiveData;
            const encoded = (0, import_AttributeDataEncoder.encodeAttributePayload)(value, {
              allowMissingFieldsForNonFabricFilteredRead
            });
            const encodedSize = import_types.TlvAny.getEncodedByteLength(encoded);
            if (attributeReportsToSend.length === 0) {
              attributeReportsToSend.push({
                attributeReport: value,
                encoded,
                encodedSize
              });
            } else {
              const firstQueuedAttributeData = attributeReportsToSend[0].attributeReport.attributeData;
              if (firstQueuedAttributeData !== void 0 && value.attributeData !== void 0 && firstQueuedAttributeData.path.nodeId === value.attributeData.path.nodeId && firstQueuedAttributeData.path.endpointId === value.attributeData.path.endpointId && firstQueuedAttributeData.path.clusterId === value.attributeData.path.clusterId) {
                attributeReportsToSend.unshift({
                  attributeReport: value,
                  encoded,
                  encodedSize
                });
              } else {
                for (const attributeReport of attributeReportsToSend) {
                  attributeReport.needSendNext = true;
                }
                attributeReportsToSend.push({
                  attributeReport: value,
                  encoded,
                  encodedSize
                });
              }
            }
          } else if ("eventData" in value || "eventStatus" in value) {
            const allowMissingFieldsForNonFabricFilteredRead = !forFabricFilteredRead && value.hasFabricSensitiveData;
            const encoded = (0, import_AttributeDataEncoder.encodeEventPayload)(value, { allowMissingFieldsForNonFabricFilteredRead });
            const encodedSize = import_types.TlvAny.getEncodedByteLength(encoded);
            eventReportsToSend.push({
              eventReport: value,
              encoded,
              encodedSize
            });
          } else {
            throw new import_general.InternalError(`Invalid report type: ${value}`);
          }
        }
        if (attributeReportsToSend.length > 0) {
          const attributeToSend = attributeReportsToSend.shift();
          if (attributeToSend === void 0) {
            continue;
          }
          const { attributeReport, encoded, encodedSize, needSendNext } = attributeToSend;
          let availableBytes = this.exchange.maxPayloadSize - messageSize - 3;
          let sendOutTheMessage = false;
          if (encodedSize > availableBytes) {
            if ((allDataReceived || needSendNext) && (0, import_AttributeDataEncoder.canAttributePayloadBeChunked)(attributeReport)) {
              const chunks = (0, import_AttributeDataEncoder.chunkAttributePayload)(attributeReport);
              const initialChunk = chunks.shift();
              const firstDataChunk = chunks.shift();
              if (initialChunk === void 0 || firstDataChunk === void 0) {
                throw new import_general.InternalError(
                  "Chunked attribute payload is unexpected. This should not happen!"
                );
              }
              initialChunk.attributeData.payload.push(firstDataChunk.attributeData.payload);
              const allowMissingFieldsForNonFabricFilteredRead = !forFabricFilteredRead && attributeReport.hasFabricSensitiveData;
              const encodedInitialChunk = (0, import_AttributeDataEncoder.encodeAttributePayload)(initialChunk, {
                allowMissingFieldsForNonFabricFilteredRead
              });
              const encodedInitialChunkSize = import_types.TlvAny.getEncodedByteLength(encodedInitialChunk);
              if (availableBytes > encodedInitialChunkSize) {
                availableBytes -= encodedInitialChunkSize;
                messageSize += encodedInitialChunkSize;
                while (chunks.length > 0) {
                  const nextChunk = chunks.shift();
                  if (nextChunk === void 0) {
                    throw new import_general.InternalError(
                      "Chunked attribute payload is undefined. This should not happen!"
                    );
                  }
                  const encodedChunkData = (0, import_AttributeDataEncoder.encodeAttributePayloadData)(nextChunk, {
                    allowMissingFieldsForNonFabricFilteredRead
                  });
                  const encodedChunkDataSize = import_types.TlvAny.getEncodedByteLength(encodedChunkData);
                  if (encodedChunkDataSize > availableBytes) {
                    chunks.unshift(nextChunk);
                    for (let i = chunks.length - 1; i >= 0; i--) {
                      const chunk = chunks[i];
                      const encodedChunk = (0, import_AttributeDataEncoder.encodeAttributePayload)(chunk, {
                        allowMissingFieldsForNonFabricFilteredRead
                      });
                      const encodedChunkSize = import_types.TlvAny.getEncodedByteLength(encodedChunk);
                      attributeReportsToSend.unshift({
                        attributeReport: chunk,
                        encoded: encodedChunk,
                        encodedSize: encodedChunkSize,
                        needSendNext: true
                      });
                    }
                    if (dataReport.attributeReports === void 0) {
                      dataReport.attributeReports = [];
                    }
                    dataReport.attributeReports.push(
                      (0, import_AttributeDataEncoder.encodeAttributePayload)(initialChunk, {
                        allowMissingFieldsForNonFabricFilteredRead
                      })
                    );
                    break;
                  }
                  availableBytes -= encodedChunkDataSize;
                  messageSize += encodedChunkDataSize;
                  initialChunk.attributeData.payload.push(nextChunk.attributeData.payload);
                }
                continue;
              } else if (needSendNext) {
                sendOutTheMessage = true;
              }
            } else {
              if (needSendNext) {
                sendOutTheMessage = true;
              } else {
                processQueueFirst = false;
              }
            }
            let messageWasSent = false;
            if (sendOutTheMessage || availableBytes < DATA_REPORT_MIN_AVAILABLE_BYTES_BEFORE_SENDING || attributeReportsToSend.length > 0 && attributeReportsToSend[0].needSendNext || attributeReportsToSend.length >= DATA_REPORT_MAX_QUEUED_ATTRIBUTE_MESSAGES) {
              await sendAndResetReport();
              messageWasSent = true;
            }
            if (!messageWasSent) {
              attributeReportsToSend.push(attributeToSend);
              continue;
            }
            if (encodedSize > this.exchange.maxPayloadSize - emptyDataReportBytes.length - 3) {
              attributeReportsToSend.unshift(attributeToSend);
              continue;
            }
          }
          messageSize += encodedSize;
          if (dataReport.attributeReports === void 0) {
            dataReport.attributeReports = [];
          }
          dataReport.attributeReports.push(encoded);
        } else if (eventReportsToSend.length > 0) {
          const eventToSend = eventReportsToSend.shift();
          if (eventToSend === void 0) {
            continue;
          }
          const { encoded, encodedSize } = eventToSend;
          if (messageSize + 3 + (dataReport.attributeReports ? 3 : 0) + encodedSize > this.exchange.maxPayloadSize) {
            await sendAndResetReport();
          }
          messageSize += encodedSize;
          if (dataReport.eventReports === void 0) {
            dataReport.eventReports = [];
          }
          dataReport.eventReports.push(encoded);
        } else if (allDataReceived) {
          delete dataReport.moreChunkedMessages;
          break;
        }
      }
    }
    await this.sendDataReportMessage(dataReport, waitForAck);
  }
  async sendDataReportMessage(dataReport, waitForAck = true) {
    const dataReportToSend = {
      ...dataReport,
      suppressResponse: dataReport.moreChunkedMessages ? false : dataReport.suppressResponse
      // always false when moreChunkedMessages is true
    };
    const encodedMessage = import_types.TlvDataReportForSend.encode(dataReportToSend);
    if (encodedMessage.length > this.exchange.maxPayloadSize) {
      throw new import_general.MatterFlowError(
        `DataReport with ${encodedMessage.length}bytes is too long to fit in a single chunk (${this.exchange.maxPayloadSize}bytes), This should not happen! Data: ${import_general.Diagnostic.json(
          dataReportToSend
        )}`
      );
    }
    const logContext = {
      subId: dataReportToSend.subscriptionId,
      interactionFlags: import_general.Diagnostic.asFlags({
        empty: !dataReportToSend.attributeReports?.length && !dataReportToSend.eventReports?.length,
        suppressResponse: dataReportToSend.suppressResponse,
        moreChunkedMessages: dataReportToSend.moreChunkedMessages
      }),
      attr: dataReportToSend.attributeReports?.length,
      ev: dataReportToSend.eventReports?.length
    };
    if (dataReportToSend.suppressResponse) {
      try {
        await this.exchange.send(5 /* ReportData */, encodedMessage, {
          expectAckOnly: true,
          disableMrpLogic: !waitForAck,
          logContext
        });
      } catch (e) {
        import_MessageExchange.UnexpectedMessageError.accept(e);
        const { receivedMessage } = e;
        this.throwIfErrorStatusMessage(receivedMessage);
      }
    } else {
      await this.exchange.send(5 /* ReportData */, encodedMessage, {
        disableMrpLogic: !waitForAck,
        logContext
      });
      await this.waitForSuccess("DataReport", { timeoutMs: waitForAck ? void 0 : 500 });
    }
  }
}
class IncomingInteractionClientMessenger extends InteractionMessenger {
  async waitFor(expectedMessageInfo, messageType, timeoutMs) {
    const message = await this.anyNextMessage(expectedMessageInfo, { timeoutMs });
    const {
      payloadHeader: { messageType: receivedMessageType }
    } = message;
    if (receivedMessageType !== messageType) {
      if (receivedMessageType === 1 /* StatusResponse */) {
        const statusCode = import_types.TlvStatusResponse.decode(message.payload).status;
        throw new import_types.ReceivedStatusResponseError(`Received status response ${statusCode}`, statusCode);
      }
      throw new import_general.MatterFlowError(
        `Received unexpected message type ${receivedMessageType.toString(16)}. Expected ${messageType.toString(
          16
        )}`
      );
    }
    return message;
  }
  async readAggregateDataReport(expectedSubscriptionIds) {
    let result;
    for await (const report of this.readDataReports()) {
      if (expectedSubscriptionIds !== void 0) {
        if (report.subscriptionId === void 0 || !expectedSubscriptionIds.includes(report.subscriptionId)) {
          await this.sendStatus(import_types.StatusCode.InvalidSubscription, {
            multipleMessageInteraction: true,
            logContext: {
              subId: report.subscriptionId
            }
          });
          throw new import_general.UnexpectedDataError(
            report.subscriptionId === void 0 ? "Invalid Data report without Subscription ID" : `Invalid Data report with unexpected subscription ID ${report.subscriptionId}`
          );
        }
      }
      if (result?.subscriptionId !== void 0 && report.subscriptionId !== result.subscriptionId) {
        throw new import_general.UnexpectedDataError(`Invalid subscription ID ${report.subscriptionId} received`);
      }
      if (!result) {
        result = report;
      } else {
        if (Array.isArray(report.attributeReports)) {
          if (!result.attributeReports) {
            result.attributeReports = report.attributeReports;
          } else {
            result.attributeReports.push(...report.attributeReports);
          }
        }
        if (Array.isArray(report.eventReports)) {
          if (!result.eventReports) {
            result.eventReports = report.eventReports;
          } else {
            result.eventReports.push(...report.eventReports);
          }
        }
      }
    }
    if (result === void 0) {
      throw new import_general.InternalError("No data reports loaded during read");
    }
    return result;
  }
  /**
   * Read data reports as they come in on the wire.
   *
   * Data reports payloads are decoded but list attributes may be split across messages; these will require reassembly.
   */
  async *readDataReports() {
    while (true) {
      const dataReportMessage = await this.waitFor("DataReport", 5 /* ReportData */);
      const report = import_types.TlvDataReport.decode(dataReportMessage.payload);
      yield report;
      if (report.moreChunkedMessages) {
        await this.sendStatus(import_types.StatusCode.Success, {
          multipleMessageInteraction: true,
          logContext: this.#logContextOf(report)
        });
      } else if (!report.suppressResponse) {
        this.sendStatus(import_types.StatusCode.Success, {
          multipleMessageInteraction: true,
          logContext: this.#logContextOf(report)
        }).catch((error) => logger.info("Error sending success after final data report chunk", error));
      }
      if (!report.moreChunkedMessages) {
        break;
      }
    }
  }
  #logContextOf(report) {
    return {
      subId: report.subscriptionId,
      dataReportFlags: import_general.Diagnostic.asFlags({
        empty: !report.attributeReports?.length && !report.eventReports?.length,
        suppressResponse: report.suppressResponse,
        moreChunkedMessages: report.moreChunkedMessages
      }),
      attr: report.attributeReports?.length,
      ev: report.eventReports?.length
    };
  }
}
class InteractionClientMessenger extends IncomingInteractionClientMessenger {
  constructor(exchange, exchangeProvider) {
    super(exchange);
    this.exchangeProvider = exchangeProvider;
  }
  static async create(exchangeProvider) {
    const exchange = await exchangeProvider.initiateExchange();
    return new this(exchange, exchangeProvider);
  }
  /** Implements a send method with an automatic reconnection mechanism */
  async send(messageType, payload, options) {
    try {
      if (this.exchange.channel.closed) {
        throw new import_ExchangeManager.ChannelNotConnectedError("The exchange channel is closed. Please connect the device first.");
      }
      return await this.exchange.send(messageType, payload, options);
    } catch (error) {
      if (this.exchangeProvider.supportsReconnect && (error instanceof import_MessageExchange.RetransmissionLimitReachedError || error instanceof import_ExchangeManager.ChannelNotConnectedError) && !options?.multipleMessageInteraction) {
        logger.debug(
          `${error instanceof import_MessageExchange.RetransmissionLimitReachedError ? "Retransmission limit reached" : "Channel not connected"}, trying to reconnect and resend the message.`
        );
        await this.exchange.close();
        if (await this.exchangeProvider.reconnectChannel()) {
          this.exchange = await this.exchangeProvider.initiateExchange();
          return await this.exchange.send(messageType, payload, options);
        }
      } else {
        throw error;
      }
    }
  }
  async sendReadRequest(readRequest) {
    await this.send(2 /* ReadRequest */, this.#encodeReadingRequest(import_types.TlvReadRequest, readRequest));
    return this.readAggregateDataReport();
  }
  #encodeReadingRequest(schema, request) {
    const encoded = schema.encode(request);
    if (encoded.length <= this.exchange.maxPayloadSize) {
      return encoded;
    }
    const originalDataVersionFilters = [...request.dataVersionFilters ?? []];
    const requestWithoutDataVersionFilters = schema.encode({
      ...request,
      dataVersionFilters: []
    });
    if (requestWithoutDataVersionFilters.length > this.exchange.maxPayloadSize) {
      throw new import_general.MatterFlowError(
        `Request is too long to fit in a single chunk, This should not happen! Data: ${import_general.Diagnostic.json(request)}`
      );
    }
    return schema.encode({
      ...request,
      dataVersionFilters: this.#shortenDataVersionFilters(
        originalDataVersionFilters,
        this.exchange.maxPayloadSize - requestWithoutDataVersionFilters.length
      )
    });
  }
  #shortenDataVersionFilters(originalDataVersionFilters, availableBytes) {
    const dataVersionFilters = new Array();
    while (availableBytes > 0 && originalDataVersionFilters.length > 0) {
      const dataVersionFilter = originalDataVersionFilters.shift();
      if (dataVersionFilter === void 0) {
        break;
      }
      const encodedDataVersionFilter = import_types.TlvDataVersionFilter.encode(dataVersionFilter);
      const encodedDataVersionFilterLength = encodedDataVersionFilter.length;
      if (encodedDataVersionFilterLength > availableBytes) {
        originalDataVersionFilters.unshift(dataVersionFilter);
        break;
      }
      dataVersionFilters.push(dataVersionFilter);
      availableBytes -= encodedDataVersionFilterLength;
    }
    logger.debug(
      `Removed ${originalDataVersionFilters.length} DataVersionFilters from Request to fit into a single message`
    );
    return dataVersionFilters;
  }
  async sendSubscribeRequest(subscribeRequest) {
    const request = this.#encodeReadingRequest(import_types.TlvSubscribeRequest, subscribeRequest);
    await this.send(3 /* SubscribeRequest */, request);
    const report = await this.readAggregateDataReport();
    const { subscriptionId } = report;
    if (subscriptionId === void 0) {
      throw new import_general.UnexpectedDataError(`Subscription ID not provided in report`);
    }
    const subscribeResponseMessage = await this.nextMessage(4 /* SubscribeResponse */);
    const subscribeResponse = import_types.TlvSubscribeResponse.decode(subscribeResponseMessage.payload);
    if (subscribeResponse.subscriptionId !== subscriptionId) {
      throw new import_general.MatterFlowError(
        `Received subscription ID ${subscribeResponse.subscriptionId} instead of ${subscriptionId}`
      );
    }
    return {
      subscribeResponse,
      report
    };
  }
  async sendInvokeCommand(invokeRequest, expectedProcessingTimeMs) {
    if (invokeRequest.suppressResponse) {
      await this.requestWithSuppressedResponse(
        8 /* InvokeRequest */,
        import_types.TlvInvokeRequest,
        invokeRequest,
        expectedProcessingTimeMs
      );
    } else {
      return await this.request(
        8 /* InvokeRequest */,
        import_types.TlvInvokeRequest,
        9 /* InvokeResponse */,
        import_types.TlvInvokeResponse,
        invokeRequest,
        expectedProcessingTimeMs
      );
    }
  }
  async sendWriteCommand(writeRequest) {
    if (writeRequest.suppressResponse) {
      await this.requestWithSuppressedResponse(6 /* WriteRequest */, import_types.TlvWriteRequest, writeRequest);
    } else {
      return await this.request(
        6 /* WriteRequest */,
        import_types.TlvWriteRequest,
        7 /* WriteResponse */,
        import_types.TlvWriteResponse,
        writeRequest
      );
    }
  }
  sendTimedRequest(timeoutSeconds) {
    return this.request(10 /* TimedRequest */, import_types.TlvTimedRequest, 1 /* StatusResponse */, import_types.TlvStatusResponse, {
      timeout: timeoutSeconds,
      interactionModelRevision: import_model.Specification.INTERACTION_MODEL_REVISION
    });
  }
  async requestWithSuppressedResponse(requestMessageType, requestSchema, request, expectedProcessingTimeMs) {
    await this.send(requestMessageType, requestSchema.encode(request), {
      expectAckOnly: true,
      expectedProcessingTimeMs,
      logContext: {
        invokeFlags: import_general.Diagnostic.asFlags({
          suppressResponse: true
        })
      }
    });
  }
  async request(requestMessageType, requestSchema, responseMessageType, responseSchema, request, expectedProcessingTimeMs) {
    await this.send(requestMessageType, requestSchema.encode(request), {
      expectAckOnly: false,
      expectedProcessingTimeMs
    });
    const responseMessage = await this.nextMessage(
      responseMessageType,
      { expectedProcessingTimeMs },
      MessageType[responseMessageType] ?? `Response-${import_general.Diagnostic.hex(responseMessageType)}`
    );
    return responseSchema.decode(responseMessage.payload);
  }
}
//# sourceMappingURL=InteractionMessenger.js.map
