/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Observable, ServerAddressIp } from "#general";
import { PeerAddress } from "#peer/PeerAddress.js";
import { SessionManager } from "#session/SessionManager.js";
import { AttributeId, ClusterId, CommandId, EndpointNumber, EventId, NodeId, StatusCode, TlvAttributePath, TlvClusterPath, TlvEventFilter, TlvEventPath, TypeFromSchema } from "#types";
import { AnyAttributeServer, AttributeServer } from "../cluster/server/AttributeServer.js";
import { CommandServer } from "../cluster/server/CommandServer.js";
import { AnyEventServer } from "../cluster/server/EventServer.js";
import { Message } from "../codec/MessageCodec.js";
import { EndpointInterface } from "../endpoint/EndpointInterface.js";
import { MessageExchange } from "../protocol/MessageExchange.js";
import { ProtocolHandler } from "../protocol/ProtocolHandler.js";
import { SecureSession } from "../session/SecureSession.js";
import { DataReportPayloadIterator } from "./AttributeDataEncoder.js";
import { InteractionEndpointStructure } from "./InteractionEndpointStructure.js";
import { DataReport, InteractionRecipient, InteractionServerMessenger, InvokeRequest, ReadRequest, SubscribeRequest, TimedRequest, WriteRequest, WriteResponse } from "./InteractionMessenger.js";
import { ServerSubscription } from "./ServerSubscription.js";
import { ServerSubscriptionConfig } from "./SubscriptionOptions.js";
export interface PeerSubscription {
    subscriptionId: number;
    peerAddress: PeerAddress;
    minIntervalFloorSeconds: number;
    maxIntervalCeilingSeconds: number;
    attributeRequests?: TypeFromSchema<typeof TlvAttributePath>[];
    eventRequests?: TypeFromSchema<typeof TlvEventPath>[];
    isFabricFiltered: boolean;
    maxInterval: number;
    sendInterval: number;
    operationalAddress?: ServerAddressIp;
}
export interface CommandPath {
    nodeId?: NodeId;
    endpointId: EndpointNumber;
    clusterId: ClusterId;
    commandId: CommandId;
}
export interface AttributePath {
    nodeId?: NodeId;
    endpointId: EndpointNumber;
    clusterId: ClusterId;
    attributeId: AttributeId;
}
export interface EventPath {
    nodeId?: NodeId;
    endpointId: EndpointNumber;
    clusterId: ClusterId;
    eventId: EventId;
    isUrgent?: boolean;
}
export interface AttributeWithPath {
    path: AttributePath;
    attribute: AnyAttributeServer<any>;
}
export interface EventWithPath {
    path: EventPath;
    event: AnyEventServer<any, any>;
}
export interface CommandWithPath {
    path: CommandPath;
    command: CommandServer<any, any>;
}
export declare function genericElementPathToId(endpointId: EndpointNumber | undefined, clusterId: ClusterId | undefined, elementId: number | undefined): string;
export declare function commandPathToId({ endpointId, clusterId, commandId }: CommandPath): string;
export declare function attributePathToId({ endpointId, clusterId, attributeId }: TypeFromSchema<typeof TlvAttributePath>): string;
export declare function eventPathToId({ endpointId, clusterId, eventId }: TypeFromSchema<typeof TlvEventPath>): string;
export declare function clusterPathToId({ nodeId, endpointId, clusterId }: TypeFromSchema<typeof TlvClusterPath>): string;
export declare function validateReadAttributesPath(path: TypeFromSchema<typeof TlvAttributePath>, isGroupSession?: boolean): void;
export declare function validateReadEventPath(path: TypeFromSchema<typeof TlvEventPath>, isGroupSession?: boolean): void;
/**
 * Interfaces {@link InteractionServer} with other components.
 */
export interface InteractionContext {
    readonly sessions: SessionManager;
    readonly structure: InteractionEndpointStructure;
    readonly subscriptionOptions?: Partial<ServerSubscriptionConfig>;
    readonly maxPathsPerInvoke?: number;
    initiateExchange(address: PeerAddress, protocolId: number): MessageExchange;
}
/**
 * Translates interactions from the Matter protocol to matter.js APIs.
 */
export declare class InteractionServer implements ProtocolHandler, InteractionRecipient {
    #private;
    readonly id = 1;
    constructor(context: InteractionContext);
    protected get isClosing(): boolean;
    get maxPathsPerInvoke(): number;
    get subscriptionEstablishmentStarted(): Observable<[peerAddress: PeerAddress], void>;
    onNewExchange(exchange: MessageExchange, message: Message): Promise<void>;
    get clientHandler(): ProtocolHandler | undefined;
    set clientHandler(clientHandler: ProtocolHandler);
    handleReadRequest(exchange: MessageExchange, readRequest: ReadRequest, message: Message): Promise<{
        dataReport: DataReport;
        payload?: DataReportPayloadIterator;
    }>;
    protected readAttribute(_path: AttributePath, attribute: AnyAttributeServer<any>, exchange: MessageExchange, isFabricFiltered: boolean, message: Message, offline?: boolean): {
        version: number;
        value: any;
    };
    /**
     * Reads the attributes for the given endpoint.
     * This can currently only be used for subscriptions because errors are ignored!
     */
    protected readEndpointAttributesForSubscription(attributes: {
        path: AttributePath;
        attribute: AnyAttributeServer<any>;
    }[], exchange: MessageExchange, isFabricFiltered: boolean, message: Message, offline?: boolean): {
        path: AttributePath;
        attribute: AnyAttributeServer<unknown>;
        value: any;
        version: number;
    }[];
    protected readEvent(_path: EventPath, eventFilters: TypeFromSchema<typeof TlvEventFilter>[] | undefined, event: AnyEventServer<any, any>, exchange: MessageExchange, isFabricFiltered: boolean, message: Message): Promise<import("../index.js").NumberedOccurrence[]>;
    handleWriteRequest(exchange: MessageExchange, { suppressResponse, timedRequest, writeRequests, interactionModelRevision, moreChunkedMessages }: WriteRequest, message: Message): Promise<WriteResponse>;
    protected writeAttribute(_path: AttributePath, attribute: AttributeServer<any>, value: any, exchange: MessageExchange, message: Message, _endpoint: EndpointInterface, _receivedWithinTimedInteraction?: boolean, isListWrite?: boolean): Promise<void>;
    handleSubscribeRequest(exchange: MessageExchange, request: SubscribeRequest, messenger: InteractionServerMessenger, message: Message): Promise<void>;
    establishFormerSubscription({ subscriptionId, attributeRequests, eventRequests, isFabricFiltered, minIntervalFloorSeconds, maxIntervalCeilingSeconds, maxInterval, sendInterval, }: PeerSubscription, session: SecureSession): Promise<ServerSubscription>;
    handleInvokeRequest(exchange: MessageExchange, { invokeRequests, timedRequest, suppressResponse, interactionModelRevision }: InvokeRequest, messenger: InteractionServerMessenger, message: Message): Promise<void>;
    protected invokeCommand(_path: CommandPath, command: CommandServer<any, any>, exchange: MessageExchange, commandFields: any, message: Message, endpoint: EndpointInterface, _receivedWithinTimedInteraction?: boolean): Promise<{
        code: StatusCode;
        clusterCode?: number;
        responseId: CommandId;
        response: import("#types").TlvStream;
    }>;
    handleTimedRequest(exchange: MessageExchange, { timeout, interactionModelRevision }: TimedRequest): void;
    close(): Promise<void>;
}
//# sourceMappingURL=InteractionServer.d.ts.map