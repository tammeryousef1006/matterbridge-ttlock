"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var InteractionServer_exports = {};
__export(InteractionServer_exports, {
  InteractionServer: () => InteractionServer,
  attributePathToId: () => attributePathToId,
  clusterPathToId: () => clusterPathToId,
  commandPathToId: () => commandPathToId,
  eventPathToId: () => eventPathToId,
  genericElementPathToId: () => genericElementPathToId,
  validateReadAttributesPath: () => validateReadAttributesPath,
  validateReadEventPath: () => validateReadEventPath
});
module.exports = __toCommonJS(InteractionServer_exports);
var import_general = require("#general");
var import_model = require("#model");
var import_types = require("#types");
var import_AttributeServer = require("../cluster/server/AttributeServer.js");
var import_MessageCodec = require("../codec/MessageCodec.js");
var import_SecureSession = require("../session/SecureSession.js");
var import_AttributeDataDecoder = require("./AttributeDataDecoder.js");
var import_InteractionMessenger = require("./InteractionMessenger.js");
var import_ServerSubscription = require("./ServerSubscription.js");
var import_SubscriptionOptions = require("./SubscriptionOptions.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("InteractionServer");
function genericElementPathToId(endpointId, clusterId, elementId) {
  return `${endpointId}/${clusterId}/${elementId}`;
}
function commandPathToId({ endpointId, clusterId, commandId }) {
  return genericElementPathToId(endpointId, clusterId, commandId);
}
function attributePathToId({ endpointId, clusterId, attributeId }) {
  return genericElementPathToId(endpointId, clusterId, attributeId);
}
function eventPathToId({ endpointId, clusterId, eventId }) {
  return genericElementPathToId(endpointId, clusterId, eventId);
}
function clusterPathToId({ nodeId, endpointId, clusterId }) {
  return `${nodeId}/${endpointId}/${clusterId}`;
}
function isConcreteAttributePath(path) {
  const { endpointId, clusterId, attributeId } = path;
  return endpointId !== void 0 && clusterId !== void 0 && attributeId !== void 0;
}
function validateReadAttributesPath(path, isGroupSession = false) {
  if (isGroupSession) {
    throw new import_types.StatusResponseError("Illegal read request with group session", import_types.StatusCode.InvalidAction);
  }
  const { clusterId, attributeId } = path;
  if (clusterId === void 0 && attributeId !== void 0) {
    if (!import_model.GLOBAL_IDS.has(attributeId)) {
      throw new import_types.StatusResponseError(
        `Illegal read request for wildcard cluster and non global attribute ${attributeId}`,
        import_types.StatusCode.InvalidAction
      );
    }
  }
}
function validateWriteAttributesPath(path, isGroupSession = false) {
  const { endpointId, clusterId, attributeId } = path;
  if (clusterId === void 0 || attributeId === void 0) {
    throw new import_types.StatusResponseError(
      "Illegal write request with wildcard cluster or attribute ID",
      import_types.StatusCode.InvalidAction
    );
  }
  if (isGroupSession && endpointId !== void 0) {
    throw new import_types.StatusResponseError("Illegal write request with group ID and endpoint ID", import_types.StatusCode.InvalidAction);
  }
}
function isConcreteEventPath(path) {
  const { endpointId, clusterId, eventId } = path;
  return endpointId !== void 0 && clusterId !== void 0 && eventId !== void 0;
}
function validateReadEventPath(path, isGroupSession = false) {
  const { clusterId, eventId } = path;
  if (clusterId === void 0 && eventId !== void 0) {
    throw new import_types.StatusResponseError("Illegal read request with wildcard cluster ID", import_types.StatusCode.InvalidAction);
  }
  if (isGroupSession) {
    throw new import_types.StatusResponseError("Illegal read request with group session", import_types.StatusCode.InvalidAction);
  }
}
function isConcreteCommandPath(path) {
  const { endpointId, clusterId, commandId } = path;
  return endpointId !== void 0 && clusterId !== void 0 && commandId !== void 0;
}
function validateCommandPath(path, isGroupSession = false) {
  const { endpointId, clusterId, commandId } = path;
  if (clusterId === void 0 || commandId === void 0) {
    throw new import_types.StatusResponseError(
      "Illegal write request with wildcard cluster or attribute ID",
      import_types.StatusCode.InvalidAction
    );
  }
  if (isGroupSession && endpointId !== void 0) {
    throw new import_types.StatusResponseError("Illegal write request with group ID and endpoint ID", import_types.StatusCode.InvalidAction);
  }
}
function getMatterModelCluster(clusterId) {
  return import_model.MatterModel.standard.get(import_model.ClusterModel, clusterId);
}
function getMatterModelClusterAttribute(clusterId, attributeId) {
  return getMatterModelCluster(clusterId)?.get(import_model.AttributeModel, attributeId);
}
function getMatterModelClusterCommand(clusterId, commandId) {
  return getMatterModelCluster(clusterId)?.get(import_model.CommandModel, commandId);
}
class InteractionServer {
  id = import_types.INTERACTION_PROTOCOL_ID;
  #context;
  #nextSubscriptionId = import_general.Crypto.getRandomUInt32();
  #isClosing = false;
  #clientHandler;
  #subscriptionConfig;
  #maxPathsPerInvoke;
  #subscriptionEstablishmentStarted = (0, import_general.Observable)();
  constructor(context) {
    this.#context = context;
    this.#subscriptionConfig = import_SubscriptionOptions.ServerSubscriptionConfig.of(context.subscriptionOptions);
    this.#maxPathsPerInvoke = context.maxPathsPerInvoke ?? import_types.DEFAULT_MAX_PATHS_PER_INVOKE;
    this.#context.structure.change.on(async () => {
      this.#context.sessions.updateAllSubscriptions();
    });
  }
  get isClosing() {
    return this.#isClosing;
  }
  get maxPathsPerInvoke() {
    return this.#maxPathsPerInvoke;
  }
  get subscriptionEstablishmentStarted() {
    return this.#subscriptionEstablishmentStarted;
  }
  async onNewExchange(exchange, message) {
    if (this.#isClosing) return;
    if (message.payloadHeader.messageType === import_InteractionMessenger.MessageType.SubscribeRequest && this.#clientHandler) {
      return this.#clientHandler.onNewExchange(exchange, message);
    }
    await new import_InteractionMessenger.InteractionServerMessenger(exchange).handleRequest(this);
  }
  get clientHandler() {
    return this.#clientHandler;
  }
  set clientHandler(clientHandler) {
    this.#clientHandler = clientHandler;
  }
  async #collectEventDataForRead({ eventRequests, eventFilters, isFabricFiltered }, exchange, message) {
    let eventReportsPayload;
    if (eventRequests) {
      eventReportsPayload = [];
      for (const requestPath of eventRequests) {
        validateReadEventPath(requestPath);
        const events = this.#endpointStructure.getEvents([requestPath]);
        if (events.length === 0) {
          if (isConcreteEventPath(requestPath)) {
            const { endpointId, clusterId, eventId } = requestPath;
            try {
              this.#endpointStructure.validateConcreteEventPath(endpointId, clusterId, eventId);
              throw new import_general.InternalError(
                "validateConcreteEventPath should throw StatusResponseError but did not."
              );
            } catch (e) {
              import_types.StatusResponseError.accept(e);
              logger.debug(
                `Read event from ${exchange.channel.name}: ${this.#endpointStructure.resolveEventName(requestPath)}: unsupported path: Status=${e.code}`
              );
              eventReportsPayload?.push({
                hasFabricSensitiveData: false,
                eventStatus: { path: requestPath, status: { status: e.code } }
              });
            }
          }
          logger.debug(
            `Read event from ${exchange.channel.name}: ${this.#endpointStructure.resolveEventName(
              requestPath
            )}: ignore non-existing event`
          );
          continue;
        }
        const reportsForPath = new Array();
        for (const { path, event } of events) {
          try {
            const matchingEvents = await this.readEvent(
              path,
              eventFilters,
              event,
              exchange,
              isFabricFiltered,
              message
            );
            logger.debug(
              `Read event from ${exchange.channel.name}: ${this.#endpointStructure.resolveEventName(
                path
              )}=${import_general.Diagnostic.json(matchingEvents)}`
            );
            const { schema } = event;
            reportsForPath.push(
              ...matchingEvents.map(({ number, priority, epochTimestamp, payload }) => ({
                hasFabricSensitiveData: event.hasFabricSensitiveData,
                eventData: {
                  path,
                  eventNumber: number,
                  priority,
                  epochTimestamp,
                  payload,
                  schema
                }
              }))
            );
          } catch (error) {
            logger.error(
              `Error while reading event from ${exchange.channel.name} to ${this.#endpointStructure.resolveEventName(path)}:`,
              error
            );
            import_types.StatusResponseError.accept(error);
            if (isConcreteEventPath(requestPath)) {
              eventReportsPayload?.push({
                hasFabricSensitiveData: false,
                eventStatus: { path, status: { status: error.code } }
              });
            }
          }
        }
        eventReportsPayload.push(
          ...reportsForPath.sort((a, b) => {
            const eventNumberA = a.eventData?.eventNumber ?? (0, import_types.EventNumber)(0);
            const eventNumberB = b.eventData?.eventNumber ?? (0, import_types.EventNumber)(0);
            if (eventNumberA > eventNumberB) {
              return 1;
            } else if (eventNumberA < eventNumberB) {
              return -1;
            } else {
              return 0;
            }
          })
        );
      }
    }
    return eventReportsPayload;
  }
  /**
   * Returns an iterator that yields the data reports and events data for the given read request.
   */
  *#iterateReadAttributesPaths({ attributeRequests, dataVersionFilters, isFabricFiltered }, eventReportsPayload, exchange, message) {
    const dataVersionFilterMap = new Map(
      dataVersionFilters?.map(({ path, dataVersion }) => [clusterPathToId(path), dataVersion]) ?? []
    );
    if (dataVersionFilterMap.size > 0) {
      logger.debug(
        `DataVersionFilters: ${Array.from(dataVersionFilterMap.entries()).map(([path, version]) => `${path}=${version}`).join(", ")}`
      );
    }
    for (const requestPath of attributeRequests ?? []) {
      validateReadAttributesPath(requestPath);
      const attributes = this.#endpointStructure.getAttributes([requestPath]);
      if (attributes.length === 0) {
        if (isConcreteAttributePath(requestPath)) {
          const { endpointId, clusterId, attributeId } = requestPath;
          try {
            this.#endpointStructure.validateConcreteAttributePath(endpointId, clusterId, attributeId);
            throw new import_general.InternalError(
              "validateConcreteAttributePath should throw StatusResponseError but did not."
            );
          } catch (e) {
            import_types.StatusResponseError.accept(e);
            logger.debug(
              `Error reading attribute from ${exchange.channel.name}: ${this.#endpointStructure.resolveAttributeName(requestPath)}: unsupported path: Status=${e.code}`
            );
            yield {
              hasFabricSensitiveData: false,
              attributeStatus: { path: requestPath, status: { status: e.code } }
            };
          }
        }
        logger.debug(
          `Read from ${exchange.channel.name}: ${this.#endpointStructure.resolveAttributeName(
            requestPath
          )}: ${this.#endpointStructure.resolveAttributeName(requestPath)}: ignore non-existing attribute`
        );
        continue;
      }
      for (const { path, attribute } of attributes) {
        const { nodeId, endpointId, clusterId } = path;
        try {
          if (getMatterModelClusterAttribute(clusterId, attribute.id)?.readable === false) {
            throw new import_types.StatusResponseError(
              `Attribute ${attribute.id} is not readable.`,
              import_types.StatusCode.UnsupportedRead
            );
          }
          let value, version;
          try {
            ({ value, version } = this.readAttribute(path, attribute, exchange, isFabricFiltered, message));
          } catch (e) {
            import_SecureSession.NoAssociatedFabricError.accept(e);
            if (endpointId === void 0 || clusterId === void 0) {
              throw new import_general.MatterFlowError("Should never happen");
            }
            const cluster = this.#endpointStructure.getClusterServer(endpointId, clusterId);
            if (cluster === void 0 || cluster.datasource == void 0) {
              throw new import_general.MatterFlowError("Should never happen");
            }
            version = cluster.datasource.version;
            value = [];
          }
          const versionFilterValue = endpointId !== void 0 && clusterId !== void 0 ? dataVersionFilterMap.get(clusterPathToId({ nodeId, endpointId, clusterId })) : void 0;
          if (versionFilterValue !== void 0 && versionFilterValue === version) {
            logger.debug(
              `Read attribute from ${exchange.channel.name}: ${this.#endpointStructure.resolveAttributeName(
                path
              )}=${import_general.Diagnostic.json(value)} (version=${version}) ignored because of dataVersionFilter`
            );
            continue;
          }
          logger.debug(
            `Read attribute from ${exchange.channel.name}: ${this.#endpointStructure.resolveAttributeName(
              path
            )}=${import_general.Diagnostic.json(value)} (version=${version})`
          );
          const { schema } = attribute;
          yield {
            hasFabricSensitiveData: attribute.hasFabricSensitiveData,
            attributeData: { path, dataVersion: version, payload: value, schema }
          };
        } catch (error) {
          const what = `reading ${this.#endpointStructure.resolveAttributeName(path)} from ${exchange.channel.name}`;
          if (!(error instanceof import_types.StatusResponseError)) {
            const wrappedError = new import_general.ImplementationError(`Unhandled error ${what}`);
            wrappedError.cause = error;
            throw wrappedError;
          }
          logger.error(`Error ${what}:`, error.message);
          if (isConcreteAttributePath(requestPath)) {
            yield {
              hasFabricSensitiveData: false,
              attributeStatus: { path, status: { status: error.code } }
            };
          }
        }
      }
    }
    if (eventReportsPayload !== void 0) {
      for (const eventReport of eventReportsPayload) {
        yield eventReport;
      }
    }
  }
  async handleReadRequest(exchange, readRequest, message) {
    const { attributeRequests, eventRequests, isFabricFiltered, interactionModelRevision } = readRequest;
    logger.debug(
      `Received read request from ${exchange.channel.name}: attributes:${attributeRequests?.map((path) => this.#endpointStructure.resolveAttributeName(path)).join(", ") ?? "none"}, events:${eventRequests?.map((path) => this.#endpointStructure.resolveEventName(path)).join(", ") ?? "none"} isFabricFiltered=${isFabricFiltered}`
    );
    if (interactionModelRevision > import_model.Specification.INTERACTION_MODEL_REVISION) {
      logger.debug(
        `Interaction model revision of sender ${interactionModelRevision} is higher than supported ${import_model.Specification.INTERACTION_MODEL_REVISION}.`
      );
    }
    if (attributeRequests === void 0 && eventRequests === void 0) {
      return {
        dataReport: {
          interactionModelRevision: import_model.Specification.INTERACTION_MODEL_REVISION,
          suppressResponse: true
        }
      };
    }
    if (message.packetHeader.sessionType !== import_MessageCodec.SessionType.Unicast) {
      throw new import_types.StatusResponseError(
        "Subscriptions are only allowed on unicast sessions",
        import_types.StatusCode.InvalidAction
      );
    }
    return {
      dataReport: {
        interactionModelRevision: import_model.Specification.INTERACTION_MODEL_REVISION,
        suppressResponse: true
      },
      payload: this.#iterateReadAttributesPaths(
        readRequest,
        await this.#collectEventDataForRead(readRequest, exchange, message),
        exchange,
        message
      )
    };
  }
  readAttribute(_path, attribute, exchange, isFabricFiltered, message, offline = false) {
    return attribute.getWithVersion(exchange.session, isFabricFiltered, offline ? void 0 : message);
  }
  /**
   * Reads the attributes for the given endpoint.
   * This can currently only be used for subscriptions because errors are ignored!
   */
  readEndpointAttributesForSubscription(attributes, exchange, isFabricFiltered, message, offline = false) {
    const result = new Array();
    for (const { path, attribute } of attributes) {
      try {
        const { version, value } = this.readAttribute(
          path,
          attribute,
          exchange,
          isFabricFiltered,
          message,
          offline
        );
        result.push({ path, value, version, attribute });
      } catch (error) {
        if (import_types.StatusResponseError.is(error, import_types.StatusCode.UnsupportedAccess)) {
          logger.warn(
            `Permission denied reading attribute ${this.#endpointStructure.resolveAttributeName(path)}`
          );
        } else {
          logger.warn(
            `Error reading attribute ${this.#endpointStructure.resolveAttributeName(path)}:`,
            error
          );
        }
      }
    }
    return result;
  }
  async readEvent(_path, eventFilters, event, exchange, isFabricFiltered, message) {
    return event.get(exchange.session, isFabricFiltered, message, eventFilters);
  }
  async handleWriteRequest(exchange, { suppressResponse, timedRequest, writeRequests, interactionModelRevision, moreChunkedMessages }, message) {
    const sessionType = message.packetHeader.sessionType;
    logger.debug(
      `Received write request from ${exchange.channel.name}: ${writeRequests.map((req) => this.#endpointStructure.resolveAttributeName(req.path)).join(", ")}, suppressResponse=${suppressResponse}, moreChunkedMessages=${moreChunkedMessages}`
    );
    if (moreChunkedMessages && suppressResponse) {
      throw new import_types.StatusResponseError(
        "MoreChunkedMessages and SuppressResponse cannot be used together in write messages",
        import_types.StatusCode.InvalidAction
      );
    }
    if (interactionModelRevision > import_model.Specification.INTERACTION_MODEL_REVISION) {
      logger.debug(
        `Interaction model revision of sender ${interactionModelRevision} is higher than supported ${import_model.Specification.INTERACTION_MODEL_REVISION}.`
      );
    }
    const receivedWithinTimedInteraction = exchange.hasActiveTimedInteraction();
    if (receivedWithinTimedInteraction && moreChunkedMessages) {
      throw new import_types.StatusResponseError(
        "Write Request action that is part of a Timed Write Interaction SHALL NOT be chunked.",
        import_types.StatusCode.InvalidAction
      );
    }
    if (exchange.hasExpiredTimedInteraction()) {
      exchange.clearTimedInteraction();
      throw new import_types.StatusResponseError(`Timed request window expired. Decline write request.`, import_types.StatusCode.Timeout);
    }
    if (timedRequest !== exchange.hasTimedInteraction()) {
      throw new import_types.StatusResponseError(
        `timedRequest flag of write interaction (${timedRequest}) mismatch with expected timed interaction (${receivedWithinTimedInteraction}).`,
        import_types.StatusCode.TimedRequestMismatch
      );
    }
    if (receivedWithinTimedInteraction) {
      logger.debug(
        `Write request from ${exchange.channel.name} successfully received while timed interaction is running.`
      );
      exchange.clearTimedInteraction();
      if (sessionType !== import_MessageCodec.SessionType.Unicast) {
        throw new import_types.StatusResponseError(
          "Write requests are only allowed on unicast sessions when a timed interaction is running.",
          import_types.StatusCode.InvalidAction
        );
      }
    }
    if (sessionType === import_MessageCodec.SessionType.Group && !suppressResponse) {
      throw new import_types.StatusResponseError(
        "Write requests are only allowed as group casts when suppressResponse=true.",
        import_types.StatusCode.InvalidAction
      );
    }
    const writeData = (0, import_AttributeDataDecoder.expandPathsInAttributeData)(writeRequests, true);
    const writeResults = new Array();
    const attributeListWrites = /* @__PURE__ */ new Set();
    const clusterDataVersionInfo = /* @__PURE__ */ new Map();
    const inaccessiblePaths = /* @__PURE__ */ new Set();
    for (const writeRequest of writeData) {
      const { path: writePath, dataVersion } = writeRequest;
      validateWriteAttributesPath(writePath);
      const attributes = this.#endpointStructure.getAttributes([writePath], true);
      if (attributes.length === 0) {
        if (isConcreteAttributePath(writePath)) {
          const { endpointId, clusterId, attributeId } = writePath;
          try {
            this.#endpointStructure.validateConcreteAttributePath(endpointId, clusterId, attributeId);
            throw new import_types.StatusResponseError(
              `Attribute ${attributeId} is not writable.`,
              import_types.StatusCode.UnsupportedWrite
            );
          } catch (e) {
            import_types.StatusResponseError.accept(e);
            logger.debug(
              `Write from ${exchange.channel.name}: ${this.#endpointStructure.resolveAttributeName(
                writePath
              )} not allowed: Status=${e.code}`
            );
            writeResults.push({ path: writePath, statusCode: e.code });
          }
        } else {
          logger.debug(
            `Write from ${exchange.channel.name}: ${this.#endpointStructure.resolveAttributeName(
              writePath
            )}: ignore non-existing (wildcard) attribute`
          );
        }
        continue;
      }
      if (attributes.length === 1 && isConcreteAttributePath(writePath)) {
        const { endpointId, clusterId } = writePath;
        const { attribute } = attributes[0];
        if (attribute.requiresTimedInteraction && !receivedWithinTimedInteraction) {
          logger.debug(`This write requires a timed interaction which is not initialized.`);
          writeResults.push({ path: writePath, statusCode: import_types.StatusCode.NeedsTimedInteraction });
          continue;
        }
        if (attribute instanceof import_AttributeServer.FabricScopedAttributeServer && (!exchange.session.isSecure || !exchange.session.fabric)) {
          logger.debug(`This write requires a secure session with a fabric assigned which is missing.`);
          writeResults.push({ path: writePath, statusCode: import_types.StatusCode.UnsupportedAccess });
          continue;
        }
        if (dataVersion !== void 0) {
          const datasource = this.#endpointStructure.getClusterServer(endpointId, clusterId)?.datasource;
          const { nodeId } = writePath;
          const clusterKey = clusterPathToId({ nodeId, endpointId, clusterId });
          const currentDataVersion = clusterDataVersionInfo.get(clusterKey) ?? datasource?.version;
          if (currentDataVersion !== void 0) {
            if (dataVersion !== currentDataVersion) {
              logger.debug(
                `This write requires a specific data version (${dataVersion}) which do not match the current cluster data version (${currentDataVersion}).`
              );
              writeResults.push({ path: writePath, statusCode: import_types.StatusCode.DataVersionMismatch });
              continue;
            }
            clusterDataVersionInfo.set(clusterKey, currentDataVersion);
          }
        }
      }
      for (const { path, attribute } of attributes) {
        const { schema, defaultValue } = attribute;
        const pathId = attributePathToId(path);
        try {
          if (!(attribute instanceof import_AttributeServer.AttributeServer) && !(attribute instanceof import_AttributeServer.FabricScopedAttributeServer)) {
            throw new import_types.StatusResponseError(
              "Fixed attributes cannot be written",
              import_types.StatusCode.UnsupportedWrite
            );
          }
          if (inaccessiblePaths.has(pathId)) {
            logger.debug(`This write is not allowed due to previous access denied.`);
            continue;
          }
          const { endpointId } = path;
          const { listIndex } = writePath;
          const value = listIndex === void 0 ? (0, import_AttributeDataDecoder.decodeAttributeValueWithSchema)(schema, [writeRequest], defaultValue) : (0, import_AttributeDataDecoder.decodeListAttributeValueWithSchema)(
            schema,
            [writeRequest],
            this.readAttribute(path, attribute, exchange, true, message).value ?? defaultValue
          );
          logger.debug(
            `Handle write request from ${exchange.channel.name} resolved to: ${this.#endpointStructure.resolveAttributeName(path)}=${import_general.Diagnostic.json(
              value
            )} (listIndex=${listIndex}, for-version=${dataVersion})`
          );
          if (attribute.requiresTimedInteraction && !receivedWithinTimedInteraction) {
            logger.debug(`This write requires a timed interaction which is not initialized.`);
            throw new import_types.StatusResponseError(
              "This write requires a timed interaction which is not initialized.",
              import_types.StatusCode.NeedsTimedInteraction
            );
          }
          await this.writeAttribute(
            path,
            attribute,
            value,
            exchange,
            message,
            this.#endpointStructure.getEndpoint(endpointId),
            receivedWithinTimedInteraction,
            schema instanceof import_types.ArraySchema
          );
          if (schema instanceof import_types.ArraySchema && !attributeListWrites.has(attribute)) {
            attributeListWrites.add(attribute);
          }
        } catch (error) {
          if (import_types.StatusResponseError.is(error, import_types.StatusCode.UnsupportedAccess)) {
            inaccessiblePaths.add(pathId);
          }
          if (attributes.length === 1 && isConcreteAttributePath(writePath)) {
            logger.error(
              `Error while handling write request from ${exchange.channel.name} to ${this.#endpointStructure.resolveAttributeName(path)}:`,
              error instanceof import_types.StatusResponseError ? error.message : error
            );
            if (error instanceof import_types.StatusResponseError) {
              writeResults.push({ path, statusCode: error.code, clusterStatusCode: error.clusterCode });
              continue;
            }
            writeResults.push({ path, statusCode: import_types.StatusCode.ConstraintError });
            continue;
          } else {
            logger.debug(
              `While handling write request from ${exchange.channel.name} to ${this.#endpointStructure.resolveAttributeName(path)} ignored: ${error.message}`
            );
          }
        }
        writeResults.push({ path, statusCode: import_types.StatusCode.Success });
      }
    }
    const errorResults = writeResults.filter(({ statusCode }) => statusCode !== import_types.StatusCode.Success);
    logger.debug(
      `Write request from ${exchange.channel.name} done ${errorResults.length ? `with following errors: ${errorResults.map(
        ({ path, statusCode }) => `${this.#endpointStructure.resolveAttributeName(path)}=${import_general.Diagnostic.json(statusCode)}`
      ).join(", ")}` : "without errors"}`
    );
    const response = {
      interactionModelRevision: import_model.Specification.INTERACTION_MODEL_REVISION,
      writeResponses: writeResults.map(({ path, statusCode, clusterStatusCode }) => ({
        path,
        status: { status: statusCode, clusterStatus: clusterStatusCode }
      }))
    };
    for (const attribute of attributeListWrites.values()) {
      try {
        attribute.triggerDelayedChangeEvents();
      } catch (error) {
        logger.error(
          `Ignored Error while writing attribute from ${exchange.channel.name} to ${attribute.name}:`,
          error
        );
      }
    }
    return response;
  }
  async writeAttribute(_path, attribute, value, exchange, message, _endpoint, _receivedWithinTimedInteraction, isListWrite = false) {
    attribute.set(value, exchange.session, message, isListWrite);
  }
  async handleSubscribeRequest(exchange, request, messenger, message) {
    const {
      minIntervalFloorSeconds,
      maxIntervalCeilingSeconds,
      attributeRequests,
      dataVersionFilters,
      eventRequests,
      eventFilters,
      keepSubscriptions,
      isFabricFiltered,
      interactionModelRevision
    } = request;
    logger.debug(
      `Received subscribe request from ${exchange.channel.name} (keepSubscriptions=${keepSubscriptions}, isFabricFiltered=${isFabricFiltered})`
    );
    if (interactionModelRevision > import_model.Specification.INTERACTION_MODEL_REVISION) {
      logger.debug(
        `Interaction model revision of sender ${interactionModelRevision} is higher than supported ${import_model.Specification.INTERACTION_MODEL_REVISION}.`
      );
    }
    if (message.packetHeader.sessionType !== import_MessageCodec.SessionType.Unicast) {
      throw new import_types.StatusResponseError(
        "Subscriptions are only allowed on unicast sessions",
        import_types.StatusCode.InvalidAction
      );
    }
    (0, import_SecureSession.assertSecureSession)(exchange.session, "Subscriptions are only implemented on secure sessions");
    const session = exchange.session;
    const fabric = session.fabric;
    if (fabric === void 0)
      throw new import_types.StatusResponseError(
        "Subscriptions are only implemented after a fabric has been assigned",
        import_types.StatusCode.InvalidAction
      );
    if (!keepSubscriptions) {
      const clearedCount = await this.#context.sessions.clearSubscriptionsForNode(
        fabric.addressOf(session.peerNodeId),
        true
      );
      if (clearedCount > 0) {
        logger.debug(
          `Cleared ${clearedCount} subscriptions for Subscriber node ${session.peerNodeId} because keepSubscriptions=false`
        );
      }
    }
    if ((!Array.isArray(attributeRequests) || attributeRequests.length === 0) && (!Array.isArray(eventRequests) || eventRequests.length === 0)) {
      throw new import_types.StatusResponseError("No attributes or events requested", import_types.StatusCode.InvalidAction);
    }
    logger.debug(
      `Subscribe to attributes:${attributeRequests?.map((path) => this.#endpointStructure.resolveAttributeName(path)).join(", ") ?? "none"}, events:${eventRequests?.map((path) => this.#endpointStructure.resolveEventName(path)).join(", ") ?? "none"}`
    );
    if (dataVersionFilters !== void 0 && dataVersionFilters.length > 0) {
      logger.debug(
        `DataVersionFilters: ${dataVersionFilters.map(
          ({ path: { nodeId, endpointId, clusterId }, dataVersion }) => `${clusterPathToId({ nodeId, endpointId, clusterId })}=${dataVersion}`
        ).join(", ")}`
      );
    }
    if (eventFilters !== void 0 && eventFilters.length > 0)
      logger.debug(
        `Event filters: ${eventFilters.map((filter) => `${filter.nodeId}/${filter.eventMin}`).join(", ")}`
      );
    attributeRequests?.forEach((path) => validateReadAttributesPath(path));
    eventRequests?.forEach((path) => validateReadEventPath(path));
    if (minIntervalFloorSeconds < 0) {
      throw new import_types.StatusResponseError(
        "minIntervalFloorSeconds should be greater or equal to 0",
        import_types.StatusCode.InvalidAction
      );
    }
    if (maxIntervalCeilingSeconds < 0) {
      throw new import_types.StatusResponseError(
        "maxIntervalCeilingSeconds should be greater or equal to 1",
        import_types.StatusCode.InvalidAction
      );
    }
    if (maxIntervalCeilingSeconds < minIntervalFloorSeconds) {
      throw new import_types.StatusResponseError(
        "maxIntervalCeilingSeconds should be greater or equal to minIntervalFloorSeconds",
        import_types.StatusCode.InvalidAction
      );
    }
    if (this.#nextSubscriptionId === 4294967295) this.#nextSubscriptionId = 0;
    const subscriptionId = this.#nextSubscriptionId++;
    this.#subscriptionEstablishmentStarted.emit(session.peerAddress);
    let subscription;
    try {
      subscription = await this.#establishSubscription(
        subscriptionId,
        request,
        messenger,
        session,
        exchange,
        message
      );
    } catch (error) {
      logger.error(
        `Subscription ${subscriptionId} for Session ${session.id}: Error while sending initial data reports`,
        error instanceof import_general.MatterError ? error.message : error
      );
      if (error instanceof import_types.StatusResponseError && !(error instanceof import_types.ReceivedStatusResponseError)) {
        logger.info(`Sending status response ${error.code} for interaction error: ${error.message}`);
        await messenger.sendStatus(error.code, {
          logContext: {
            for: "I/SubscriptionSeed-Status"
          }
        });
      }
      await messenger.close();
      return;
    }
    const maxInterval = subscription.maxInterval;
    await messenger.send(
      import_InteractionMessenger.MessageType.SubscribeResponse,
      import_types.TlvSubscribeResponse.encode({
        subscriptionId,
        maxInterval,
        interactionModelRevision: import_model.Specification.INTERACTION_MODEL_REVISION
      }),
      {
        logContext: {
          subId: subscriptionId,
          maxInterval
        }
      }
    );
    subscription.activate();
  }
  async #establishSubscription(id, {
    minIntervalFloorSeconds,
    maxIntervalCeilingSeconds,
    attributeRequests,
    dataVersionFilters,
    eventRequests,
    eventFilters,
    isFabricFiltered
  }, messenger, session, exchange, message) {
    const context = {
      session,
      structure: this.#endpointStructure,
      readAttribute: (path, attribute, offline) => this.readAttribute(path, attribute, exchange, isFabricFiltered, message, offline),
      readEndpointAttributesForSubscription: (attributes) => this.readEndpointAttributesForSubscription(attributes, exchange, isFabricFiltered, message),
      readEvent: (path, event, eventFilters2) => this.readEvent(path, eventFilters2, event, exchange, isFabricFiltered, message),
      initiateExchange: (address, protocolId) => this.#context.initiateExchange(address, protocolId)
    };
    const subscription = new import_ServerSubscription.ServerSubscription({
      id,
      context,
      criteria: {
        attributeRequests,
        dataVersionFilters,
        eventRequests,
        eventFilters,
        isFabricFiltered
      },
      minIntervalFloorSeconds,
      maxIntervalCeilingSeconds,
      subscriptionOptions: this.#subscriptionConfig
    });
    try {
      await subscription.sendInitialReport(messenger);
    } catch (error) {
      await subscription.close();
      throw error;
    }
    logger.info(
      `Successfully created subscription ${id} for Session ${session.id} to ${session.peerAddress}. Updates: ${minIntervalFloorSeconds} - ${maxIntervalCeilingSeconds} => ${subscription.maxInterval} seconds (sendInterval = ${subscription.sendInterval} seconds)`
    );
    return subscription;
  }
  async establishFormerSubscription({
    subscriptionId,
    attributeRequests,
    eventRequests,
    isFabricFiltered,
    minIntervalFloorSeconds,
    maxIntervalCeilingSeconds,
    maxInterval,
    sendInterval
  }, session) {
    const exchange = this.#context.initiateExchange(session.peerAddress, import_types.INTERACTION_PROTOCOL_ID);
    const message = {};
    logger.debug(
      `Send DataReports to re-establish subscription ${subscriptionId} to `,
      import_general.Diagnostic.dict({ isFabricFiltered, maxInterval, sendInterval })
    );
    const context = {
      session,
      structure: this.#endpointStructure,
      readAttribute: (path, attribute, offline) => this.readAttribute(path, attribute, exchange, isFabricFiltered, message, offline),
      readEndpointAttributesForSubscription: (attributes) => this.readEndpointAttributesForSubscription(attributes, exchange, isFabricFiltered, message),
      readEvent: (path, event, eventFilters) => this.readEvent(path, eventFilters, event, exchange, isFabricFiltered, message),
      initiateExchange: (address, protocolId) => this.#context.initiateExchange(address, protocolId)
    };
    const subscription = new import_ServerSubscription.ServerSubscription({
      id: subscriptionId,
      context,
      minIntervalFloorSeconds,
      maxIntervalCeilingSeconds,
      criteria: {
        attributeRequests,
        eventRequests,
        isFabricFiltered
      },
      subscriptionOptions: this.#subscriptionConfig,
      useAsMaxInterval: maxInterval,
      useAsSendInterval: sendInterval
    });
    try {
      await subscription.sendInitialReport(new import_InteractionMessenger.InteractionServerMessenger(exchange));
      subscription.activate();
      logger.info(
        `Successfully re-established subscription ${subscriptionId} for Session ${session.id} to ${session.peerAddress}. Updates: ${minIntervalFloorSeconds} - ${maxIntervalCeilingSeconds} => ${subscription.maxInterval} seconds (sendInterval = ${subscription.sendInterval} seconds)`
      );
    } catch (error) {
      await subscription.close();
      throw error;
    }
    return subscription;
  }
  async handleInvokeRequest(exchange, { invokeRequests, timedRequest, suppressResponse, interactionModelRevision }, messenger, message) {
    logger.debug(
      `Received invoke request from ${exchange.channel.name}${invokeRequests.length > 0 ? ` with ${invokeRequests.length} commands` : ""}: ${invokeRequests.map(
        ({ commandPath: { endpointId, clusterId, commandId } }) => this.#endpointStructure.resolveCommandName({ endpointId, clusterId, commandId })
      ).join(", ")}, suppressResponse=${suppressResponse}`
    );
    if (interactionModelRevision > import_model.Specification.INTERACTION_MODEL_REVISION) {
      logger.debug(
        `Interaction model revision of sender ${interactionModelRevision} is higher than supported ${import_model.Specification.INTERACTION_MODEL_REVISION}.`
      );
    }
    const receivedWithinTimedInteraction = exchange.hasActiveTimedInteraction();
    if (exchange.hasExpiredTimedInteraction()) {
      exchange.clearTimedInteraction();
      throw new import_types.StatusResponseError(`Timed request window expired. Decline invoke request.`, import_types.StatusCode.Timeout);
    }
    if (timedRequest !== exchange.hasTimedInteraction()) {
      throw new import_types.StatusResponseError(
        `timedRequest flag of invoke interaction (${timedRequest}) mismatch with expected timed interaction (${receivedWithinTimedInteraction}).`,
        import_types.StatusCode.TimedRequestMismatch
      );
    }
    if (receivedWithinTimedInteraction) {
      logger.debug(`Invoke request from ${exchange.channel.name} received while timed interaction is running.`);
      exchange.clearTimedInteraction();
      if (message.packetHeader.sessionType !== import_MessageCodec.SessionType.Unicast) {
        throw new import_types.StatusResponseError(
          "Invoke requests are only allowed on unicast sessions when a timed interaction is running.",
          import_types.StatusCode.InvalidAction
        );
      }
    }
    if (invokeRequests.length > this.#maxPathsPerInvoke) {
      throw new import_types.StatusResponseError(
        `Only ${this.#maxPathsPerInvoke} invoke requests are supported in one message. This message contains ${invokeRequests.length}`,
        import_types.StatusCode.InvalidAction
      );
    }
    invokeRequests.forEach(({ commandPath }) => validateCommandPath(commandPath));
    if (invokeRequests.length > 1) {
      const pathsUsed = /* @__PURE__ */ new Set();
      const commandRefsUsed = /* @__PURE__ */ new Set();
      invokeRequests.forEach(({ commandPath, commandRef }) => {
        if (!isConcreteCommandPath(commandPath)) {
          throw new import_types.StatusResponseError("Illegal wildcard path in batch invoke", import_types.StatusCode.InvalidAction);
        }
        const commandPathId = commandPathToId(commandPath);
        if (pathsUsed.has(commandPathId)) {
          throw new import_types.StatusResponseError(
            `Duplicate command path (${commandPathId}) in batch invoke`,
            import_types.StatusCode.InvalidAction
          );
        }
        if (commandRef === void 0) {
          throw new import_types.StatusResponseError(
            `Command reference missing in batch invoke of ${commandPathId}`,
            import_types.StatusCode.InvalidAction
          );
        }
        if (commandRefsUsed.has(commandRef)) {
          throw new import_types.StatusResponseError(
            `Duplicate command reference ${commandRef} in invoke of ${commandPathId}`,
            import_types.StatusCode.InvalidAction
          );
        }
        pathsUsed.add(commandPathId);
        commandRefsUsed.add(commandRef);
      });
    }
    const isGroupSession = message.packetHeader.sessionType === import_MessageCodec.SessionType.Group;
    const invokeResponseMessage = {
      suppressResponse: false,
      // Deprecated but must be present
      interactionModelRevision: import_model.Specification.INTERACTION_MODEL_REVISION,
      invokeResponses: [],
      moreChunkedMessages: invokeRequests.length > 1
      // Assume for now we have multiple responses when having multiple invokes
    };
    const emptyInvokeResponseBytes = import_types.TlvInvokeResponseForSend.encode(invokeResponseMessage);
    let messageSize = emptyInvokeResponseBytes.length;
    let invokeResultsProcessed = 0;
    const processResponseResult = async (invokeResponse) => {
      invokeResultsProcessed++;
      if (isGroupSession) {
        return;
      }
      const encodedInvokeResponse = import_types.TlvInvokeResponseData.encodeTlv(invokeResponse);
      const invokeResponseBytes = import_types.TlvAny.getEncodedByteLength(encodedInvokeResponse);
      if (messageSize + invokeResponseBytes > exchange.maxPayloadSize || invokeResultsProcessed === invokeRequests.length) {
        let lastMessageProcessed = false;
        if (messageSize + invokeResponseBytes <= exchange.maxPayloadSize) {
          invokeResponseMessage.invokeResponses.push(encodedInvokeResponse);
          lastMessageProcessed = true;
        }
        if (invokeResponseMessage.invokeResponses.length > 0) {
          if (invokeRequests.length > 1) {
            logger.debug(
              `Send ${lastMessageProcessed ? "final " : ""}invoke response for ${invokeResponseMessage.invokeResponses} commands`
            );
          }
          const moreChunkedMessages = lastMessageProcessed ? void 0 : true;
          await messenger.send(
            import_InteractionMessenger.MessageType.InvokeResponse,
            import_types.TlvInvokeResponseForSend.encode({
              ...invokeResponseMessage,
              moreChunkedMessages
            }),
            {
              logContext: {
                invokeMsgFlags: import_general.Diagnostic.asFlags({
                  suppressResponse,
                  moreChunkedMessages
                })
              }
            }
          );
          invokeResponseMessage.invokeResponses = [];
          messageSize = emptyInvokeResponseBytes.length;
        }
        if (!lastMessageProcessed) {
          invokeResultsProcessed--;
          return processResponseResult(invokeResponse);
        }
      } else {
        invokeResponseMessage.invokeResponses.push(encodedInvokeResponse);
        messageSize += invokeResponseBytes;
      }
    };
    for (const { commandPath, commandFields, commandRef } of invokeRequests) {
      const commands = this.#endpointStructure.getCommands([commandPath]);
      if (commands.length === 0) {
        if (isConcreteCommandPath(commandPath)) {
          const { endpointId, clusterId, commandId } = commandPath;
          let result;
          try {
            this.#endpointStructure.validateConcreteCommandPath(endpointId, clusterId, commandId);
            throw new import_general.InternalError(
              "validateConcreteCommandPath should throw StatusResponseError but did not."
            );
          } catch (e) {
            import_types.StatusResponseError.accept(e);
            logger.debug(
              `Invoke from ${exchange.channel.name}: ${this.#endpointStructure.resolveCommandName(
                commandPath
              )} unsupported path: Status=${e.code}`
            );
            result = { status: { commandPath, status: { status: e.code }, commandRef } };
          }
          await processResponseResult(result);
        } else {
          logger.debug(
            `Invoke from ${exchange.channel.name}: ${this.#endpointStructure.resolveCommandName(
              commandPath
            )} ignore non-existing command`
          );
        }
        continue;
      }
      const isConcretePath = isConcreteCommandPath(commandPath);
      for (const { command, path } of commands) {
        const { endpointId, clusterId, commandId } = path;
        if (endpointId === void 0) {
          logger.error(
            `Invoke from ${exchange.channel.name}: ${this.#endpointStructure.resolveCommandName(
              path
            )} invalid path because empty endpoint!`
          );
          if (isConcretePath) {
            await processResponseResult({
              status: {
                commandPath: path,
                status: { status: import_types.StatusCode.UnsupportedEndpoint },
                commandRef
              }
            });
          }
          continue;
        }
        const endpoint = this.#endpointStructure.getEndpoint(endpointId);
        if (endpoint === void 0) {
          logger.error(
            `Invoke from ${exchange.channel.name}: ${this.#endpointStructure.resolveCommandName(
              path
            )} invalid path because endpoint not found!`
          );
          if (isConcretePath) {
            await processResponseResult({
              status: {
                commandPath: path,
                status: { status: import_types.StatusCode.UnsupportedEndpoint },
                commandRef
              }
            });
          }
          continue;
        }
        if (command.requiresTimedInteraction && !receivedWithinTimedInteraction) {
          logger.debug(`This invoke requires a timed interaction which is not initialized.`);
          if (isConcretePath) {
            await processResponseResult({
              status: {
                commandPath: path,
                status: { status: import_types.StatusCode.NeedsTimedInteraction },
                commandRef
              }
            });
          }
          continue;
        }
        if (getMatterModelClusterCommand(clusterId, commandId)?.fabricScoped && (!exchange.session.isSecure || !exchange.session.fabric)) {
          logger.debug(`This invoke requires a secure session with a fabric assigned which is missing.`);
          if (isConcretePath) {
            await processResponseResult({
              status: { commandPath: path, status: { status: import_types.StatusCode.UnsupportedAccess }, commandRef }
            });
          }
          continue;
        }
        let result;
        try {
          result = await this.invokeCommand(
            path,
            command,
            exchange,
            commandFields ?? import_types.TlvNoArguments.encodeTlv(commandFields),
            message,
            endpoint,
            receivedWithinTimedInteraction
          );
        } catch (e) {
          import_types.StatusResponseError.accept(e);
          let errorCode = e.code;
          const errorLogText = `Error ${import_general.Diagnostic.hex(errorCode)}${e.clusterCode !== void 0 ? `/${import_general.Diagnostic.hex(e.clusterCode)}` : ""} while invoking command: ${e.message}`;
          if (e instanceof import_types.ValidationError) {
            logger.info(
              `Validation-${errorLogText}${e.fieldName !== void 0 ? ` in field ${e.fieldName}` : ""}`
            );
            if (errorCode === import_types.StatusCode.InvalidAction) {
              errorCode = import_types.StatusCode.InvalidCommand;
            }
          } else {
            logger.info(errorLogText);
          }
          result = {
            code: errorCode,
            clusterCode: e.clusterCode,
            responseId: command.responseId,
            response: import_types.TlvNoResponse.encodeTlv()
          };
        }
        const { code, clusterCode, responseId, response } = result;
        if (response.length === 0) {
          await processResponseResult({
            status: { commandPath: path, status: { status: code, clusterStatus: clusterCode }, commandRef }
          });
        } else {
          await processResponseResult({
            command: {
              commandPath: { ...path, commandId: responseId },
              commandFields: response,
              commandRef
            }
          });
        }
      }
    }
  }
  async invokeCommand(_path, command, exchange, commandFields, message, endpoint, _receivedWithinTimedInteraction = false) {
    return command.invoke(exchange.session, commandFields, message, endpoint);
  }
  handleTimedRequest(exchange, { timeout, interactionModelRevision }) {
    logger.debug(`Received timed request (${timeout}ms) from ${exchange.channel.name}`);
    if (interactionModelRevision > import_model.Specification.INTERACTION_MODEL_REVISION) {
      logger.debug(
        `Interaction model revision of sender ${interactionModelRevision} is higher than supported ${import_model.Specification.INTERACTION_MODEL_REVISION}.`
      );
    }
    exchange.startTimedInteraction(timeout);
  }
  async close() {
    this.#isClosing = true;
  }
  get #endpointStructure() {
    return this.#context.structure;
  }
}
//# sourceMappingURL=InteractionServer.js.map
