"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var SubscriptionClient_exports = {};
__export(SubscriptionClient_exports, {
  SubscriptionClient: () => SubscriptionClient
});
module.exports = __toCommonJS(SubscriptionClient_exports);
var import_general = require("@matter/general");
var import_types = require("@matter/types");
var import_InteractionMessenger = require("./InteractionMessenger.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("SubscriptionClient");
class SubscriptionClient {
  #listeners = /* @__PURE__ */ new Map();
  #timeouts = /* @__PURE__ */ new Map();
  constructor() {
  }
  static [import_general.Environmental.create](env) {
    const client = new SubscriptionClient();
    env.set(SubscriptionClient, client);
    return client;
  }
  id = import_types.INTERACTION_PROTOCOL_ID;
  /**
   * Register a subscription.
   */
  add(subscription) {
    const { id, onData, onTimeout } = subscription;
    this.#listeners.set(id, onData);
    if (onTimeout) {
      let timer = this.#timeouts.get(id);
      if (timer !== void 0) {
        timer.stop();
        this.#timeouts.delete(id);
      }
      const maxIntervalMs = subscription.maxIntervalS * 1e3 + subscription.maximumPeerResponseTime;
      timer = import_general.Time.getTimer("Subscription timeout", maxIntervalMs, () => {
        logger.info(`Subscription ${id} timed out after ${maxIntervalMs}ms`);
        this.delete(id);
        onTimeout();
      }).start();
      this.#timeouts.set(id, timer);
    }
  }
  /**
   * Unregister a subscription.
   */
  delete(id) {
    this.#listeners.delete(id);
    const timer = this.#timeouts.get(id);
    if (timer !== void 0) {
      timer.stop();
      this.#timeouts.delete(id);
    }
  }
  async onNewExchange(exchange) {
    const messenger = new import_InteractionMessenger.IncomingInteractionClientMessenger(exchange);
    let dataReport;
    try {
      dataReport = await messenger.readAggregateDataReport([...this.#listeners.keys()]);
    } finally {
      messenger.close().catch((error) => logger.info("Error closing client messenger", error));
    }
    const subscriptionId = dataReport.subscriptionId;
    const listener = this.#listeners.get(subscriptionId);
    const timer = this.#timeouts.get(subscriptionId);
    if (timer !== void 0) {
      timer.stop().start();
    }
    await listener?.(dataReport);
  }
  async close() {
    this.#listeners.clear();
    this.#timeouts.forEach((timer) => timer.stop());
    this.#timeouts.clear();
  }
}
//# sourceMappingURL=SubscriptionClient.js.map
