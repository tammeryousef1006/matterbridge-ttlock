"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var MdnsBroadcaster_exports = {};
__export(MdnsBroadcaster_exports, {
  MdnsBroadcaster: () => MdnsBroadcaster
});
module.exports = __toCommonJS(MdnsBroadcaster_exports);
var import_general = require("#general");
var import_types = require("#types");
var import_InstanceBroadcaster = require("../common/InstanceBroadcaster.js");
var import_Session = require("../session/Session.js");
var import_MdnsConsts = require("./MdnsConsts.js");
var import_MdnsInstanceBroadcaster = require("./MdnsInstanceBroadcaster.js");
var import_MdnsServer = require("./MdnsServer.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("MdnsBroadcaster");
const DEFAULT_PAIRING_HINT = {
  powerCycle: true,
  deviceManual: true
};
class MdnsBroadcaster {
  #activeCommissioningAnnouncements = /* @__PURE__ */ new Set();
  #activeOperationalAnnouncements = /* @__PURE__ */ new Map();
  #network;
  #mdnsServer;
  #enableIpv4;
  #instances = new import_general.BasicSet();
  static async create(network, options) {
    const { enableIpv4, multicastInterface } = options ?? {};
    return new MdnsBroadcaster(
      network,
      await import_MdnsServer.MdnsServer.create(network, { enableIpv4, netInterface: multicastInterface }),
      enableIpv4
    );
  }
  constructor(network, mdnsServer, enableIpv4) {
    this.#network = network;
    this.#mdnsServer = mdnsServer;
    this.#enableIpv4 = enableIpv4;
  }
  createInstanceBroadcaster(port) {
    const instance = new import_MdnsInstanceBroadcaster.MdnsInstanceBroadcaster(port, this, () => {
      this.#instances.delete(instance);
    });
    this.#instances.add(instance);
    return instance;
  }
  #validateCommissioningData(data) {
    const { sessionIdleInterval, sessionActiveInterval, sessionActiveThreshold } = data;
    if (sessionIdleInterval !== void 0 && sessionIdleInterval > 36e5) {
      throw new import_general.ImplementationError("Session Idle Interval must be less than 1 hour");
    }
    if (sessionActiveInterval !== void 0 && sessionActiveInterval > 36e5) {
      throw new import_general.ImplementationError("Session Active Interval must be less than 1 hour");
    }
    if (sessionActiveThreshold !== void 0 && sessionActiveThreshold > 65535) {
      throw new import_general.ImplementationError("Session Active Threshold must be less than 65535 seconds");
    }
  }
  #validatePairingInstructions(pairingHint, pairingInstructions) {
    const needsInstructions = [
      "customInstruction",
      "pressRestButtonForNumberOfSeconds",
      "pressResetButtonUntilLightBlinks",
      "pressResetButtonForNumberOfSecondsWithApplicationOfPower",
      "pressResetButtonUntilLightBlinksWithApplicationOfPower",
      "pressResetButtonNumberOfTimes",
      "pressSetupButtonForNumberOfSeconds",
      "pressSetupButtonUntilLightBlinks",
      "pressSetupButtonForNumberOfSecondsWithApplicationOfPower",
      "pressSetupButtonUntilLightBlinksWithApplicationOfPower",
      "pressSetupButtonNumberOfTimes"
    ].find((hint) => pairingHint[hint] === true);
    if (needsInstructions && pairingInstructions.length === 0) {
      throw new import_general.ImplementationError(
        `Pairing instructions required for Pairing Hint of type "${needsInstructions}"`
      );
    }
  }
  #getIpRecords(hostname, ips) {
    const records = new Array();
    ips.forEach((ip) => {
      if ((0, import_general.isIPv6)(ip)) {
        records.push((0, import_general.AAAARecord)(hostname, ip));
      } else if ((0, import_general.isIPv4)(ip)) {
        if (this.#enableIpv4) {
          records.push((0, import_general.ARecord)(hostname, ip));
        }
      } else {
        logger.warn(`Unknown IP address type: ${ip}`);
      }
    });
    return records;
  }
  /** Set the Broadcaster data to announce a device ready for commissioning in a special mode */
  async setCommissionMode(announcedNetPort, mode, commissioningModeData) {
    this.#validateCommissioningData(commissioningModeData);
    const {
      name: deviceName,
      deviceType,
      vendorId,
      productId,
      discriminator,
      sessionIdleInterval = import_Session.SESSION_IDLE_INTERVAL_MS,
      sessionActiveInterval = import_Session.SESSION_ACTIVE_INTERVAL_MS,
      sessionActiveThreshold = import_Session.SESSION_ACTIVE_THRESHOLD_MS,
      pairingHint = DEFAULT_PAIRING_HINT,
      pairingInstructions = ""
    } = commissioningModeData;
    this.#validatePairingInstructions(pairingHint, pairingInstructions);
    await this.expireCommissioningAnnouncement(announcedNetPort);
    logger.debug(
      `Announce commissioning mode ${mode} ${deviceName} ${deviceType} ${vendorId} ${productId} ${discriminator} ${announcedNetPort}`
    );
    this.#activeCommissioningAnnouncements.add(announcedNetPort);
    const shortDiscriminator = discriminator >> 8 & 15;
    const instanceId = import_general.Bytes.toHex(import_general.Crypto.getRandomData(8)).toUpperCase();
    const vendorQname = (0, import_MdnsConsts.getVendorQname)(vendorId);
    const deviceTypeQname = (0, import_MdnsConsts.getDeviceTypeQname)(deviceType);
    const shortDiscriminatorQname = (0, import_MdnsConsts.getShortDiscriminatorQname)(shortDiscriminator);
    const longDiscriminatorQname = (0, import_MdnsConsts.getLongDiscriminatorQname)(discriminator);
    const commissionModeQname = (0, import_MdnsConsts.getCommissioningModeQname)();
    const deviceQname = (0, import_MdnsConsts.getDeviceInstanceQname)(instanceId);
    await this.#mdnsServer.setRecordsGenerator(
      announcedNetPort,
      import_MdnsServer.AnnouncementType.Commissionable,
      async (netInterface) => {
        const ipMac = await this.#network.getIpMac(netInterface);
        if (ipMac === void 0) return [];
        const { mac, ipV4, ipV6 } = ipMac;
        const hostname = mac.replace(/:/g, "").toUpperCase() + "0000.local";
        logger.debug(
          "Announcement Generator: Commission mode ",
          import_general.Diagnostic.dict({
            mode,
            qname: deviceQname,
            port: announcedNetPort,
            interface: netInterface
          })
        );
        const records = [
          (0, import_general.PtrRecord)(import_MdnsConsts.SERVICE_DISCOVERY_QNAME, import_MdnsConsts.MATTER_COMMISSION_SERVICE_QNAME),
          (0, import_general.PtrRecord)(import_MdnsConsts.SERVICE_DISCOVERY_QNAME, vendorQname),
          (0, import_general.PtrRecord)(import_MdnsConsts.SERVICE_DISCOVERY_QNAME, deviceTypeQname),
          (0, import_general.PtrRecord)(import_MdnsConsts.SERVICE_DISCOVERY_QNAME, shortDiscriminatorQname),
          (0, import_general.PtrRecord)(import_MdnsConsts.SERVICE_DISCOVERY_QNAME, longDiscriminatorQname),
          (0, import_general.PtrRecord)(import_MdnsConsts.SERVICE_DISCOVERY_QNAME, commissionModeQname),
          (0, import_general.PtrRecord)(import_MdnsConsts.MATTER_COMMISSION_SERVICE_QNAME, deviceQname),
          (0, import_general.PtrRecord)(vendorQname, deviceQname),
          (0, import_general.PtrRecord)(deviceTypeQname, deviceQname),
          (0, import_general.PtrRecord)(shortDiscriminatorQname, deviceQname),
          (0, import_general.PtrRecord)(longDiscriminatorQname, deviceQname),
          (0, import_general.PtrRecord)(commissionModeQname, deviceQname),
          (0, import_general.SrvRecord)(deviceQname, { priority: 0, weight: 0, port: announcedNetPort, target: hostname }),
          (0, import_general.TxtRecord)(deviceQname, [
            `VP=${vendorId}+${productId}`,
            `DT=${deviceType}`,
            `DN=${deviceName}`,
            `SII=${sessionIdleInterval}`,
            `SAI=${sessionActiveInterval}`,
            `SAT=${sessionActiveThreshold}`,
            //`T=${TCP_SUPPORTED}` /* TODO TCP not supported */,
            `D=${discriminator}`,
            `CM=${mode}`,
            `PH=${import_InstanceBroadcaster.PairingHintBitmapSchema.encode(pairingHint)}`,
            `PI=${pairingInstructions}`
            //`ICD=${ICD_SUPPORTED}` /* ICD not supported */,
          ])
        ];
        records.push(...this.#getIpRecords(hostname, [...ipV6, ...ipV4]));
        return records;
      }
    );
  }
  /** Set the Broadcaster Data to announce a device for operative discovery (aka "already paired") */
  async setFabrics(announcedNetPort, fabrics, {
    sessionIdleInterval = import_Session.SESSION_IDLE_INTERVAL_MS,
    sessionActiveInterval = import_Session.SESSION_ACTIVE_INTERVAL_MS,
    sessionActiveThreshold = import_Session.SESSION_ACTIVE_THRESHOLD_MS
  } = {}) {
    const currentOperationalFabrics = this.#activeOperationalAnnouncements.get(announcedNetPort);
    this.#activeOperationalAnnouncements.set(
      announcedNetPort,
      fabrics.map((f) => ({
        fabricIndex: f.fabricIndex,
        forInstance: (0, import_MdnsConsts.getDeviceMatterQname)(
          import_general.Bytes.toHex(f.operationalId).toUpperCase(),
          import_types.NodeId.toHexString(f.nodeId)
        )
      }))
    );
    const expires = new Array();
    if (currentOperationalFabrics !== void 0) {
      const fabricIndexesSet = new Set(fabrics.map((f) => f.fabricIndex));
      for (const { fabricIndex, forInstance } of currentOperationalFabrics) {
        if (!fabricIndexesSet.has(fabricIndex)) {
          expires.push(
            this.#mdnsServer.expireAnnouncements({
              announcedNetPort,
              type: import_MdnsServer.AnnouncementType.Operative,
              forInstance
            })
          );
        }
      }
    }
    await this.#mdnsServer.setRecordsGenerator(announcedNetPort, import_MdnsServer.AnnouncementType.Operative, async (netInterface) => {
      const ipMac = await this.#network.getIpMac(netInterface);
      if (ipMac === void 0) return [];
      const { mac, ipV4, ipV6 } = ipMac;
      const hostname = mac.replace(/:/g, "").toUpperCase() + "0000.local";
      const records = [(0, import_general.PtrRecord)(import_MdnsConsts.SERVICE_DISCOVERY_QNAME, import_MdnsConsts.MATTER_SERVICE_QNAME)];
      fabrics.forEach((fabric) => {
        const { operationalId, nodeId } = fabric;
        const operationalIdString = import_general.Bytes.toHex(operationalId).toUpperCase();
        const fabricQname = (0, import_MdnsConsts.getFabricQname)(operationalIdString);
        const deviceMatterQname = (0, import_MdnsConsts.getDeviceMatterQname)(operationalIdString, import_types.NodeId.toHexString(nodeId));
        logger.debug(
          "Announcement Generator: Fabric",
          import_general.Diagnostic.dict({
            id: `${operationalIdString}-${import_types.NodeId.toHexString(nodeId)}`,
            qname: deviceMatterQname,
            port: announcedNetPort,
            interface: netInterface
          })
        );
        const fabricRecords = [
          (0, import_general.PtrRecord)(import_MdnsConsts.SERVICE_DISCOVERY_QNAME, fabricQname, deviceMatterQname),
          (0, import_general.PtrRecord)(import_MdnsConsts.MATTER_SERVICE_QNAME, deviceMatterQname, deviceMatterQname),
          (0, import_general.PtrRecord)(fabricQname, deviceMatterQname, deviceMatterQname),
          (0, import_general.SrvRecord)(
            deviceMatterQname,
            { priority: 0, weight: 0, port: announcedNetPort, target: hostname },
            deviceMatterQname
          ),
          (0, import_general.TxtRecord)(
            deviceMatterQname,
            [
              `SII=${sessionIdleInterval}`,
              `SAI=${sessionActiveInterval}`,
              `SAT=${sessionActiveThreshold}`
              //`T=${TCP_SUPPORTED}` /* TODO TCP not supported */,
              //`ICD=${ICD_SUPPORTED}` /* ICD not supported */,
            ],
            deviceMatterQname
          )
        ];
        records.push(...fabricRecords);
      });
      records.push(...this.#getIpRecords(hostname, [...ipV6, ...ipV4]));
      return records;
    });
    await import_general.MatterAggregateError.allSettled(expires);
  }
  /** Set the Broadcaster data to announce a Commissioner (aka Commissioner discovery) */
  async setCommissionerInfo(announcedNetPort, {
    deviceName,
    deviceType,
    vendorId,
    productId,
    sessionIdleInterval = import_Session.SESSION_IDLE_INTERVAL_MS,
    sessionActiveInterval = import_Session.SESSION_ACTIVE_INTERVAL_MS,
    sessionActiveThreshold = import_Session.SESSION_ACTIVE_THRESHOLD_MS
  }) {
    logger.debug(
      "Announcement: Commissioner",
      import_general.Diagnostic.dict({
        port: announcedNetPort,
        deviceType
      })
    );
    const instanceId = import_general.Bytes.toHex(import_general.Crypto.getRandomData(8)).toUpperCase();
    const deviceTypeQname = `_T${deviceType}._sub.${import_MdnsConsts.MATTER_COMMISSIONER_SERVICE_QNAME}`;
    const vendorQname = `_V${vendorId}._sub.${import_MdnsConsts.MATTER_COMMISSIONER_SERVICE_QNAME}`;
    const deviceQname = `${instanceId}.${import_MdnsConsts.MATTER_COMMISSIONER_SERVICE_QNAME}`;
    this.#activeCommissioningAnnouncements.add(announcedNetPort);
    await this.#mdnsServer.setRecordsGenerator(
      announcedNetPort,
      import_MdnsServer.AnnouncementType.Commissionable,
      async (netInterface) => {
        const ipMac = await this.#network.getIpMac(netInterface);
        if (ipMac === void 0) return [];
        const { mac, ipV4, ipV6 } = ipMac;
        const hostname = mac.replace(/:/g, "").toUpperCase() + "0000.local";
        const records = [
          (0, import_general.PtrRecord)(import_MdnsConsts.SERVICE_DISCOVERY_QNAME, import_MdnsConsts.MATTER_COMMISSIONER_SERVICE_QNAME),
          (0, import_general.PtrRecord)(import_MdnsConsts.MATTER_COMMISSIONER_SERVICE_QNAME, vendorQname),
          (0, import_general.PtrRecord)(vendorQname, deviceQname),
          (0, import_general.SrvRecord)(deviceQname, { priority: 0, weight: 0, port: announcedNetPort, target: hostname }),
          (0, import_general.TxtRecord)(deviceQname, [
            `VP=${vendorId}+${productId}`,
            `DT=${deviceType}`,
            `DN=${deviceName}`,
            `SII=${sessionIdleInterval}`,
            `SAI=${sessionActiveInterval}`,
            `SAT=${sessionActiveThreshold}`
            //`T=${TCP_SUPPORTED}` /* TODO TCP not supported */,
            //`ICD=${ICD_SUPPORTED}` /* ICD not supported */,
          ])
        ];
        if (deviceType !== void 0) {
          records.push((0, import_general.PtrRecord)(import_MdnsConsts.SERVICE_DISCOVERY_QNAME, deviceTypeQname));
          records.push((0, import_general.PtrRecord)(deviceTypeQname, deviceQname));
        }
        records.push(...this.#getIpRecords(hostname, [...ipV6, ...ipV4]));
        return records;
      }
    );
  }
  async announce(announcementPort) {
    this.#mdnsServer.announce(announcementPort).catch((error) => logger.error(error));
  }
  async expireFabricAnnouncement(announcedNetPort) {
    if (this.#activeOperationalAnnouncements.has(announcedNetPort)) {
      await this.#mdnsServer.expireAnnouncements({ announcedNetPort, type: import_MdnsServer.AnnouncementType.Operative });
      this.#activeOperationalAnnouncements.delete(announcedNetPort);
    }
  }
  async expireCommissioningAnnouncement(announcedNetPort) {
    if (this.#activeCommissioningAnnouncements.has(announcedNetPort)) {
      await this.#mdnsServer.expireAnnouncements({ announcedNetPort, type: import_MdnsServer.AnnouncementType.Commissionable });
      this.#activeCommissioningAnnouncements.delete(announcedNetPort);
    }
  }
  async expireAllAnnouncements(announcedNetPort) {
    if (!this.#activeCommissioningAnnouncements.has(announcedNetPort) && !this.#activeOperationalAnnouncements.has(announcedNetPort))
      return;
    await this.#mdnsServer.expireAnnouncements({ announcedNetPort });
    this.#activeCommissioningAnnouncements.delete(announcedNetPort);
    this.#activeOperationalAnnouncements.delete(announcedNetPort);
  }
  async close() {
    while (this.#instances.size) {
      await this.#instances.deleted;
    }
    await this.#mdnsServer.expireAnnouncements();
    this.#activeCommissioningAnnouncements.clear();
    this.#activeOperationalAnnouncements.clear();
    await this.#mdnsServer.close();
  }
}
//# sourceMappingURL=MdnsBroadcaster.js.map
