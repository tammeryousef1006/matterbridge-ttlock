/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { ChannelType, Diagnostic, Lifespan, Network, ServerAddressIp, UdpMulticastServer } from "#general";
import { NodeId } from "#types";
import { CommissionableDevice, CommissionableDeviceIdentifiers, DiscoveryData, OperationalDevice, Scanner } from "../common/Scanner.js";
import { Fabric } from "../fabric/Fabric.js";
type MatterServerRecordWithExpire = ServerAddressIp & Lifespan;
/**
 * This class implements the Scanner interface for a MDNS scanner via UDP messages in a IP based network. It sends out
 * queries to discover various types of Matter device types and listens for announcements.
 */
export declare class MdnsScanner implements Scanner {
    #private;
    get type(): ChannelType;
    static create(network: Network, options?: {
        enableIpv4?: boolean;
        netInterface?: string;
    }): Promise<MdnsScanner>;
    constructor(multicastServer: UdpMulticastServer, enableIpv4?: boolean);
    /**
     * Method to find an operational device (already commissioned) and return a promise with the list of discovered
     * IP/ports or an empty array if not found.
     */
    findOperationalDevice({ operationalId }: Fabric, nodeId: NodeId, timeoutSeconds?: number, ignoreExistingRecords?: boolean): Promise<OperationalDevice | undefined>;
    cancelOperationalDeviceDiscovery(fabric: Fabric, nodeId: NodeId, resolvePromise?: boolean): void;
    cancelCommissionableDeviceDiscovery(identifier: CommissionableDeviceIdentifiers, resolvePromise?: boolean): void;
    getDiscoveredOperationalDevice({ operationalId }: Fabric, nodeId: NodeId): OperationalDevice | undefined;
    /**
     * Discovers commissionable devices based on a defined identifier for maximal given timeout, but returns the
     * first found entries. If already a discovered device matches in the cache the response is returned directly and
     * no query is triggered. If no record exists a query is sent out and the promise gets fulfilled as soon as at least
     * one device is found. If no device is discovered in the defined timeframe an empty array is returned. When the
     * promise got fulfilled no more queries are send out, but more device entries might be added when discovered later.
     * These can be requested by the getCommissionableDevices method.
     */
    findCommissionableDevices(identifier: CommissionableDeviceIdentifiers, timeoutSeconds?: number, ignoreExistingRecords?: boolean): Promise<CommissionableDevice[]>;
    /**
     * Discovers commissionable devices based on a defined identifier and returns the first found entries.
     * If an own cancelSignal promise is used the discovery can only be cancelled via this signal!
     */
    findCommissionableDevicesContinuously(identifier: CommissionableDeviceIdentifiers, callback: (device: CommissionableDevice) => void, timeoutSeconds?: number, cancelSignal?: Promise<void>): Promise<CommissionableDevice[]>;
    getDiscoveredCommissionableDevices(identifier: CommissionableDeviceIdentifiers): {
        addresses: ServerAddressIp[];
        discoveredAt: undefined;
        ttl: undefined;
        SII?: number | undefined;
        SAI?: number | undefined;
        SAT?: number | undefined;
        VP?: string | undefined;
        DT?: number | undefined;
        DN?: string | undefined;
        RI?: string | undefined;
        PH?: number | undefined;
        PI?: string | undefined;
        T?: number | undefined;
        ICD?: number | undefined;
        deviceIdentifier: string;
        D: number;
        CM: number;
        instanceId: string;
        SD: number;
        V?: number;
        P?: number;
    }[];
    /**
     * Close all connects, end all timers and resolve all pending promises.
     */
    close(): Promise<void>;
    static discoveryDataDiagnostics(data: DiscoveryData): Record<string, unknown> & Diagnostic;
    static deviceAddressDiagnostics(addresses: Map<string, MatterServerRecordWithExpire>): (Record<string, unknown> & Diagnostic)[];
}
export {};
//# sourceMappingURL=MdnsScanner.d.ts.map