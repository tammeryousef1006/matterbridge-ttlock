"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var MdnsScanner_exports = {};
__export(MdnsScanner_exports, {
  MdnsScanner: () => MdnsScanner
});
module.exports = __toCommonJS(MdnsScanner_exports);
var import_general = require("#general");
var import_types = require("#types");
var import_MdnsConsts = require("./MdnsConsts.js");
var import_MdnsServer = require("./MdnsServer.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("MdnsScanner");
const MDNS_EXPIRY_GRACE_PERIOD_FACTOR = 1.05;
const START_ANNOUNCE_INTERVAL_SECONDS = 1.5;
class MdnsScanner {
  get type() {
    return import_general.ChannelType.UDP;
  }
  static async create(network, options) {
    const { enableIpv4, netInterface } = options ?? {};
    return new MdnsScanner(
      await import_general.UdpMulticastServer.create({
        network,
        netInterface,
        broadcastAddressIpv4: enableIpv4 ? import_MdnsServer.MDNS_BROADCAST_IPV4 : void 0,
        broadcastAddressIpv6: import_MdnsServer.MDNS_BROADCAST_IPV6,
        listeningPort: import_MdnsServer.MDNS_BROADCAST_PORT
      }),
      enableIpv4
    );
  }
  /** Active announces by queryId with queries and known answers */
  #activeAnnounceQueries = /* @__PURE__ */ new Map();
  /** Known IP addresses by network interface */
  #discoveredIpRecords = /* @__PURE__ */ new Map();
  /** Known operational device records by Matter Qname */
  #operationalDeviceRecords = /* @__PURE__ */ new Map();
  /** Known commissionable device records by queryId */
  #commissionableDeviceRecords = /* @__PURE__ */ new Map();
  /** Waiters for specific queryIds to resolve a promise when a record is discovered */
  #recordWaiters = /* @__PURE__ */ new Map();
  #queryTimer;
  #nextAnnounceIntervalSeconds = START_ANNOUNCE_INTERVAL_SECONDS;
  #periodicTimer;
  #closing = false;
  #multicastServer;
  #enableIpv4;
  constructor(multicastServer, enableIpv4) {
    multicastServer.onMessage(
      (message, remoteIp, netInterface) => this.#handleDnsMessage(message, remoteIp, netInterface)
    );
    this.#multicastServer = multicastServer;
    this.#enableIpv4 = enableIpv4;
    this.#periodicTimer = import_general.Time.getPeriodicTimer(
      "Discovered node expiration",
      60 * 1e3,
      () => this.#expire()
    ).start();
  }
  #effectiveTTL(ttl) {
    return Math.ceil(ttl * MDNS_EXPIRY_GRACE_PERIOD_FACTOR);
  }
  /**
   * Sends out one DNS-SD query for all collected announce records and start a timer for the next query with doubled
   * interval, maximum 60min, as per MDNS specs. The already known answers are tried to be sent in the query as long
   * as they fit into a maximum 1500 byte long packet (as defined in MDNS specs), else they are split into more
   * packets and the query is sent as Truncated query.
   */
  async #sendQueries() {
    this.#queryTimer?.stop();
    const allQueries = Array.from(this.#activeAnnounceQueries.values());
    const queries = allQueries.flatMap(({ queries: queries2 }) => queries2);
    const answers = allQueries.flatMap(
      ({ answers: answers2 }) => Object.values(answers2).flatMap(
        (answer) => Object.values(answer).flatMap((records) => Array.isArray(records) ? records : records.values())
      )
    );
    this.#queryTimer = import_general.Time.getTimer(
      "MDNS discovery",
      this.#nextAnnounceIntervalSeconds * 1e3,
      () => this.#sendQueries()
    ).start();
    logger.debug(
      `Sending ${queries.length} query records for ${this.#activeAnnounceQueries.size} queries with ${answers.length} known answers. Re-Announce in ${this.#nextAnnounceIntervalSeconds} seconds`
    );
    const nextAnnounceInterval = this.#nextAnnounceIntervalSeconds * 2;
    this.#nextAnnounceIntervalSeconds = Math.min(
      nextAnnounceInterval,
      60 * 60
      /* 1 hour */
    );
    const answersToSend = [...answers];
    const dnsMessageDataToSend = {
      messageType: import_general.DnsMessageType.TruncatedQuery,
      transactionId: 0,
      queries,
      authorities: [],
      answers: [],
      additionalRecords: []
    };
    const emptyDnsMessage = import_general.DnsCodec.encode(dnsMessageDataToSend);
    let dnsMessageSize = emptyDnsMessage.length;
    while (true) {
      if (answersToSend.length > 0) {
        const nextAnswer = answersToSend.shift();
        if (nextAnswer === void 0) {
          break;
        }
        const nextAnswerEncoded = import_general.DnsCodec.encodeRecord(nextAnswer);
        dnsMessageSize += nextAnswerEncoded.length;
        if (dnsMessageSize > import_general.MAX_MDNS_MESSAGE_SIZE) {
          if (dnsMessageDataToSend.answers.length === 0) {
            logger.warn(
              `MDNS Query with ${import_general.Diagnostic.json(
                queries
              )} is too big to fit into a single MDNS message. Send anyway, but please report!`
            );
          }
          await this.#multicastServer.send(import_general.DnsCodec.encode(dnsMessageDataToSend));
          dnsMessageDataToSend.queries.length = 0;
          dnsMessageDataToSend.answers.length = 0;
          dnsMessageSize = emptyDnsMessage.length + nextAnswerEncoded.length;
        }
        dnsMessageDataToSend.answers.push(nextAnswerEncoded);
      } else {
        break;
      }
    }
    await this.#multicastServer.send(
      import_general.DnsCodec.encode({ ...dnsMessageDataToSend, messageType: import_general.DnsMessageType.Query })
    );
  }
  /**
   * Set new DnsQuery records to the list of active queries to discover devices in the network and start sending them
   * out. When entry already exists the query is overwritten and answers are always added.
   */
  #setQueryRecords(queryId, queries, answers = {}) {
    const activeExistingQuery = this.#activeAnnounceQueries.get(queryId);
    if (activeExistingQuery) {
      const { queries: existingQueries } = activeExistingQuery;
      const newQueries = queries.filter(
        (query) => !existingQueries.some(
          (existingQuery) => existingQuery.name === query.name && existingQuery.recordType === query.recordType && existingQuery.recordClass === query.recordClass
        )
      );
      if (newQueries.length === 0) {
        logger.debug(
          `No new query records for query ${queryId}, keeping existing queries and do not re-announce.`
        );
        return;
      }
      queries = [...newQueries, ...existingQueries];
      answers = this.#combineStructuredAnswers(activeExistingQuery.answers, answers);
    }
    this.#activeAnnounceQueries.set(queryId, { queries, answers });
    logger.debug(`Set ${queries.length} query records for query ${queryId}: ${import_general.Diagnostic.json(queries)}`);
    this.#queryTimer?.stop();
    this.#nextAnnounceIntervalSeconds = START_ANNOUNCE_INTERVAL_SECONDS;
    this.#queryTimer = import_general.Time.getTimer("MDNS discovery", 0, () => this.#sendQueries()).start();
  }
  /**
   * Combines the known answers from all active queries and the known IP addresses from the network
   * interface into one data package
   */
  #getActiveQueryEarlierAnswers(netInterface) {
    return this.#combineStructuredAnswers(
      ...[...this.#activeAnnounceQueries.values()].map(({ answers }) => answers),
      this.#discoveredIpRecords.get(netInterface) ?? {}
    );
  }
  /**
   * Remove a query from the list of active queries because discovery has finished or timed out and stop sending it
   * out. If it was the last query announcing will stop completely.
   */
  #removeQuery(queryId) {
    this.#activeAnnounceQueries.delete(queryId);
    if (this.#activeAnnounceQueries.size === 0) {
      logger.debug(`Removing last query ${queryId} and stopping announce timer`);
      this.#queryTimer?.stop();
      this.#nextAnnounceIntervalSeconds = START_ANNOUNCE_INTERVAL_SECONDS;
    } else {
      logger.debug(`Removing query ${queryId}`);
    }
  }
  /**
   * Returns the list of all targets (IP/port) discovered for a queried operational device record.
   */
  #getOperationalDeviceRecords(deviceMatterQname) {
    const device = this.#operationalDeviceRecords.get(deviceMatterQname);
    if (device === void 0) {
      return void 0;
    }
    const { addresses } = device;
    if (addresses.size === 0) {
      return void 0;
    }
    return {
      ...device,
      addresses: this.#sortServerEntries(Array.from(addresses.values())).map(({ ip, port }) => ({
        ip,
        port,
        type: "udp"
      }))
    };
  }
  /**
   * Sort the list of found IP/ports and make sure link-local IPv6 addresses come first, IPv6 next and IPv4 last.
   *
   * @param entries
   */
  #sortServerEntries(entries) {
    return entries.sort((a, b) => {
      const aIsIPv6 = (0, import_general.isIPv6)(a.ip);
      const bIsIPv6 = (0, import_general.isIPv6)(b.ip);
      if (aIsIPv6 && !bIsIPv6) {
        return -1;
      } else if (!aIsIPv6 && bIsIPv6) {
        return 1;
      } else if (aIsIPv6 && bIsIPv6) {
        if (a.ip.startsWith("fd") && !b.ip.startsWith("fd")) {
          return -1;
        } else if (!a.ip.startsWith("fd") && b.ip.startsWith("fd")) {
          return 1;
        } else if (a.ip.startsWith("fe80:") && !b.ip.startsWith("fe80:")) {
          return -1;
        } else if (!a.ip.startsWith("fe80:") && b.ip.startsWith("fe80:")) {
          return 1;
        }
      }
      return 0;
    });
  }
  /**
   * Registers a deferred promise for a specific queryId together with a timeout and return the promise.
   * The promise will be resolved when the timer runs out latest.
   */
  async #registerWaiterPromise(queryId, timeoutSeconds, resolveOnUpdatedRecords = true, cancelResolver) {
    const { promise, resolver } = (0, import_general.createPromise)();
    const timer = timeoutSeconds !== void 0 ? import_general.Time.getTimer("MDNS timeout", timeoutSeconds * 1e3, () => {
      cancelResolver?.();
      this.#finishWaiter(queryId, true);
    }).start() : void 0;
    this.#recordWaiters.set(queryId, { resolver, timer, resolveOnUpdatedRecords, cancelResolver });
    logger.debug(
      `Registered waiter for query ${queryId} with ${timeoutSeconds !== void 0 ? `timeout ${timeoutSeconds} seconds` : "no timeout"}${resolveOnUpdatedRecords ? "" : " (not resolving on updated records)"}`
    );
    await promise;
  }
  /**
   * Remove a waiter promise for a specific queryId and stop the connected timer. If required also resolve the
   * promise.
   */
  #finishWaiter(queryId, resolvePromise, isUpdatedRecord = false) {
    const waiter = this.#recordWaiters.get(queryId);
    if (waiter === void 0) return;
    const { timer, resolver, resolveOnUpdatedRecords } = waiter;
    if (isUpdatedRecord && !resolveOnUpdatedRecords) return;
    logger.debug(`Finishing waiter for query ${queryId}, resolving: ${resolvePromise}`);
    if (timer !== void 0) {
      timer.stop();
    }
    if (resolvePromise) {
      resolver();
    }
    this.#recordWaiters.delete(queryId);
  }
  /** Returns weather a waiter promise is registered for a specific queryId. */
  #hasWaiter(queryId) {
    return this.#recordWaiters.has(queryId);
  }
  #createOperationalMatterQName(operationalId, nodeId) {
    const operationalIdString = import_general.Bytes.toHex(operationalId).toUpperCase();
    return (0, import_MdnsConsts.getDeviceMatterQname)(operationalIdString, import_types.NodeId.toHexString(nodeId));
  }
  /**
   * Method to find an operational device (already commissioned) and return a promise with the list of discovered
   * IP/ports or an empty array if not found.
   */
  async findOperationalDevice({ operationalId }, nodeId, timeoutSeconds, ignoreExistingRecords = false) {
    if (this.#closing) {
      throw new import_general.ImplementationError("Cannot discover operational device because scanner is closing.");
    }
    const deviceMatterQname = this.#createOperationalMatterQName(operationalId, nodeId);
    let storedDevice = ignoreExistingRecords ? void 0 : this.#getOperationalDeviceRecords(deviceMatterQname);
    if (storedDevice === void 0) {
      const promise = this.#registerWaiterPromise(deviceMatterQname, timeoutSeconds);
      this.#setQueryRecords(deviceMatterQname, [
        {
          name: deviceMatterQname,
          recordClass: import_general.DnsRecordClass.IN,
          recordType: import_general.DnsRecordType.SRV
        }
      ]);
      await promise;
      storedDevice = this.#getOperationalDeviceRecords(deviceMatterQname);
      this.#removeQuery(deviceMatterQname);
    }
    return storedDevice;
  }
  cancelOperationalDeviceDiscovery(fabric, nodeId, resolvePromise = true) {
    const deviceMatterQname = this.#createOperationalMatterQName(fabric.operationalId, nodeId);
    this.#finishWaiter(deviceMatterQname, resolvePromise);
  }
  cancelCommissionableDeviceDiscovery(identifier, resolvePromise = true) {
    const queryId = this.#buildCommissionableQueryIdentifier(identifier);
    const { cancelResolver } = this.#recordWaiters.get(queryId) ?? {};
    cancelResolver?.();
    this.#finishWaiter(queryId, resolvePromise);
  }
  getDiscoveredOperationalDevice({ operationalId }, nodeId) {
    return this.#getOperationalDeviceRecords(this.#createOperationalMatterQName(operationalId, nodeId));
  }
  /**
   * Returns the metadata and list of all target addresses (IP/port) discovered for a queried commissionable device
   * record.
   */
  #getCommissionableDeviceRecords(identifier) {
    const storedRecords = Array.from(this.#commissionableDeviceRecords.values());
    const foundRecords = new Array();
    if ("instanceId" in identifier) {
      foundRecords.push(...storedRecords.filter(({ instanceId }) => instanceId === identifier.instanceId));
    } else if ("longDiscriminator" in identifier) {
      foundRecords.push(...storedRecords.filter(({ D }) => D === identifier.longDiscriminator));
    } else if ("shortDiscriminator" in identifier) {
      foundRecords.push(...storedRecords.filter(({ SD }) => SD === identifier.shortDiscriminator));
    } else if ("vendorId" in identifier && "productId" in identifier) {
      foundRecords.push(
        ...storedRecords.filter(({ V, P }) => V === identifier.vendorId && P === identifier.productId)
      );
    } else if ("vendorId" in identifier) {
      foundRecords.push(...storedRecords.filter(({ V }) => V === identifier.vendorId));
    } else if ("deviceType" in identifier) {
      foundRecords.push(...storedRecords.filter(({ DT }) => DT === identifier.deviceType));
    } else if ("productId" in identifier) {
      foundRecords.push(...storedRecords.filter(({ P }) => P === identifier.productId));
    } else if (Object.keys(identifier).length === 0) {
      foundRecords.push(...storedRecords.filter(({ CM }) => CM === 1 || CM === 2));
    }
    return foundRecords.filter(({ addresses }) => addresses.size > 0).map((record) => {
      return {
        ...record,
        addresses: this.#sortServerEntries(Array.from(record.addresses.values())).map(({ ip, port }) => ({
          ip,
          port,
          type: "udp"
        })),
        discoveredAt: void 0,
        ttl: void 0
      };
    });
  }
  /**
   * Builds an identifier string for commissionable queries based on the given identifier object.
   * Some identifiers are identical to the official DNS-SD identifiers, others are custom.
   */
  #buildCommissionableQueryIdentifier(identifier) {
    if ("instanceId" in identifier) {
      return (0, import_MdnsConsts.getDeviceInstanceQname)(identifier.instanceId);
    }
    if ("longDiscriminator" in identifier) {
      return (0, import_MdnsConsts.getLongDiscriminatorQname)(identifier.longDiscriminator);
    }
    if ("shortDiscriminator" in identifier) {
      return (0, import_MdnsConsts.getShortDiscriminatorQname)(identifier.shortDiscriminator);
    }
    if ("vendorId" in identifier && "productId" in identifier) {
      return `_VP${identifier.vendorId}+${identifier.productId}`;
    }
    if ("vendorId" in identifier) {
      return (0, import_MdnsConsts.getVendorQname)(identifier.vendorId);
    }
    if ("deviceType" in identifier) {
      return (0, import_MdnsConsts.getDeviceTypeQname)(identifier.deviceType);
    }
    if ("productId" in identifier) {
      return `_P${identifier.productId}`;
    }
    return (0, import_MdnsConsts.getCommissioningModeQname)();
  }
  #extractInstanceId(instanceName) {
    const instanceNameSeparator = instanceName.indexOf(".");
    if (instanceNameSeparator !== -1) {
      return instanceName.substring(0, instanceNameSeparator);
    }
    return instanceName;
  }
  /**
   * Check all options for a query identifier and return the most relevant one with an active query
   */
  #findCommissionableQueryIdentifier(instanceName, record) {
    if (this.#closing) {
      throw new import_general.ImplementationError("Cannot discover commissionable device because scanner is closing.");
    }
    const instanceQueryId = this.#buildCommissionableQueryIdentifier({
      instanceId: this.#extractInstanceId(instanceName)
    });
    if (this.#activeAnnounceQueries.has(instanceQueryId)) {
      return instanceQueryId;
    }
    const longDiscriminatorQueryId = this.#buildCommissionableQueryIdentifier({ longDiscriminator: record.D });
    if (this.#activeAnnounceQueries.has(longDiscriminatorQueryId)) {
      return longDiscriminatorQueryId;
    }
    const shortDiscriminatorQueryId = this.#buildCommissionableQueryIdentifier({ shortDiscriminator: record.SD });
    if (this.#activeAnnounceQueries.has(shortDiscriminatorQueryId)) {
      return shortDiscriminatorQueryId;
    }
    if (record.V !== void 0 && record.P !== void 0) {
      const vendorProductIdQueryId = this.#buildCommissionableQueryIdentifier({
        vendorId: (0, import_types.VendorId)(record.V),
        productId: record.P
      });
      if (this.#activeAnnounceQueries.has(vendorProductIdQueryId)) {
        return vendorProductIdQueryId;
      }
    }
    if (record.V !== void 0) {
      const vendorIdQueryId = this.#buildCommissionableQueryIdentifier({ vendorId: (0, import_types.VendorId)(record.V) });
      if (this.#activeAnnounceQueries.has(vendorIdQueryId)) {
        return vendorIdQueryId;
      }
    }
    if (record.DT !== void 0) {
      const deviceTypeQueryId = this.#buildCommissionableQueryIdentifier({ deviceType: record.DT });
      if (this.#activeAnnounceQueries.has(deviceTypeQueryId)) {
        return deviceTypeQueryId;
      }
    }
    if (record.P !== void 0) {
      const productIdQueryId = this.#buildCommissionableQueryIdentifier({ productId: record.P });
      if (this.#activeAnnounceQueries.has(productIdQueryId)) {
        return productIdQueryId;
      }
    }
    const commissioningModeQueryId = this.#buildCommissionableQueryIdentifier({});
    if (this.#activeAnnounceQueries.has(commissioningModeQueryId)) {
      return commissioningModeQueryId;
    }
    return void 0;
  }
  #getCommissionableQueryRecords(identifier) {
    const names = new Array();
    names.push(import_MdnsConsts.MATTER_COMMISSION_SERVICE_QNAME);
    if ("instanceId" in identifier) {
      names.push((0, import_MdnsConsts.getDeviceInstanceQname)(identifier.instanceId));
    } else if ("longDiscriminator" in identifier) {
      names.push((0, import_MdnsConsts.getLongDiscriminatorQname)(identifier.longDiscriminator));
    } else if ("shortDiscriminator" in identifier) {
      names.push((0, import_MdnsConsts.getShortDiscriminatorQname)(identifier.shortDiscriminator));
    } else if ("vendorId" in identifier) {
      names.push((0, import_MdnsConsts.getVendorQname)(identifier.vendorId));
    } else if ("deviceType" in identifier) {
      names.push((0, import_MdnsConsts.getDeviceTypeQname)(identifier.deviceType));
    } else {
      names.push((0, import_MdnsConsts.getCommissioningModeQname)());
    }
    return names.map((name) => ({ name, recordClass: import_general.DnsRecordClass.IN, recordType: import_general.DnsRecordType.PTR }));
  }
  /**
   * Discovers commissionable devices based on a defined identifier for maximal given timeout, but returns the
   * first found entries. If already a discovered device matches in the cache the response is returned directly and
   * no query is triggered. If no record exists a query is sent out and the promise gets fulfilled as soon as at least
   * one device is found. If no device is discovered in the defined timeframe an empty array is returned. When the
   * promise got fulfilled no more queries are send out, but more device entries might be added when discovered later.
   * These can be requested by the getCommissionableDevices method.
   */
  async findCommissionableDevices(identifier, timeoutSeconds = 5, ignoreExistingRecords = false) {
    let storedRecords = ignoreExistingRecords ? [] : this.#getCommissionableDeviceRecords(identifier).filter(({ addresses }) => addresses.length > 0);
    if (storedRecords.length === 0) {
      const queryId = this.#buildCommissionableQueryIdentifier(identifier);
      const promise = this.#registerWaiterPromise(queryId, timeoutSeconds);
      this.#setQueryRecords(queryId, this.#getCommissionableQueryRecords(identifier));
      await promise;
      storedRecords = this.#getCommissionableDeviceRecords(identifier);
      this.#removeQuery(queryId);
    }
    return storedRecords;
  }
  /**
   * Discovers commissionable devices based on a defined identifier and returns the first found entries.
   * If an own cancelSignal promise is used the discovery can only be cancelled via this signal!
   */
  async findCommissionableDevicesContinuously(identifier, callback, timeoutSeconds, cancelSignal) {
    const discoveredDevices = /* @__PURE__ */ new Set();
    const discoveryEndTime = timeoutSeconds ? import_general.Time.nowMs() + timeoutSeconds * 1e3 : void 0;
    const queryId = this.#buildCommissionableQueryIdentifier(identifier);
    this.#setQueryRecords(queryId, this.#getCommissionableQueryRecords(identifier));
    let queryResolver;
    if (cancelSignal === void 0) {
      const { promise, resolver } = (0, import_general.createPromise)();
      cancelSignal = promise;
      queryResolver = resolver;
    }
    let canceled = false;
    cancelSignal?.then(
      () => {
        canceled = true;
        if (queryResolver === void 0) {
          this.#finishWaiter(queryId, true);
        }
      },
      (cause) => {
        logger.error("Unexpected error canceling commissioning", cause);
      }
    );
    while (!canceled) {
      this.#getCommissionableDeviceRecords(identifier).forEach((device) => {
        const { deviceIdentifier } = device;
        if (!discoveredDevices.has(deviceIdentifier)) {
          discoveredDevices.add(deviceIdentifier);
          callback(device);
        }
      });
      let remainingTime;
      if (discoveryEndTime !== void 0) {
        remainingTime = Math.ceil((discoveryEndTime - import_general.Time.nowMs()) / 1e3);
        if (remainingTime <= 0) {
          break;
        }
      }
      await this.#registerWaiterPromise(queryId, remainingTime, false, queryResolver);
    }
    return this.#getCommissionableDeviceRecords(identifier);
  }
  getDiscoveredCommissionableDevices(identifier) {
    return this.#getCommissionableDeviceRecords(identifier);
  }
  /**
   * Close all connects, end all timers and resolve all pending promises.
   */
  async close() {
    this.#closing = true;
    this.#periodicTimer.stop();
    this.#queryTimer?.stop();
    await this.#multicastServer.close();
    [...this.#recordWaiters.keys()].forEach(
      (queryId) => this.#finishWaiter(queryId, !!this.#recordWaiters.get(queryId)?.timer)
    );
  }
  /** Converts the discovery data into a structured format for performant access. */
  #structureAnswers(...answersList) {
    const structuredAnswers = {};
    const discoveredAt = import_general.Time.nowMs();
    answersList.forEach(
      (answers) => answers.forEach((answer) => {
        const { name, recordType } = answer;
        if (name.endsWith(import_MdnsConsts.MATTER_SERVICE_QNAME)) {
          structuredAnswers.operational = structuredAnswers.operational ?? {};
          structuredAnswers.operational[recordType] = structuredAnswers.operational[recordType] ?? [];
          structuredAnswers.operational[recordType].push({
            discoveredAt,
            ...answer
          });
        } else if (name.endsWith(import_MdnsConsts.MATTER_COMMISSION_SERVICE_QNAME)) {
          structuredAnswers.commissionable = structuredAnswers.commissionable ?? {};
          structuredAnswers.commissionable[recordType] = structuredAnswers.commissionable[recordType] ?? [];
          structuredAnswers.commissionable[recordType].push({
            discoveredAt,
            ...answer
          });
        } else if (recordType === import_general.DnsRecordType.AAAA) {
          structuredAnswers.addressesV6 = structuredAnswers.addressesV6 ?? {};
          structuredAnswers.addressesV6[name] = structuredAnswers.addressesV6[name] ?? /* @__PURE__ */ new Map();
          structuredAnswers.addressesV6[name].set(answer.value, {
            discoveredAt,
            ...answer
          });
        } else if (this.#enableIpv4 && recordType === import_general.DnsRecordType.A) {
          structuredAnswers.addressesV4 = structuredAnswers.addressesV4 ?? {};
          structuredAnswers.addressesV4[name] = structuredAnswers.addressesV4[name] ?? /* @__PURE__ */ new Map();
          structuredAnswers.addressesV4[name].set(answer.value, {
            discoveredAt,
            ...answer
          });
        }
      })
    );
    return structuredAnswers;
  }
  #combineStructuredAnswers(...answersList) {
    const combinedAnswers = {};
    for (const answers of answersList) {
      if (answers.operational) {
        combinedAnswers.operational = combinedAnswers.operational ?? {};
        for (const [recordType, records] of Object.entries(answers.operational)) {
          combinedAnswers.operational[recordType] = combinedAnswers.operational[recordType] ?? /* @__PURE__ */ new Map();
          records.forEach((record) => {
            const existingRecord = combinedAnswers.operational[recordType].get(record.name);
            if (existingRecord && existingRecord.discoveredAt < record.discoveredAt) {
              if (record.ttl === 0) {
                combinedAnswers.operational[recordType].delete(record.name);
              } else {
                combinedAnswers.operational[recordType].set(record.name, record);
              }
            }
          });
        }
      }
      if (answers.commissionable) {
        combinedAnswers.commissionable = combinedAnswers.commissionable ?? {};
        for (const [recordType, records] of Object.entries(answers.commissionable)) {
          combinedAnswers.commissionable[recordType] = combinedAnswers.commissionable[recordType] ?? /* @__PURE__ */ new Map();
          records.forEach((record) => {
            const existingRecord = combinedAnswers.commissionable[recordType].get(record.name);
            if (existingRecord && existingRecord.discoveredAt < record.discoveredAt) {
              if (record.ttl === 0) {
                combinedAnswers.commissionable[recordType].delete(record.name);
              } else {
                combinedAnswers.commissionable[recordType].set(record.name, record);
              }
            }
          });
        }
      }
      if (answers.addressesV6) {
        combinedAnswers.addressesV6 = combinedAnswers.addressesV6 ?? {};
        for (const [name, records] of Object.entries(answers.addressesV6)) {
          combinedAnswers.addressesV6[name] = combinedAnswers.addressesV6[name] ?? /* @__PURE__ */ new Map();
          Object.values(records).forEach((record) => {
            const existingRecord = combinedAnswers.addressesV6[name].get(record.value);
            if (existingRecord && existingRecord.discoveredAt < record.discoveredAt) {
              if (record.ttl === 0) {
                combinedAnswers.addressesV6[name].delete(name);
              } else {
                combinedAnswers.addressesV6[name].set(name, record);
              }
            }
          });
        }
      }
      if (this.#enableIpv4 && answers.addressesV4) {
        combinedAnswers.addressesV4 = combinedAnswers.addressesV4 ?? {};
        for (const [name, records] of Object.entries(answers.addressesV4)) {
          combinedAnswers.addressesV4[name] = combinedAnswers.addressesV4[name] ?? /* @__PURE__ */ new Map();
          Object.values(records).forEach((record) => {
            const existingRecord = combinedAnswers.addressesV4[name].get(record.value);
            if (existingRecord && existingRecord.discoveredAt < record.discoveredAt) {
              if (record.ttl === 0) {
                combinedAnswers.addressesV4[name].delete(name);
              } else {
                combinedAnswers.addressesV4[name].set(name, record);
              }
            }
          });
        }
      }
    }
    const result = {};
    if (combinedAnswers.operational) {
      result.operational = Object.fromEntries(
        Object.entries(combinedAnswers.operational).map(([recordType, records]) => [
          recordType,
          Array.from(records.values())
        ])
      );
    }
    if (combinedAnswers.commissionable) {
      result.commissionable = Object.fromEntries(
        Object.entries(combinedAnswers.commissionable).map(([recordType, records]) => [
          recordType,
          Array.from(records.values())
        ])
      );
    }
    if (combinedAnswers.addressesV6) {
      result.addressesV6 = combinedAnswers.addressesV6;
    }
    if (this.#enableIpv4 && combinedAnswers.addressesV4) {
      result.addressesV4 = combinedAnswers.addressesV4;
    }
    return result;
  }
  /**
   * Main method to handle all incoming DNS messages.
   * It will parse the message and check if it contains relevant discovery records.
   */
  #handleDnsMessage(messageBytes, _remoteIp, netInterface) {
    if (this.#closing) return;
    const message = import_general.DnsCodec.decode(messageBytes);
    if (message === void 0) return;
    if (message.messageType !== import_general.DnsMessageType.Response && message.messageType !== import_general.DnsMessageType.TruncatedResponse)
      return;
    const answers = this.#structureAnswers([...message.answers, ...message.additionalRecords]);
    const formerAnswers = this.#getActiveQueryEarlierAnswers(netInterface);
    this.#handleOperationalRecords(answers, formerAnswers, netInterface);
    this.#handleCommissionableRecords(answers, formerAnswers, netInterface);
    this.#updateIpRecords(answers, netInterface);
  }
  /**
   * Update the discovered matter relevant IP records with the new data from the DNS message.
   */
  #updateIpRecords(answers, netInterface) {
    const interfaceRecords = this.#discoveredIpRecords.get(netInterface);
    if (interfaceRecords === void 0) {
      return;
    }
    let updated = false;
    if (answers.addressesV6) {
      for (const [target, ipAddresses] of Object.entries(answers.addressesV6)) {
        if (interfaceRecords.addressesV6?.[target] !== void 0) {
          for (const [ip, record] of Object.entries(ipAddresses)) {
            if (record.ttl === 0) {
              interfaceRecords.addressesV6[target].delete(ip);
            } else {
              interfaceRecords.addressesV6[target].set(ip, record);
            }
            updated = true;
          }
        }
      }
    }
    if (this.#enableIpv4 && answers.addressesV4) {
      for (const [target, ipAddresses] of Object.entries(answers.addressesV4)) {
        if (interfaceRecords.addressesV4?.[target] !== void 0) {
          for (const [ip, record] of Object.entries(ipAddresses)) {
            if (record.ttl === 0) {
              interfaceRecords.addressesV4[target].delete(ip);
            } else {
              interfaceRecords.addressesV4[target].set(ip, record);
            }
            updated = true;
          }
        }
      }
    }
    if (updated) {
      this.#discoveredIpRecords.set(netInterface, interfaceRecords);
    }
  }
  /**
   * Register Matter relevant IP records for later usage.
   */
  #registerIpRecords(ipAddresses, netInterface) {
    const interfaceRecords = this.#discoveredIpRecords.get(netInterface) ?? {};
    for (const record of ipAddresses) {
      const { recordType, name, value: ip, ttl } = record;
      if (ttl === 0) continue;
      if (recordType === import_general.DnsRecordType.AAAA) {
        interfaceRecords.addressesV6 = interfaceRecords.addressesV6 ?? {};
        interfaceRecords.addressesV6[name] = interfaceRecords.addressesV6[name] ?? /* @__PURE__ */ new Map();
        interfaceRecords.addressesV6[name].set(ip, record);
      } else if (this.#enableIpv4 && recordType === import_general.DnsRecordType.A) {
        interfaceRecords.addressesV4 = interfaceRecords.addressesV4 ?? {};
        interfaceRecords.addressesV4[name] = interfaceRecords.addressesV4[name] ?? /* @__PURE__ */ new Map();
        interfaceRecords.addressesV4[name].set(ip, record);
      }
    }
    this.#discoveredIpRecords.set(netInterface, interfaceRecords);
  }
  #handleIpRecords(answers, target, netInterface) {
    const ipRecords = new Array();
    answers.forEach((answer) => {
      if (answer.addressesV6?.[target]) {
        ipRecords.push(...answer.addressesV6[target].values());
      }
      if (this.#enableIpv4 && answer.addressesV4?.[target]) {
        ipRecords.push(...answer.addressesV4[target].values());
      }
    });
    if (ipRecords.length === 0) {
      return [];
    }
    this.#registerIpRecords(ipRecords, netInterface);
    const collectedIps = /* @__PURE__ */ new Map();
    ipRecords.forEach((record) => {
      const { value, ttl } = record;
      if (value.startsWith("fe80::")) {
        collectedIps.set(value, { value: `${value}%${netInterface}`, ttl });
      } else {
        collectedIps.set(value, { value, ttl });
      }
    });
    return [...collectedIps.values()];
  }
  #handleOperationalRecords(answers, formerAnswers, netInterface) {
    if (!answers.operational) return;
    const operationalTxtRecords = answers.operational[import_general.DnsRecordType.TXT] ?? [];
    operationalTxtRecords.forEach((record) => this.#handleOperationalTxtRecord(record, netInterface));
    let operationalSrvRecords = answers.operational[import_general.DnsRecordType.SRV] ?? [];
    if (!operationalSrvRecords.length && formerAnswers.operational) {
      operationalSrvRecords = formerAnswers.operational[import_general.DnsRecordType.SRV] ?? [];
    }
    if (operationalSrvRecords.length) {
      operationalSrvRecords.forEach(
        (record) => this.#handleOperationalSrvRecord(record, answers, formerAnswers, netInterface)
      );
    }
  }
  #handleOperationalTxtRecord(record, netInterface) {
    const { name: matterName, value, ttl } = record;
    const discoveredAt = import_general.Time.nowMs();
    if (ttl === 0) {
      if (this.#operationalDeviceRecords.has(matterName)) {
        logger.debug(
          `Removing operational device ${matterName} from cache (interface ${netInterface}) because of ttl=0`
        );
        this.#operationalDeviceRecords.delete(matterName);
      }
      return;
    }
    if (!Array.isArray(value)) return;
    const txtData = this.#parseTxtRecord(record);
    if (txtData === void 0) return;
    let device = this.#operationalDeviceRecords.get(matterName);
    if (device !== void 0) {
      device = {
        ...device,
        discoveredAt,
        ttl: ttl * 1e3,
        ...txtData
      };
    } else {
      logger.debug(
        `Adding operational device ${matterName} in cache (interface ${netInterface}, ttl=${ttl}) with TXT data:`,
        MdnsScanner.discoveryDataDiagnostics(txtData)
      );
      device = {
        deviceIdentifier: matterName,
        addresses: /* @__PURE__ */ new Map(),
        discoveredAt,
        ttl: ttl * 1e3,
        ...txtData
      };
    }
    this.#operationalDeviceRecords.set(matterName, device);
  }
  #handleOperationalSrvRecord(record, answers, formerAnswers, netInterface) {
    const {
      name: matterName,
      ttl,
      value: { target, port }
    } = record;
    const discoveredAt = import_general.Time.nowMs();
    if (ttl === 0) {
      if (this.#operationalDeviceRecords.has(matterName)) {
        logger.debug(
          `Removing operational device ${matterName} from cache (interface ${netInterface}) because of ttl=0`
        );
        this.#operationalDeviceRecords.delete(matterName);
      }
      return true;
    }
    const ips = this.#handleIpRecords([formerAnswers, answers], target, netInterface);
    const deviceExisted = this.#operationalDeviceRecords.has(matterName);
    const device = this.#operationalDeviceRecords.get(matterName) ?? {
      deviceIdentifier: matterName,
      addresses: /* @__PURE__ */ new Map(),
      discoveredAt,
      ttl: ttl * 1e3
    };
    const ipsInitiallyEmpty = device.addresses.size === 0;
    const { addresses } = device;
    if (ips.length > 0) {
      for (const { value: ip, ttl: ttl2 } of ips) {
        if (ttl2 === 0) {
          logger.debug(
            `Removing IP ${ip} for operational device ${matterName} from cache (interface ${netInterface}) because of ttl=0`
          );
          addresses.delete(ip);
          continue;
        }
        const address = addresses.get(ip) ?? { ip, port, type: "udp" };
        address.discoveredAt = discoveredAt;
        address.ttl = ttl2 * 1e3;
        addresses.set(address.ip, address);
      }
      device.addresses = addresses;
      if (ipsInitiallyEmpty) {
        logger.debug(
          `Added ${addresses.size} IPs for operational device ${matterName} to cache (interface ${netInterface}):`,
          ...MdnsScanner.deviceAddressDiagnostics(addresses)
        );
      }
      this.#operationalDeviceRecords.set(matterName, device);
    }
    if (addresses.size === 0 && this.#hasWaiter(matterName)) {
      const queries = [{ name: target, recordClass: import_general.DnsRecordClass.IN, recordType: import_general.DnsRecordType.AAAA }];
      if (this.#enableIpv4) {
        queries.push({ name: target, recordClass: import_general.DnsRecordClass.IN, recordType: import_general.DnsRecordType.A });
      }
      logger.debug(`Requesting IP addresses for operational device ${matterName} (interface ${netInterface}).`);
      this.#setQueryRecords(matterName, queries, answers);
    } else if (addresses.size > 0) {
      this.#finishWaiter(matterName, true, deviceExisted);
    }
    return true;
  }
  #handleCommissionableRecords(answers, formerAnswers, netInterface) {
    let commissionableRecords = answers.commissionable ?? {};
    if (!commissionableRecords[import_general.DnsRecordType.SRV]?.length && !commissionableRecords[import_general.DnsRecordType.TXT]?.length) {
      commissionableRecords = formerAnswers.commissionable ?? {};
      if (!commissionableRecords[import_general.DnsRecordType.SRV]?.length && !commissionableRecords[import_general.DnsRecordType.TXT]?.length)
        return;
    }
    const queryMissingDataForInstances = /* @__PURE__ */ new Set();
    const txtRecords = commissionableRecords[import_general.DnsRecordType.TXT] ?? [];
    for (const record of txtRecords) {
      const { name, ttl } = record;
      if (ttl === 0) {
        if (this.#commissionableDeviceRecords.has(name)) {
          logger.debug(
            `Removing commissionable device ${name} from cache (interface ${netInterface}) because of ttl=0`
          );
          this.#commissionableDeviceRecords.delete(name);
        }
        continue;
      }
      const txtRecord = this.#parseCommissionableTxtRecord(record);
      if (txtRecord === void 0) continue;
      const instanceId = this.#extractInstanceId(name);
      const parsedRecord = {
        ...txtRecord,
        instanceId,
        deviceIdentifier: instanceId
      };
      if (parsedRecord.D !== void 0 && parsedRecord.SD === void 0) {
        parsedRecord.SD = parsedRecord.D >> 8 & 15;
      }
      if (parsedRecord.VP !== void 0) {
        const VpValueArr = parsedRecord.VP.split("+");
        parsedRecord.V = VpValueArr[0] !== void 0 ? parseInt(VpValueArr[0]) : void 0;
        parsedRecord.P = VpValueArr[1] !== void 0 ? parseInt(VpValueArr[1]) : void 0;
      }
      const storedRecord = this.#commissionableDeviceRecords.get(name);
      if (storedRecord === void 0) {
        queryMissingDataForInstances.add(name);
        logger.debug(
          `Found commissionable device ${name} with data:`,
          MdnsScanner.discoveryDataDiagnostics(parsedRecord)
        );
      } else {
        parsedRecord.addresses = storedRecord.addresses;
      }
      this.#commissionableDeviceRecords.set(name, parsedRecord);
    }
    const srvRecords = commissionableRecords[import_general.DnsRecordType.SRV] ?? [];
    for (const record of srvRecords) {
      const storedRecord = this.#commissionableDeviceRecords.get(record.name);
      if (storedRecord === void 0) continue;
      const {
        value: { target, port },
        ttl
      } = record;
      if (ttl === 0) {
        logger.debug(
          `Removing commissionable device ${record.name} from cache (interface ${netInterface}) because of ttl=0`
        );
        this.#commissionableDeviceRecords.delete(record.name);
        continue;
      }
      const recordAddressesKnown = storedRecord.addresses.size > 0;
      const ips = this.#handleIpRecords([formerAnswers, answers], target, netInterface);
      if (ips.length > 0) {
        for (const { value: ip, ttl: ttl2 } of ips) {
          if (ttl2 === 0) {
            logger.debug(
              `Removing IP ${ip} for commissionable device ${record.name} from cache (interface ${netInterface}) because of ttl=0`
            );
            storedRecord.addresses.delete(ip);
            continue;
          }
          const matterServer = storedRecord.addresses.get(ip) ?? { ip, port, type: "udp" };
          matterServer.discoveredAt = import_general.Time.nowMs();
          matterServer.ttl = ttl2 * 1e3;
          storedRecord.addresses.set(ip, matterServer);
        }
      }
      this.#commissionableDeviceRecords.set(record.name, storedRecord);
      if (storedRecord.addresses.size === 0) {
        const queryId2 = this.#findCommissionableQueryIdentifier("", storedRecord);
        if (queryId2 === void 0) continue;
        const queries = [{ name: target, recordClass: import_general.DnsRecordClass.IN, recordType: import_general.DnsRecordType.AAAA }];
        if (this.#enableIpv4) {
          queries.push({ name: target, recordClass: import_general.DnsRecordClass.IN, recordType: import_general.DnsRecordType.A });
        }
        logger.debug(
          `Requesting IP addresses for commissionable device ${record.name} (interface ${netInterface}).`
        );
        this.#setQueryRecords(queryId2, queries, answers);
      } else if (!recordAddressesKnown) {
        logger.debug(
          `Added ${storedRecord.addresses.size} IPs for commissionable device ${record.name} to cache (interface ${netInterface}):`,
          ...MdnsScanner.deviceAddressDiagnostics(storedRecord.addresses)
        );
      }
      if (storedRecord.addresses.size === 0) continue;
      const queryId = this.#findCommissionableQueryIdentifier(record.name, storedRecord);
      if (queryId === void 0) continue;
      queryMissingDataForInstances.delete(record.name);
      this.#finishWaiter(queryId, true, recordAddressesKnown);
    }
    if (queryMissingDataForInstances.size !== 0) {
      for (const name of Array.from(queryMissingDataForInstances.values())) {
        const storedRecord = this.#commissionableDeviceRecords.get(name);
        if (storedRecord === void 0) continue;
        const queryId = this.#findCommissionableQueryIdentifier("", storedRecord);
        if (queryId === void 0) continue;
        logger.debug(`Requesting more records for commissionable device ${name} (interface ${netInterface}).`);
        this.#setQueryRecords(
          queryId,
          [{ name, recordClass: import_general.DnsRecordClass.IN, recordType: import_general.DnsRecordType.ANY }],
          answers
        );
      }
    }
  }
  #parseTxtRecord(record) {
    const { value } = record;
    const result = {};
    if (Array.isArray(value)) {
      for (const item of value) {
        const [key, value2] = item.split("=");
        if (key === void 0 || value2 === void 0) continue;
        if (["SII", "SAI", "SAT", "T", "D", "CM", "DT", "PH", "ICD"].includes(key)) {
          const intValue = parseInt(value2);
          if (isNaN(intValue)) continue;
          result[key] = intValue;
        } else if (["VP", "DN", "RI", "PI"].includes(key)) {
          result[key] = value2;
        }
      }
    }
    if (result.T === void 0) {
      result.T = 0;
    } else if (!(result.T & ~1 & 6)) {
      result.T = 0;
    }
    if (result.ICD === void 0) {
      result.ICD = 0;
    }
    return result;
  }
  #parseCommissionableTxtRecord(record) {
    const { value, ttl } = record;
    if (!Array.isArray(value)) return void 0;
    const txtRecord = this.#parseTxtRecord(record);
    if (txtRecord === void 0 || txtRecord.D === void 0 || txtRecord.CM === void 0) {
      return void 0;
    }
    return {
      addresses: /* @__PURE__ */ new Map(),
      discoveredAt: import_general.Time.nowMs(),
      ttl: ttl * 1e3,
      ...txtRecord
    };
  }
  #expire() {
    const now = import_general.Time.nowMs();
    [...this.#operationalDeviceRecords.entries()].forEach(([recordKey, { addresses, discoveredAt, ttl }]) => {
      const expires = discoveredAt + this.#effectiveTTL(ttl);
      if (now <= expires) {
        [...addresses.entries()].forEach(([key, { discoveredAt: discoveredAt2, ttl: ttl2 }]) => {
          if (now < discoveredAt2 + this.#effectiveTTL(ttl2)) return;
          addresses.delete(key);
        });
      }
      if (now > expires && !addresses.size) {
        this.#operationalDeviceRecords.delete(recordKey);
      }
    });
    [...this.#commissionableDeviceRecords.entries()].forEach(([recordKey, { addresses, discoveredAt, ttl }]) => {
      const expires = discoveredAt + this.#effectiveTTL(ttl);
      if (now <= expires) {
        [...addresses.entries()].forEach(([key, { discoveredAt: discoveredAt2, ttl: ttl2 }]) => {
          if (now < discoveredAt2 + this.#effectiveTTL(ttl2)) return;
          addresses.delete(key);
        });
      }
      if (now > expires && !addresses.size) {
        this.#commissionableDeviceRecords.delete(recordKey);
      }
    });
    [...this.#activeAnnounceQueries.values()].forEach(({ answers }) => this.#expireStructuredAnswers(answers, now));
    this.#discoveredIpRecords.forEach((answers) => this.#expireStructuredAnswers(answers, now));
  }
  #expireStructuredAnswers(data, now) {
    if (data.operational) {
      Object.keys(data.operational).forEach((recordType) => {
        const type = parseInt(recordType);
        data.operational[type] = data.operational[type].filter(
          ({ discoveredAt, ttl }) => now < discoveredAt + this.#effectiveTTL(ttl * 1e3)
        );
        if (data.operational[type].length === 0) {
          delete data.operational[type];
        }
      });
    }
    if (data.commissionable) {
      Object.keys(data.commissionable).forEach((recordType) => {
        const type = parseInt(recordType);
        data.commissionable[type] = data.commissionable[type].filter(
          ({ discoveredAt, ttl }) => now < discoveredAt + this.#effectiveTTL(ttl * 1e3)
        );
        if (data.commissionable[type].length === 0) {
          delete data.commissionable[type];
        }
      });
    }
    if (data.addressesV6) {
      Object.keys(data.addressesV6).forEach((name) => {
        for (const [ip, { discoveredAt, ttl }] of data.addressesV6[name].entries()) {
          if (now < discoveredAt + this.#effectiveTTL(ttl * 1e3)) continue;
          data.addressesV6[name].delete(ip);
        }
        if (data.addressesV6[name].size === 0) {
          delete data.addressesV6[name];
        }
      });
    }
    if (data.addressesV4) {
      Object.keys(data.addressesV4).forEach((name) => {
        for (const [ip, { discoveredAt, ttl }] of data.addressesV4[name].entries()) {
          if (now < discoveredAt + this.#effectiveTTL(ttl * 1e3)) continue;
          data.addressesV4[name].delete(ip);
        }
        if (data.addressesV4[name].size === 0) {
          delete data.addressesV4[name];
        }
      });
    }
  }
  static discoveryDataDiagnostics(data) {
    return import_general.Diagnostic.dict(
      {
        SII: data.SII,
        SAI: data.SAI,
        SAT: data.SAT,
        T: data.T,
        DT: data.DT,
        PH: data.PH,
        ICD: data.ICD,
        VP: data.VP,
        DN: data.DN,
        RI: data.RI,
        PI: data.PI
      },
      true
    );
  }
  static deviceAddressDiagnostics(addresses) {
    return Array.from(addresses.values()).map(
      (address) => import_general.Diagnostic.dict({
        type: address.type,
        ip: address.ip,
        port: address.port
      })
    );
  }
}
//# sourceMappingURL=MdnsScanner.js.map
