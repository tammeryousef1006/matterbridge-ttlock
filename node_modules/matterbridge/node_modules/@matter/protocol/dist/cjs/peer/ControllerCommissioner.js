"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ControllerCommissioner_exports = {};
__export(ControllerCommissioner_exports, {
  ControllerCommissioner: () => ControllerCommissioner
});
module.exports = __toCommonJS(ControllerCommissioner_exports);
var import_CertificateAuthority = require("#certificate/CertificateAuthority.js");
var import_general_commissioning = require("#clusters/general-commissioning");
var import_Scanner = require("#common/Scanner.js");
var import_general = require("#general");
var import_MdnsScanner = require("#mdns/MdnsScanner.js");
var import_ControllerCommissioningFlow = require("#peer/ControllerCommissioningFlow.js");
var import_ControllerDiscovery = require("#peer/ControllerDiscovery.js");
var import_securechannel = require("#securechannel/index.js");
var import_session = require("#session/index.js");
var import_SessionManager = require("#session/SessionManager.js");
var import_types = require("#types");
var import_InteractionClient = require("../interaction/InteractionClient.js");
var import_ExchangeManager = require("../protocol/ExchangeManager.js");
var import_ExchangeProvider = require("../protocol/ExchangeProvider.js");
var import_PeerSet = require("./PeerSet.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("PeerCommissioner");
class ControllerCommissioner {
  #context;
  #paseClient;
  constructor(context) {
    this.#context = context;
    this.#paseClient = new import_session.PaseClient(context.sessions);
  }
  static [import_general.Environmental.create](env) {
    const instance = new ControllerCommissioner({
      peers: env.get(import_PeerSet.PeerSet),
      clients: env.get(import_InteractionClient.InteractionClientProvider),
      scanners: env.get(import_Scanner.ScannerSet),
      netInterfaces: env.get(import_general.NetInterfaceSet),
      sessions: env.get(import_SessionManager.SessionManager),
      exchanges: env.get(import_ExchangeManager.ExchangeManager),
      ca: env.get(import_CertificateAuthority.CertificateAuthority)
    });
    env.set(ControllerCommissioner, instance);
    return instance;
  }
  /**
   * Commmission a previously discovered node.
   */
  async commission(options) {
    const { passcode, addresses, discoveryData, fabric, nodeId } = options;
    if (nodeId !== void 0) {
      this.#assertPeerAddress(fabric.addressOf(nodeId));
    }
    addresses.sort((a) => a.type === "udp" ? -1 : 1);
    let channel;
    for (const address of addresses) {
      try {
        channel = await this.#initializePaseSecureChannel(address, passcode, discoveryData);
      } catch (e) {
        import_general.NoResponseTimeoutError.accept(e);
        logger.warn(`Could not connect to ${(0, import_general.serverAddressToString)(address)}: ${e.message}`);
      }
    }
    if (channel === void 0) {
      throw new import_general.NoResponseTimeoutError("Could not connect to device");
    }
    return await this.#commissionConnectedNode(channel, options, discoveryData);
  }
  /**
   * Discover and establish a PASE channel with a device.
   */
  async discoverAndEstablishPase(options) {
    const {
      discovery: { timeoutSeconds = 30 },
      passcode
    } = options;
    const commissionableDevice = "commissionableDevice" in options.discovery ? options.discovery.commissionableDevice : void 0;
    let {
      discovery: { discoveryCapabilities = {}, knownAddress }
    } = options;
    let identifierData = "identifierData" in options.discovery ? options.discovery.identifierData : {};
    if (this.#context.scanners.hasScannerFor(import_general.ChannelType.UDP) && this.#context.netInterfaces.hasInterfaceFor(import_general.ChannelType.UDP, "::") !== void 0) {
      discoveryCapabilities.onIpNetwork = true;
    }
    if (commissionableDevice !== void 0) {
      let { addresses } = commissionableDevice;
      if (discoveryCapabilities.ble === true) {
        discoveryCapabilities = { onIpNetwork: true, ble: addresses.some((address) => address.type === "ble") };
      } else if (discoveryCapabilities.onIpNetwork === true) {
        addresses = addresses.filter((address) => address.type !== "ble");
      }
      addresses.sort((a) => a.type === "udp" ? -1 : 1);
      knownAddress = addresses[0];
      if ("instanceId" in commissionableDevice && commissionableDevice.instanceId !== void 0) {
        identifierData = { instanceId: commissionableDevice.instanceId };
      } else {
        identifierData = { longDiscriminator: commissionableDevice.D };
      }
    }
    const scannersToUse = this.#context.scanners.select(discoveryCapabilities);
    logger.info(
      `Connecting to device with identifier ${import_general.Diagnostic.json(identifierData)} and ${scannersToUse.length} scanners and knownAddress ${import_general.Diagnostic.json(knownAddress)}`
    );
    let paseSecureChannel;
    let discoveryData;
    if (knownAddress !== void 0) {
      try {
        paseSecureChannel = await this.#initializePaseSecureChannel(knownAddress, passcode);
      } catch (error) {
        import_general.NoResponseTimeoutError.accept(error);
      }
    }
    if (paseSecureChannel === void 0) {
      const discoveredDevices = await import_ControllerDiscovery.ControllerDiscovery.discoverDeviceAddressesByIdentifier(
        scannersToUse,
        identifierData,
        timeoutSeconds
      );
      const { result } = await import_ControllerDiscovery.ControllerDiscovery.iterateServerAddresses(
        discoveredDevices,
        import_general.NoResponseTimeoutError,
        async () => scannersToUse.flatMap((scanner) => scanner.getDiscoveredCommissionableDevices(identifierData)),
        async (address, device) => {
          const channel = await this.#initializePaseSecureChannel(address, passcode, device);
          discoveryData = device;
          return channel;
        }
      );
      paseSecureChannel = result;
    }
    return { paseSecureChannel, discoveryData };
  }
  /**
   * Commission a node with discovery.
   */
  async commissionWithDiscovery(options) {
    const { fabric, nodeId } = options;
    if (nodeId !== void 0) {
      this.#assertPeerAddress(fabric.addressOf(nodeId));
    }
    const { paseSecureChannel, discoveryData } = await this.discoverAndEstablishPase(options);
    return await this.#commissionConnectedNode(paseSecureChannel, options, discoveryData);
  }
  /**
   * Method to start commission process with a PASE pairing.
   * If this not successful and throws an RetransmissionLimitReachedError the address is invalid or the passcode
   * is wrong.
   */
  async #initializePaseSecureChannel(address, passcode, device) {
    let paseChannel;
    if (device !== void 0) {
      logger.info(`Establish PASE to device`, import_MdnsScanner.MdnsScanner.discoveryDataDiagnostics(device));
    }
    if (address.type === "udp") {
      const { ip } = address;
      const isIpv6Address = (0, import_general.isIPv6)(ip);
      const paseInterface = this.#context.netInterfaces.interfaceFor(
        import_general.ChannelType.UDP,
        isIpv6Address ? "::" : "0.0.0.0"
      );
      if (paseInterface === void 0) {
        throw new import_ControllerDiscovery.PairRetransmissionLimitReachedError(
          `IPv${isIpv6Address ? "6" : "4"} interface not initialized. Cannot use ${ip} for commissioning.`
        );
      }
      paseChannel = await paseInterface.openChannel(address);
    } else {
      const ble = this.#context.netInterfaces.interfaceFor(import_general.ChannelType.BLE);
      if (!ble) {
        throw new import_ControllerDiscovery.PairRetransmissionLimitReachedError(
          `BLE interface not initialized. Cannot use ${address.peripheralAddress} for commissioning.`
        );
      }
      paseChannel = await ble.openChannel(address);
    }
    const unsecureSession = this.#context.sessions.createInsecureSession({
      // Use the session parameters from MDNS announcements when available and rest is assumed to be fallbacks
      sessionParameters: {
        idleIntervalMs: device?.SII,
        activeIntervalMs: device?.SAI,
        activeThresholdMs: device?.SAT
      },
      isInitiator: true
    });
    const paseUnsecureMessageChannel = new import_ExchangeManager.MessageChannel(paseChannel, unsecureSession);
    const paseExchange = this.#context.exchanges.initiateExchangeWithChannel(
      paseUnsecureMessageChannel,
      import_types.SECURE_CHANNEL_PROTOCOL_ID
    );
    let paseSecureSession;
    try {
      paseSecureSession = await this.#paseClient.pair(
        this.#context.sessions.sessionParameters,
        paseExchange,
        passcode
      );
    } catch (e) {
      await paseExchange.close();
      if (e instanceof import_securechannel.ChannelStatusResponseError) {
        throw new import_general.NoResponseTimeoutError(
          `Establishing PASE channel failed with channel status response error ${e.message}`
        );
      }
      throw e;
    }
    await unsecureSession.destroy();
    return new import_ExchangeManager.MessageChannel(paseChannel, paseSecureSession);
  }
  /** Validate if a Peert Address is already known and commissioned */
  #assertPeerAddress(address) {
    if (this.#context.peers.has(address)) {
      throw new import_ControllerCommissioningFlow.CommissioningError(`Node ID ${address.nodeId} is already commissioned and can not be reused.`);
    }
  }
  /** Finds an unused random Node-ID to use for commissioning if not already provided. */
  #determineAddress(fabric, nodeId) {
    while (true) {
      const address = fabric.addressOf(nodeId ?? import_types.NodeId.randomOperationalNodeId());
      try {
        this.#assertPeerAddress(address);
      } catch (error) {
        if (error instanceof import_ControllerCommissioningFlow.CommissioningError && nodeId !== void 0) {
          throw error;
        }
        continue;
      }
      return address;
    }
  }
  /**
   * Method to commission a device with a PASE secure channel. It returns the NodeId of the commissioned device on
   * success.
   */
  async #commissionConnectedNode(paseSecureMessageChannel, options, discoveryData) {
    const {
      fabric,
      finalizeCommissioning: performCaseCommissioning,
      commissioningFlowImpl = import_ControllerCommissioningFlow.ControllerCommissioningFlow
    } = options;
    const commissioningOptions = {
      regulatoryLocation: import_general_commissioning.GeneralCommissioning.RegulatoryLocationType.Outdoor,
      // Set to the most restrictive if relevant
      regulatoryCountryCode: "XX",
      ...options
    };
    const address = this.#determineAddress(fabric, commissioningOptions.nodeId);
    logger.info(
      `Start commissioning of node ${address.nodeId} into fabric ${fabric.fabricId} (index ${address.fabricIndex})`
    );
    const commissioningManager = new commissioningFlowImpl(
      // Use the created secure session to do the commissioning
      new import_InteractionClient.InteractionClient(
        new import_ExchangeProvider.DedicatedChannelExchangeProvider(this.#context.exchanges, paseSecureMessageChannel),
        this.#context.clients.peers.subscriptionClient,
        address
      ),
      this.#context.ca,
      fabric,
      commissioningOptions,
      async (address2, supportsConcurrentConnections) => {
        if (!supportsConcurrentConnections) {
          await paseSecureMessageChannel.close();
        }
        if (performCaseCommissioning !== void 0) {
          await performCaseCommissioning(address2, discoveryData);
          return;
        }
        return await this.#context.clients.connect(address2, {
          discoveryOptions: {
            discoveryType: import_PeerSet.NodeDiscoveryType.TimedDiscovery,
            timeoutSeconds: 120,
            discoveryData
          },
          allowUnknownPeer: true
        });
      }
    );
    try {
      await commissioningManager.executeCommissioning();
    } catch (error) {
      await this.#context.clients.peers.delete(address);
      throw error;
    } finally {
      if (!paseSecureMessageChannel.closed) {
        await paseSecureMessageChannel.close();
      }
    }
    return address;
  }
}
//# sourceMappingURL=ControllerCommissioner.js.map
