/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { GeneralCommissioning } from "#clusters/general-commissioning";
import { NetworkCommissioning } from "#clusters/network-commissioning";
import { MatterError } from "#general";
import { ClusterId, EndpointNumber, FabricIndex, TypeFromPartialBitSchema, TypeFromSchema, VendorId } from "#types";
import { CertificateAuthority } from "../certificate/CertificateAuthority.js";
import { Fabric } from "../fabric/Fabric.js";
import { InteractionClient } from "../interaction/InteractionClient.js";
import { PeerAddress } from "./PeerAddress.js";
/**
 * User specific options for the Commissioning process
 */
export type ControllerCommissioningFlowOptions = {
    /**
     * The regulatory location (indoor or outdoor) where the device is used.
     */
    regulatoryLocation: GeneralCommissioning.RegulatoryLocationType;
    /**
     * The country where the device is used.
     */
    regulatoryCountryCode: string;
    /**
     * The vendor ID we present as a commissioner.
     */
    adminVendorId?: VendorId;
    /**
     * Required credentials if the device is to connect to a wifi network provide the credentials here.
     */
    wifiNetwork?: {
        wifiSsid: string;
        wifiCredentials: string;
    };
    /**
     * If the device should connect to a thread network.
     */
    threadNetwork?: {
        networkName: string;
        operationalDataset: string;
    };
};
/** Result code of a single commissioning step. */
declare enum CommissioningStepResultCode {
    Success = 0,
    Failure = 1,
    Skipped = 2,
    Stop = 3
}
/**
 * Result of a single commissioning step
 * Breadcrump value is stored for each step for transparency
 */
type CommissioningStepResult = {
    code: CommissioningStepResultCode;
    breadcrumb: number;
};
/**
 * Definition of one commissioning step
 * All steps are for execution sorted by stepNumber and subStepNumber
 */
type CommissioningStep = {
    /** Step Number according to the specs */
    stepNumber: number;
    /** Order of actions within a step */
    subStepNumber: number;
    /** Name of the action or step */
    name: string;
    /** Logic function to execute */
    stepLogic: () => Promise<CommissioningStepResult>;
    /** Optional flag to indicate that the failsafe timer should be rearmed in any case before this step. */
    reArmFailsafe?: boolean;
};
/** Data that are collected initially or through the commissioning process and can be used also by other steps. */
type CollectedCommissioningData = {
    basicCommissioningInfo?: TypeFromSchema<typeof GeneralCommissioning.TlvBasicCommissioningInfo>;
    productName?: string;
    networkFeatures?: {
        endpointId: number;
        value: TypeFromPartialBitSchema<typeof NetworkCommissioning.Complete.features>;
    }[];
    networkStatus?: {
        endpointId: number;
        value: TypeFromSchema<typeof NetworkCommissioning.TlvNetworkInfo>[];
    }[];
    rootPartsList?: EndpointNumber[];
    rootServerList?: ClusterId[];
    vendorId?: VendorId;
    productId?: number;
    supportsConcurrentConnection?: boolean;
    successfullyConnectedToNetwork?: boolean;
    fabricIndex?: FabricIndex;
};
/** Error that throws when Commissioning fails and process cannot be continued. */
export declare class CommissioningError extends MatterError {
}
/**
 * Class to abstract the Device commission flow in a step wise way as defined in Specs. The specs are not 100%
 */
export declare class ControllerCommissioningFlow {
    #private;
    protected interactionClient: InteractionClient;
    protected readonly ca: CertificateAuthority;
    protected readonly fabric: Fabric;
    protected readonly transitionToCase: (peerAddress: PeerAddress, supportsConcurrentConnections: boolean) => Promise<InteractionClient | undefined>;
    protected readonly commissioningOptions: ControllerCommissioningFlowOptions;
    protected readonly commissioningSteps: CommissioningStep[];
    protected readonly commissioningStepResults: Map<string, CommissioningStepResult>;
    protected lastBreadcrumb: number;
    protected collectedCommissioningData: CollectedCommissioningData;
    constructor(
    /** InteractionClient for the initiated PASE session */
    interactionClient: InteractionClient, 
    /** CertificateManager of the controller. */
    ca: CertificateAuthority, 
    /** Fabric of the controller. */
    fabric: Fabric, 
    /** Commissioning options for the commissioning process. */
    commissioningOptions: ControllerCommissioningFlowOptions, 
    /** Callback that establishes CASE connection or handles final commissioning */
    transitionToCase: (peerAddress: PeerAddress, supportsConcurrentConnections: boolean) => Promise<InteractionClient | undefined>);
    /**
     * Execute the commissioning process in the defined order. The steps are sorted before execution based on the step
     * number and sub step number.
     * If >50% of the failsafe time has passed, the failsafe timer is re-armed (50% of 60s default are 30s and each
     * action is allowed to take 30s at minimum based on specs).
     */
    executeCommissioning(): Promise<void>;
    getCommissioningStepResult(stepNumber: number, subStepNumber: number): CommissioningStepResult | undefined;
}
export {};
//# sourceMappingURL=ControllerCommissioningFlow.d.ts.map