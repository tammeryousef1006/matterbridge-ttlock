"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ControllerCommissioningFlow_exports = {};
__export(ControllerCommissioningFlow_exports, {
  CommissioningError: () => CommissioningError,
  ControllerCommissioningFlow: () => ControllerCommissioningFlow
});
module.exports = __toCommonJS(ControllerCommissioningFlow_exports);
var import_basic_information = require("#clusters/basic-information");
var import_descriptor = require("#clusters/descriptor");
var import_general_commissioning = require("#clusters/general-commissioning");
var import_network_commissioning = require("#clusters/network-commissioning");
var import_operational_credentials = require("#clusters/operational-credentials");
var import_time_synchronization = require("#clusters/time-synchronization");
var import_general = require("#general");
var import_types = require("#types");
var import_CertificateManager = require("../certificate/CertificateManager.js");
var import_ClusterClient = require("../cluster/client/ClusterClient.js");
var import_OperationalCredentialsTypes = require("../common/OperationalCredentialsTypes.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("ControllerCommissioner");
var CommissioningStepResultCode = /* @__PURE__ */ ((CommissioningStepResultCode2) => {
  CommissioningStepResultCode2[CommissioningStepResultCode2["Success"] = 0] = "Success";
  CommissioningStepResultCode2[CommissioningStepResultCode2["Failure"] = 1] = "Failure";
  CommissioningStepResultCode2[CommissioningStepResultCode2["Skipped"] = 2] = "Skipped";
  CommissioningStepResultCode2[CommissioningStepResultCode2["Stop"] = 3] = "Stop";
  return CommissioningStepResultCode2;
})(CommissioningStepResultCode || {});
class CommissioningError extends import_general.MatterError {
}
class RecoverableCommissioningError extends CommissioningError {
}
const DEFAULT_FAILSAFE_TIME_MS = 6e4;
class ControllerCommissioningFlow {
  interactionClient;
  ca;
  fabric;
  transitionToCase;
  commissioningOptions;
  commissioningSteps = new Array();
  commissioningStepResults = /* @__PURE__ */ new Map();
  #clusterClients = /* @__PURE__ */ new Map();
  #commissioningStartedTime;
  #commissioningExpiryTime;
  #lastFailSafeTime;
  lastBreadcrumb = 1;
  collectedCommissioningData = {};
  #failSafeTimeMs = DEFAULT_FAILSAFE_TIME_MS;
  constructor(interactionClient, ca, fabric, commissioningOptions, transitionToCase) {
    this.interactionClient = interactionClient;
    this.ca = ca;
    this.fabric = fabric;
    this.transitionToCase = transitionToCase;
    this.commissioningOptions = commissioningOptions;
    logger.debug(`Commissioning options: ${import_general.Diagnostic.json(commissioningOptions)}`);
    this.#initializeCommissioningSteps();
  }
  /**
   * Execute the commissioning process in the defined order. The steps are sorted before execution based on the step
   * number and sub step number.
   * If >50% of the failsafe time has passed, the failsafe timer is re-armed (50% of 60s default are 30s and each
   * action is allowed to take 30s at minimum based on specs).
   */
  async executeCommissioning() {
    this.#sortSteps();
    let failSafeTimerReArmedAfterPreviousStep = false;
    for (const step of this.commissioningSteps) {
      logger.info(`Executing commissioning step ${step.stepNumber}.${step.subStepNumber}: ${step.name}`);
      try {
        if (step.reArmFailsafe && !failSafeTimerReArmedAfterPreviousStep) {
          logger.debug(`Re-Arming failsafe timer before executing step`);
          await this.#armFailsafe();
        }
        failSafeTimerReArmedAfterPreviousStep = false;
        const result = await step.stepLogic();
        this.#setCommissioningStepResult(step, result);
        if (this.#lastFailSafeTime !== void 0) {
          const timeSinceLastArmFailsafe = import_general.Time.nowMs() - this.#lastFailSafeTime;
          if (this.#commissioningExpiryTime !== void 0 && import_general.Time.nowMs() > this.#commissioningExpiryTime) {
            logger.error(
              `Commissioning step ${step.stepNumber}.${step.subStepNumber}: ${step.name} succeeded, but commissioning took too long in general!`
            );
            throw new CommissioningError(`Commissioning took too long!`);
          }
          if (timeSinceLastArmFailsafe > this.#failSafeTimeMs / 2) {
            logger.info(
              `After Commissioning step ${step.stepNumber}.${step.subStepNumber}: ${step.name} succeeded, ${Math.floor(
                timeSinceLastArmFailsafe / 1e3
              )}s elapsed since last arm failsafe, re-arming failsafe`
            );
            await this.#armFailsafe();
            failSafeTimerReArmedAfterPreviousStep = true;
          }
        }
        if (result.code === 3 /* Stop */) {
          break;
        }
      } catch (error) {
        if (error instanceof RecoverableCommissioningError) {
          logger.error(
            `Commissioning step ${step.stepNumber}.${step.subStepNumber}: ${step.name} failed with recoverable error: ${error.message} ... Continuing with process`
          );
        } else if (error instanceof CommissioningError || error instanceof import_types.StatusResponseError) {
          logger.error(
            `Commissioning step ${step.stepNumber}.${step.subStepNumber}: ${step.name} failed with error: ${error.message} ... Aborting commissioning`
          );
          await this.#resetFailsafeTimer();
          import_types.StatusResponseError.accept(error);
          throw (0, import_general.repackErrorAs)(error, CommissioningError);
        } else {
          throw error;
        }
      }
    }
  }
  /**
   * Helper method to create ClusterClients. If not feature specific and for the Root Endpoint they are also reused.
   */
  #getClusterClient(cluster, endpointId = (0, import_types.EndpointNumber)(0), isFeatureSpecific = false) {
    if (!isFeatureSpecific && endpointId === 0) {
      const clusterClient = this.#clusterClients.get(cluster.id);
      if (clusterClient !== void 0) {
        logger.debug(
          `Returning existing cluster client for cluster ${cluster.name} (endpoint ${endpointId}, isFeatureSpecific ${isFeatureSpecific})`
        );
        return clusterClient;
      }
    }
    logger.debug(
      `Creating new cluster client for cluster ${cluster.name} (endpoint ${endpointId}, isFeatureSpecific ${isFeatureSpecific})`
    );
    const client = (0, import_ClusterClient.ClusterClient)(cluster, endpointId, this.interactionClient);
    this.#clusterClients.set(cluster.id, client);
    return client;
  }
  /**
   * Initialize commissioning steps and add them in the default order as defined by
   * @see {@link MatterSpecification.v13.Core} § 5.5
   */
  #initializeCommissioningSteps() {
    this.commissioningSteps.push({
      stepNumber: 0,
      // Preparation
      subStepNumber: 1,
      name: "GetInitialData",
      stepLogic: () => this.#getInitialData()
    });
    this.commissioningSteps.push({
      stepNumber: 7,
      subStepNumber: 1,
      name: "GeneralCommissioning.ArmFailsafe",
      stepLogic: () => this.#armFailsafe()
    });
    this.commissioningSteps.push({
      stepNumber: 8,
      subStepNumber: 1,
      name: "GeneralCommissioning.ConfigureRegulatoryInformation",
      stepLogic: () => this.#configureRegulatoryInformation()
    });
    this.commissioningSteps.push({
      stepNumber: 8,
      subStepNumber: 2,
      name: "TimeSynchronization.SynchronizeTime",
      stepLogic: () => this.#synchronizeTime()
    });
    this.commissioningSteps.push({
      stepNumber: 10,
      subStepNumber: 1,
      name: "OperationalCredentials.DeviceAttestation",
      stepLogic: () => this.#deviceAttestation()
    });
    this.commissioningSteps.push({
      stepNumber: 11,
      // includes 11-13
      subStepNumber: 1,
      name: "OperationalCredentials.Certificates",
      stepLogic: () => this.#certificates()
    });
    this.commissioningSteps.push({
      stepNumber: 15,
      subStepNumber: 1,
      name: "AccessControl",
      stepLogic: () => this.#configureAccessControlLists()
    });
    if (this.interactionClient.channelType === import_general.ChannelType.BLE) {
      this.commissioningSteps.push({
        stepNumber: 16,
        subStepNumber: 1,
        name: "NetworkCommissioning.Validate",
        stepLogic: () => this.#validateNetwork()
      });
      if (this.commissioningOptions.wifiNetwork !== void 0) {
        this.commissioningSteps.push({
          stepNumber: 16,
          // includes step 17
          subStepNumber: 2,
          name: "NetworkCommissioning.Wifi",
          reArmFailsafe: true,
          stepLogic: () => this.#configureNetworkWifi()
        });
      }
      if (this.commissioningOptions.threadNetwork !== void 0) {
        this.commissioningSteps.push({
          stepNumber: 16,
          // includes step 17
          subStepNumber: 3,
          name: "NetworkCommissioning.Thread",
          reArmFailsafe: true,
          stepLogic: () => this.#configureNetworkThread()
        });
      }
    } else {
      logger.info(
        `Skipping NetworkCommissioning steps because the device is already on IP network (${this.interactionClient.channelType})`
      );
    }
    this.commissioningSteps.push({
      stepNumber: 18,
      // includes step 19 (CASE connection)
      subStepNumber: 1,
      name: "Reconnect",
      reArmFailsafe: true,
      stepLogic: () => this.#reconnectWithDevice()
    });
    this.commissioningSteps.push({
      stepNumber: 20,
      subStepNumber: 1,
      name: "GeneralCommissioning.Complete",
      stepLogic: () => this.#completeCommissioning()
    });
    this.commissioningSteps.push({
      stepNumber: 99,
      // Should be allowed in Step 13, but Tasmota is not supporting this
      subStepNumber: 1,
      name: "OperationalCredentials.UpdateFabricLabel",
      stepLogic: () => this.#updateFabricLabel()
    });
  }
  #sortSteps() {
    this.commissioningSteps.sort((a, b) => {
      if (a.stepNumber !== b.stepNumber) return a.stepNumber - b.stepNumber;
      return a.subStepNumber - b.subStepNumber;
    });
  }
  #setCommissioningStepResult(step, result) {
    this.commissioningStepResults.set(`${step.stepNumber}-${step.subStepNumber}`, result);
  }
  getCommissioningStepResult(stepNumber, subStepNumber) {
    return this.commissioningStepResults.get(`${stepNumber}-${subStepNumber}`);
  }
  /** Helper method to check for errorCode/debugTest responses and throw error on failure */
  #ensureOperationalCredentialsSuccess(context, { statusCode, debugText, fabricIndex }) {
    logger.debug(
      `Commissioning step ${context} returned ${statusCode}, ${debugText}${fabricIndex !== void 0 ? `, fabricIndex: ${fabricIndex}` : ""}`
    );
    if (statusCode === import_operational_credentials.OperationalCredentials.NodeOperationalCertStatus.Ok) return;
    if (context === "addNoc" && statusCode === import_operational_credentials.OperationalCredentials.NodeOperationalCertStatus.FabricConflict) {
      throw new CommissioningError(
        `Commission error: This device is already commissioned into this fabric. You can not commission it again.`
      );
    }
    throw new CommissioningError(
      `Commission error for "${context}": ${statusCode}, ${debugText}${fabricIndex !== void 0 ? `, fabricIndex: ${fabricIndex}` : ""}`
    );
  }
  /** Helper method to check for errorCode/debugTest responses and throw error on failure */
  #ensureGeneralCommissioningSuccess(context, { errorCode, debugText }) {
    logger.debug(`Commissioning step ${context} returned ${errorCode}, ${debugText}`);
    if (errorCode === import_general_commissioning.GeneralCommissioning.CommissioningError.Ok) return;
    throw new CommissioningError(
      `Commission error for "${context}": ${errorCode}${debugText ? `, ${debugText}` : ""}`
    );
  }
  /**
   * Initial Step to receive some common data used by other steps
   */
  async #getInitialData() {
    const descriptorClient = this.#getClusterClient(import_descriptor.Descriptor.Cluster);
    this.collectedCommissioningData.rootPartsList = await descriptorClient.getPartsListAttribute();
    this.collectedCommissioningData.rootServerList = await descriptorClient.getServerListAttribute();
    const networkData = await this.interactionClient.getMultipleAttributes({
      attributes: [
        {
          clusterId: import_network_commissioning.NetworkCommissioning.Complete.id,
          attributeId: import_network_commissioning.NetworkCommissioning.Complete.attributes.featureMap.id
        },
        {
          clusterId: import_network_commissioning.NetworkCommissioning.Complete.id,
          attributeId: import_network_commissioning.NetworkCommissioning.Complete.attributes.networks.id
        }
      ]
    });
    const networkFeatures = new Array();
    const networkStatus = new Array();
    for (const {
      path: { endpointId, attributeId },
      value
    } of networkData) {
      if (attributeId === import_network_commissioning.NetworkCommissioning.Complete.attributes.featureMap.id) {
        networkFeatures.push({ endpointId, value });
      } else if (attributeId === import_network_commissioning.NetworkCommissioning.Complete.attributes.networks.id) {
        networkStatus.push({ endpointId, value });
      }
    }
    this.collectedCommissioningData.networkFeatures = networkFeatures;
    this.collectedCommissioningData.networkStatus = networkStatus;
    const basicInfoClient = this.#getClusterClient(import_basic_information.BasicInformation.Cluster);
    this.collectedCommissioningData.vendorId = await basicInfoClient.getVendorIdAttribute();
    this.collectedCommissioningData.productId = await basicInfoClient.getProductIdAttribute();
    this.collectedCommissioningData.productName = await basicInfoClient.getProductNameAttribute();
    const generalCommissioningClient = this.#getClusterClient(import_general_commissioning.GeneralCommissioning.Cluster);
    this.collectedCommissioningData.supportsConcurrentConnection = await generalCommissioningClient.getSupportsConcurrentConnectionAttribute();
    return {
      code: 0 /* Success */,
      breadcrumb: this.lastBreadcrumb
    };
  }
  /**
   * Step 7
   * Commissioner SHALL re-arm the Fail-safe timer on the Commissionee to the desired commissioning
   * timeout within 60 seconds of the completion of PASE session establishment, using the
   * ArmFailSafe command (see Section 11.10.6.2, “ArmFailSafe Command”). A Commissioner MAY
   * obtain device information including guidance on the fail-safe value from the Commissionee by
   * reading BasicCommissioningInfo attribute (see Section 11.10.5.2, “BasicCommissioningInfo
   * Attribute”) prior to invoking the ArmFailSafe command.
   */
  async #armFailsafe() {
    const client = this.#getClusterClient(import_general_commissioning.GeneralCommissioning.Cluster);
    if (this.collectedCommissioningData.basicCommissioningInfo === void 0) {
      const basicCommissioningInfo = await client.getBasicCommissioningInfoAttribute();
      this.collectedCommissioningData.basicCommissioningInfo = basicCommissioningInfo;
      this.#failSafeTimeMs = basicCommissioningInfo.failSafeExpiryLengthSeconds * 1e3;
      this.#commissioningStartedTime = import_general.Time.nowMs();
      this.#commissioningExpiryTime = this.#commissioningStartedTime + basicCommissioningInfo.maxCumulativeFailsafeSeconds * 1e3;
    }
    this.#ensureGeneralCommissioningSuccess(
      "armFailSafe",
      await client.armFailSafe({
        breadcrumb: this.lastBreadcrumb,
        expiryLengthSeconds: this.collectedCommissioningData.basicCommissioningInfo?.failSafeExpiryLengthSeconds
      })
    );
    this.#lastFailSafeTime = import_general.Time.nowMs();
    return {
      code: 0 /* Success */,
      breadcrumb: this.lastBreadcrumb
    };
  }
  async #resetFailsafeTimer() {
    if (this.#lastFailSafeTime === void 0) return;
    try {
      const client = this.#getClusterClient(import_general_commissioning.GeneralCommissioning.Cluster);
      await client.armFailSafe({
        breadcrumb: this.lastBreadcrumb,
        expiryLengthSeconds: 0
      });
      this.#lastFailSafeTime = void 0;
    } catch (error) {
      logger.error(`Error while resetting failsafe timer`, error);
    }
  }
  /**
   * Step 8 - 1
   * Commissioner SHALL configure regulatory information if the Commissionee has at least one instance of
   * the Network Commissioning cluster on any endpoint with either the WI (i.e. Wi-Fi) or TH (i.e. Thread)
   * feature flags set in its FeatureMap, Commissioner SHALL configure regulatory information in the
   * Commissionee using the SetRegulatoryConfig command.
   */
  async #configureRegulatoryInformation() {
    if (this.collectedCommissioningData.networkFeatures === void 0) {
      throw new CommissioningError("No network features collected. This should never happen.");
    }
    const hasRadioNetwork = this.collectedCommissioningData.networkFeatures.some(
      ({ value: { wiFiNetworkInterface, threadNetworkInterface } }) => wiFiNetworkInterface || threadNetworkInterface
    );
    if (hasRadioNetwork) {
      const client = this.#getClusterClient(import_general_commissioning.GeneralCommissioning.Cluster);
      let locationCapability = await client.getLocationCapabilityAttribute();
      if (locationCapability === import_general_commissioning.GeneralCommissioning.RegulatoryLocationType.IndoorOutdoor) {
        locationCapability = this.commissioningOptions.regulatoryLocation;
      } else {
        logger.debug(
          `Device does not support a configurable regulatory location type. Location is set to "${locationCapability === import_general_commissioning.GeneralCommissioning.RegulatoryLocationType.Indoor ? "Indoor" : "Outdoor"}"`
        );
      }
      let countryCode = this.commissioningOptions.regulatoryCountryCode;
      const regulatoryResult = await client.setRegulatoryConfig(
        {
          breadcrumb: this.lastBreadcrumb++,
          newRegulatoryConfig: locationCapability,
          countryCode
        },
        { useExtendedFailSafeMessageResponseTimeout: true }
      );
      if (regulatoryResult.errorCode === import_general_commissioning.GeneralCommissioning.CommissioningError.ValueOutsideRange && countryCode !== "XX") {
        logger.debug(
          `Device does not support a configurable country code. Use "XX" instead of "${countryCode}"`
        );
        countryCode = "XX";
        this.#ensureGeneralCommissioningSuccess(
          "setRegulatoryConfig",
          await client.setRegulatoryConfig(
            {
              breadcrumb: this.lastBreadcrumb,
              newRegulatoryConfig: locationCapability,
              countryCode
            },
            { useExtendedFailSafeMessageResponseTimeout: true }
          )
        );
      } else {
        this.#ensureGeneralCommissioningSuccess("setRegulatoryConfig", regulatoryResult);
      }
      return {
        code: 0 /* Success */,
        breadcrumb: this.lastBreadcrumb
      };
    }
    return {
      code: 2 /* Skipped */,
      breadcrumb: this.lastBreadcrumb
    };
  }
  /**
   * Step 8 - 2
   * Commissioner SHOULD configure UTC time, timezone, and DST offset, if the Commissionee supports the
   * time synchronization cluster.
   * ▪ The Commissioner SHOULD configure UTC time using the SetUTCTime command.
   * ▪ The Commissioner SHOULD set the time zone using the SetTimeZone command, if the TimeZone Feature is supported.
   * ▪ The Commissioner SHOULD set the DST offsets using the SetDSTOffset command if the TimeZone Feature is supported, and the SetTimeZoneResponse from the Commissionee had the DSTOffsetsRequired field set to True.
   * ▪ The Commissioner SHOULD set a Default NTP server using the SetDefaultNTP command if the NTPClient Feature is supported and the DefaultNTP attribute is null. If the current value is non-null, Commissioners MAY opt to overwrite the current value.
   */
  async #synchronizeTime() {
    if (this.collectedCommissioningData.rootServerList !== void 0 && this.collectedCommissioningData.rootServerList.find(
      (clusterId) => clusterId === import_time_synchronization.TimeSynchronizationCluster.id
    )) {
      logger.debug("TimeSynchronization cluster is supported");
    }
    return {
      code: 2 /* Skipped */,
      breadcrumb: this.lastBreadcrumb
    };
  }
  /**
   * Step 10
   * Commissioner SHALL establish the authenticity of the Commissionee as a certified Matter device
   * (see Section 6.2.3, “Device Attestation Procedure”).
   */
  async #deviceAttestation() {
    const operationalCredentialsClusterClient = this.#getClusterClient(import_operational_credentials.OperationalCredentials.Cluster);
    const { certificate: deviceAttestation } = await operationalCredentialsClusterClient.certificateChainRequest(
      {
        certificateType: import_operational_credentials.OperationalCredentials.CertificateChainType.DacCertificate
      },
      { useExtendedFailSafeMessageResponseTimeout: true }
    );
    const { certificate: productAttestation } = await operationalCredentialsClusterClient.certificateChainRequest(
      {
        certificateType: import_operational_credentials.OperationalCredentials.CertificateChainType.PaiCertificate
      },
      { useExtendedFailSafeMessageResponseTimeout: true }
    );
    const { attestationElements, attestationSignature } = await operationalCredentialsClusterClient.attestationRequest(
      {
        attestationNonce: import_general.Crypto.getRandomData(32)
      },
      { useExtendedFailSafeMessageResponseTimeout: true }
    );
    if (deviceAttestation.length === 0 || productAttestation.length === 0 || attestationElements.length === 0 || attestationSignature.length === 0) {
      throw new CommissioningError("Device Attestation data missing from device");
    }
    return {
      code: 0 /* Success */,
      breadcrumb: this.lastBreadcrumb
    };
  }
  /**
   * Step 11-13
   * 11: Following the Device Attestation Procedure yielding a decision to proceed with commissioning, the Commissioner
   *     SHALL request operational CSR from Commissionee using the CSRRequest command (see Section 11.17.6.5,
   *     “CSRRequest Command”). The CSRRequest command will cause the generation of a new operational key pair at the
   *     Commissionee.
   * 12: Commissioner SHALL generate or otherwise obtain an Operational Certificate containing Operational ID after
   *     receiving the CSRResponse command from the Commissionee (see Section 11.17.6.5, “CSRRequest Command”), using
   *     implementation-specific means.
   * 13: Commissioner SHALL install operational credentials (see Figure 40, “Node Operational Credentials
   *     flow”) on the Commissionee using the AddTrustedRootCertificate and AddNOC commands,
   *     and SHALL use the UpdateFabricLabel command to set a string that the user can recognize and
   *     relate to this Commissioner/Administrator.
   *     The AdminVendorId field of the AddNOC command SHALL be set to a value for which the Vendor Schema in
   *     DCL contains the name and other information of the Commissioner’s manufacturer.
   */
  async #certificates() {
    const operationalCredentialsClusterClient = this.#getClusterClient(import_operational_credentials.OperationalCredentials.Cluster);
    const { nocsrElements, attestationSignature: csrSignature } = await operationalCredentialsClusterClient.csrRequest(
      { csrNonce: import_general.Crypto.getRandomData(32) },
      { useExtendedFailSafeMessageResponseTimeout: true }
    );
    if (nocsrElements.length === 0 || csrSignature.length === 0) {
      throw new import_general.UnexpectedDataError("Invalid response from device");
    }
    const { certSigningRequest } = import_OperationalCredentialsTypes.TlvCertSigningRequest.decode(nocsrElements);
    const operationalPublicKey = import_CertificateManager.CertificateManager.getPublicKeyFromCsr(certSigningRequest);
    await operationalCredentialsClusterClient.addTrustedRootCertificate(
      {
        rootCaCertificate: this.ca.rootCert
      },
      { useExtendedFailSafeMessageResponseTimeout: true }
    );
    const peerOperationalCert = this.ca.generateNoc(
      operationalPublicKey,
      this.fabric.fabricId,
      this.interactionClient.address.nodeId
    );
    const addNocResponse = await operationalCredentialsClusterClient.addNoc(
      {
        nocValue: peerOperationalCert,
        icacValue: new Uint8Array(0),
        ipkValue: this.fabric.identityProtectionKey,
        adminVendorId: this.fabric.rootVendorId,
        caseAdminSubject: this.fabric.rootNodeId
      },
      { useExtendedFailSafeMessageResponseTimeout: true }
    );
    this.#ensureOperationalCredentialsSuccess("addNoc", addNocResponse);
    const { fabricIndex } = addNocResponse;
    this.collectedCommissioningData.fabricIndex = fabricIndex;
    return {
      code: 0 /* Success */,
      breadcrumb: this.lastBreadcrumb
    };
  }
  /**
   * Step 13-2 (we do as 99 at the end because)
   * The Administrator having established a CASE session with the Commissionee over the operational network in the
   * previous steps SHALL invoke the CommissioningComplete command (see Section 11.9.6.6,
   * “CommissioningComplete Command”). A success response after invocation of the CommissioningComplete command ends
   * the commissioning process.
   */
  async #updateFabricLabel() {
    const { fabricIndex } = this.collectedCommissioningData;
    if (fabricIndex === void 0) {
      logger.error("No fabric index available after addNoc. This should never happen.");
      return {
        code: 1 /* Failure */,
        breadcrumb: this.lastBreadcrumb
      };
    }
    const operationalCredentialCluster = this.#getClusterClient(import_operational_credentials.OperationalCredentials.Cluster);
    try {
      this.#ensureOperationalCredentialsSuccess(
        "updateFabricLabel",
        await operationalCredentialCluster.updateFabricLabel({
          label: this.fabric.label,
          fabricIndex
        })
      );
    } catch (error) {
      throw (0, import_general.repackErrorAs)(error, RecoverableCommissioningError);
    }
    return {
      code: 0 /* Success */,
      breadcrumb: this.lastBreadcrumb
    };
  }
  /**
   * Step 15
   * Commissioner MAY configure the Access Control List (see Access Control Cluster) on the Commissionee in any way
   * it sees fit, if the singular entry added by the AddNOC command in the previous step granting Administer
   * privilege over CASE authentication type for the Node ID provided with the command is not sufficient to express
   * its desired access control policies.
   */
  async #configureAccessControlLists() {
    return {
      code: 2 /* Skipped */,
      breadcrumb: this.lastBreadcrumb
    };
  }
  /**
   * Step 16-17
   * 16: If the Commissionee both supports it and requires it, the Commissioner SHALL configure the operational network
   *     at the Commissionee using commands such as AddOrUpdateWiFiNetwork (see Section 11.8.7.3, “AddOrUpdateWiFiNetwork
   *     Command”) and AddOrUpdateThreadNetwork (see Section 11.8.7.4, “AddOrUpdateThreadNetwork Command”).
   *     A Commissionee requires network commissioning if it is not already on the desired operational network.
   *     A Commissionee supports network commissioning if it has any NetworkCommissioning cluster instances.
   *     A Commissioner MAY learn about the networks visible to the Commissionee using ScanNetworks command
   *     (see Section 11.8.7.1, “ScanNetworks Command”).
   * 17: The Commissioner SHALL trigger the Commissionee to connect to the operational network using ConnectNetwork
   *     command (see Section 11.8.7.9, “ConnectNetwork Command”) unless the Commissionee is already on the desired
   *     operational network.
   */
  async #validateNetwork() {
    if (this.collectedCommissioningData.networkFeatures === void 0 || this.collectedCommissioningData.networkStatus === void 0) {
      throw new CommissioningError("No network features or status collected. This should never happen.");
    }
    if ((this.commissioningOptions.wifiNetwork === void 0 || !this.commissioningOptions.wifiNetwork.wifiSsid || !this.commissioningOptions.wifiNetwork.wifiCredentials) && (this.commissioningOptions.threadNetwork === void 0 || !this.commissioningOptions.threadNetwork.networkName || !this.commissioningOptions.threadNetwork.operationalDataset)) {
      const anyEthernetInterface = this.collectedCommissioningData.networkFeatures.length === 0 || this.collectedCommissioningData.networkFeatures.some(
        ({ value: { ethernetNetworkInterface } }) => ethernetNetworkInterface === true
      );
      const anyInterfaceConnected = this.collectedCommissioningData.networkStatus.length === 0 || this.collectedCommissioningData.networkStatus.some(
        ({ value }) => value.some(({ connected }) => connected)
      );
      if (!anyEthernetInterface && !anyInterfaceConnected) {
        throw new CommissioningError(
          "No Wi-Fi/Thread network credentials are configured for commissioning and no Ethernet interface is available on the device and no interface already connected."
        );
      }
    }
    return {
      code: 0 /* Success */,
      breadcrumb: this.lastBreadcrumb
    };
  }
  async #configureNetworkWifi() {
    if (this.commissioningOptions.wifiNetwork === void 0) {
      logger.debug("WiFi network is not configured");
      return {
        code: 2 /* Skipped */,
        breadcrumb: this.lastBreadcrumb
      };
    }
    if (this.collectedCommissioningData.networkFeatures !== void 0 && this.collectedCommissioningData.networkStatus !== void 0) {
      const rootNetworkFeatures = this.collectedCommissioningData.networkFeatures.find(
        ({ endpointId }) => endpointId === 0
      )?.value;
      const rootNetworkStatus = this.collectedCommissioningData.networkStatus.find(
        ({ endpointId }) => endpointId === 0
      )?.value;
      logger.debug(
        `Root Networks found: ${import_general.Diagnostic.json(rootNetworkFeatures)} - ${import_general.Diagnostic.json(rootNetworkStatus)}`
      );
      if (rootNetworkFeatures?.wiFiNetworkInterface !== true) {
        logger.debug("Commissionee does not support any WiFi network interface");
        return {
          code: 2 /* Skipped */,
          breadcrumb: this.lastBreadcrumb
        };
      }
      if (rootNetworkStatus !== void 0 && rootNetworkStatus.length > 0 && rootNetworkStatus[0].connected) {
        logger.debug("Commissionee is already connected to the WiFi network");
        this.collectedCommissioningData.successfullyConnectedToNetwork = true;
        return {
          code: 2 /* Skipped */,
          breadcrumb: this.lastBreadcrumb
        };
      }
    }
    logger.debug("Configuring WiFi network ...");
    const networkCommissioningClusterClient = this.#getClusterClient(
      import_network_commissioning.NetworkCommissioning.Cluster.with("WiFiNetworkInterface"),
      (0, import_types.EndpointNumber)(0),
      true
    );
    const ssid = import_general.Bytes.fromString(this.commissioningOptions.wifiNetwork.wifiSsid);
    const credentials = import_general.Bytes.fromString(this.commissioningOptions.wifiNetwork.wifiCredentials);
    const { networkingStatus, wiFiScanResults, debugText } = await networkCommissioningClusterClient.scanNetworks(
      {
        ssid,
        breadcrumb: this.lastBreadcrumb++
      },
      { useExtendedFailSafeMessageResponseTimeout: true }
    );
    if (networkingStatus !== import_network_commissioning.NetworkCommissioning.NetworkCommissioningStatus.Success) {
      throw new CommissioningError(`Commissionee failed to scan for WiFi networks: ${debugText}`);
    }
    if (wiFiScanResults === void 0 || wiFiScanResults.length === 0) {
      throw new CommissioningError(
        `Commissionee did not return any WiFi networks for the requested SSID ${this.commissioningOptions.wifiNetwork.wifiSsid}`
      );
    }
    const {
      networkingStatus: addNetworkingStatus,
      debugText: addDebugText,
      networkIndex
    } = await networkCommissioningClusterClient.addOrUpdateWiFiNetwork(
      {
        ssid,
        credentials,
        breadcrumb: this.lastBreadcrumb++
      },
      { useExtendedFailSafeMessageResponseTimeout: true }
    );
    if (addNetworkingStatus !== import_network_commissioning.NetworkCommissioning.NetworkCommissioningStatus.Success) {
      throw new CommissioningError(`Commissionee failed to add WiFi network: ${addDebugText}`);
    }
    if (networkIndex === void 0) {
      throw new CommissioningError(`Commissionee did not return network index`);
    }
    logger.debug(
      `Commissionee added WiFi network ${this.commissioningOptions.wifiNetwork.wifiSsid} with network index ${networkIndex}`
    );
    const updatedNetworks = await networkCommissioningClusterClient.getNetworksAttribute();
    if (updatedNetworks[networkIndex] === void 0) {
      throw new CommissioningError(`Commissionee did not return network with index ${networkIndex}`);
    }
    const { networkId, connected } = updatedNetworks[networkIndex];
    if (connected) {
      this.collectedCommissioningData.successfullyConnectedToNetwork = true;
      logger.debug(
        `Commissionee is already connected to WiFi network ${this.commissioningOptions.wifiNetwork.wifiSsid} (networkId ${import_general.Bytes.toHex(networkId)})`
      );
      return {
        code: 0 /* Success */,
        breadcrumb: this.lastBreadcrumb
      };
    }
    const connectResult = await networkCommissioningClusterClient.connectNetwork(
      {
        networkId,
        breadcrumb: this.lastBreadcrumb++
      },
      { useExtendedFailSafeMessageResponseTimeout: true }
    );
    if (connectResult.networkingStatus !== import_network_commissioning.NetworkCommissioning.NetworkCommissioningStatus.Success) {
      throw new CommissioningError(`Commissionee failed to connect to WiFi network: ${connectResult.debugText}`);
    }
    this.collectedCommissioningData.successfullyConnectedToNetwork = true;
    logger.debug(
      `Commissionee successfully connected to WiFi network ${this.commissioningOptions.wifiNetwork.wifiSsid} (networkId ${import_general.Bytes.toHex(networkId)})`
    );
    return {
      code: 0 /* Success */,
      breadcrumb: this.lastBreadcrumb
    };
  }
  async #configureNetworkThread() {
    if (this.collectedCommissioningData.successfullyConnectedToNetwork) {
      logger.info("Node is already connected to a network. Skipping Thread configuration.");
      return {
        code: 2 /* Skipped */,
        breadcrumb: this.lastBreadcrumb
      };
    }
    if (this.commissioningOptions.threadNetwork === void 0) {
      logger.debug("Thread network is not configured");
      return {
        code: 2 /* Skipped */,
        breadcrumb: this.lastBreadcrumb
      };
    }
    if (this.collectedCommissioningData.networkFeatures !== void 0 && this.collectedCommissioningData.networkStatus !== void 0) {
      const rootNetworkFeatures = this.collectedCommissioningData.networkFeatures.find(
        ({ endpointId }) => endpointId === 0
      )?.value;
      const rootNetworkStatus = this.collectedCommissioningData.networkStatus.find(
        ({ endpointId }) => endpointId === 0
      )?.value;
      logger.debug(
        `Root Networks found: ${import_general.Diagnostic.json(rootNetworkFeatures)} - ${import_general.Diagnostic.json(rootNetworkStatus)}`
      );
      if (rootNetworkFeatures?.threadNetworkInterface !== true) {
        logger.debug("Commissionee does not support any Thread network interface");
        return {
          code: 2 /* Skipped */,
          breadcrumb: this.lastBreadcrumb
        };
      }
      if (rootNetworkStatus !== void 0 && rootNetworkStatus.length > 0 && rootNetworkStatus[0].connected) {
        logger.debug("Commissionee is already connected to the Thread network");
        return {
          code: 2 /* Skipped */,
          breadcrumb: this.lastBreadcrumb
        };
      }
    }
    logger.debug("Configuring Thread network ...");
    const networkCommissioningClusterClient = this.#getClusterClient(
      import_network_commissioning.NetworkCommissioning.Cluster.with("ThreadNetworkInterface"),
      (0, import_types.EndpointNumber)(0),
      true
    );
    const { networkingStatus, threadScanResults, debugText } = await networkCommissioningClusterClient.scanNetworks(
      { breadcrumb: this.lastBreadcrumb++ },
      { useExtendedFailSafeMessageResponseTimeout: true }
    );
    if (networkingStatus !== import_network_commissioning.NetworkCommissioning.NetworkCommissioningStatus.Success) {
      throw new CommissioningError(`Commissionee failed to scan for Thread networks: ${debugText}`);
    }
    if (threadScanResults === void 0 || threadScanResults.length === 0) {
      throw new CommissioningError(
        `Commissionee did not return any Thread networks for the requested Network ${this.commissioningOptions.threadNetwork.networkName}`
      );
    }
    const wantedNetworkFound = threadScanResults.find(
      ({ networkName }) => networkName === this.commissioningOptions.threadNetwork?.networkName
    );
    if (wantedNetworkFound === void 0) {
      throw new CommissioningError(
        `Commissionee did not return the requested Network ${this.commissioningOptions.threadNetwork.networkName}: ${import_general.Diagnostic.json(threadScanResults)}`
      );
    }
    logger.debug(
      `Commissionee found wanted Thread network ${this.commissioningOptions.threadNetwork.networkName}: ${import_general.Diagnostic.json(wantedNetworkFound)}`
    );
    const {
      networkingStatus: addNetworkingStatus,
      debugText: addDebugText,
      networkIndex
    } = await networkCommissioningClusterClient.addOrUpdateThreadNetwork(
      {
        operationalDataset: import_general.Bytes.fromHex(this.commissioningOptions.threadNetwork.operationalDataset),
        breadcrumb: this.lastBreadcrumb++
      },
      { useExtendedFailSafeMessageResponseTimeout: true }
    );
    if (addNetworkingStatus !== import_network_commissioning.NetworkCommissioning.NetworkCommissioningStatus.Success) {
      throw new CommissioningError(`Commissionee failed to add Thread network: ${addDebugText}`);
    }
    if (networkIndex === void 0) {
      throw new CommissioningError(`Commissionee did not return network index`);
    }
    logger.debug(
      `Commissionee added Thread network ${this.commissioningOptions.threadNetwork.networkName} with network index ${networkIndex}`
    );
    const updatedNetworks = await networkCommissioningClusterClient.getNetworksAttribute();
    if (updatedNetworks[networkIndex] === void 0) {
      throw new CommissioningError(`Commissionee did not return network with index ${networkIndex}`);
    }
    const { networkId, connected } = updatedNetworks[networkIndex];
    if (connected) {
      logger.debug(
        `Commissionee is already connected to Thread network ${this.commissioningOptions.threadNetwork.networkName} (networkId ${import_general.Bytes.toHex(networkId)})`
      );
      return {
        code: 0 /* Success */,
        breadcrumb: this.lastBreadcrumb
      };
    }
    const connectResult = await networkCommissioningClusterClient.connectNetwork(
      {
        networkId,
        breadcrumb: this.lastBreadcrumb++
      },
      { useExtendedFailSafeMessageResponseTimeout: true }
    );
    if (connectResult.networkingStatus !== import_network_commissioning.NetworkCommissioning.NetworkCommissioningStatus.Success) {
      throw new CommissioningError(
        `Commissionee failed to connect to Thread network: ${connectResult.debugText}`
      );
    }
    logger.debug(
      `Commissionee successfully connected to Thread network ${this.commissioningOptions.threadNetwork.networkName} (networkId ${import_general.Bytes.toHex(networkId)})`
    );
    return {
      code: 0 /* Success */,
      breadcrumb: this.lastBreadcrumb
    };
  }
  /**
   * Step 18-19
   * 18: Finalization of the Commissioning process begins. An Administrator configured in the ACL of the Commissionee
   *     by the Commissioner SHALL use Operational Discovery to discover the Commissionee. This Administrator MAY be
   *     the Commissioner itself, or another Node to which the Commissioner has delegated the task.
   * 19: The Administrator SHALL open a CASE (see Section 4.13.2, “Certificate Authenticated Session Establishment
   *     (CASE)”) session with the Commissionee over the operational network.
   */
  async #reconnectWithDevice() {
    const isConcurrentFlow = this.collectedCommissioningData.supportsConcurrentConnection !== false;
    logger.debug(`Reconnecting with device with ${isConcurrentFlow ? "concurrent" : "non-concurrent"} flow ...`);
    const reArmFailsafeInterval = import_general.Time.getPeriodicTimer(
      "Re-Arm Failsafe during reconnect",
      this.#failSafeTimeMs / 2,
      () => {
        const now = import_general.Time.nowMs();
        if (this.#commissioningExpiryTime !== void 0 && now < this.#commissioningExpiryTime) {
          logger.error(
            `Re-Arm Failsafe Timer during reconnect with device. Time left: ${Math.round((this.#commissioningExpiryTime - now) / 1e3)}s`
          );
          this.#armFailsafe().catch((error) => {
            logger.error("Error while re-arming failsafe during reconnect", error);
            reArmFailsafeInterval.stop();
          });
        } else {
          reArmFailsafeInterval.stop();
        }
      }
    );
    if (isConcurrentFlow) {
      reArmFailsafeInterval.start();
    }
    const transitionResult = await this.transitionToCase(
      this.interactionClient.address,
      // Assume concurrent connections are supported if not know (which should not be the case when we came here)
      isConcurrentFlow
    );
    reArmFailsafeInterval.stop();
    if (transitionResult === void 0) {
      logger.debug("CASE commissioning handled externally, terminating commissioning flow");
      return {
        code: 3 /* Stop */,
        breadcrumb: this.lastBreadcrumb
      };
    }
    this.interactionClient = transitionResult;
    this.#clusterClients.clear();
    logger.debug("Successfully reconnected with device ...");
    return {
      code: 0 /* Success */,
      breadcrumb: this.lastBreadcrumb
    };
  }
  /**
   * Step 20
   * The Administrator having established a CASE session with the Commissionee over the operational network in the
   * previous steps SHALL invoke the CommissioningComplete command (see Section 11.9.6.6,
   * “CommissioningComplete Command”). A success response after invocation of the CommissioningComplete command ends
   * the commissioning process.
   */
  async #completeCommissioning() {
    const generalCommissioningClusterClient = this.#getClusterClient(import_general_commissioning.GeneralCommissioning.Cluster);
    this.#ensureGeneralCommissioningSuccess(
      "commissioningComplete",
      await generalCommissioningClusterClient.commissioningComplete(void 0, {
        useExtendedFailSafeMessageResponseTimeout: true
      })
    );
    this.#lastFailSafeTime = void 0;
    return {
      code: 0 /* Success */,
      breadcrumb: this.lastBreadcrumb
    };
  }
}
//# sourceMappingURL=ControllerCommissioningFlow.js.map
