"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ControllerDiscovery_exports = {};
__export(ControllerDiscovery_exports, {
  ControllerDiscovery: () => ControllerDiscovery,
  DiscoveryError: () => DiscoveryError,
  PairRetransmissionLimitReachedError: () => PairRetransmissionLimitReachedError
});
module.exports = __toCommonJS(ControllerDiscovery_exports);
var import_general = require("#general");
var import_MessageExchange = require("../protocol/MessageExchange.js");
var import_ControllerCommissioningFlow = require("./ControllerCommissioningFlow.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("ControllerDiscovery");
class DiscoveryError extends import_MessageExchange.RetransmissionLimitReachedError {
}
class PairRetransmissionLimitReachedError extends import_MessageExchange.RetransmissionLimitReachedError {
}
class ControllerDiscovery {
  /**
   * Discovers devices by a provided identifier and a list of scanners (e.g. IP and BLE in parallel).
   * It returns after the timeout or if at least one device was found.
   * The method returns a list of addresses of the discovered devices.
   */
  static async discoverDeviceAddressesByIdentifier(scanners, identifier, timeoutSeconds = 30) {
    logger.info(`Start Discovering devices using identifier ${import_general.Diagnostic.json(identifier)} ...`);
    const scanResults = scanners.map(async (scanner) => {
      const foundDevices = await scanner.findCommissionableDevices(
        identifier,
        timeoutSeconds,
        scanner.type === "ble"
        // Force rediscovery for BLE
      );
      logger.info(`Found ${foundDevices.length} devices using identifier ${import_general.Diagnostic.json(identifier)}`);
      if (foundDevices.length === 0) {
        throw new import_ControllerCommissioningFlow.CommissioningError(
          `No device discovered using identifier ${import_general.Diagnostic.json(
            identifier
          )}! Please check that the relevant device is online.`
        );
      }
      const devices = foundDevices.filter((device) => device.addresses.length > 0);
      if (devices.length === 0) {
        throw new import_ControllerCommissioningFlow.CommissioningError(
          `Device discovered using identifier ${import_general.Diagnostic.json(
            identifier
          )}, but no Network addresses discovered.`
        );
      }
      return devices;
    });
    return await (0, import_general.anyPromise)(scanResults);
  }
  static async discoverCommissionableDevices(scanners, timeoutSeconds, identifier = {}, discoveredCallback) {
    const discoveredDevices = /* @__PURE__ */ new Map();
    await Promise.all(
      scanners.map(async (scanner) => {
        await scanner.findCommissionableDevicesContinuously(
          identifier,
          (device) => {
            const { deviceIdentifier } = device;
            if (!discoveredDevices.has(deviceIdentifier)) {
              discoveredDevices.set(deviceIdentifier, device);
              discoveredCallback?.(device);
            }
          },
          timeoutSeconds
        );
      })
    );
    const finalDiscoveredDevices = /* @__PURE__ */ new Map();
    scanners.forEach((scanner) => {
      const devices = scanner.getDiscoveredCommissionableDevices(identifier);
      devices.forEach((device) => {
        const { deviceIdentifier } = device;
        if (!discoveredDevices.has(deviceIdentifier)) {
          discoveredDevices.set(deviceIdentifier, device);
          discoveredCallback?.(device);
        }
        if (!finalDiscoveredDevices.has(deviceIdentifier)) {
          finalDiscoveredDevices.set(deviceIdentifier, device);
        }
      });
    });
    return Array.from(finalDiscoveredDevices.values());
  }
  static async discoverOperationalDevice(fabric, peerNodeId, scanner, timeoutSeconds, ignoreExistingRecords) {
    const foundDevice = await scanner.findOperationalDevice(
      fabric,
      peerNodeId,
      timeoutSeconds,
      ignoreExistingRecords
    );
    if (foundDevice === void 0) {
      throw new DiscoveryError(
        "The operational device cannot be found on the network. Please make sure it is online."
      );
    }
    return foundDevice;
  }
  static cancelOperationalDeviceDiscovery(fabric, peerNodeId, scanner) {
    scanner.cancelOperationalDeviceDiscovery(fabric, peerNodeId);
  }
  static cancelCommissionableDeviceDiscovery(scanner, identifier = {}) {
    scanner.cancelCommissionableDeviceDiscovery(identifier);
  }
  /**
   * Helper method to iterate through a list of server addresses and try to execute a method on each of them. If the
   * method throws a configurable error (or EHOSTUNREACH), the server address list is updated (to also add later
   * discovered addresses or devices) and then next server address is tried.The result of the first successful method
   * call is returned. The logic makes sure to only try each unique address (IP/port) once.
   */
  static async iterateServerAddresses(devices, errorType, updateDevicesFunc, func, lastKnownAddress) {
    const processOneAddress = async (address, device) => {
      const serverKey = (0, import_general.serverAddressToString)(address);
      logger.debug(`Try to communicate with ${serverKey} ...`);
      try {
        return { result: await func(address, device), resultAddress: address, resultDevice: device };
      } catch (error) {
        if (error instanceof errorType || error instanceof import_general.NoResponseTimeoutError) {
          logger.debug(`Failed to communicate with ${serverKey}, try other servers ...`, error);
        } else {
          throw error;
        }
      }
    };
    const addresses = /* @__PURE__ */ new Map();
    devices.forEach(
      (device) => device.addresses.forEach((address) => addresses.set((0, import_general.serverAddressToString)(address), { address, device }))
    );
    const triedAddresses = /* @__PURE__ */ new Set();
    if (lastKnownAddress !== void 0) {
      const knownKey = (0, import_general.serverAddressToString)(lastKnownAddress);
      const knownDevice = addresses.has((0, import_general.serverAddressToString)(lastKnownAddress)) ? addresses.get(knownKey)?.device : void 0;
      addresses.delete(knownKey);
      const result = await processOneAddress(lastKnownAddress, knownDevice);
      if (result !== void 0) {
        return result;
      }
      triedAddresses.add(knownKey);
    }
    while (true) {
      logger.debug(
        `Server addresses to try: ${Array.from(addresses).map(([addressString, { device }]) => `${addressString}${device?.DN ? ` (${device.DN})` : ""}`).join(",")}`
      );
      let triedOne = false;
      for (const { address, device } of addresses.values()) {
        const serverKey = (0, import_general.serverAddressToString)(address);
        if (triedAddresses.has(serverKey)) continue;
        triedAddresses.add(serverKey);
        try {
          triedOne = true;
          const result = await processOneAddress(address, device);
          if (result !== void 0) {
            return result;
          }
        } catch (error) {
          if (error instanceof errorType || error instanceof import_general.NoResponseTimeoutError) {
            logger.debug(`Failed to communicate with ${serverKey}, try next server ...`, error);
          } else {
            throw error;
          }
        }
      }
      if (triedOne) {
        (await updateDevicesFunc()).forEach(
          (device) => device.addresses.forEach(
            (address) => addresses.set((0, import_general.serverAddressToString)(address), { address, device })
          )
        );
      } else {
        throw new PairRetransmissionLimitReachedError(`Failed to connect on any discovered server`);
      }
    }
  }
}
//# sourceMappingURL=ControllerDiscovery.js.map
