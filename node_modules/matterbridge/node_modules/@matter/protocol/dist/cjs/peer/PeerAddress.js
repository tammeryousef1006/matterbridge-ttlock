"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var PeerAddress_exports = {};
__export(PeerAddress_exports, {
  PeerAddress: () => PeerAddress,
  PeerAddressMap: () => PeerAddressMap,
  PeerAddressSet: () => PeerAddressSet
});
module.exports = __toCommonJS(PeerAddress_exports);
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const interned = Symbol("interned-logical-address");
const internedAddresses = /* @__PURE__ */ new Map();
function PeerAddress(address) {
  if (interned in address) {
    return address;
  }
  let internedFabric = internedAddresses.get(address.fabricIndex);
  if (internedFabric === void 0) {
    internedAddresses.set(address.fabricIndex, internedFabric = /* @__PURE__ */ new Map());
  }
  let internedAddress = internedFabric.get(address.nodeId);
  if (internedAddress) {
    return internedAddress;
  }
  internedFabric.set(
    address.nodeId,
    internedAddress = {
      ...address,
      [interned]: true,
      toString() {
        const nodeStr = this.nodeId > 65535 ? `0x${this.nodeId.toString(16)}` : this.nodeId;
        return `peer@${this.fabricIndex}:${nodeStr}`;
      }
    }
  );
  return internedAddress;
}
((PeerAddress2) => {
  function is(addr1, addr2) {
    if (addr1 === void 0 || addr2 === void 0) {
      return false;
    }
    return addr1.fabricIndex === addr2.fabricIndex && addr1.nodeId === addr2.nodeId;
  }
  PeerAddress2.is = is;
})(PeerAddress || (PeerAddress = {}));
class PeerAddressMap extends Map {
  delete(key) {
    return super.delete(PeerAddress(key));
  }
  has(key) {
    return super.has(PeerAddress(key));
  }
  set(key, value) {
    return super.set(PeerAddress(key), value);
  }
  get(key) {
    return super.get(PeerAddress(key));
  }
}
class PeerAddressSet extends Set {
  add(value) {
    return super.add(PeerAddress(value));
  }
  has(value) {
    return super.has(PeerAddress(value));
  }
  delete(value) {
    return super.delete(PeerAddress(value));
  }
}
//# sourceMappingURL=PeerAddress.js.map
