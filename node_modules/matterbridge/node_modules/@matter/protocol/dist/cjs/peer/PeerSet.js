"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var PeerSet_exports = {};
__export(PeerSet_exports, {
  NodeDiscoveryType: () => NodeDiscoveryType,
  PeerSet: () => PeerSet,
  UnknownNodeError: () => UnknownNodeError
});
module.exports = __toCommonJS(PeerSet_exports);
var import_Scanner = require("#common/Scanner.js");
var import_general = require("#general");
var import_SubscriptionClient = require("#interaction/SubscriptionClient.js");
var import_PeerAddress = require("#peer/PeerAddress.js");
var import_session = require("#session/index.js");
var import_SessionManager = require("#session/SessionManager.js");
var import_types = require("@matter/types");
var import_ChannelManager = require("../protocol/ChannelManager.js");
var import_ExchangeManager = require("../protocol/ExchangeManager.js");
var import_ExchangeProvider = require("../protocol/ExchangeProvider.js");
var import_MessageExchange = require("../protocol/MessageExchange.js");
var import_ControllerDiscovery = require("./ControllerDiscovery.js");
var import_InteractionQueue = require("./InteractionQueue.js");
var import_PeerAddressStore = require("./PeerAddressStore.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("PeerSet");
const RECONNECTION_POLLING_INTERVAL_MS = 6e5;
const RETRANSMISSION_DISCOVERY_TIMEOUT_S = 5;
var NodeDiscoveryType = /* @__PURE__ */ ((NodeDiscoveryType2) => {
  NodeDiscoveryType2[NodeDiscoveryType2["None"] = 0] = "None";
  NodeDiscoveryType2[NodeDiscoveryType2["RetransmissionDiscovery"] = 1] = "RetransmissionDiscovery";
  NodeDiscoveryType2[NodeDiscoveryType2["TimedDiscovery"] = 2] = "TimedDiscovery";
  NodeDiscoveryType2[NodeDiscoveryType2["FullDiscovery"] = 3] = "FullDiscovery";
  return NodeDiscoveryType2;
})(NodeDiscoveryType || {});
class UnknownNodeError extends import_general.MatterError {
}
class PeerSet {
  #sessions;
  #channels;
  #exchanges;
  #subscriptionClient;
  #scanners;
  #netInterfaces;
  #caseClient;
  #peers = new import_general.BasicSet();
  #peersByAddress = new import_PeerAddress.PeerAddressMap();
  #runningPeerDiscoveries = new import_PeerAddress.PeerAddressMap();
  #runningPeerReconnections = new import_PeerAddress.PeerAddressMap();
  #construction;
  #store;
  #interactionQueue = new import_InteractionQueue.InteractionQueue();
  #nodeCachedData = new import_PeerAddress.PeerAddressMap();
  // Temporarily until we store it in new API
  #disconnected = (0, import_general.AsyncObservable)();
  constructor(context) {
    const { sessions, channels, exchanges, subscriptionClient, scanners, netInterfaces, store } = context;
    this.#sessions = sessions;
    this.#channels = channels;
    this.#exchanges = exchanges;
    this.#subscriptionClient = subscriptionClient;
    this.#scanners = scanners;
    this.#netInterfaces = netInterfaces;
    this.#store = store;
    this.#caseClient = new import_session.CaseClient(this.#sessions);
    this.#peers.added.on((peer) => {
      peer.address = (0, import_PeerAddress.PeerAddress)(peer.address);
      this.#peersByAddress.set(peer.address, peer);
    });
    this.#peers.deleted.on((peer) => {
      this.#peersByAddress.delete(peer.address);
    });
    this.#sessions.resubmissionStarted.on(this.#handleResubmissionStarted.bind(this));
    this.#channels.added.on((address, msgChannel) => {
      if ((0, import_general.isIpNetworkChannel)(msgChannel.channel)) {
        return this.#addOrUpdatePeer(address, msgChannel.channel.networkAddress);
      }
    });
    this.#construction = (0, import_general.Construction)(this, async () => {
      for (const peer of await this.#store.loadPeers()) {
        this.#peers.add(peer);
      }
    });
  }
  get added() {
    return this.#peers.added;
  }
  get deleted() {
    return this.#peers.deleted;
  }
  get disconnected() {
    return this.#disconnected;
  }
  has(item) {
    if ("address" in item) {
      return this.#peers.has(item);
    }
    return this.#peersByAddress.has(item);
  }
  get size() {
    return this.#peers.size;
  }
  find(predicate) {
    return this.#peers.find(predicate);
  }
  filter(predicate) {
    return this.#peers.filter(predicate);
  }
  map(mapper) {
    return this.#peers.map(mapper);
  }
  [Symbol.iterator]() {
    return this.#peers[Symbol.iterator]();
  }
  get construction() {
    return this.#construction;
  }
  static [import_general.Environmental.create](env) {
    const instance = new PeerSet({
      sessions: env.get(import_SessionManager.SessionManager),
      channels: env.get(import_ChannelManager.ChannelManager),
      exchanges: env.get(import_ExchangeManager.ExchangeManager),
      subscriptionClient: env.get(import_SubscriptionClient.SubscriptionClient),
      scanners: env.get(import_Scanner.ScannerSet),
      netInterfaces: env.get(import_general.NetInterfaceSet),
      store: env.get(import_PeerAddressStore.PeerAddressStore)
    });
    env.set(PeerSet, instance);
    return instance;
  }
  get peers() {
    return this.#peers;
  }
  get subscriptionClient() {
    return this.#subscriptionClient;
  }
  get interactionQueue() {
    return this.#interactionQueue;
  }
  /**
   * Ensure there is a channel to the designated peer.
   */
  async ensureConnection(address, options) {
    const { discoveryOptions, allowUnknownPeer, operationalAddress } = options;
    if (!this.#peersByAddress.has(address) && !allowUnknownPeer) {
      throw new UnknownNodeError(`Cannot connect to unknown device ${(0, import_PeerAddress.PeerAddress)(address)}`);
    }
    address = (0, import_PeerAddress.PeerAddress)(address);
    if (!this.#channels.hasChannel(address)) {
      const { promise: existingReconnectPromise } = this.#runningPeerReconnections.get(address) ?? {};
      if (existingReconnectPromise !== void 0) {
        return existingReconnectPromise;
      }
      const { promise, resolver, rejecter } = (0, import_general.createPromise)();
      this.#runningPeerReconnections.set(address, { promise, rejecter });
      this.#resume(address, discoveryOptions, operationalAddress).then((channel) => {
        this.#runningPeerReconnections.delete(address);
        resolver(channel);
      }).catch((error) => {
        this.#runningPeerReconnections.delete(address);
        rejecter(error);
      });
      return promise;
    }
  }
  /**
   * Obtain an exchange provider for the designated peer.
   */
  async exchangeProviderFor(addressOrChannel, discoveryOptions) {
    if (addressOrChannel instanceof import_ExchangeManager.MessageChannel) {
      return new import_ExchangeProvider.DedicatedChannelExchangeProvider(this.#exchanges, addressOrChannel);
    }
    const address = addressOrChannel;
    let initiallyConnected = this.#channels.hasChannel(address);
    return new import_ExchangeProvider.ReconnectableExchangeProvider(this.#exchanges, this.#channels, address, async () => {
      if (!initiallyConnected && !this.#channels.hasChannel(address)) {
        await this.ensureConnection(address, {
          discoveryOptions: { discoveryType: 0 /* None */ }
        });
        initiallyConnected = true;
        if (this.#channels.hasChannel(address)) {
          return;
        }
      }
      if (!this.#channels.hasChannel(address)) {
        throw new import_MessageExchange.RetransmissionLimitReachedError(`Device ${(0, import_PeerAddress.PeerAddress)(address)} is currently not reachable.`);
      }
      await this.#channels.removeAllNodeChannels(address);
      const { discoveryData } = discoveryOptions ?? {
        discoveryData: this.#peersByAddress.get(address)?.discoveryData
      };
      const operationalAddress = this.#knownOperationalAddressFor(address, true);
      if (operationalAddress === void 0) {
        logger.info(
          `Re-discovering device failed (no address found), remove all sessions for ${(0, import_PeerAddress.PeerAddress)(address)}`
        );
        await this.#sessions.removeAllSessionsForNode(address);
        throw new import_MessageExchange.RetransmissionLimitReachedError(`No operational address found for ${(0, import_PeerAddress.PeerAddress)(address)}`);
      }
      if (await this.#reconnectKnownAddress(address, operationalAddress, discoveryData, 2e3) === void 0) {
        throw new import_MessageExchange.RetransmissionLimitReachedError(`${(0, import_PeerAddress.PeerAddress)(address)} is not reachable.`);
      }
    });
  }
  /**
   * Retrieve a peer by address.
   */
  get(peer) {
    if ("address" in peer) {
      return this.#peersByAddress.get(peer.address);
    }
    return this.#peersByAddress.get(peer);
  }
  /**
   * Terminate any active peer connection.
   */
  async disconnect(peer, sendSessionClose = true) {
    const address = this.get(peer)?.address;
    if (address === void 0) {
      return;
    }
    await this.#sessions.removeAllSessionsForNode(address, sendSessionClose);
    await this.#channels.removeAllNodeChannels(address);
    await this.#disconnected.emit(address);
  }
  /**
   * Forget a known peer.
   */
  async delete(peer) {
    const actual = this.get(peer);
    if (actual === void 0) {
      return;
    }
    const { address } = actual;
    logger.info(`Removing ${address}`);
    this.#peers.delete(actual);
    await this.#store.deletePeer(address);
    await this.disconnect(address, false);
    await this.#sessions.deleteResumptionRecord(address);
  }
  async close() {
    for (const [address, { stopTimerFunc, mdnsScanner }] of this.#runningPeerDiscoveries.entries()) {
      stopTimerFunc?.();
      mdnsScanner?.cancelOperationalDeviceDiscovery(this.#sessions.fabricFor(address), address.nodeId, false);
    }
    for (const { address } of this.#peers) {
      await this.disconnect(address, false);
    }
    this.#interactionQueue.close();
    this.#runningPeerReconnections.forEach(
      ({ rejecter }) => rejecter(new import_ExchangeManager.ChannelNotConnectedError("PeerSet closed"))
    );
    this.#runningPeerReconnections.clear();
  }
  /**
   * Resume a device connection and establish a CASE session that was previously paired with the controller. This
   * method will try to connect to the device using the previously used server address (if set). If that fails, the
   * device is discovered again using its operational instance details.
   * It returns the operational MessageChannel on success.
   */
  async #resume(address, discoveryOptions, tryOperationalAddress) {
    const { discoveryType } = discoveryOptions ?? {};
    const operationalAddress = tryOperationalAddress ?? (discoveryType === 0 /* None */ ? this.#getLastOperationalAddress(address) : this.#knownOperationalAddressFor(address));
    try {
      return await this.#connectOrDiscoverNode(address, operationalAddress, discoveryOptions);
    } catch (error) {
      if ((error instanceof import_ControllerDiscovery.DiscoveryError || error instanceof import_general.NoResponseTimeoutError) && this.#peersByAddress.has(address) && tryOperationalAddress === void 0) {
        logger.info(`Resume failed, remove all sessions for ${(0, import_PeerAddress.PeerAddress)(address)}`);
        await this.#sessions.removeAllSessionsForNode(address);
      }
      throw error;
    }
  }
  async #connectOrDiscoverNode(address, operationalAddress, discoveryOptions = {}) {
    address = (0, import_PeerAddress.PeerAddress)(address);
    const {
      discoveryType: requestedDiscoveryType = 3 /* FullDiscovery */,
      timeoutSeconds,
      discoveryData = this.#peersByAddress.get(address)?.discoveryData
    } = discoveryOptions;
    if (timeoutSeconds !== void 0 && requestedDiscoveryType !== 2 /* TimedDiscovery */) {
      throw new import_general.ImplementationError("Cannot set timeout without timed discovery.");
    }
    if (requestedDiscoveryType === 1 /* RetransmissionDiscovery */) {
      throw new import_general.ImplementationError("Cannot set retransmission discovery type.");
    }
    const mdnsScanner = this.#scanners.scannerFor(import_general.ChannelType.UDP);
    if (!mdnsScanner) {
      throw new import_general.ImplementationError("Cannot discover device without mDNS scanner.");
    }
    const existingDiscoveryDetails = this.#runningPeerDiscoveries.get(address) ?? {
      type: 0 /* None */
    };
    if (existingDiscoveryDetails.type !== 0 /* None */ && existingDiscoveryDetails.type < requestedDiscoveryType) {
      mdnsScanner.cancelOperationalDeviceDiscovery(this.#sessions.fabricFor(address), address.nodeId);
      this.#runningPeerDiscoveries.delete(address);
      existingDiscoveryDetails.type = 0 /* None */;
    }
    const { type: runningDiscoveryType, promises } = existingDiscoveryDetails;
    if (operationalAddress !== void 0 && (runningDiscoveryType === 0 /* None */ || requestedDiscoveryType === 0 /* None */)) {
      const directReconnection = await this.#reconnectKnownAddress(
        address,
        operationalAddress,
        discoveryData,
        // When we use a timeout for discovery also use this for reconnecting to the node
        timeoutSeconds ? timeoutSeconds * 1e3 : void 0
      );
      if (directReconnection !== void 0) {
        return directReconnection;
      }
      if (requestedDiscoveryType === 0 /* None */) {
        throw new import_ControllerDiscovery.DiscoveryError(`${address} is not reachable right now.`);
      }
    }
    if (operationalAddress === void 0 && requestedDiscoveryType === 0 /* None */) {
      throw new import_ControllerDiscovery.DiscoveryError(`${address} has no known address and No discovery was requested.`);
    }
    if (promises !== void 0) {
      if (runningDiscoveryType > requestedDiscoveryType) {
        throw new import_ControllerDiscovery.DiscoveryError(`${address} is not reachable right now and discovery already running.`);
      } else {
        return await (0, import_general.anyPromise)(promises);
      }
    }
    const discoveryPromises = new Array();
    let reconnectionPollingTimer;
    let stopTimerFunc;
    const lastOperationalAddress = this.#getLastOperationalAddress(address);
    if (lastOperationalAddress !== void 0) {
      if (requestedDiscoveryType === 3 /* FullDiscovery */) {
        const { promise, resolver, rejecter } = (0, import_general.createPromise)();
        logger.debug(
          `Starting reconnection polling for ${(0, import_general.serverAddressToString)(lastOperationalAddress)} (Interval ${RECONNECTION_POLLING_INTERVAL_MS / 1e3}s)`
        );
        reconnectionPollingTimer = import_general.Time.getPeriodicTimer(
          "Controller reconnect",
          RECONNECTION_POLLING_INTERVAL_MS,
          async () => {
            try {
              logger.debug(`Polling for device at ${(0, import_general.serverAddressToString)(lastOperationalAddress)} ...`);
              const result = await this.#reconnectKnownAddress(
                address,
                lastOperationalAddress,
                discoveryData
              );
              if (result !== void 0 && reconnectionPollingTimer?.isRunning) {
                reconnectionPollingTimer?.stop();
                mdnsScanner.cancelOperationalDeviceDiscovery(
                  this.#sessions.fabricFor(address),
                  address.nodeId
                );
                this.#runningPeerDiscoveries.delete(address);
                resolver(result);
              }
            } catch (error) {
              if (reconnectionPollingTimer?.isRunning) {
                reconnectionPollingTimer?.stop();
                mdnsScanner.cancelOperationalDeviceDiscovery(
                  this.#sessions.fabricFor(address),
                  address.nodeId
                );
                this.#runningPeerDiscoveries.delete(address);
                rejecter(error);
              }
            }
          }
        ).start();
        stopTimerFunc = () => {
          reconnectionPollingTimer?.stop();
          reconnectionPollingTimer = void 0;
          rejecter(new import_general.NoResponseTimeoutError("Reconnection polling cancelled"));
        };
        discoveryPromises.push(() => promise);
      }
    }
    discoveryPromises.push(async () => {
      const scanResult = await import_ControllerDiscovery.ControllerDiscovery.discoverOperationalDevice(
        this.#sessions.fabricFor(address),
        address.nodeId,
        mdnsScanner,
        timeoutSeconds,
        timeoutSeconds === void 0
      );
      const { stopTimerFunc: stopTimerFunc2 } = this.#runningPeerDiscoveries.get(address) ?? {};
      stopTimerFunc2?.();
      this.#runningPeerDiscoveries.delete(address);
      const { result } = await import_ControllerDiscovery.ControllerDiscovery.iterateServerAddresses(
        [scanResult],
        import_general.NoResponseTimeoutError,
        async () => {
          const device = mdnsScanner.getDiscoveredOperationalDevice(
            this.#sessions.fabricFor(address),
            address.nodeId
          );
          return device !== void 0 ? [device] : [];
        },
        async (operationalAddress2, peer) => {
          const result2 = await this.#pair(address, operationalAddress2, peer);
          await this.#addOrUpdatePeer(address, operationalAddress2, {
            ...discoveryData,
            ...peer
          });
          return result2;
        }
      );
      return result;
    });
    this.#runningPeerDiscoveries.set(address, {
      type: requestedDiscoveryType,
      promises: discoveryPromises,
      stopTimerFunc,
      mdnsScanner
    });
    return await (0, import_general.anyPromise)(discoveryPromises).finally(() => {
      this.#runningPeerDiscoveries.delete(address);
    });
  }
  async #reconnectKnownAddress(address, operationalAddress, discoveryData, expectedProcessingTimeMs) {
    address = (0, import_PeerAddress.PeerAddress)(address);
    const { ip, port } = operationalAddress;
    const startTime = import_general.Time.nowMs();
    try {
      logger.debug(
        `Resuming connection to ${(0, import_PeerAddress.PeerAddress)(address)} at ${ip}:${port}${expectedProcessingTimeMs !== void 0 ? ` with expected processing time of ${expectedProcessingTimeMs}ms` : ""}`
      );
      const channel = await this.#pair(address, operationalAddress, discoveryData, expectedProcessingTimeMs);
      await this.#addOrUpdatePeer(address, operationalAddress);
      return channel;
    } catch (error) {
      if (error instanceof import_general.NoResponseTimeoutError) {
        logger.debug(
          `Failed to resume connection to ${address} connection with ${ip}:${port}, discovering the node now:`,
          error.message ? error.message : error
        );
        await this.#sessions.removeAllSessionsForNode(address, false, startTime);
        return void 0;
      } else {
        throw error;
      }
    }
  }
  /** Pair with an operational device (already commissioned) and establish a CASE session. */
  async #pair(address, operationalServerAddress, discoveryData, expectedProcessingTimeMs) {
    logger.debug(`Pair with ${address} at ${(0, import_general.serverAddressToString)(operationalServerAddress)}`);
    const { ip, port } = operationalServerAddress;
    const isIpv6Address = (0, import_general.isIPv6)(ip);
    const operationalInterface = this.#netInterfaces.interfaceFor(
      import_general.ChannelType.UDP,
      isIpv6Address ? "::" : "0.0.0.0"
    );
    if (operationalInterface === void 0) {
      throw new import_ControllerDiscovery.PairRetransmissionLimitReachedError(
        `IPv${isIpv6Address ? "6" : "4"} interface not initialized for port ${port}. Cannot use ${ip} for pairing.`
      );
    }
    const operationalChannel = await operationalInterface.openChannel(operationalServerAddress);
    const { sessionParameters } = this.#sessions.findResumptionRecordByAddress(address) ?? {};
    const unsecureSession = this.#sessions.createInsecureSession({
      // Use the session parameters from MDNS announcements when available and rest is assumed to be fallbacks
      sessionParameters: {
        idleIntervalMs: discoveryData?.SII ?? sessionParameters?.idleIntervalMs,
        activeIntervalMs: discoveryData?.SAI ?? sessionParameters?.activeIntervalMs,
        activeThresholdMs: discoveryData?.SAT ?? sessionParameters?.activeThresholdMs
      },
      isInitiator: true
    });
    const operationalUnsecureMessageExchange = new import_ExchangeManager.MessageChannel(operationalChannel, unsecureSession);
    let operationalSecureSession;
    try {
      const exchange = this.#exchanges.initiateExchangeWithChannel(
        operationalUnsecureMessageExchange,
        import_types.SECURE_CHANNEL_PROTOCOL_ID
      );
      try {
        const { session, resumed } = await this.#caseClient.pair(
          exchange,
          this.#sessions.fabricFor(address),
          address.nodeId,
          expectedProcessingTimeMs
        );
        operationalSecureSession = session;
        if (!resumed) {
          this.#nodeCachedData.delete(address);
        }
      } catch (e) {
        await exchange.close();
        throw e;
      }
    } catch (e) {
      import_general.NoResponseTimeoutError.accept(e);
      throw new import_ControllerDiscovery.PairRetransmissionLimitReachedError(e.message);
    } finally {
      await unsecureSession.destroy();
    }
    const channel = new import_ExchangeManager.MessageChannel(operationalChannel, operationalSecureSession);
    await this.#channels.setChannel(address, channel);
    return channel;
  }
  /**
   * Obtain an operational address for a logical address from cache.
   */
  #knownOperationalAddressFor(address, ignoreDiscoveredAddresses = false) {
    const lastKnownAddress = this.#getLastOperationalAddress(address);
    if (lastKnownAddress !== void 0 && ignoreDiscoveredAddresses) {
      return lastKnownAddress;
    }
    const mdnsScanner = this.#scanners.scannerFor(import_general.ChannelType.UDP);
    const discoveredAddresses = mdnsScanner?.getDiscoveredOperationalDevice(
      this.#sessions.fabricFor(address),
      address.nodeId
    );
    if (lastKnownAddress !== void 0 && discoveredAddresses !== void 0 && discoveredAddresses.addresses.some(
      ({ ip, port }) => ip === lastKnownAddress.ip && port === lastKnownAddress.port
    )) {
      discoveredAddresses.addresses.length = 0;
    }
    return discoveredAddresses?.addresses[0];
  }
  async #addOrUpdatePeer(address, operationalServerAddress, discoveryData) {
    let peer = this.#peersByAddress.get(address);
    if (peer === void 0) {
      peer = { address, dataStore: await this.#store.createNodeStore(address) };
      this.#peers.add(peer);
    }
    peer.operationalAddress = operationalServerAddress;
    if (discoveryData !== void 0) {
      peer.discoveryData = {
        ...peer.discoveryData,
        ...discoveryData
      };
    }
    await this.#store.updatePeer(peer);
    if (this.#runningPeerDiscoveries.has(address)) {
      logger.info(`Found ${address} during discovery, cancel discovery.`);
      const { mdnsScanner } = this.#runningPeerDiscoveries.get(address) ?? {};
      mdnsScanner?.cancelOperationalDeviceDiscovery(this.#sessions.fabricFor(address), address.nodeId, true);
    }
  }
  #getLastOperationalAddress(address) {
    return this.#peersByAddress.get(address)?.operationalAddress;
  }
  #handleResubmissionStarted(session) {
    if (!session.isSecure || session.fabric === void 0) {
      return;
    }
    const { associatedFabric: fabric, peerNodeId: nodeId } = session;
    if (fabric === void 0 || nodeId === void 0) {
      return;
    }
    const address = fabric.addressOf(nodeId);
    if (this.#runningPeerDiscoveries.has(address)) {
      return;
    }
    this.#runningPeerDiscoveries.set(address, { type: 1 /* RetransmissionDiscovery */ });
    this.#scanners.scannerFor(import_general.ChannelType.UDP)?.findOperationalDevice(fabric, nodeId, RETRANSMISSION_DISCOVERY_TIMEOUT_S, true).catch((error) => {
      logger.error(`Failed to discover ${address} after resubmission started.`, error);
    }).finally(() => {
      if (this.#runningPeerDiscoveries.get(address)?.type === 1 /* RetransmissionDiscovery */) {
        this.#runningPeerDiscoveries.delete(address);
      }
    });
  }
}
//# sourceMappingURL=PeerSet.js.map
