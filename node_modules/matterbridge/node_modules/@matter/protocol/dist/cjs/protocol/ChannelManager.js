"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ChannelManager_exports = {};
__export(ChannelManager_exports, {
  ChannelManager: () => ChannelManager,
  NoChannelError: () => NoChannelError
});
module.exports = __toCommonJS(ChannelManager_exports);
var import_general = require("#general");
var import_PeerAddress = require("#peer/PeerAddress.js");
var import_ExchangeManager = require("./ExchangeManager.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("ChannelManager");
class NoChannelError extends import_general.MatterError {
}
class ChannelManager {
  #channels = new import_PeerAddress.PeerAddressMap();
  #paseChannels = /* @__PURE__ */ new Map();
  #caseSessionsPerFabricAndNode;
  #added = (0, import_general.AsyncObservable)();
  // TODO evaluate with controller the effects of limiting the entries just for FabricIndex and not also NodeId
  constructor(caseSessionsPerFabricAndNode = 3) {
    this.#caseSessionsPerFabricAndNode = caseSessionsPerFabricAndNode;
  }
  static [import_general.Environmental.create](env) {
    const instance = new ChannelManager();
    env.set(ChannelManager, instance);
    return instance;
  }
  get added() {
    return this.#added;
  }
  set caseSessionsPerFabricAndNode(count) {
    this.#caseSessionsPerFabricAndNode = count;
  }
  #findLeastActiveChannel(channels) {
    let oldest = channels[0];
    for (const channel of channels) {
      if (channel.session.timestamp < oldest.session.timestamp) {
        oldest = channel;
      }
    }
    return oldest;
  }
  async setChannel(address, channel) {
    channel.closeCallback = async () => this.removeChannel(address, channel.session);
    const currentChannels = this.#channels.get(address) ?? [];
    currentChannels.push(channel);
    this.#channels.set(address, currentChannels);
    await this.#added.emit(address, channel);
    if (currentChannels.length > this.#caseSessionsPerFabricAndNode) {
      const oldestChannel = this.#findLeastActiveChannel(currentChannels);
      const { session: oldSession } = oldestChannel;
      if (channel.session.id !== oldSession.id) {
        await oldSession.destroy(false, false);
      }
      logger.info(`Close oldest channel for fabric ${(0, import_PeerAddress.PeerAddress)(address)} (from session ${oldSession.id})`);
      await oldestChannel.close();
    }
  }
  hasChannel(address) {
    return !!this.#channels.get(address)?.filter((channel) => !channel.closed && !channel.session.closingAfterExchangeFinished).length;
  }
  getChannel(address, session) {
    let results = this.#channels.get(address) ?? [];
    if (session !== void 0) {
      results = results.filter((channel) => channel.session.id === session.id);
    }
    results = results.filter((channel) => !channel.closed && !channel.session.closingAfterExchangeFinished);
    if (results.length === 0)
      throw new NoChannelError(
        `Can't find a channel to ${(0, import_PeerAddress.PeerAddress)(address)}${session !== void 0 ? ` session ${session.id}` : ""}`
      );
    return results[results.length - 1];
  }
  /**
   * Returns the last established session for a Fabric and Node
   */
  getChannelForSession(session) {
    if (session.isSecure && !session.isPase) {
      const secureSession = session;
      const fabric = secureSession.fabric;
      const nodeId = secureSession.peerNodeId;
      if (fabric === void 0) {
        return this.#paseChannels.get(session);
      }
      return this.getChannel(fabric.addressOf(nodeId), session);
    }
    return this.#paseChannels.get(session);
  }
  async removeAllNodeChannels(address) {
    const channelsToRemove = this.#channels.get(address) ?? [];
    for (const channel of channelsToRemove) {
      await channel.close();
    }
  }
  async removeChannel(address, session) {
    const fabricChannels = this.#channels.get(address) ?? [];
    const channelEntryIndex = fabricChannels.findIndex(
      ({ session: entrySession }) => entrySession.id === session.id
    );
    if (channelEntryIndex === -1) {
      return;
    }
    const channelEntry = fabricChannels.splice(channelEntryIndex, 1)[0];
    if (channelEntry === void 0) {
      return;
    }
    await channelEntry.close();
    this.#channels.set(address, fabricChannels);
  }
  getOrCreateAsPaseChannel(byteArrayChannel, session) {
    const msgChannel = new import_ExchangeManager.MessageChannel(
      byteArrayChannel,
      session,
      async () => void this.#paseChannels.delete(session)
    );
    this.#paseChannels.set(session, msgChannel);
    if (session.isSecure) {
      session.destroyed.on(() => msgChannel.close());
    }
    return msgChannel;
  }
  async getOrCreateChannel(byteArrayChannel, session) {
    if (!session.isSecure) {
      return this.getOrCreateAsPaseChannel(byteArrayChannel, session);
    }
    const secureSession = session;
    const fabric = secureSession.fabric;
    const nodeId = secureSession.peerNodeId;
    if (fabric === void 0) {
      return this.getOrCreateAsPaseChannel(byteArrayChannel, session);
    }
    const address = fabric.addressOf(nodeId);
    try {
      return this.getChannel(address, session);
    } catch (e) {
      NoChannelError.accept(e);
    }
    const msgChannel = new import_ExchangeManager.MessageChannel(
      byteArrayChannel,
      session,
      async () => this.removeChannel(address, session)
    );
    await this.setChannel(address, msgChannel);
    session.destroyed.on(() => msgChannel.close());
    return msgChannel;
  }
  async close() {
    for (const channel of this.#paseChannels.values()) {
      await channel.close();
    }
    this.#paseChannels.clear();
    for (const channels of this.#channels.values()) {
      for (const channel of channels) {
        await channel.close();
      }
    }
    this.#channels.clear();
  }
}
//# sourceMappingURL=ChannelManager.js.map
