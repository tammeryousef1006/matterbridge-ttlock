"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var DeviceAdvertiser_exports = {};
__export(DeviceAdvertiser_exports, {
  DeviceAdvertiser: () => DeviceAdvertiser
});
module.exports = __toCommonJS(DeviceAdvertiser_exports);
var import_InstanceBroadcaster = require("#common/InstanceBroadcaster.js");
var import_FabricManager = require("#fabric/FabricManager.js");
var import_general = require("#general");
var import_SessionManager = require("#session/SessionManager.js");
var import_types = require("#types");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("DeviceAdvertiser");
class DeviceAdvertiser {
  #context;
  #broadcasters = /* @__PURE__ */ new Set();
  #timedOut = (0, import_general.AsyncObservable)();
  #operationalModeEnabled = new import_general.AsyncObservable();
  #operationalModeEnded = new import_general.AsyncObservable();
  #observers = new import_general.ObserverGroup();
  #interval;
  #startTime = null;
  #isClosing = false;
  #commissioningMode = import_InstanceBroadcaster.CommissioningMode.NotCommissioning;
  // Currently we do not put much effort into synchronizing announcements as it probably isn't really necessary.  But
  // this mutex prevents automated announcements from piling up and allows us to ensure announcements are complete on
  // close
  #mutex = new import_general.Mutex(this);
  constructor(context) {
    this.#context = context;
    this.#interval = import_general.Time.getPeriodicTimer(
      "Server node announcement",
      import_types.DEVICE_ANNOUNCEMENT_INTERVAL_MS,
      () => (
        // Announcement needs to await a previous announcement because otherwise in testing at least announcement
        // may crash if started simultaneously
        this.#mutex.run(this.advertise.bind(this))
      )
    );
    this.#observers.on(this.#context.fabrics.events.deleted, () => {
      if (this.#context.fabrics.length === 0) {
        this.#mutex.run(this.#exitOperationalMode.bind(this));
      } else {
        this.#mutex.run(() => this.advertise(true));
      }
    });
    this.#observers.on(this.#context.sessions.resubmissionStarted, (session) => {
      logger.debug(`Resubmission started, re-announce node ${session?.nodeId}`);
      this.#mutex.run(() => this.advertise(true));
    });
    this.#observers.on(this.#context.sessions.subscriptionsChanged, (_session, subscription) => {
      if (subscription.isCanceledByPeer) {
        logger.debug(`Subscription canceled by peer, re-announce`);
        this.#mutex.run(this.startAdvertising.bind(this));
      }
    });
  }
  toString() {
    return "DeviceAdvertiser";
  }
  static [import_general.Environmental.create](env) {
    const instance = new DeviceAdvertiser({
      fabrics: env.get(import_FabricManager.FabricManager),
      sessions: env.get(import_SessionManager.SessionManager)
    });
    env.set(DeviceAdvertiser, instance);
    return instance;
  }
  /**
   * Emitted when the advertising window closes with no response.
   */
  get timedOut() {
    return this.#timedOut;
  }
  /**
   * Emitted when the device stops advertising due to decommissioning.
   */
  get operationalModeEnded() {
    return this.#operationalModeEnded;
  }
  /**
   * Emitted when the device starts advertising in operational mode.
   */
  get operationalModeEnabled() {
    return this.#operationalModeEnabled;
  }
  async enterCommissioningMode(mode, deviceData) {
    this.#commissioningMode = mode;
    for (const broadcaster of this.#broadcasters) {
      await broadcaster.setCommissionMode(mode, deviceData);
    }
    await this.startAdvertising();
  }
  async exitCommissioningMode() {
    this.#commissioningMode = import_InstanceBroadcaster.CommissioningMode.NotCommissioning;
    this.#interval.stop();
    this.#startTime = null;
    for (const broadcaster of this.#broadcasters) {
      await broadcaster.expireCommissioningAnnouncement();
    }
  }
  async startAdvertising() {
    if (this.#isClosing) return;
    if (this.#interval.isRunning) {
      this.#interval.stop();
    }
    this.#startTime = import_general.Time.nowMs();
    this.#interval.start();
    await this.advertise();
  }
  async advertise(once = false) {
    if (!once) {
      if (this.#startTime !== null && import_general.Time.nowMs() - this.#startTime > import_types.DEVICE_ANNOUNCEMENT_DURATION_MS) {
        logger.debug("Announcement duration reached, stop announcing");
        await this.#timedOut.emit();
        return;
      }
      if (this.#commissioningMode !== import_InstanceBroadcaster.CommissioningMode.NotCommissioning) {
        for (const broadcaster of this.#broadcasters) {
          await broadcaster.announce();
        }
        return;
      }
    }
    const fabrics = this.#context.fabrics;
    if (fabrics.length) {
      let fabricsWithoutSessions = 0;
      for (const fabric of fabrics) {
        const session = this.#context.sessions.getSessionForNode(fabric.addressOf(fabric.rootNodeId));
        if (session === void 0 || !session.isSecure || session.subscriptions.size === 0) {
          fabricsWithoutSessions++;
          logger.debug(
            "Announcing",
            import_general.Diagnostic.dict({ fabricIndex: fabric.fabricIndex, fabricId: fabric.fabricId })
          );
        }
      }
      for (const broadcaster of this.#broadcasters) {
        await broadcaster.setFabrics(fabrics.fabrics);
        if (fabricsWithoutSessions > 0 || this.#commissioningMode !== import_InstanceBroadcaster.CommissioningMode.NotCommissioning) {
          await broadcaster.announce();
        }
      }
    } else {
      await this.#exitOperationalMode();
      await this.#operationalModeEnded.emit();
    }
  }
  async advertiseFabrics(fabrics, expireCommissioningAnnouncement = false) {
    if (expireCommissioningAnnouncement) {
      await this.#operationalModeEnabled.emit();
    }
    for (const broadcaster of this.#broadcasters) {
      await broadcaster.setFabrics(fabrics, expireCommissioningAnnouncement);
      await broadcaster.announce();
    }
  }
  async #exitOperationalMode() {
    for (const broadcaster of this.#broadcasters) {
      await broadcaster.expireFabricAnnouncement();
    }
  }
  async close() {
    this.#isClosing = true;
    await this.#mutex;
    this.#observers.close();
    this.#interval.stop();
    await this.clearBroadcasters();
  }
  hasBroadcaster(broadcaster) {
    return this.#broadcasters.has(broadcaster);
  }
  addBroadcaster(broadcaster) {
    this.#broadcasters.add(broadcaster);
  }
  async deleteBroadcaster(broadcaster) {
    if (this.#broadcasters.delete(broadcaster)) {
      await broadcaster.expireAllAnnouncements();
    }
  }
  async clearBroadcasters() {
    const broadcasters = [...this.#broadcasters];
    const closed = import_general.MatterAggregateError.allSettled(
      broadcasters.map((b) => b.close()),
      "Error closing broadcasters"
    ).catch((error) => logger.error(error));
    this.#broadcasters.clear();
    await closed;
  }
}
//# sourceMappingURL=DeviceAdvertiser.js.map
