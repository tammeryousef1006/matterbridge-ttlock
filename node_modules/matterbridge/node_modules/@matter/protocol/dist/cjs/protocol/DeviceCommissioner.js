"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var DeviceCommissioner_exports = {};
__export(DeviceCommissioner_exports, {
  CommissioningConfigProvider: () => CommissioningConfigProvider,
  DeviceCommissioner: () => DeviceCommissioner
});
module.exports = __toCommonJS(DeviceCommissioner_exports);
var import_administrator_commissioning = require("#clusters/administrator-commissioning");
var import_InstanceBroadcaster = require("#common/InstanceBroadcaster.js");
var import_FabricManager = require("#fabric/FabricManager.js");
var import_general = require("#general");
var import_SecureChannelProtocol = require("#securechannel/SecureChannelProtocol.js");
var import_session = require("#session/index.js");
var import_types = require("#types");
var import_DeviceAdvertiser = require("./DeviceAdvertiser.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("DeviceCommissioner");
class CommissioningConfigProvider {
}
class DeviceCommissioner {
  #context;
  #failsafeContext;
  #windowStatus = import_administrator_commissioning.AdministratorCommissioning.CommissioningWindowStatus.WindowNotOpen;
  #activeDiscriminator;
  #activeCommissioningEndCallback;
  #observers = new import_general.ObserverGroup(this);
  constructor(context) {
    this.#context = context;
    this.#observers.on(this.#context.advertiser.timedOut, this.endCommissioning);
    this.#observers.on(this.#context.fabrics.events.deleted, async () => {
      if (this.#context.fabrics.length === 0 || this.#windowStatus !== import_administrator_commissioning.AdministratorCommissioning.CommissioningWindowStatus.WindowNotOpen) {
        this.reactivateAdvertiser();
      }
    });
    this.#observers.on(this.#context.advertiser.operationalModeEnded, this.allowBasicCommissioning);
    this.#observers.on(this.#context.secureChannelProtocol.tooManyPaseErrors, async () => {
      logger.info("Maximum number of PASE pairing errors reached, canceling commissioning");
      await this.endCommissioning();
    });
    this.#observers.on(this.#context.sessions.sessions.deleted, (session) => {
      const currentFabricIndex = session.fabric?.fabricIndex;
      const existingSessionFabric = currentFabricIndex === void 0 ? void 0 : this.#context.fabrics.findByIndex(currentFabricIndex)?.fabricIndex;
      if (this.#context.fabrics.length > 0 || session.isPase || !existingSessionFabric) {
        this.#context.advertiser.startAdvertising().catch((error) => logger.warn(`Error while announcing`, error));
      }
    });
  }
  static [import_general.Environmental.create](env) {
    const instance = new DeviceCommissioner({
      fabrics: env.get(import_FabricManager.FabricManager),
      sessions: env.get(import_session.SessionManager),
      advertiser: env.get(import_DeviceAdvertiser.DeviceAdvertiser),
      secureChannelProtocol: env.get(import_SecureChannelProtocol.SecureChannelProtocol),
      commissioningConfig: env.get(CommissioningConfigProvider)
    });
    env.set(DeviceCommissioner, instance);
    return instance;
  }
  get failsafeContext() {
    this.assertFailsafeArmed();
    return this.#failsafeContext;
  }
  async allowEnhancedCommissioning(discriminator, paseServer, commissioningEndCallback) {
    if (this.#windowStatus === import_administrator_commissioning.AdministratorCommissioning.CommissioningWindowStatus.BasicWindowOpen) {
      throw new import_general.MatterFlowError(
        "Basic commissioning window is already open! Cannot set Enhanced commissioning mode."
      );
    }
    this.#context.secureChannelProtocol.setPaseCommissioner(paseServer);
    await this.#becomeCommissionable(
      import_administrator_commissioning.AdministratorCommissioning.CommissioningWindowStatus.EnhancedWindowOpen,
      commissioningEndCallback,
      discriminator
    );
  }
  async allowBasicCommissioning(commissioningEndCallback) {
    if (this.#windowStatus === import_administrator_commissioning.AdministratorCommissioning.CommissioningWindowStatus.EnhancedWindowOpen) {
      throw new import_general.MatterFlowError(
        "Enhanced commissioning window is already open! Cannot set Basic commissioning mode."
      );
    }
    this.#context.secureChannelProtocol.setPaseCommissioner(
      await import_session.PaseServer.fromPin(this.#context.sessions, this.#context.commissioningConfig.values.passcode, {
        iterations: 1e3,
        salt: import_general.Crypto.get().getRandomData(32)
      })
    );
    await this.#becomeCommissionable(
      import_administrator_commissioning.AdministratorCommissioning.CommissioningWindowStatus.BasicWindowOpen,
      commissioningEndCallback
    );
  }
  async beginTimed(failsafeContext) {
    await failsafeContext.construction;
    this.#failsafeContext = failsafeContext;
    this.#context.fabrics.events.added.on((fabric) => {
      const fabrics = this.#context.fabrics.fabrics;
      this.#context.advertiser.advertiseFabrics(fabrics, true).catch(
        (error) => logger.warn(`Error sending Fabric announcement for Index ${fabric.fabricIndex}`, error)
      );
      logger.info("Announce done", import_general.Diagnostic.dict({ fabric: fabric.fabricId, fabricIndex: fabric.fabricIndex }));
    });
    failsafeContext.commissioned.on(async () => await this.endCommissioning());
    failsafeContext.construction.change.on((status) => {
      if (status === import_general.Lifecycle.Status.Destroyed) {
        this.#failsafeContext = void 0;
      }
    });
  }
  get isFailsafeArmed() {
    return this.#failsafeContext !== void 0;
  }
  assertFailsafeArmed(message) {
    if (this.isFailsafeArmed) return;
    throw new import_types.StatusResponseError(
      message ?? "Failsafe timer needs to be armed to execute this action.",
      import_types.StatusCode.FailsafeRequired
    );
  }
  reactivateAdvertiser() {
    if (this.#windowStatus === import_administrator_commissioning.AdministratorCommissioning.CommissioningWindowStatus.WindowNotOpen) {
      return;
    }
    this.#enterCommissioningMode(this.#windowStatus, this.#activeDiscriminator).catch(
      (error) => logger.warn("Error sending announcement:", error)
    );
  }
  async #enterCommissioningMode(windowStatus, discriminator) {
    this.#windowStatus = windowStatus;
    const commissioningConfig = this.#context.commissioningConfig.values;
    await this.#context.advertiser.enterCommissioningMode(
      windowStatus === import_administrator_commissioning.AdministratorCommissioning.CommissioningWindowStatus.EnhancedWindowOpen ? import_InstanceBroadcaster.CommissioningMode.Enhanced : import_InstanceBroadcaster.CommissioningMode.Basic,
      {
        ...commissioningConfig.productDescription,
        discriminator: discriminator ?? commissioningConfig.discriminator
      }
    );
  }
  async #becomeCommissionable(windowStatus, activeCommissioningEndCallback, discriminator) {
    if (this.#windowStatus === windowStatus && (discriminator === void 0 || discriminator === this.#activeDiscriminator)) {
      return this.reactivateAdvertiser();
    }
    if (this.#windowStatus !== import_administrator_commissioning.AdministratorCommissioning.CommissioningWindowStatus.WindowNotOpen) {
      throw new import_general.InternalError(`Commissioning window already open with different mode (${this.#windowStatus})!`);
    }
    if (this.#activeCommissioningEndCallback !== void 0) {
      throw new import_general.InternalError("Commissioning window already open with different callback!");
    }
    this.#activeCommissioningEndCallback = activeCommissioningEndCallback;
    this.#activeDiscriminator = discriminator;
    this.#enterCommissioningMode(windowStatus, discriminator).catch(
      (error) => logger.warn("Error sending announcement:", error)
    );
  }
  async endCommissioning() {
    if (this.#windowStatus === import_administrator_commissioning.AdministratorCommissioning.CommissioningWindowStatus.WindowNotOpen) {
      return;
    }
    logger.debug("Commissioning mode ended, stop announcements.");
    this.#context.secureChannelProtocol.removePaseCommissioner();
    this.#windowStatus = import_administrator_commissioning.AdministratorCommissioning.CommissioningWindowStatus.WindowNotOpen;
    if (this.#activeCommissioningEndCallback !== void 0) {
      const activeCommissioningEndCallback = this.#activeCommissioningEndCallback;
      this.#activeCommissioningEndCallback = void 0;
      await activeCommissioningEndCallback();
    }
    await this.#context.advertiser.exitCommissioningMode();
    logger.info("All commissioning announcements stopped");
  }
  async close() {
    this.#observers.close();
    await this.endCommissioning();
    if (this.#failsafeContext) {
      await this.#failsafeContext.close();
      this.#failsafeContext = void 0;
    }
  }
}
//# sourceMappingURL=DeviceCommissioner.js.map
