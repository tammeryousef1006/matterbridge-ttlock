/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { ChannelType, Observable } from "#general";
import { PeerAddress } from "../peer/PeerAddress.js";
import { ChannelManager } from "../protocol/ChannelManager.js";
import { ExchangeManager, MessageChannel } from "../protocol/ExchangeManager.js";
import { MessageExchange } from "../protocol/MessageExchange.js";
import { ProtocolHandler } from "../protocol/ProtocolHandler.js";
import { Session } from "../session/Session.js";
/**
 * Interface for obtaining an exchange with a specific peer.
 */
export declare abstract class ExchangeProvider {
    protected readonly exchangeManager: ExchangeManager;
    abstract readonly supportsReconnect: boolean;
    constructor(exchangeManager: ExchangeManager);
    hasProtocolHandler(protocolId: number): boolean;
    getProtocolHandler(protocolId: number): ProtocolHandler | undefined;
    addProtocolHandler(handler: ProtocolHandler): void;
    abstract initiateExchange(): Promise<MessageExchange>;
    abstract reconnectChannel(): Promise<boolean>;
    abstract session: Session;
    abstract channelType: ChannelType;
}
/**
 * Manages an exchange over an established channel.
 */
export declare class DedicatedChannelExchangeProvider extends ExchangeProvider {
    #private;
    readonly supportsReconnect = false;
    constructor(exchangeManager: ExchangeManager, channel: MessageChannel);
    initiateExchange(): Promise<MessageExchange>;
    reconnectChannel(): Promise<boolean>;
    get session(): Session;
    get channelType(): ChannelType;
}
/**
 * Manages peer exchange that will reestablish automatically in the case of communication failure.
 */
export declare class ReconnectableExchangeProvider extends ExchangeProvider {
    #private;
    protected readonly channelManager: ChannelManager;
    readonly supportsReconnect = true;
    constructor(exchangeManager: ExchangeManager, channelManager: ChannelManager, address: PeerAddress, reconnectChannelFunc: () => Promise<void>);
    get channelUpdated(): Observable<[void], void>;
    initiateExchange(): Promise<MessageExchange>;
    reconnectChannel(): Promise<boolean>;
    get session(): Session;
    get channelType(): ChannelType;
}
//# sourceMappingURL=ExchangeProvider.d.ts.map