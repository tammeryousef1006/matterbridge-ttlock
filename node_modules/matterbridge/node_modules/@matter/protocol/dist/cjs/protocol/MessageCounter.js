"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var MessageCounter_exports = {};
__export(MessageCounter_exports, {
  MAX_COUNTER_VALUE_32BIT: () => MAX_COUNTER_VALUE_32BIT,
  MessageCounter: () => MessageCounter,
  MessageCounterTypes: () => MessageCounterTypes,
  PersistedMessageCounter: () => PersistedMessageCounter
});
module.exports = __toCommonJS(MessageCounter_exports);
var import_general = require("#general");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const MAX_COUNTER_VALUE_32BIT = 4294967294;
const ROLLOVER_INFO_DIFFERENCE = 1e3;
var MessageCounterTypes = /* @__PURE__ */ ((MessageCounterTypes2) => {
  MessageCounterTypes2[MessageCounterTypes2["GlobalUnencrypted"] = 0] = "GlobalUnencrypted";
  MessageCounterTypes2[MessageCounterTypes2["GlobalEncryptedData"] = 1] = "GlobalEncryptedData";
  MessageCounterTypes2[MessageCounterTypes2["GlobalEncryptedControl"] = 2] = "GlobalEncryptedControl";
  MessageCounterTypes2[MessageCounterTypes2["SecureSession"] = 3] = "SecureSession";
  return MessageCounterTypes2;
})(MessageCounterTypes || {});
class MessageCounter {
  // 28 bit random number plus 1
  /**
   * Creates a new message counter with a random start value. If a aboutToRolloverCallback is provided this
   * counter is not allowed to rollover and the callback is called before a rollover would happen. Optionally provide
   * a number of messages before the rollover callback is called (Default 1000).
   */
  constructor(aboutToRolloverCallback, rolloverInfoDifference = ROLLOVER_INFO_DIFFERENCE) {
    this.aboutToRolloverCallback = aboutToRolloverCallback;
    this.rolloverInfoDifference = rolloverInfoDifference;
  }
  messageCounter = (import_general.Crypto.getRandomUInt32() >>> 4) + 1;
  async getIncrementedCounter() {
    this.messageCounter++;
    if (this.messageCounter > MAX_COUNTER_VALUE_32BIT) {
      if (this.aboutToRolloverCallback !== void 0) {
        this.messageCounter = 0;
      } else {
        throw new import_general.InternalError("Message counter rollover not allowed.");
      }
    } else if (this.aboutToRolloverCallback !== void 0 && this.messageCounter === MAX_COUNTER_VALUE_32BIT - this.rolloverInfoDifference) {
      this.aboutToRolloverCallback();
    }
    return this.messageCounter;
  }
}
class PersistedMessageCounter extends MessageCounter {
  constructor(storageContext, storageKey, aboutToRolloverCallback, rolloverInfoDifference = ROLLOVER_INFO_DIFFERENCE) {
    super(aboutToRolloverCallback, rolloverInfoDifference);
    this.storageContext = storageContext;
    this.storageKey = storageKey;
    this.#construction = (0, import_general.Construction)(this, async () => {
      if (await storageContext.has(storageKey)) {
        this.messageCounter = await storageContext.get(storageKey);
        if (this.messageCounter < 0 || this.messageCounter > MAX_COUNTER_VALUE_32BIT) {
          throw new import_general.InternalError(`Invalid message counter value: ${this.messageCounter}`);
        }
        if (this.aboutToRolloverCallback !== void 0 && this.messageCounter >= MAX_COUNTER_VALUE_32BIT - this.rolloverInfoDifference) {
          this.aboutToRolloverCallback();
        }
      }
    });
  }
  #construction;
  get construction() {
    return this.#construction;
  }
  static async create(storageContext, storageKey, aboutToRolloverCallback, rolloverInfoDifference = ROLLOVER_INFO_DIFFERENCE) {
    return (0, import_general.asyncNew)(
      PersistedMessageCounter,
      storageContext,
      storageKey,
      aboutToRolloverCallback,
      rolloverInfoDifference
    );
  }
  async getIncrementedCounter() {
    const counter = await super.getIncrementedCounter();
    await this.storageContext.set(this.storageKey, counter);
    return counter;
  }
}
//# sourceMappingURL=MessageCounter.js.map
