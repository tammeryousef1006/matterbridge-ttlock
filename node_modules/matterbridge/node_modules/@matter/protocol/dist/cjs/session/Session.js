"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Session_exports = {};
__export(Session_exports, {
  FALLBACK_DATAMODEL_REVISION: () => FALLBACK_DATAMODEL_REVISION,
  FALLBACK_INTERACTIONMODEL_REVISION: () => FALLBACK_INTERACTIONMODEL_REVISION,
  FALLBACK_MAX_PATHS_PER_INVOKE: () => FALLBACK_MAX_PATHS_PER_INVOKE,
  FALLBACK_MAX_TCP_MESSAGE_SIZE: () => FALLBACK_MAX_TCP_MESSAGE_SIZE,
  FALLBACK_SPECIFICATION_VERSION: () => FALLBACK_SPECIFICATION_VERSION,
  SESSION_ACTIVE_INTERVAL_MS: () => SESSION_ACTIVE_INTERVAL_MS,
  SESSION_ACTIVE_THRESHOLD_MS: () => SESSION_ACTIVE_THRESHOLD_MS,
  SESSION_IDLE_INTERVAL_MS: () => SESSION_IDLE_INTERVAL_MS,
  Session: () => Session
});
module.exports = __toCommonJS(Session_exports);
var import_general = require("#general");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const SESSION_ACTIVE_INTERVAL_MS = 300;
const SESSION_IDLE_INTERVAL_MS = 500;
const SESSION_ACTIVE_THRESHOLD_MS = 4e3;
const FALLBACK_DATAMODEL_REVISION = 17;
const FALLBACK_INTERACTIONMODEL_REVISION = 11;
const FALLBACK_SPECIFICATION_VERSION = 0;
const FALLBACK_MAX_PATHS_PER_INVOKE = 1;
const FALLBACK_MAX_TCP_MESSAGE_SIZE = 64e3;
class Session {
  #manager;
  timestamp = import_general.Time.nowMs();
  createdAt = import_general.Time.nowMs();
  activeTimestamp = 0;
  idleIntervalMs;
  activeIntervalMs;
  activeThresholdMs;
  dataModelRevision;
  interactionModelRevision;
  specificationVersion;
  maxPathsPerInvoke;
  messageCounter;
  messageReceptionState;
  supportedTransports;
  maxTcpMessageSize;
  /**
   * If the ExchangeManager performs async work to clean up a session it sets this promise.  This is because
   * historically we didn't return from destroy() until ExchangeManager was complete.  Not sure if this is entirely
   * necessary, but it makes sense so this allows us to maintain the old behavior.
   */
  closer;
  #destroyed = (0, import_general.AsyncObservable)();
  constructor(args) {
    const {
      manager,
      messageCounter,
      messageReceptionState,
      sessionParameters: {
        idleIntervalMs = SESSION_IDLE_INTERVAL_MS,
        activeIntervalMs = SESSION_ACTIVE_INTERVAL_MS,
        activeThresholdMs = SESSION_ACTIVE_THRESHOLD_MS,
        dataModelRevision = FALLBACK_DATAMODEL_REVISION,
        interactionModelRevision = FALLBACK_INTERACTIONMODEL_REVISION,
        specificationVersion = FALLBACK_SPECIFICATION_VERSION,
        maxPathsPerInvoke = FALLBACK_MAX_PATHS_PER_INVOKE,
        supportedTransports = {},
        // no TCP support by default
        maxTcpMessageSize = FALLBACK_MAX_TCP_MESSAGE_SIZE
      } = {},
      setActiveTimestamp
    } = args;
    this.#manager = manager;
    this.messageCounter = messageCounter;
    this.messageReceptionState = messageReceptionState;
    this.idleIntervalMs = idleIntervalMs;
    this.activeIntervalMs = activeIntervalMs;
    this.activeThresholdMs = activeThresholdMs;
    this.dataModelRevision = dataModelRevision;
    this.interactionModelRevision = interactionModelRevision;
    this.specificationVersion = specificationVersion;
    this.maxPathsPerInvoke = maxPathsPerInvoke;
    this.supportedTransports = supportedTransports;
    this.maxTcpMessageSize = maxTcpMessageSize;
    if (setActiveTimestamp) {
      this.activeTimestamp = this.timestamp;
    }
  }
  get destroyed() {
    return this.#destroyed;
  }
  notifyActivity(messageReceived) {
    this.timestamp = import_general.Time.nowMs();
    if (messageReceived) {
      this.activeTimestamp = this.timestamp;
    }
  }
  isPeerActive() {
    return import_general.Time.nowMs() - this.activeTimestamp < this.activeThresholdMs;
  }
  getIncrementedMessageCounter() {
    return this.messageCounter.getIncrementedCounter();
  }
  updateMessageCounter(messageCounter, _sourceNodeId) {
    this.messageReceptionState.updateMessageCounter(messageCounter);
  }
  /**
   * The peer's session parameters.
   */
  get parameters() {
    const {
      idleIntervalMs,
      activeIntervalMs,
      activeThresholdMs,
      dataModelRevision,
      interactionModelRevision,
      specificationVersion,
      maxPathsPerInvoke,
      supportedTransports,
      maxTcpMessageSize
    } = this;
    return {
      idleIntervalMs,
      activeIntervalMs,
      activeThresholdMs,
      dataModelRevision,
      interactionModelRevision,
      specificationVersion,
      maxPathsPerInvoke,
      supportedTransports,
      maxTcpMessageSize
    };
  }
  get manager() {
    return this.#manager;
  }
  /**
   * @deprecated
   */
  get owner() {
    return this.#manager?.owner;
  }
}
//# sourceMappingURL=Session.js.map
