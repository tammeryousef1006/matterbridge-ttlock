"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var SessionManager_exports = {};
__export(SessionManager_exports, {
  SessionManager: () => SessionManager,
  UNICAST_UNSECURE_SESSION_ID: () => UNICAST_UNSECURE_SESSION_ID
});
module.exports = __toCommonJS(SessionManager_exports);
var import_FabricManager = require("#fabric/FabricManager.js");
var import_general = require("#general");
var import_model = require("#model");
var import_PeerAddress = require("#peer/PeerAddress.js");
var import_types = require("#types");
var import_Scanner = require("../common/Scanner.js");
var import_MessageCounter = require("../protocol/MessageCounter.js");
var import_InsecureSession = require("./InsecureSession.js");
var import_SecureSession = require("./SecureSession.js");
var import_Session = require("./Session.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("SessionManager");
const DEFAULT_SESSION_PARAMETERS = {
  idleIntervalMs: import_Session.SESSION_IDLE_INTERVAL_MS,
  activeIntervalMs: import_Session.SESSION_ACTIVE_INTERVAL_MS,
  activeThresholdMs: import_Session.SESSION_ACTIVE_THRESHOLD_MS,
  dataModelRevision: import_model.Specification.DATA_MODEL_REVISION,
  interactionModelRevision: import_model.Specification.INTERACTION_MODEL_REVISION,
  specificationVersion: import_model.Specification.SPECIFICATION_VERSION,
  maxPathsPerInvoke: import_types.DEFAULT_MAX_PATHS_PER_INVOKE,
  supportedTransports: {},
  maxTcpMessageSize: import_Session.FALLBACK_MAX_TCP_MESSAGE_SIZE
};
const UNICAST_UNSECURE_SESSION_ID = 0;
class SessionManager {
  #context;
  #insecureSessions = /* @__PURE__ */ new Map();
  #sessions = new import_general.BasicSet();
  #nextSessionId = import_general.Crypto.getRandomUInt16();
  #resumptionRecords = new import_PeerAddress.PeerAddressMap();
  #globalUnencryptedMessageCounter = new import_MessageCounter.MessageCounter();
  #subscriptionsChanged = (0, import_general.Observable)();
  #sessionParameters;
  #resubmissionStarted = (0, import_general.Observable)();
  #construction;
  #observers = new import_general.ObserverGroup();
  #subscriptionUpdateMutex = new import_general.Mutex(this);
  constructor(context) {
    this.#context = context;
    this.#sessionParameters = { ...DEFAULT_SESSION_PARAMETERS, ...context.parameters };
    this.#observers.on(
      context.fabrics.events.deleted,
      async (fabric) => this.deleteResumptionRecordsForFabric(fabric)
    );
    this.#construction = (0, import_general.Construction)(this, () => this.#initialize());
  }
  static [import_general.Environmental.create](env) {
    const instance = new SessionManager({
      storage: env.get(import_general.StorageManager).createContext("sessions"),
      fabrics: env.get(import_FabricManager.FabricManager)
    });
    env.set(SessionManager, instance);
    return instance;
  }
  get construction() {
    return this.#construction;
  }
  get context() {
    return this.#context;
  }
  /**
   * Active secure sessions.
   */
  get sessions() {
    return this.#sessions;
  }
  /**
   * Active insecure sessions.
   */
  get insecureSessions() {
    return this.#insecureSessions;
  }
  /**
   * Our session parameters.  These are the parameters we provide during session negotiation.  The peer may specify
   * different parameters.
   */
  get sessionParameters() {
    return this.#sessionParameters;
  }
  /**
   * Change session parameters.
   *
   * Parameters values you omit in {@link parameters} will retain their current values.  This only affects new
   * sessions.
   */
  set sessionParameters(parameters) {
    this.#sessionParameters = {
      ...this.#sessionParameters,
      ...parameters
    };
  }
  /**
   * Emits when there is a change to the subscription set.
   */
  get subscriptionsChanged() {
    return this.#subscriptionsChanged;
  }
  /**
   * Emits when resubmission is necessary due to timeout or network error.
   */
  get resubmissionStarted() {
    return this.#resubmissionStarted;
  }
  /**
   * Convenience function for accessing a fabric by address.
   */
  fabricFor(address) {
    return this.#context.fabrics.for(address);
  }
  /**
   * @deprecated
   */
  get owner() {
    return this.#context.owner;
  }
  createInsecureSession(options) {
    this.#construction.assert();
    const { initiatorNodeId, sessionParameters, isInitiator } = options;
    if (initiatorNodeId !== void 0) {
      if (this.#insecureSessions.has(initiatorNodeId)) {
        throw new import_general.MatterFlowError(`UnsecureSession with NodeId ${initiatorNodeId} already exists.`);
      }
    }
    while (true) {
      const session = new import_InsecureSession.InsecureSession({
        manager: this,
        messageCounter: this.#globalUnencryptedMessageCounter,
        initiatorNodeId,
        sessionParameters,
        isInitiator: isInitiator ?? false
      });
      const ephemeralNodeId = session.nodeId;
      if (this.#insecureSessions.has(ephemeralNodeId)) continue;
      this.#insecureSessions.set(ephemeralNodeId, session);
      return session;
    }
  }
  async createSecureSession(args) {
    await this.construction;
    const {
      sessionId,
      fabric,
      peerNodeId,
      peerSessionId,
      sharedSecret,
      salt,
      isInitiator,
      isResumption,
      peerSessionParameters,
      caseAuthenticatedTags
    } = args;
    const session = await import_SecureSession.SecureSession.create({
      manager: this,
      id: sessionId,
      fabric,
      peerNodeId,
      peerSessionId,
      sharedSecret,
      salt,
      isInitiator,
      isResumption,
      peerSessionParameters,
      caseAuthenticatedTags
    });
    const subscriptionsChanged = (subscription) => {
      if (session.isClosing) {
        return;
      }
      this.#subscriptionsChanged.emit(session, subscription);
    };
    session.subscriptions.added.on(subscriptionsChanged);
    session.subscriptions.deleted.on(subscriptionsChanged);
    this.#sessions.add(session);
    return session;
  }
  async deleteResumptionRecord(address) {
    await this.#construction;
    this.#resumptionRecords.delete(address);
    await this.#storeResumptionRecords();
  }
  async deleteResumptionRecordsForFabric(fabric) {
    await this.#construction;
    for (const address of this.#resumptionRecords.keys()) {
      if (address.fabricIndex === fabric.fabricIndex) {
        this.#resumptionRecords.delete(address);
      }
    }
    await this.#storeResumptionRecords();
  }
  findOldestInactiveSession() {
    this.#construction.assert();
    let oldestSession = void 0;
    for (const session of this.#sessions) {
      if (!oldestSession || session.activeTimestamp < oldestSession.activeTimestamp) {
        oldestSession = session;
      }
    }
    if (oldestSession === void 0) {
      throw new import_general.MatterFlowError("No session found to close and all session ids are taken.");
    }
    return oldestSession;
  }
  async getNextAvailableSessionId() {
    await this.#construction;
    for (let i = 0; i < 65535; i++) {
      const id = this.#nextSessionId;
      this.#nextSessionId = this.#nextSessionId + 1 & 65535;
      if (this.#nextSessionId === 0) this.#nextSessionId++;
      if (this.getSession(id) === void 0) {
        return id;
      }
    }
    const oldestSession = this.findOldestInactiveSession();
    await oldestSession.end(true, false);
    this.#nextSessionId = oldestSession.id;
    return this.#nextSessionId++;
  }
  getSession(sessionId) {
    this.#construction.assert();
    return this.#sessions.get("id", sessionId);
  }
  getPaseSession() {
    this.#construction.assert();
    return [...this.#sessions].find(
      (session) => session.isSecure && session.isPase && !session.closingAfterExchangeFinished
    );
  }
  getSessionForNode(address) {
    this.#construction.assert();
    return [...this.#sessions].find((session) => {
      if (!session.isSecure) return false;
      const secureSession = session;
      return secureSession.peerIs(address);
    });
  }
  async removeAllSessionsForNode(address, sendClose = false, closeBeforeCreatedTimestamp) {
    await this.#construction;
    for (const session of this.#sessions) {
      if (!session.isSecure) continue;
      if (closeBeforeCreatedTimestamp !== void 0 && session.createdAt >= closeBeforeCreatedTimestamp) continue;
      const secureSession = session;
      if (secureSession.peerIs(address)) {
        await secureSession.destroy(sendClose, false);
        this.#sessions.delete(session);
      }
    }
  }
  getUnsecureSession(sourceNodeId) {
    this.#construction.assert();
    if (sourceNodeId === void 0) {
      return this.#insecureSessions.get(import_types.NodeId.UNSPECIFIED_NODE_ID);
    }
    return this.#insecureSessions.get(sourceNodeId);
  }
  findGroupSession(groupId, groupSessionId) {
    this.#construction.assert();
    throw new Error(`Not implemented ${groupId} ${groupSessionId}`);
  }
  findResumptionRecordById(resumptionId) {
    this.#construction.assert();
    return [...this.#resumptionRecords.values()].find((record) => import_general.Bytes.areEqual(record.resumptionId, resumptionId));
  }
  findResumptionRecordByAddress(address) {
    this.#construction.assert();
    return this.#resumptionRecords.get(address);
  }
  async saveResumptionRecord(resumptionRecord) {
    await this.#construction;
    this.#resumptionRecords.set(resumptionRecord.fabric.addressOf(resumptionRecord.peerNodeId), resumptionRecord);
    await this.#storeResumptionRecords();
  }
  async #storeResumptionRecords() {
    await this.#construction;
    await this.#context.storage.set(
      "resumptionRecords",
      [...this.#resumptionRecords].map(
        ([
          address,
          { sharedSecret, resumptionId, peerNodeId, fabric, sessionParameters, caseAuthenticatedTags }
        ]) => ({
          nodeId: address.nodeId,
          sharedSecret,
          resumptionId,
          fabricId: fabric.fabricId,
          peerNodeId,
          sessionParameters: {
            ...sessionParameters,
            supportedTransports: sessionParameters.supportedTransports ? import_Scanner.SupportedTransportsSchema.encode(sessionParameters.supportedTransports) : void 0
          },
          caseAuthenticatedTags
        })
      )
    );
  }
  async #initialize() {
    await this.#context.fabrics.construction;
    const storedResumptionRecords = await this.#context.storage.get(
      "resumptionRecords",
      []
    );
    storedResumptionRecords.forEach(
      ({
        nodeId,
        sharedSecret,
        resumptionId,
        fabricId,
        peerNodeId,
        sessionParameters: {
          idleIntervalMs,
          activeIntervalMs,
          activeThresholdMs,
          dataModelRevision,
          interactionModelRevision,
          specificationVersion,
          maxPathsPerInvoke,
          supportedTransports,
          maxTcpMessageSize
        } = {},
        caseAuthenticatedTags
      }) => {
        const fabric = this.#context.fabrics.find((fabric2) => fabric2.fabricId === fabricId);
        logger.info(
          "restoring resumption record for node",
          nodeId,
          "and peer node",
          peerNodeId,
          "for fabric index",
          fabric?.fabricIndex
        );
        if (!fabric) {
          logger.error("fabric not found for resumption record", fabricId);
          return;
        }
        this.#resumptionRecords.set(fabric.addressOf(nodeId), {
          sharedSecret,
          resumptionId,
          fabric,
          peerNodeId,
          sessionParameters: {
            // Make sure to initialize default values when restoring an older resumption record
            idleIntervalMs: idleIntervalMs ?? import_Session.SESSION_IDLE_INTERVAL_MS,
            activeIntervalMs: activeIntervalMs ?? import_Session.SESSION_ACTIVE_INTERVAL_MS,
            activeThresholdMs: activeThresholdMs ?? import_Session.SESSION_ACTIVE_THRESHOLD_MS,
            dataModelRevision: dataModelRevision ?? import_Session.FALLBACK_DATAMODEL_REVISION,
            interactionModelRevision: interactionModelRevision ?? import_Session.FALLBACK_INTERACTIONMODEL_REVISION,
            specificationVersion: specificationVersion ?? import_Session.FALLBACK_SPECIFICATION_VERSION,
            maxPathsPerInvoke: maxPathsPerInvoke ?? import_Session.FALLBACK_MAX_PATHS_PER_INVOKE,
            supportedTransports: supportedTransports !== void 0 ? import_Scanner.SupportedTransportsSchema.decode(supportedTransports) : {},
            maxTcpMessageSize: maxTcpMessageSize ?? import_Session.FALLBACK_MAX_TCP_MESSAGE_SIZE
          },
          caseAuthenticatedTags
        });
      }
    );
  }
  getActiveSessionInformation() {
    this.#construction.assert();
    return [...this.#sessions].filter((session) => session.isSecure && !session.isPase).map((session) => ({
      name: session.name,
      nodeId: session.nodeId,
      peerNodeId: session.peerNodeId,
      fabric: session instanceof import_SecureSession.SecureSession ? session.fabric?.externalInformation : void 0,
      isPeerActive: session.isPeerActive(),
      secure: session.isSecure,
      lastInteractionTimestamp: session instanceof import_SecureSession.SecureSession ? session.timestamp : void 0,
      lastActiveTimestamp: session instanceof import_SecureSession.SecureSession ? session.activeTimestamp : void 0,
      numberOfActiveSubscriptions: session instanceof import_SecureSession.SecureSession ? session.subscriptions.size : 0
    }));
  }
  async close() {
    if (this.#construction.status === import_general.Lifecycle.Status.Initializing) {
      await this.#construction;
    }
    await this.#subscriptionUpdateMutex;
    this.#observers.close();
    await this.#storeResumptionRecords();
    const closePromises = this.#sessions.map(async (session) => {
      await session?.end(false);
      this.#sessions.delete(session);
    });
    for (const session of this.#insecureSessions.values()) {
      closePromises.push(session?.end());
    }
    await import_general.MatterAggregateError.allSettled(closePromises, "Error closing sessions").catch(
      (error) => logger.error(error)
    );
  }
  async clear() {
    await this.close();
    await this.#context.storage.clear();
    this.#resumptionRecords.clear();
  }
  updateAllSubscriptions() {
    this.#subscriptionUpdateMutex.run(async () => {
      for (const session of this.#sessions) {
        for (const subscription of session.subscriptions) {
          await subscription.update();
        }
      }
    });
  }
  /** Clears all subscriptions for a given node and returns how many were cleared. */
  async clearSubscriptionsForNode(peerAddress, flushSubscriptions) {
    let clearedCount = 0;
    for (const session of this.#sessions) {
      if (import_PeerAddress.PeerAddress.is(session.peerAddress, peerAddress)) {
        clearedCount += await session.clearSubscriptions(flushSubscriptions, true);
      }
    }
    return clearedCount;
  }
}
//# sourceMappingURL=SessionManager.js.map
