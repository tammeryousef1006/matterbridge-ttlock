export declare const KDFSR1_KEY_INFO: Uint8Array<ArrayBufferLike>;
export declare const KDFSR2_KEY_INFO: Uint8Array<ArrayBufferLike>;
export declare const RESUME1_MIC_NONCE: Uint8Array<ArrayBufferLike>;
export declare const RESUME2_MIC_NONCE: Uint8Array<ArrayBufferLike>;
export declare const KDFSR2_INFO: Uint8Array<ArrayBufferLike>;
export declare const KDFSR3_INFO: Uint8Array<ArrayBufferLike>;
export declare const TBE_DATA2_NONCE: Uint8Array<ArrayBufferLike>;
export declare const TBE_DATA3_NONCE: Uint8Array<ArrayBufferLike>;
/** @see {@link MatterSpecification.v13.Core} § 4.14.2.3 */
export declare const TlvCaseSigma1: import("#types").ObjectSchema<{
    initiatorRandom: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
    initiatorSessionId: import("#types").FieldType<number>;
    destinationId: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
    initiatorEcdhPublicKey: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
    initiatorSessionParams: import("#types").OptionalFieldType<import("#types").TypeFromFields<{
        idleIntervalMs: import("#types").OptionalFieldType<number>;
        activeIntervalMs: import("#types").OptionalFieldType<number>;
        activeThresholdMs: import("#types").OptionalFieldType<number>;
        dataModelRevision: import("#types").OptionalFieldType<number>;
        interactionModelRevision: import("#types").OptionalFieldType<number>;
        specificationVersion: import("#types").OptionalFieldType<number>;
        maxPathsPerInvoke: import("#types").OptionalFieldType<number>;
        supportedTransports: import("#types").OptionalFieldType<import("#types").TypeFromPartialBitSchema<{
            tcpClient: import("#types").BitFlag;
            tcpServer: import("#types").BitFlag;
        }>>;
        maxTcpMessageSize: import("#types").OptionalFieldType<number>;
    }>>;
    resumptionId: import("#types").OptionalFieldType<Uint8Array<ArrayBufferLike>>;
    initiatorResumeMic: import("#types").OptionalFieldType<Uint8Array<ArrayBufferLike>>;
}>;
/** @see {@link MatterSpecification.v13.Core} § 4.14.2.3 */
export declare const TlvCaseSigma2: import("#types").ObjectSchema<{
    responderRandom: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
    responderSessionId: import("#types").FieldType<number>;
    responderEcdhPublicKey: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
    encrypted: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
    responderSessionParams: import("#types").OptionalFieldType<import("#types").TypeFromFields<{
        idleIntervalMs: import("#types").OptionalFieldType<number>;
        activeIntervalMs: import("#types").OptionalFieldType<number>;
        activeThresholdMs: import("#types").OptionalFieldType<number>;
        dataModelRevision: import("#types").OptionalFieldType<number>;
        interactionModelRevision: import("#types").OptionalFieldType<number>;
        specificationVersion: import("#types").OptionalFieldType<number>;
        maxPathsPerInvoke: import("#types").OptionalFieldType<number>;
        supportedTransports: import("#types").OptionalFieldType<import("#types").TypeFromPartialBitSchema<{
            tcpClient: import("#types").BitFlag;
            tcpServer: import("#types").BitFlag;
        }>>;
        maxTcpMessageSize: import("#types").OptionalFieldType<number>;
    }>>;
}>;
/** @see {@link MatterSpecification.v13.Core} § 4.14.2.3 */
export declare const TlvCaseSigma2Resume: import("#types").ObjectSchema<{
    resumptionId: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
    resumeMic: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
    responderSessionId: import("#types").FieldType<number>;
    responderSessionParams: import("#types").OptionalFieldType<import("#types").TypeFromFields<{
        idleIntervalMs: import("#types").OptionalFieldType<number>;
        activeIntervalMs: import("#types").OptionalFieldType<number>;
        activeThresholdMs: import("#types").OptionalFieldType<number>;
        dataModelRevision: import("#types").OptionalFieldType<number>;
        interactionModelRevision: import("#types").OptionalFieldType<number>;
        specificationVersion: import("#types").OptionalFieldType<number>;
        maxPathsPerInvoke: import("#types").OptionalFieldType<number>;
        supportedTransports: import("#types").OptionalFieldType<import("#types").TypeFromPartialBitSchema<{
            tcpClient: import("#types").BitFlag;
            tcpServer: import("#types").BitFlag;
        }>>;
        maxTcpMessageSize: import("#types").OptionalFieldType<number>;
    }>>;
}>;
/** @see {@link MatterSpecification.v13.Core} § 4.14.2.3 */
export declare const TlvCaseSigma3: import("#types").ObjectSchema<{
    encrypted: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
}>;
/** @see {@link MatterSpecification.v10.Core} § 4.13.2.3 */
export declare const TlvSignedData: import("#types").ObjectSchema<{
    nodeOpCert: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
    intermediateCACert: import("#types").OptionalFieldType<Uint8Array<ArrayBufferLike>>;
    ecdhPublicKey: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
    peerEcdhPublicKey: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
}>;
/** @see {@link MatterSpecification.v10.Core} § 4.13.2.3 */
export declare const TlvEncryptedDataSigma2: import("#types").ObjectSchema<{
    nodeOpCert: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
    intermediateCACert: import("#types").OptionalFieldType<Uint8Array<ArrayBufferLike>>;
    signature: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
    resumptionId: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
}>;
/** @see {@link MatterSpecification.v10.Core} § 4.13.2.3 */
export declare const TlvEncryptedDataSigma3: import("#types").ObjectSchema<{
    nodeOpCert: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
    intermediateCACert: import("#types").OptionalFieldType<Uint8Array<ArrayBufferLike>>;
    signature: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
}>;
//# sourceMappingURL=CaseMessages.d.ts.map