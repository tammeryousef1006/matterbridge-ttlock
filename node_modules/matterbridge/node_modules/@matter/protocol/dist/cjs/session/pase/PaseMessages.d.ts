/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
/** @see {@link MatterSpecification.v13.Core} § 4.12.8 */
export declare const TlvSessionParameters: import("#types").ObjectSchema<{
    /** Maximum sleep interval of node when in idle mode. */
    idleIntervalMs: import("#types").OptionalFieldType<number>;
    /** Maximum sleep interval of node when in active mode. */
    activeIntervalMs: import("#types").OptionalFieldType<number>;
    /** Minimum amount of time the node SHOULD stay active after network activity. */
    activeThresholdMs: import("#types").OptionalFieldType<number>;
    /** Data model revision. */
    dataModelRevision: import("#types").OptionalFieldType<number>;
    /** Interaction model revision. */
    interactionModelRevision: import("#types").OptionalFieldType<number>;
    /** Specification version. */
    specificationVersion: import("#types").OptionalFieldType<number>;
    /** Maximum Paths pert Invoke */
    maxPathsPerInvoke: import("#types").OptionalFieldType<number>;
    /** Supported transport protocols in addition to MRP.*/
    supportedTransports: import("#types").OptionalFieldType<import("#types").TypeFromPartialBitSchema<{
        tcpClient: import("#types").BitFlag;
        tcpServer: import("#types").BitFlag;
    }>>;
    /** Maximum size of the message carried over TCP in bytes */
    maxTcpMessageSize: import("#types").OptionalFieldType<number>;
}>;
/** @see {@link MatterSpecification.v13.Core} § 4.14.1.2 */
export declare const TlvPbkdfParamRequest: import("#types").ObjectSchema<{
    initiatorRandom: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
    initiatorSessionId: import("#types").FieldType<number>;
    passcodeId: import("#types").FieldType<number>;
    hasPbkdfParameters: import("#types").FieldType<boolean>;
    initiatorSessionParams: import("#types").OptionalFieldType<import("#types").TypeFromFields<{
        /** Maximum sleep interval of node when in idle mode. */
        idleIntervalMs: import("#types").OptionalFieldType<number>;
        /** Maximum sleep interval of node when in active mode. */
        activeIntervalMs: import("#types").OptionalFieldType<number>;
        /** Minimum amount of time the node SHOULD stay active after network activity. */
        activeThresholdMs: import("#types").OptionalFieldType<number>;
        /** Data model revision. */
        dataModelRevision: import("#types").OptionalFieldType<number>;
        /** Interaction model revision. */
        interactionModelRevision: import("#types").OptionalFieldType<number>;
        /** Specification version. */
        specificationVersion: import("#types").OptionalFieldType<number>;
        /** Maximum Paths pert Invoke */
        maxPathsPerInvoke: import("#types").OptionalFieldType<number>;
        /** Supported transport protocols in addition to MRP.*/
        supportedTransports: import("#types").OptionalFieldType<import("#types").TypeFromPartialBitSchema<{
            tcpClient: import("#types").BitFlag;
            tcpServer: import("#types").BitFlag;
        }>>;
        /** Maximum size of the message carried over TCP in bytes */
        maxTcpMessageSize: import("#types").OptionalFieldType<number>;
    }>>;
}>;
/** @see {@link MatterSpecification.v13.Core} § 4.14.1.2 */
export declare const TlvPbkdfParamResponse: import("#types").ObjectSchema<{
    initiatorRandom: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
    responderRandom: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
    responderSessionId: import("#types").FieldType<number>;
    pbkdfParameters: import("#types").OptionalFieldType<import("#types").TypeFromFields<{
        iterations: import("#types").FieldType<number>;
        salt: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
    }>>;
    responderSessionParams: import("#types").OptionalFieldType<import("#types").TypeFromFields<{
        /** Maximum sleep interval of node when in idle mode. */
        idleIntervalMs: import("#types").OptionalFieldType<number>;
        /** Maximum sleep interval of node when in active mode. */
        activeIntervalMs: import("#types").OptionalFieldType<number>;
        /** Minimum amount of time the node SHOULD stay active after network activity. */
        activeThresholdMs: import("#types").OptionalFieldType<number>;
        /** Data model revision. */
        dataModelRevision: import("#types").OptionalFieldType<number>;
        /** Interaction model revision. */
        interactionModelRevision: import("#types").OptionalFieldType<number>;
        /** Specification version. */
        specificationVersion: import("#types").OptionalFieldType<number>;
        /** Maximum Paths pert Invoke */
        maxPathsPerInvoke: import("#types").OptionalFieldType<number>;
        /** Supported transport protocols in addition to MRP.*/
        supportedTransports: import("#types").OptionalFieldType<import("#types").TypeFromPartialBitSchema<{
            tcpClient: import("#types").BitFlag;
            tcpServer: import("#types").BitFlag;
        }>>;
        /** Maximum size of the message carried over TCP in bytes */
        maxTcpMessageSize: import("#types").OptionalFieldType<number>;
    }>>;
}>;
/** @see {@link MatterSpecification.v13.Core} § 4.14.1.2 */
export declare const TlvPasePake1: import("#types").ObjectSchema<{
    x: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
}>;
/** @see {@link MatterSpecification.v13.Core} § 4.14.1.2 */
export declare const TlvPasePake2: import("#types").ObjectSchema<{
    y: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
    verifier: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
}>;
/** @see {@link MatterSpecification.v13.Core} § 4.14.1.2 */
export declare const TlvPasePake3: import("#types").ObjectSchema<{
    verifier: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
}>;
//# sourceMappingURL=PaseMessages.d.ts.map