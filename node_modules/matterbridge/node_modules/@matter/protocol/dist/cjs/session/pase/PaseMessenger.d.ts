/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { TypeFromSchema } from "#types";
import { SecureChannelMessenger } from "../../securechannel/SecureChannelMessenger.js";
import { TlvPasePake1, TlvPasePake2, TlvPasePake3, TlvPbkdfParamRequest, TlvPbkdfParamResponse } from "./PaseMessages.js";
export declare const DEFAULT_PASSCODE_ID = 0;
export declare const SPAKE_CONTEXT: Uint8Array<ArrayBufferLike>;
type PbkdfParamRequest = TypeFromSchema<typeof TlvPbkdfParamRequest>;
type PbkdfParamResponse = TypeFromSchema<typeof TlvPbkdfParamResponse>;
type PasePake1 = TypeFromSchema<typeof TlvPasePake1>;
type PasePake2 = TypeFromSchema<typeof TlvPasePake2>;
type PasePake3 = TypeFromSchema<typeof TlvPasePake3>;
export declare class PaseServerMessenger extends SecureChannelMessenger {
    readPbkdfParamRequest(): Promise<{
        requestPayload: Uint8Array<ArrayBufferLike>;
        request: import("#types").TypeFromFields<{
            initiatorRandom: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
            initiatorSessionId: import("#types").FieldType<number>;
            passcodeId: import("#types").FieldType<number>;
            hasPbkdfParameters: import("#types").FieldType<boolean>;
            initiatorSessionParams: import("#types").OptionalFieldType<import("#types").TypeFromFields<{
                idleIntervalMs: import("#types").OptionalFieldType<number>;
                activeIntervalMs: import("#types").OptionalFieldType<number>;
                activeThresholdMs: import("#types").OptionalFieldType<number>;
                dataModelRevision: import("#types").OptionalFieldType<number>;
                interactionModelRevision: import("#types").OptionalFieldType<number>;
                specificationVersion: import("#types").OptionalFieldType<number>;
                maxPathsPerInvoke: import("#types").OptionalFieldType<number>;
                supportedTransports: import("#types").OptionalFieldType<import("#types").TypeFromPartialBitSchema<{
                    tcpClient: import("#types").BitFlag;
                    tcpServer: import("#types").BitFlag;
                }>>;
                maxTcpMessageSize: import("#types").OptionalFieldType<number>;
            }>>;
        }>;
    }>;
    sendPbkdfParamResponse(response: PbkdfParamResponse): Promise<Uint8Array<ArrayBufferLike>>;
    readPasePake1(): Promise<import("#types").TypeFromFields<{
        x: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
    }>>;
    sendPasePake2(pasePake2: PasePake2): Promise<Uint8Array<ArrayBufferLike>>;
    readPasePake3(): Promise<import("#types").TypeFromFields<{
        verifier: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
    }>>;
}
export declare class PaseClientMessenger extends SecureChannelMessenger {
    sendPbkdfParamRequest(request: PbkdfParamRequest): Promise<Uint8Array<ArrayBufferLike>>;
    readPbkdfParamResponse(): Promise<{
        responsePayload: Uint8Array<ArrayBufferLike>;
        response: import("#types").TypeFromFields<{
            initiatorRandom: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
            responderRandom: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
            responderSessionId: import("#types").FieldType<number>;
            pbkdfParameters: import("#types").OptionalFieldType<import("#types").TypeFromFields<{
                iterations: import("#types").FieldType<number>;
                salt: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
            }>>;
            responderSessionParams: import("#types").OptionalFieldType<import("#types").TypeFromFields<{
                idleIntervalMs: import("#types").OptionalFieldType<number>;
                activeIntervalMs: import("#types").OptionalFieldType<number>;
                activeThresholdMs: import("#types").OptionalFieldType<number>;
                dataModelRevision: import("#types").OptionalFieldType<number>;
                interactionModelRevision: import("#types").OptionalFieldType<number>;
                specificationVersion: import("#types").OptionalFieldType<number>;
                maxPathsPerInvoke: import("#types").OptionalFieldType<number>;
                supportedTransports: import("#types").OptionalFieldType<import("#types").TypeFromPartialBitSchema<{
                    tcpClient: import("#types").BitFlag;
                    tcpServer: import("#types").BitFlag;
                }>>;
                maxTcpMessageSize: import("#types").OptionalFieldType<number>;
            }>>;
        }>;
    }>;
    sendPasePake1(pasePake1: PasePake1): Promise<Uint8Array<ArrayBufferLike>>;
    readPasePake2(): Promise<import("#types").TypeFromFields<{
        y: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
        verifier: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
    }>>;
    sendPasePake3(pasePake3: PasePake3): Promise<Uint8Array<ArrayBufferLike>>;
}
export {};
//# sourceMappingURL=PaseMessenger.d.ts.map