/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Access, AccessLevel, ElementTag, ValueModel } from "#model";
import { StatusCode } from "#types";
import { InvokeError, ReadError, SchemaImplementationError, WriteError } from "../errors.js";
const cache = /* @__PURE__ */ new WeakMap();
function AccessControl(schema) {
  let enforcer = cache.get(schema);
  if (enforcer === void 0) {
    enforcer = enforcerFor(schema);
  }
  return enforcer;
}
((AccessControl2) => {
  let Authority;
  ((Authority2) => {
    Authority2[Authority2["Granted"] = 1] = "Granted";
    Authority2[Authority2["Unauthorized"] = 2] = "Unauthorized";
    Authority2[Authority2["Restricted"] = 3] = "Restricted";
  })(Authority = AccessControl2.Authority || (AccessControl2.Authority = {}));
})(AccessControl || (AccessControl = {}));
Object.freeze(AccessControl);
Object.freeze(AccessControl.Authority);
function enforcerFor(schema) {
  if (schema.tag === ElementTag.Command) {
    return commandEnforcerFor(schema);
  }
  return dataEnforcerFor(schema);
}
function dataEnforcerFor(schema) {
  const limits = limitsFor(schema);
  let mayRead = (session, location) => {
    if (session.offline || session.command) {
      return true;
    }
    return session.authorityAt(limits.readLevel, location) === 1 /* Granted */;
  };
  let mayWrite = (session, location) => {
    if (session.offline || session.command) {
      return true;
    }
    return session.authorityAt(limits.writeLevel, location) === 1 /* Granted */;
  };
  let authorizeRead = (session, location) => {
    if (session.offline || session.command) {
      return;
    }
    if (session.authorityAt(limits.readLevel, location) === 1 /* Granted */) {
      return;
    }
    throw new ReadError(location, "Permission denied", StatusCode.UnsupportedAccess);
  };
  let authorizeWrite = (session, location) => {
    if (session.offline || session.command) {
      return;
    }
    if (session.authorityAt(limits.writeLevel, location) === 1 /* Granted */) {
      return;
    }
    throw new WriteError(location, "Permission denied", StatusCode.UnsupportedAccess);
  };
  if (limits.timed) {
    const wrappedAuthorizeWrite = authorizeWrite;
    const wrappedMayWrite = mayWrite;
    authorizeWrite = (session, location) => {
      if (!session.offline && !session.timed) {
        throw new WriteError(
          location,
          "Permission denied because interaction is not timed",
          StatusCode.NeedsTimedInteraction
        );
      }
      wrappedAuthorizeWrite?.(session, location);
    };
    mayWrite = (session, location) => {
      if (!session.offline && !session.timed) {
        return false;
      }
      return wrappedMayWrite(session, location);
    };
  }
  if (limits.fabricSensitive) {
    const wrappedAuthorizeRead = authorizeRead;
    const wrappedMayRead = mayRead;
    const wrappedAuthorizeWrite = authorizeWrite;
    const wrappedMayWrite = mayWrite;
    authorizeRead = (session, location) => {
      if (session.offline || session.command) {
        return;
      }
      if (session.fabricFiltered) {
        if (session.fabric === void 0) {
          throw new ReadError(
            location,
            "Permission denied: No accessing fabric",
            StatusCode.UnsupportedAccess
          );
        }
        if (location?.owningFabric && location.owningFabric !== session.fabric) {
          throw new ReadError(
            location,
            "Permission denied: Owning/accessing fabric mismatch",
            StatusCode.UnsupportedAccess
          );
        }
      }
      wrappedAuthorizeRead(session, location);
    };
    mayRead = (session, location) => {
      if (session.offline || session.command) {
        return true;
      }
      if (session.fabric === void 0) {
        return false;
      }
      if (location?.owningFabric && location.owningFabric !== session.fabric) {
        return false;
      }
      return wrappedMayRead(session, location);
    };
    authorizeWrite = (session, location) => {
      if (session.offline || session.command) {
        return;
      }
      if (session.fabric === void 0) {
        throw new WriteError(location, "Permission denied: No accessing fabric", StatusCode.UnsupportedAccess);
      }
      if (location?.owningFabric && location.owningFabric !== session.fabric) {
        throw new WriteError(location, "Permission denied: Owning/accessing fabric mismatch");
      }
      wrappedAuthorizeWrite(session, location);
    };
    mayWrite = (session, location) => {
      if (session.offline || session.command) {
        return true;
      }
      if (session.fabric === void 0) {
        return false;
      }
      if (location?.owningFabric && location.owningFabric !== session.fabric) {
        return false;
      }
      return wrappedMayWrite(session, location);
    };
  }
  if (!limits.readable) {
    authorizeRead = (session, location) => {
      if (session.offline || session.command) {
        return;
      }
      throw new ReadError(location, "Permission defined: Value is write-only");
    };
    mayRead = (session) => {
      return !!session.offline || !!session.command;
    };
  }
  if (!limits.writable) {
    authorizeWrite = (session, location) => {
      if (session.offline || session.command) {
        return;
      }
      throw new WriteError(location, "Permission denied: Value is read-only");
    };
    mayWrite = (session) => {
      return !!session.offline || !!session.command;
    };
  }
  return Object.freeze({
    limits,
    authorizeRead,
    mayRead,
    authorizeWrite,
    mayWrite,
    authorizeInvoke(_session, location) {
      throw new SchemaImplementationError(location, "Permission denied: Invoke request but non-command schema");
    },
    mayInvoke() {
      return false;
    }
  });
}
function commandEnforcerFor(schema) {
  const limits = limitsFor(schema);
  const timed = schema.effectiveAccess.timed;
  const fabric = schema.effectiveAccess.fabric;
  return {
    limits,
    authorizeRead(_session, location) {
      throw new SchemaImplementationError(location, "Permission denied: Read request but command schema");
    },
    mayRead() {
      return false;
    },
    authorizeWrite(_session, location) {
      throw new SchemaImplementationError(location, "Permission denied: Write request but command schema");
    },
    mayWrite() {
      return false;
    },
    authorizeInvoke(session, location) {
      if (session.offline) {
        return;
      }
      if (!session.command) {
        throw new InvokeError(location, "Invoke attempt without command context");
      }
      if (timed && !session.timed) {
        throw new InvokeError(
          location,
          "Invoke attempt without required timed context",
          StatusCode.TimedRequestMismatch
        );
      }
      if (fabric && session.fabric === void 0) {
        throw new WriteError(location, "Permission denied: No accessing fabric", StatusCode.UnsupportedAccess);
      }
      if (session.authorityAt(limits.writeLevel, location) === 1 /* Granted */) {
        return;
      }
      throw new InvokeError(location, "Permission denied", StatusCode.UnsupportedAccess);
    },
    mayInvoke(session, location) {
      if (session.offline) {
        return true;
      }
      if (!session.command) {
        return false;
      }
      if (timed && !session.timed) {
        return false;
      }
      if (fabric && session.fabric === void 0) {
        return false;
      }
      return session.authorityAt(limits.writeLevel, location) === 1 /* Granted */;
    }
  };
}
function limitsFor(schema) {
  const access = schema.effectiveAccess;
  const quality = schema instanceof ValueModel ? schema.effectiveQuality : void 0;
  let fixed = quality?.fixed;
  for (let s = schema.parent; !fixed && s instanceof ValueModel; s = s.parent) {
    if (s.effectiveQuality.fixed) {
      fixed = true;
    }
  }
  const limits = Object.freeze({
    readable: access.readable,
    writable: access.writable && !fixed,
    fabricScoped: access.fabric === Access.Fabric.Scoped || access.fabric === Access.Fabric.Sensitive,
    fabricSensitive: access.fabric === Access.Fabric.Sensitive,
    timed: access.timed === true,
    // Official Matter defaults are View for read and Operate for write. However, the schema's effective access
    // should already have these defaults.  Here we just adopt minimum needed rights as a safe fallback access level.
    readLevel: access.readPriv === void 0 ? AccessLevel.View : Access.PrivilegeLevel[access.readPriv],
    writeLevel: access.writePriv === void 0 ? AccessLevel.Operate : Access.PrivilegeLevel[access.writePriv]
  });
  return limits;
}
export {
  AccessControl
};
//# sourceMappingURL=AccessControl.js.map
