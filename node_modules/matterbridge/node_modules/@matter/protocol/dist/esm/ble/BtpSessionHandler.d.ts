/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { MatterError } from "#general";
export declare class BtpMatterError extends MatterError {
}
export declare class BtpProtocolError extends BtpMatterError {
}
export declare class BtpFlowError extends BtpMatterError {
}
export declare const BTP_SUPPORTED_VERSIONS: number[];
export declare class BtpSessionHandler {
    private readonly role;
    private readonly fragmentSize;
    private readonly clientWindowSize;
    private readonly writeBleCallback;
    private readonly disconnectBleCallback;
    private readonly handleMatterMessagePayload;
    private currentIncomingSegmentedMsgLength;
    private currentIncomingSegmentedPayload;
    private prevIncomingSequenceNumber;
    private prevIncomingAckNumber;
    private readonly ackReceiveTimer;
    private sequenceNumber;
    private prevAckedSequenceNumber;
    private readonly queuedOutgoingMatterMessages;
    private sendInProgress;
    private readonly sendAckTimer;
    private isActive;
    private idleTimeout;
    /** Factory method to create a new BTPSessionHandler from a received handshake request */
    static createFromHandshakeRequest(maxDataSize: number | undefined, handshakeRequestPayload: Uint8Array, writeBleCallback: (data: Uint8Array) => Promise<void>, disconnectBleCallback: () => Promise<void>, handleMatterMessagePayload: (data: Uint8Array) => Promise<void>): Promise<BtpSessionHandler>;
    static createAsCentral(handshakeResponsePayload: Uint8Array, writeBleCallback: (data: Uint8Array) => Promise<void>, disconnectBleCallback: () => Promise<void>, handleMatterMessagePayload: (data: Uint8Array) => Promise<void>): Promise<BtpSessionHandler>;
    /**
     * Creates a new BTP session handler
     *
     * @param role The role of the BTP session handler
     * @param btpVersion The BTP protocol version to use
     * @param fragmentSize The fragment size to use for the messages
     * @param clientWindowSize The client window size to use
     * @param writeBleCallback Callback to write data to the BLE transport
     * @param disconnectBleCallback Callback to disconnect the BLE transport
     * @param handleMatterMessagePayload Callback to handle a Matter message payload
     */
    constructor(role: "central" | "peripheral", btpVersion: number, fragmentSize: number, clientWindowSize: number, writeBleCallback: (data: Uint8Array) => Promise<void>, disconnectBleCallback: () => Promise<void>, handleMatterMessagePayload: (data: Uint8Array) => Promise<void>);
    /**
     * Handle incoming data from the transport layer and hand over completely received matter messages to the
     * ExchangeManager layer
     *
     * @param data ByteArray containing the data
     */
    handleIncomingBleData(data: Uint8Array): Promise<void>;
    /**
     * Send a Matter message to the transport layer, but before that encode it into a BTP packet and potentially split
     * it into multiple segments. This Method is indirectly called by the ExchangeManager layer when a Matter message
     * should be sent.
     *
     * @param data ByteArray containing the Matter message
     */
    sendMatterMessage(data: Uint8Array): Promise<void>;
    private processSendQueue;
    /**
     * Close the BTP session. This method is called when the BLE transport is disconnected and so the BTP session gets closed.
     */
    close(): Promise<void>;
    /**
     * If this timer expires and the peer has a pending acknowledgement, the peer SHALL immediately send that
     * acknowledgement
     */
    private btpSendAckTimeoutTriggered;
    /**
     * If a peerâ€™s acknowledgement-received timer expires, or if a peer receives an invalid acknowledgement,
     * the peer SHALL close the BTP session and report an error to the application.
     */
    private btpAckTimeoutTriggered;
    /**
     * Increments sequence number for the packets and round it off to 0 when it reaches the maximum limit.
     */
    getNextSequenceNumber(): number;
    /**
     * Checks if incoming ackNumber and sent sequence number exceeds the client window size or not.
     */
    private exceedsWindowSize;
}
//# sourceMappingURL=BtpSessionHandler.d.ts.map