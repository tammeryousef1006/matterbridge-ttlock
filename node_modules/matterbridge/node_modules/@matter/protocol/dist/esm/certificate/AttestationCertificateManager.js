/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Bytes, Crypto, PrivateKey, Time, toHex } from "#general";
import { CertificateManager, jsToMatterDate } from "./CertificateManager.js";
import {
  TestCert_PAA_NoVID_PrivateKey,
  TestCert_PAA_NoVID_PublicKey,
  TestCert_PAA_NoVID_SKID
} from "./ChipPAAuthorities.js";
function getPaiCommonName(vendorId, productId) {
  return `node-matter Dev PAI 0x${vendorId.toString(16).toUpperCase()} ${productId === void 0 ? "no PID" : `0x${productId.toString(16).toUpperCase()}`}`;
}
function getDacCommonName(vendorId, productId) {
  return `node-matter Dev DAC 0x${vendorId.toString(16).toUpperCase()}/0x${productId.toString(16).toUpperCase()}`;
}
function getPaaCommonName() {
  return "Matter Test PAA";
}
class AttestationCertificateManager {
  constructor(vendorId) {
    this.vendorId = vendorId;
    this.paiCertBytes = this.generatePAICert(vendorId);
  }
  paaCertId = BigInt(0);
  // We use the official PAA cert for now because else pairing with Chip tool do not work because
  // only this one is the Certificate store
  paaKeyPair = PrivateKey(TestCert_PAA_NoVID_PrivateKey, {
    publicKey: TestCert_PAA_NoVID_PublicKey
  });
  paaKeyIdentifier = TestCert_PAA_NoVID_SKID;
  paiCertId = BigInt(1);
  paiKeyPair = Crypto.createKeyPair();
  paiKeyIdentifier = Crypto.hash(this.paiKeyPair.publicKey).slice(0, 20);
  paiCertBytes;
  nextCertificateId = 2;
  getPAICert() {
    return this.paiCertBytes;
  }
  getDACert(productId) {
    const dacKeyPair = Crypto.createKeyPair();
    return {
      keyPair: dacKeyPair,
      dac: this.generateDaCert(dacKeyPair.publicKey, this.vendorId, productId)
    };
  }
  // Method unused for now because we use the official Matter Test PAA, but is functional
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  generatePAACert(vendorId) {
    const now = Time.get().now();
    const unsignedCertificate = {
      serialNumber: Bytes.fromHex(toHex(this.paaCertId)),
      signatureAlgorithm: 1,
      publicKeyAlgorithm: 1,
      ellipticCurveIdentifier: 1,
      issuer: {
        commonName: getPaaCommonName(),
        vendorId
      },
      notBefore: jsToMatterDate(now, -1),
      notAfter: jsToMatterDate(now, 10),
      subject: {
        commonName: getPaaCommonName(),
        vendorId
      },
      ellipticCurvePublicKey: this.paaKeyPair.publicKey,
      extensions: {
        basicConstraints: {
          isCa: true,
          pathLen: 1
        },
        keyUsage: {
          keyCertSign: true,
          cRLSign: true
        },
        subjectKeyIdentifier: this.paaKeyIdentifier,
        authorityKeyIdentifier: this.paaKeyIdentifier
      }
    };
    return CertificateManager.productAttestationAuthorityCertToAsn1(unsignedCertificate, this.paaKeyPair);
  }
  generatePAICert(vendorId, productId) {
    const now = Time.get().now();
    const unsignedCertificate = {
      serialNumber: Bytes.fromHex(toHex(this.paiCertId)),
      signatureAlgorithm: 1,
      publicKeyAlgorithm: 1,
      ellipticCurveIdentifier: 1,
      issuer: {
        commonName: getPaaCommonName()
      },
      notBefore: jsToMatterDate(now, -1),
      notAfter: jsToMatterDate(now, 10),
      subject: {
        commonName: getPaiCommonName(vendorId, productId),
        vendorId,
        productId
      },
      ellipticCurvePublicKey: this.paiKeyPair.publicKey,
      extensions: {
        basicConstraints: {
          isCa: true,
          pathLen: 0
        },
        keyUsage: {
          keyCertSign: true,
          cRLSign: true
        },
        subjectKeyIdentifier: this.paiKeyIdentifier,
        authorityKeyIdentifier: this.paaKeyIdentifier
      }
    };
    return CertificateManager.productAttestationIntermediateCertToAsn1(unsignedCertificate, this.paaKeyPair);
  }
  generateDaCert(publicKey, vendorId, productId) {
    const now = Time.get().now();
    const certId = this.nextCertificateId++;
    const unsignedCertificate = {
      serialNumber: Bytes.fromHex(toHex(certId)),
      signatureAlgorithm: 1,
      publicKeyAlgorithm: 1,
      ellipticCurveIdentifier: 1,
      notBefore: jsToMatterDate(now, -1),
      notAfter: jsToMatterDate(now, 10),
      issuer: {
        commonName: getPaiCommonName(vendorId),
        vendorId
      },
      subject: {
        commonName: getDacCommonName(vendorId, productId),
        vendorId,
        productId
      },
      ellipticCurvePublicKey: publicKey,
      extensions: {
        basicConstraints: {
          isCa: false
        },
        keyUsage: {
          digitalSignature: true
        },
        subjectKeyIdentifier: Crypto.hash(publicKey).slice(0, 20),
        authorityKeyIdentifier: this.paiKeyIdentifier
      }
    };
    return CertificateManager.deviceAttestationCertToAsn1(unsignedCertificate, this.paiKeyPair);
  }
}
export {
  AttestationCertificateManager
};
//# sourceMappingURL=AttestationCertificateManager.js.map
