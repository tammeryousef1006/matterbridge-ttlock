/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Construction, Crypto, ImplementationError, InternalError, PrivateKey } from "#general";
import { AttestationCertificateManager } from "./AttestationCertificateManager.js";
import { CertificationDeclarationManager } from "./CertificationDeclarationManager.js";
class DeviceCertification {
  #privateKey;
  #certificate;
  #intermediateCertificate;
  #declaration;
  #construction;
  get construction() {
    return this.#construction;
  }
  get certificate() {
    return this.#assertInitialized().certificate;
  }
  get intermediateCertificate() {
    return this.#assertInitialized().intermediateCertificate;
  }
  get declaration() {
    return this.#assertInitialized().declaration;
  }
  constructor(config, product) {
    if (typeof config === "function") {
      const configProvider = config;
      this.#construction = Construction(this, async () => {
        this.#initializeFromConfig(await configProvider());
      });
      return;
    }
    this.#construction = Construction(this, () => {
    });
    if (config === void 0) {
      if (product === void 0) {
        throw new ImplementationError(`Cannot generate device certification without product information`);
      }
      const paa = new AttestationCertificateManager(product.vendorId);
      const { keyPair: dacKeyPair, dac } = paa.getDACert(product.productId);
      config = {
        privateKey: PrivateKey(dacKeyPair.privateKey),
        certificate: dac,
        intermediateCertificate: paa.getPAICert(),
        declaration: CertificationDeclarationManager.generate(product.vendorId, product.productId)
      };
    }
    this.#initializeFromConfig(config);
  }
  #initializeFromConfig(config) {
    this.#privateKey = config.privateKey instanceof Uint8Array ? PrivateKey(config.privateKey) : config.privateKey;
    this.#certificate = config.certificate;
    this.#intermediateCertificate = config.intermediateCertificate;
    this.#declaration = config.declaration;
  }
  sign(session, data) {
    return Crypto.sign(this.#assertInitialized().privateKey, [data, session.attestationChallengeKey]);
  }
  /**
   * Makes sure that the device certification is initialized and construction is completed and returns "Non-undefined"
   * values
   */
  #assertInitialized() {
    this.#construction.assert();
    if (this.#certificate === void 0 || this.#intermediateCertificate === void 0 || this.#declaration === void 0 || this.#privateKey === void 0) {
      throw new InternalError(
        `Device certification not initialized while trying to access it. This should never happen.`
      );
    }
    return {
      certificate: this.#certificate,
      intermediateCertificate: this.#intermediateCertificate,
      declaration: this.#declaration,
      privateKey: this.#privateKey
    };
  }
}
export {
  DeviceCertification
};
//# sourceMappingURL=DeviceCertification.js.map
