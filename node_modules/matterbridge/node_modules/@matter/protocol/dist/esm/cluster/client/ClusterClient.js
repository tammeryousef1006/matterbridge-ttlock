/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { capitalize, Diagnostic, Logger, Merge } from "#general";
import {
  GlobalAttributes,
  StatusCode,
  StatusResponseError,
  UnknownAttribute
} from "#types";
import { createAttributeClient } from "./AttributeClient.js";
import { createEventClient } from "./EventClient.js";
const logger = Logger.get("ClusterClient");
function ClusterClient(clusterDef, endpointId, interactionClient, globalAttributeValues = {}) {
  function addAttributeToResult(attribute, attributeName) {
    attributes[attributeName] = createAttributeClient(
      attribute,
      attributeName,
      endpointId,
      clusterId,
      interactionClient,
      !!globalAttributeValues?.attributeList?.includes(attribute.id)
    );
    attributes[attribute.id] = attributes[attributeName];
    attributeToId[attribute.id] = attributeName;
    const capitalizedAttributeName = capitalize(attributeName);
    result[`get${capitalizedAttributeName}Attribute`] = async (requestFromRemote, isFabricFiltered = true) => {
      try {
        return await attributes[attributeName].get(requestFromRemote, isFabricFiltered);
      } catch (e) {
        if (StatusResponseError.is(e, StatusCode.UnsupportedAttribute)) {
          return void 0;
        }
        throw e;
      }
    };
    result[`set${capitalizedAttributeName}Attribute`] = async (value, dataVersion) => attributes[attributeName].set(value, dataVersion);
    result[`subscribe${capitalizedAttributeName}Attribute`] = async (listener, minIntervalS, maxIntervalS, knownDataVersion, isFabricFiltered) => {
      attributes[attributeName].addListener(listener);
      return attributes[attributeName].subscribe(
        minIntervalS,
        maxIntervalS,
        knownDataVersion,
        isFabricFiltered
      );
    };
    result[`add${capitalizedAttributeName}AttributeListener`] = (listener) => {
      attributes[attributeName].addListener(listener);
    };
    result[`remove${capitalizedAttributeName}AttributeListener`] = (listener) => {
      attributes[attributeName].removeListener(listener);
    };
  }
  function addEventToResult(event, eventName) {
    events[eventName] = createEventClient(event, eventName, endpointId, clusterId, interactionClient);
    events[event.id] = events[eventName];
    eventToId[event.id] = eventName;
    const capitalizedEventName = capitalize(eventName);
    result[`get${capitalizedEventName}Event`] = async (minimumEventNumber, isFabricFiltered) => {
      try {
        return await events[eventName].get(minimumEventNumber, isFabricFiltered);
      } catch (e) {
        if (StatusResponseError.is(e, StatusCode.UnsupportedEvent)) {
          return void 0;
        }
        throw e;
      }
    };
    result[`subscribe${capitalizedEventName}Event`] = async (listener, minIntervalS, maxIntervalS, isUrgent, minimumEventNumber, isFabricFiltered) => {
      events[eventName].addListener(listener);
      return events[eventName].subscribe(
        minIntervalS,
        maxIntervalS,
        isUrgent,
        minimumEventNumber,
        isFabricFiltered
      );
    };
    result[`add${capitalizedEventName}EventListener`] = (listener) => {
      events[eventName].addListener(listener);
    };
    result[`remove${capitalizedEventName}EventListener`] = (listener) => {
      events[eventName].removeListener(listener);
    };
  }
  const {
    id: clusterId,
    name,
    commands: commandDef,
    attributes: attributeDef,
    events: eventDef,
    features,
    supportedFeatures,
    revision,
    unknown
  } = clusterDef;
  const attributes = {};
  const events = {};
  const commands = {};
  let reportedFeatures = void 0;
  if (globalAttributeValues !== void 0) {
    if (globalAttributeValues.featureMap !== void 0) {
      reportedFeatures = globalAttributeValues.featureMap;
    }
  }
  const result = {
    id: clusterId,
    name,
    revision: globalAttributeValues?.clusterRevision ?? revision,
    _type: "ClusterClient",
    supportedFeatures: reportedFeatures ?? supportedFeatures ?? {},
    isUnknown: unknown,
    endpointId,
    attributes,
    events,
    commands,
    subscribeAllAttributes: async (options) => {
      const {
        minIntervalFloorSeconds,
        maxIntervalCeilingSeconds,
        keepSubscriptions,
        isFabricFiltered,
        eventFilters,
        dataVersionFilters
      } = options;
      return interactionClient.subscribeMultipleAttributesAndEvents({
        attributes: [{ endpointId, clusterId }],
        events: [{ endpointId, clusterId }],
        minIntervalFloorSeconds,
        maxIntervalCeilingSeconds,
        keepSubscriptions,
        isFabricFiltered,
        eventFilters,
        dataVersionFilters,
        attributeListener: (attributeData) => {
          const { path, value } = attributeData;
          result._triggerAttributeUpdate(path.attributeId, value);
        },
        eventListener: (eventData) => {
          const { path, events: newEvents } = eventData;
          result._triggerEventUpdate(path.eventId, newEvents);
        }
      });
    },
    /** Trigger a value change for an Attributed, used by subscriptions. */
    _triggerAttributeUpdate(attributeId, value) {
      const attributeName = attributeToId[attributeId];
      if (attributeName === void 0) {
        logger.warn("Unknown attribute id", attributeId);
        return;
      }
      if (attributes[attributeName] !== void 0) {
        attributes[attributeName].update(value);
      } else {
        logger.warn("Attribute not found", attributeName, "in list", Object.keys(attributes));
      }
    },
    /** Trigger a value change for an Event, used by subscriptions. */
    _triggerEventUpdate(eventId, eventData) {
      const eventName = eventToId[eventId];
      if (eventName === void 0) {
        logger.warn("Unknown event id", eventId);
        return;
      }
      if (events[eventName] !== void 0) {
        const event = events[eventName];
        eventData.forEach((data) => event.update(data));
      } else {
        logger.warn("Event not found", eventName, "in list", Object.keys(events));
      }
    },
    isAttributeSupported: (attributeId) => {
      return !!globalAttributeValues?.attributeList?.includes(attributeId);
    },
    isAttributeSupportedByName: (attributeName) => {
      const attribute = attributes[attributeName];
      if (attribute === void 0) {
        return false;
      }
      return !!globalAttributeValues?.attributeList?.includes(attribute.id);
    },
    isCommandSupported: (commandId) => {
      return !!globalAttributeValues?.acceptedCommandList?.includes(commandId);
    },
    isCommandSupportedByName: (commandName) => {
      const command = commandDef[commandName];
      if (command === void 0) {
        return false;
      }
      return !!globalAttributeValues?.acceptedCommandList?.includes(command.requestId);
    }
  };
  const attributeToId = {};
  const allAttributeDefs = Merge(
    attributeDef,
    GlobalAttributes(features)
  );
  for (const attributeName in allAttributeDefs) {
    addAttributeToResult(allAttributeDefs[attributeName], attributeName);
  }
  if (globalAttributeValues?.attributeList !== void 0) {
    for (const attributeId of globalAttributeValues.attributeList) {
      if (attributeToId[attributeId] === void 0) {
        const attribute = UnknownAttribute(attributeId);
        addAttributeToResult(attribute, `unknownAttribute_${Diagnostic.hex(attributeId)}`);
        logger.info(
          `Added unknown attribute ${Diagnostic.hex(attributeId)} to cluster ${Diagnostic.hex(clusterId)}`
        );
      }
    }
  }
  const eventToId = {};
  for (const eventName in eventDef) {
    addEventToResult(eventDef[eventName], eventName);
  }
  const commandToId = {};
  for (const commandName in commandDef) {
    const { requestId } = commandDef[commandName];
    commandToId[requestId] = commandName;
    commands[commandName] = async (request, options = {}) => {
      const { asTimedRequest, timedRequestTimeoutMs, useExtendedFailSafeMessageResponseTimeout } = options;
      return interactionClient.invoke({
        endpointId,
        clusterId,
        command: commandDef[commandName],
        request,
        asTimedRequest,
        timedRequestTimeoutMs,
        useExtendedFailSafeMessageResponseTimeout
      });
    };
    commands[requestId] = commands[commandName];
    result[commandName] = result.commands[commandName];
  }
  if (globalAttributeValues?.acceptedCommandList !== void 0) {
    for (const requestId of globalAttributeValues.acceptedCommandList) {
      if (commandToId[requestId] === void 0) {
        logger.info(`Ignoring unknown command ${requestId} at cluster ${Diagnostic.hex(clusterId)}`);
      }
    }
  }
  return result;
}
export {
  ClusterClient
};
//# sourceMappingURL=ClusterClient.js.map
