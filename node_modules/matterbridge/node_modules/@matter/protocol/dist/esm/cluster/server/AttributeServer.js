/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import {
  Diagnostic,
  ImplementationError,
  InternalError,
  Logger,
  MatterError,
  MaybePromise,
  camelize,
  isDeepEqual
} from "#general";
import { AccessLevel, AttributeModel, ClusterModel, DatatypeModel, FabricIndex, MatterModel } from "#model";
import {
  StatusCode,
  StatusResponseError,
  ValidationError
} from "#types";
import { NoAssociatedFabricError, assertSecureSession } from "../../session/SecureSession.js";
const logger = Logger.get("AttributeServer");
const FabricIndexName = camelize(FabricIndex.name);
class FabricScopeError extends MatterError {
}
function createAttributeServer(clusterDef, attributeDef, attributeName, initValue, datasource, getter, setter, validator) {
  const {
    id,
    schema,
    writable,
    fabricScoped,
    fixed,
    omitChanges,
    timed,
    default: defaultValue,
    readAcl,
    writeAcl
  } = attributeDef;
  if (fixed) {
    return new FixedAttributeServer(
      id,
      attributeName,
      readAcl,
      writeAcl,
      schema,
      writable,
      false,
      timed,
      initValue,
      defaultValue,
      datasource,
      getter
    );
  }
  if (fabricScoped) {
    return new FabricScopedAttributeServer(
      id,
      attributeName,
      readAcl,
      writeAcl,
      schema,
      writable,
      !omitChanges,
      timed,
      initValue,
      defaultValue,
      clusterDef,
      datasource,
      getter,
      setter,
      validator
    );
  }
  return new AttributeServer(
    id,
    attributeName,
    readAcl,
    writeAcl,
    schema,
    writable,
    !omitChanges,
    timed,
    initValue,
    defaultValue,
    datasource,
    getter,
    setter,
    validator
  );
}
class BaseAttributeServer {
  constructor(id, name, readAcl, writeAcl, schema, isWritable, isSubscribable, requiresTimedInteraction, initValue, defaultValue) {
    this.id = id;
    this.name = name;
    this.schema = schema;
    this.isWritable = isWritable;
    this.isSubscribable = isSubscribable;
    this.requiresTimedInteraction = requiresTimedInteraction;
    this.#readAcl = readAcl;
    this.#writeAcl = writeAcl;
    try {
      this.validateWithSchema(initValue);
      this.value = initValue;
    } catch (error) {
      logger.warn(
        `Attribute value to initialize for ${name} has an invalid value ${Diagnostic.json(
          initValue
        )}. Restore to default ${Diagnostic.json(defaultValue)}`
      );
      if (defaultValue === void 0) {
        throw new ImplementationError(`Attribute value to initialize for ${name} cannot be undefined.`);
      }
      this.validateWithSchema(defaultValue);
      this.value = defaultValue;
    }
    this.defaultValue = this.value;
  }
  /**
   * The value is undefined when getter/setter are used. But we still handle the version number here.
   */
  value = void 0;
  endpoint;
  defaultValue;
  #readAcl;
  #writeAcl;
  get hasFabricSensitiveData() {
    return false;
  }
  validateWithSchema(value) {
    try {
      this.schema.validate(value);
    } catch (e) {
      ValidationError.accept(e);
      e.message = `Validation error for attribute "${this.name}"${e.fieldName !== void 0 ? ` in field ${e.fieldName}` : ""}: ${e.message}`;
      throw e;
    }
  }
  assignToEndpoint(endpoint) {
    this.endpoint = endpoint;
  }
  get writeAcl() {
    return this.#writeAcl ?? AccessLevel.Operate;
  }
  get readAcl() {
    return this.#readAcl ?? AccessLevel.View;
  }
}
class FixedAttributeServer extends BaseAttributeServer {
  constructor(id, name, readAcl, writeAcl, schema, isWritable, isSubscribable, requiresTimedInteraction, initValue, defaultValue, datasource, getter) {
    super(
      id,
      name,
      readAcl,
      writeAcl,
      schema,
      isWritable,
      isSubscribable,
      requiresTimedInteraction,
      initValue,
      defaultValue
    );
    this.datasource = datasource;
    if (getter === void 0) {
      this.getter = () => {
        if (this.value === void 0) {
          throw new InternalError(`Attribute value for attribute "${name}" is not initialized.`);
        }
        return this.value;
      };
    } else {
      this.getter = getter;
    }
  }
  isFixed = true;
  getter;
  /**
   * Get the value of the attribute. This method is used by the Interaction model to read the value of the attribute
   * and includes the ACL check. It should not be used locally in the code!
   *
   * If a getter is defined the value is determined by that getter method.
   */
  get(session, isFabricFiltered, message) {
    return this.getter(session, this.endpoint, isFabricFiltered, message);
  }
  /**
   * Get the value of the attribute including the version number. This method is used by the Interaction model to read
   * the value of the attribute and includes the ACL check. It should not be used locally in the code!
   *
   * If a getter is defined the value is determined by that getter method. The version number is always 0 for fixed
   * attributes.
   */
  getWithVersion(session, isFabricFiltered, message) {
    return { version: this.datasource.version, value: this.get(session, isFabricFiltered, message) };
  }
  /**
   * Get the value of the attribute locally. This method should be used locally in the code and does not include the
   * ACL check.
   * If a getter is defined the value is determined by that getter method.
   */
  getLocal() {
    return this.getter(void 0, this.endpoint);
  }
  /**
   * Initialize the value of the attribute, used when a persisted value is set initially or when values needs to be
   * adjusted before the Device gets announced. Do not use this method to change values when the device is in use!
   * If a getter or setter is defined the value must be undefined The version number must also be undefined.
   */
  init(value) {
    if (value === void 0) {
      throw new InternalError(`Cannot initialize fixed attribute "${this.name}" with undefined value.`);
    }
    this.validateWithSchema(value);
    this.value = value;
  }
  /**
   * Add an internal listener that is called when the value of the attribute changes. The listener is called with the
   * new value and the version number.
   */
  addValueChangeListener(_listener) {
  }
  /**
   * Remove an internal listener.
   */
  removeValueChangeListener(_listener) {
  }
  /**
   * Add an external listener that is called when the value of the attribute changes. The listener is called with the
   * new value and the old value.
   */
  addValueSetListener(_listener) {
  }
  /**
   * Add an external listener that is called when the value of the attribute changes. The listener is called with the
   * new value and the old value. This method is a convenient alias for addValueSetListener.
   */
  subscribe(_listener) {
  }
  /**
   * Remove an external listener.
   */
  removeValueSetListener(_listener) {
  }
}
class AttributeServer extends FixedAttributeServer {
  isFixed = false;
  valueChangeListeners = new Array();
  valueSetListeners = new Array();
  setter;
  validator;
  delayedChangeData = void 0;
  constructor(id, name, readAcl, writeAcl, schema, isWritable, isSubscribable, requiresTimedInteraction, initValue, defaultValue, datasource, getter, setter, validator) {
    if (isWritable && (getter === void 0 || setter === void 0) && !(getter === void 0 && setter === void 0)) {
      throw new ImplementationError(
        `Getter and setter must be implemented together for writeable attribute "${name}".`
      );
    }
    super(
      id,
      name,
      readAcl,
      writeAcl,
      schema,
      isWritable,
      isSubscribable,
      requiresTimedInteraction,
      initValue,
      defaultValue,
      datasource,
      getter
    );
    if (setter === void 0) {
      this.setter = (value) => {
        const oldValue = this.value;
        this.value = value;
        return !isDeepEqual(value, oldValue);
      };
    } else {
      this.setter = setter;
    }
    this.validator = (value, session, endpoint) => {
      this.validateWithSchema(value);
      if (validator !== void 0) {
        validator(value, session, endpoint);
      }
    };
  }
  /**
   * Initialize the value of the attribute, used when a persisted value is set initially or when values needs to be
   * adjusted before the Device gets announced. Do not use this method to change values when the device is in use!
   */
  init(value) {
    if (value === void 0) {
      value = this.getter(void 0, this.endpoint);
    }
    if (value === void 0) {
      throw new InternalError(`Cannot initialize attribute "${this.name}" with undefined value.`);
    }
    this.validator(value, void 0, this.endpoint);
    this.value = value;
  }
  /**
   * Set the value of the attribute. This method is used by the Interaction model to write the value of the attribute
   * and includes the ACL check. It should not be used locally in the code!
   *
   * If a setter is defined this setter method is called to store the value.
   *
   * Listeners are called when the value changes (internal listeners) or in any case (external listeners).
   */
  set(value, session, message, delayChangeEvents = false) {
    if (!this.isWritable) {
      throw new StatusResponseError(`Attribute "${this.name}" is not writable.`, StatusCode.UnsupportedWrite);
    }
    this.setRemote(value, session, message, delayChangeEvents);
  }
  /**
   * Method that contains the logic to set a value "from remote" (e.g. from a client).
   */
  setRemote(value, session, message, delayChangeEvents = false) {
    this.processSet(value, session, message, delayChangeEvents);
    this.value = value;
  }
  /**
   * Set the value of the attribute locally. This method should be used locally in the code and does not include the
   * ACL check.
   *
   * If a setter is defined this setter method is called to validate and store the value.
   *
   * Else if a validator is defined the value is validated before it is stored.
   *
   * Listeners are called when the value changes (internal listeners) or in any case (external listeners).
   */
  setLocal(value) {
    this.processSet(value, void 0);
    this.value = value;
  }
  /**
   * Helper Method to process the set of a value in a generic way. This method is used internally.
   */
  processSet(value, session, message, delayChangeEvents = false) {
    this.validator(value, session, this.endpoint);
    const oldValue = this.getter(session, this.endpoint, void 0, message);
    const valueChanged = this.setter(value, session, this.endpoint, message);
    if (delayChangeEvents) {
      this.delayedChangeData = {
        oldValue: this.delayedChangeData?.oldValue ?? oldValue,
        // We keep the oldest value
        newValue: value,
        changed: !!this.delayedChangeData?.changed || valueChanged
        // We combine the changed flag
      };
      logger.info(`Delay change for attribute "${this.name}" with value ${Diagnostic.json(value)}`);
    } else {
      this.handleVersionAndTriggerListeners(value, oldValue, valueChanged);
    }
  }
  triggerDelayedChangeEvents() {
    if (this.delayedChangeData !== void 0) {
      const { oldValue, newValue, changed } = this.delayedChangeData;
      this.delayedChangeData = void 0;
      logger.info(`Trigger delayed change for attribute "${this.name}" with value ${Diagnostic.json(newValue)}`);
      this.handleVersionAndTriggerListeners(newValue, oldValue, changed);
    }
  }
  /**
   * Helper Method to handle needed version increases and trigger the relevant listeners. This method is used
   * internally.
   */
  handleVersionAndTriggerListeners(value, oldValue, considerVersionChanged) {
    if (considerVersionChanged) {
      const version = this.datasource.increaseVersion();
      this.valueChangeListeners.forEach((listener) => listener(value, version));
    }
    if (oldValue !== void 0) {
      this.valueSetListeners.forEach((listener) => listener(value, oldValue));
    }
  }
  /**
   * When the value is handled by getter or setter methods and is changed by other processes this method can be used
   * to notify the attribute server that the value has changed. This will increase the version number and trigger the
   * listeners.
   *
   * ACL checks needs to be performed before calling this method.
   */
  updated(session) {
    const oldValue = this.value ?? this.defaultValue;
    try {
      this.value = this.get(session, false);
    } catch (e) {
      NoAssociatedFabricError.accept(e);
      if (this.value === void 0) {
        this.value = this.defaultValue;
      }
    }
    this.handleVersionAndTriggerListeners(this.value, oldValue, true);
  }
  /**
   * When the value is handled by getter or setter methods and is changed by other processes and no session from the
   * originating process is known this method can be used to notify the attribute server that the value has changed.
   * This will increase the version number and trigger the listeners.
   *
   * ACL checks needs to be performed before calling this method.
   */
  updatedLocal() {
    const oldValue = this.value ?? this.defaultValue;
    this.value = this.getLocal();
    this.handleVersionAndTriggerListeners(this.value, oldValue, true);
  }
  /**
   * Add an internal listener that is called when the value of the attribute changes. The listener is called with the
   * new value and the version number.
   */
  addValueChangeListener(listener) {
    this.valueChangeListeners.push(listener);
  }
  /**
   * Remove an internal listener.
   */
  removeValueChangeListener(listener) {
    const entryIndex = this.valueChangeListeners.indexOf(listener);
    if (entryIndex !== -1) {
      this.valueChangeListeners.splice(entryIndex, 1);
    }
  }
  /**
   * Add an external listener that is called when the value of the attribute changes. The listener is called with the
   * new value and the old value.
   */
  addValueSetListener(listener) {
    this.valueSetListeners.push(listener);
  }
  /**
   * Add an external listener that is called when the value of the attribute changes. The listener is called with the
   * new value and the old value. This method is a convenient alias for addValueSetListener.
   */
  subscribe(listener) {
    this.addValueSetListener(listener);
  }
  /**
   * Remove an external listener.
   */
  removeValueSetListener(listener) {
    const entryIndex = this.valueSetListeners.indexOf(listener);
    if (entryIndex !== -1) {
      this.valueSetListeners.splice(entryIndex, 1);
    }
  }
}
function genericFabricScopedAttributeGetterFromFabric(fabric, cluster, attributeName, defaultValue) {
  const data = fabric.getScopedClusterDataValue(cluster, attributeName);
  return data?.value ?? defaultValue;
}
function genericFabricScopedAttributeGetter(session, isFabricFiltered, cluster, attributeName, defaultValue, fabrics) {
  if (session === void 0) {
    throw new FabricScopeError(`Session is required for fabric scoped attribute ${attributeName}`);
  }
  if (isFabricFiltered) {
    assertSecureSession(session);
    return genericFabricScopedAttributeGetterFromFabric(
      session.associatedFabric,
      cluster,
      attributeName,
      defaultValue
    );
  } else {
    const values = new Array();
    for (const fabric of fabrics) {
      const value = genericFabricScopedAttributeGetterFromFabric(fabric, cluster, attributeName, defaultValue);
      if (!Array.isArray(value)) {
        throw new FabricScopeError(
          `Fabric scoped attribute "${attributeName}" can only be read for all fabrics if they are arrays.`
        );
      }
      values.push(...value);
    }
    return values;
  }
}
function genericFabricScopedAttributeSetterForFabric(fabric, cluster, attributeName, value, defaultValue) {
  const oldValue = genericFabricScopedAttributeGetterFromFabric(fabric, cluster, attributeName, defaultValue);
  if (!isDeepEqual(value, oldValue)) {
    const setResult = fabric.setScopedClusterDataValue(cluster, attributeName, { value });
    if (MaybePromise.is(setResult)) {
      throw new ImplementationError(
        "Seems like an Asynchronous Storage is used with Legacy code paths which is forbidden!"
      );
    }
    return true;
  }
  return false;
}
function genericFabricScopedAttributeSetter(value, session, cluster, attributeName, defaultValue) {
  if (session === void 0) {
    throw new FabricScopeError(`Session is required for fabric scoped attribute "${attributeName}".`);
  }
  assertSecureSession(session);
  const fabric = session.associatedFabric;
  return genericFabricScopedAttributeSetterForFabric(fabric, cluster, attributeName, value, defaultValue);
}
class FabricScopedAttributeServer extends AttributeServer {
  constructor(id, name, readAcl, writeAcl, schema, isWritable, isSubscribable, requiresTimedInteraction, initValue, defaultValue, cluster, datasource, getter, setter, validator) {
    if (isWritable && (getter === void 0 || setter === void 0) && !(getter === void 0 && setter === void 0)) {
      throw new ImplementationError(
        `Getter and setter must be implemented together for writeable fabric scoped attribute "${name}".`
      );
    }
    let isCustomGetter = false;
    if (getter === void 0) {
      getter = (session, _endpoint, isFabricFiltered) => {
        if (session === void 0)
          throw new FabricScopeError(`Session is required for fabric scoped attribute ${name}`);
        if (isFabricFiltered === true) {
          assertSecureSession(session);
          return this.getLocalForFabric(session.associatedFabric);
        } else {
          const values = new Array();
          for (const fabric of datasource.fabrics) {
            const value = this.getLocalForFabric(fabric);
            if (!Array.isArray(value)) {
              throw new FabricScopeError(
                `Fabric scoped attribute "${name}" can only be read for all fabrics if they are arrays.`
              );
            }
            values.push(...value);
          }
          return values;
        }
      };
    } else {
      isCustomGetter = true;
    }
    let isCustomSetter = false;
    if (setter === void 0) {
      setter = (value, session) => genericFabricScopedAttributeSetter(value, session, this.cluster, this.name, this.defaultValue);
    } else {
      isCustomSetter = true;
    }
    super(
      id,
      name,
      readAcl,
      writeAcl,
      schema,
      isWritable,
      isSubscribable,
      requiresTimedInteraction,
      initValue,
      defaultValue,
      datasource,
      getter,
      setter,
      validator
    );
    this.cluster = cluster;
    this.isCustomGetter = isCustomGetter;
    this.isCustomSetter = isCustomSetter;
    this.#determineSensitiveFieldsToRemove();
  }
  isCustomGetter;
  isCustomSetter;
  fabricSensitiveElementsToRemove = new Array();
  #determineSensitiveFieldsToRemove() {
    const clusterFromModel = MatterModel.standard.get(ClusterModel, this.cluster.id);
    if (clusterFromModel === void 0) {
      logger.debug(`${this.cluster.name}: Cluster for Fabric scoped element not found in Model, ignore`);
      return;
    }
    const attributeFromModel = clusterFromModel.get(AttributeModel, this.id);
    if (attributeFromModel === void 0) {
      logger.debug(
        `${this.cluster.name}.${this.id}: Attribute for Fabric scoped element not found in Model, ignore`
      );
      return;
    }
    if (!attributeFromModel.fabricScoped) {
      logger.debug(`${this.cluster.name}.${this.id}: Attribute is not Fabric scoped in model, ignore`);
      return;
    }
    if (attributeFromModel.children.length !== 1) {
      logger.debug(`${this.cluster.name}.${this.id}: Attribute has not exactly one child, ignore`);
      return;
    }
    const type = attributeFromModel.children[0].type;
    if (type === void 0) {
      logger.debug(`${this.cluster.name}.${this.id}: Attribute field has no type, ignore`);
      return;
    }
    const dataType = clusterFromModel.get(DatatypeModel, type);
    if (dataType === void 0) {
      logger.debug(`${this.cluster.name}.${this.id}: DataType ${type} not found in model, ignore`);
      return;
    }
    dataType.children.filter((field) => field.fabricSensitive).forEach((field) => this.fabricSensitiveElementsToRemove.push(camelize(field.name)));
  }
  get hasFabricSensitiveData() {
    return this.fabricSensitiveElementsToRemove.length > 0;
  }
  /**
   * Sanitize the value of the attribute by removing fabric sensitive fields that do not belong to the
   * associated fabric
   */
  sanitizeFabricSensitiveFields(value, associatedFabric) {
    if (this.fabricSensitiveElementsToRemove.length && Array.isArray(value)) {
      const associatedFabricIndex = associatedFabric?.fabricIndex ?? -1;
      return value.map((data) => {
        if (data[FabricIndexName] !== associatedFabricIndex) {
          const result = { ...data };
          this.fabricSensitiveElementsToRemove.forEach((fieldName) => delete result[fieldName]);
          return result;
        }
        return data;
      });
    }
    return value;
  }
  /**
   * Initialize the attribute with a value. Because the value is stored on fabric level this method only initializes
   * the version number.
   */
  init(value) {
    if (value !== void 0) {
      throw new InternalError(`Cannot initialize fabric scoped attribute "${this.name}" with a value.`);
    }
  }
  /**
   * Fabric scoped enhancement of set to allow setting special fabricindex locally.
   */
  set(value, session, message, delayChangeEvents = false, preserveFabricIndex = false) {
    if (!this.isWritable) {
      throw new StatusResponseError(`Attribute "${this.name}" is not writable.`, StatusCode.UnsupportedWrite);
    }
    this.setRemote(value, session, message, delayChangeEvents, preserveFabricIndex);
  }
  /**
   * Method that contains the logic to set a value "from remote" (e.g. from a client). For Fabric scoped attributes
   * we need to inject the fabric index into the value.
   */
  setRemote(value, session, message, delayChangeEvents = false, preserveFabricIndex = false) {
    value = this.schema.injectField(
      value,
      FabricIndex.id,
      session.associatedFabric.fabricIndex,
      () => !preserveFabricIndex
      // No one should send any index and if we simply SHALL ignore it,  but internally we might need it
    );
    logger.info(
      `Set remote value for fabric scoped attribute "${this.name}" to ${Diagnostic.json(value)} (delayed=${delayChangeEvents})`
    );
    super.setRemote(value, session, message, delayChangeEvents);
  }
  /**
   * Set Local is not allowed for fabric scoped attributes. Use setLocalForFabric instead.
   */
  setLocal(_value) {
    throw new FabricScopeError(
      `Fabric scoped attribute "${this.name}" can only be set locally by providing a Fabric. Use setLocalForFabric instead.`
    );
  }
  /**
   * Set the value of the attribute locally for a fabric. This method should be used locally in the code and does not
   * include the ACL check.
   * If a setter is defined this method cannot be used!
   * If a validator is defined the value is validated before it is stored.
   * Listeners are called when the value changes (internal listeners) or in any case (external listeners).
   */
  setLocalForFabric(value, fabric) {
    if (this.isCustomSetter) {
      throw new FabricScopeError(
        `Fabric scoped attribute "${this.name}" cannot be set locally when a custom setter is defined.`
      );
    }
    this.validator(value, void 0, this.endpoint);
    const oldValue = this.getLocalForFabric(fabric);
    const valueChanged = !isDeepEqual(value, oldValue);
    if (valueChanged) {
      const setResult = fabric.setScopedClusterDataValue(this.cluster, this.name, { value });
      if (MaybePromise.is(setResult)) {
        throw new ImplementationError(
          "Seems like an Asynchronous Storage is used with Legacy code paths which is forbidden!"
        );
      }
    }
    this.handleVersionAndTriggerListeners(value, oldValue, valueChanged);
  }
  /**
   * When the value is handled by getter or setter methods and is changed by other processes and no session from the
   * originating process is known this method can be used to notify the attribute server that the value has changed.
   * This will increase the version number and trigger the listeners.
   * ACL checks needs to be performed before calling this method.
   */
  updatedLocalForFabric(fabric) {
    const oldValue = this.value ?? this.defaultValue;
    try {
      this.value = this.getLocalForFabric(fabric);
    } catch (e) {
      FabricScopeError.accept(e);
      if (this.value === void 0) {
        this.value = this.defaultValue;
      }
    }
    this.handleVersionAndTriggerListeners(this.value, oldValue, true);
  }
  /**
   * Get the value of the attribute locally for a special Fabric. This method should be used locally in the code and
   * does not include the ACL check.
   * If a getter is defined this method returns an error and the value should be retrieved directly internally.
   */
  getLocalForFabric(fabric) {
    if (this.isCustomGetter) {
      throw new FabricScopeError(
        `Fabric scoped attribute "${this.name}" cannot be read locally when a custom getter is defined.`
      );
    }
    return genericFabricScopedAttributeGetterFromFabric(fabric, this.cluster, this.name, this.defaultValue);
  }
}
export {
  AttributeServer,
  BaseAttributeServer,
  FabricScopeError,
  FabricScopedAttributeServer,
  FixedAttributeServer,
  createAttributeServer,
  genericFabricScopedAttributeGetter,
  genericFabricScopedAttributeGetterFromFabric,
  genericFabricScopedAttributeSetter,
  genericFabricScopedAttributeSetterForFabric
};
//# sourceMappingURL=AttributeServer.js.map
