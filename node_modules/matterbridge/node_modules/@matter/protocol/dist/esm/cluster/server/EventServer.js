/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import {
  ImplementationError,
  InternalError,
  isObject,
  MatterAggregateError,
  MaybePromise,
  Time
} from "#general";
import { AccessLevel, ClusterModel, EventModel, MatterModel } from "#model";
import {
  FabricIndex
} from "#types";
function createEventServer(clusterDef, eventDef, eventName, schema, priority, readAcl) {
  let fabricSensitive = false;
  const clusterFromModel = MatterModel.standard.get(ClusterModel, clusterDef.id);
  if (clusterFromModel !== void 0) {
    const eventModel = clusterFromModel.get(EventModel, eventDef.id);
    if (eventModel !== void 0) {
      fabricSensitive = eventModel.fabricSensitive;
    }
  }
  if (fabricSensitive) {
    return new FabricSensitiveEventServer(eventDef.id, clusterDef.id, eventName, schema, priority, readAcl);
  }
  return new EventServer(eventDef.id, clusterDef.id, eventName, schema, priority, readAcl);
}
class EventServer {
  constructor(id, clusterId, name, schema, priority, readAcl) {
    this.id = id;
    this.clusterId = clusterId;
    this.name = name;
    this.schema = schema;
    this.priority = priority;
    this.#readAcl = readAcl;
  }
  eventList = new Array();
  listeners = new Array();
  endpoint;
  eventHandler;
  #readAcl;
  hasFabricSensitiveData = false;
  get readAcl() {
    return this.#readAcl ?? AccessLevel.View;
  }
  assignToEndpoint(endpoint) {
    this.endpoint = endpoint;
  }
  // TODO Try to get rid of that late binding and simply things again
  //      potentially with refactoring out MatterDevice and MatterController
  bindToEventHandler(eventHandler) {
    this.eventHandler = eventHandler;
    const promises = new Array();
    for (const event of this.eventList) {
      const finalEvent = this.eventHandler.add(event);
      if (finalEvent !== void 0 && MaybePromise.is(finalEvent)) {
        promises.push(finalEvent.then((e) => this.listeners.forEach((listener) => listener(e))));
      } else {
        this.listeners.forEach((listener) => listener(finalEvent));
      }
    }
    this.eventList = [];
    if (promises.length > 0) {
      return MatterAggregateError.allSettled(promises, "Error binding events to the event handlers").then(
        () => {
        }
      );
    }
    return void 0;
  }
  triggerEvent(data) {
    if (this.endpoint === void 0 || this.endpoint.number === void 0) {
      throw new InternalError("Endpoint not assigned");
    }
    const occurrence = {
      eventId: this.id,
      clusterId: this.clusterId,
      endpointId: this.endpoint.number,
      epochTimestamp: Time.nowMs(),
      priority: this.priority,
      payload: data
    };
    if (this.eventHandler === void 0) {
      this.eventList.push(occurrence);
    } else {
      const finalEvent = this.eventHandler.add(occurrence);
      return MaybePromise.then(finalEvent, (e) => {
        this.listeners.forEach((listener) => listener(e));
      });
    }
    return void 0;
  }
  addListener(listener) {
    this.listeners.push(listener);
  }
  removeListener(listener) {
    const entryIndex = this.listeners.indexOf(listener);
    if (entryIndex !== -1) {
      this.listeners.splice(entryIndex, 1);
    }
  }
  get(session, isFabricFiltered, _message, filters) {
    if (this.eventHandler === void 0) {
      throw new InternalError("EventServer not bound to OccurrenceManager");
    }
    if (this.endpoint === void 0) {
      throw new InternalError("EventServer not bound to Endpoint");
    }
    return this.eventHandler.query(
      { endpointId: this.endpoint.number, clusterId: this.clusterId, eventId: this.id },
      filters,
      // When request is fabric filtered or the event is Fabric sensitive then filter the events for the fabrics
      isFabricFiltered ? session.fabric?.fabricIndex ?? FabricIndex.NO_FABRIC : void 0
    );
  }
}
class FabricSensitiveEventServer extends EventServer {
  hasFabricSensitiveData = true;
  get(session, _isFabricFiltered, message, filters) {
    return super.get(session, true, message, filters);
  }
  triggerEvent(data) {
    if (!isObject(data) || data === null) {
      throw new ImplementationError("FabricSensitive events need to have an object as data.");
    }
    if (!("fabricIndex" in data)) {
      throw new InternalError("FabricSensitive events requires fabricIndex in data.");
    }
    return super.triggerEvent(data);
  }
}
export {
  EventServer,
  FabricSensitiveEventServer,
  createEventServer
};
//# sourceMappingURL=EventServer.js.map
