/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { AsyncObservable, Construction, Logger, MatterFlowError, UnexpectedDataError } from "#general";
import { CaseAuthenticatedTag, NodeId, ValidationError } from "#types";
import { FabricBuilder } from "../fabric/Fabric.js";
import { FailsafeTimer, MatterFabricConflictError } from "./FailsafeTimer.js";
const logger = Logger.get("FailsafeContext");
class MatterFabricInvalidAdminSubjectError extends MatterFlowError {
}
class FailsafeContext {
  #sessions;
  #fabrics;
  #failsafe;
  #construction;
  #associatedFabric;
  #csrSessionId;
  #forUpdateNoc;
  #fabricBuilder = new FabricBuilder();
  #rootCertSet = false;
  #commissioned = AsyncObservable();
  constructor(options) {
    const { expiryLengthSeconds, associatedFabric, maxCumulativeFailsafeSeconds } = options;
    this.#sessions = options.sessions;
    this.#fabrics = options.fabrics;
    this.#associatedFabric = options.associatedFabric;
    this.#construction = Construction(this, async () => {
      await Promise.resolve();
      await this.storeEndpointState();
      this.#failsafe = new FailsafeTimer(
        associatedFabric,
        expiryLengthSeconds,
        maxCumulativeFailsafeSeconds,
        () => this.#failSafeExpired()
      );
      logger.debug(`Arm failSafe timer for ${expiryLengthSeconds}s.`);
    });
  }
  async extend(fabric, expiryLengthSeconds) {
    await this.#construction;
    await this.#failsafe?.reArm(fabric, expiryLengthSeconds);
    if (expiryLengthSeconds > 0) {
      logger.debug(`Extend failSafe timer for ${expiryLengthSeconds}s.`);
    }
  }
  get fabricIndex() {
    return this.#fabricBuilder.fabricIndex;
  }
  get construction() {
    return this.#construction;
  }
  get commissioned() {
    return this.#commissioned;
  }
  get associatedFabric() {
    return this.#associatedFabric;
  }
  get csrSessionId() {
    return this.#csrSessionId;
  }
  get forUpdateNoc() {
    return this.#forUpdateNoc;
  }
  get rootCertSet() {
    return this.#rootCertSet;
  }
  get hasRootCert() {
    return this.#fabricBuilder.rootCert !== void 0;
  }
  get rootCert() {
    return this.#fabricBuilder.rootCert;
  }
  async completeCommission() {
    if (this.#failsafe === void 0) {
      throw new MatterFlowError("armFailSafe should be called first!");
    }
    this.#failsafe.complete();
    if (this.fabricIndex !== void 0) {
      await this.#fabrics.persistFabrics();
    }
    this.#failsafe = void 0;
    await this.commissioned.emit();
    await this.removePaseSession();
    await this.close();
  }
  getFailSafeContext() {
    if (this.#failsafe === void 0) throw new MatterFlowError("armFailSafe should be called first!");
    return this.#failsafe;
  }
  getNextFabricIndex() {
    return this.#fabrics.allocateFabricIndex();
  }
  async addFabric(fabric) {
    this.#fabrics.addFabric(fabric);
    if (this.#failsafe !== void 0) {
      this.#associatedFabric = this.#failsafe.associatedFabric = fabric;
    }
    return fabric.fabricIndex;
  }
  async updateFabric(fabric) {
    await this.#fabrics.updateFabric(fabric);
    await this.#sessions.deleteResumptionRecordsForFabric(fabric);
  }
  /**
   * Handles a CSR from OperationalCredentials cluster and stores additional internal information for further
   * validity checks.
   */
  createCertificateSigningRequest(isForUpdateNoc, sessionId) {
    if (this.#fabrics.findByKeypair(this.#fabricBuilder.keyPair)) {
      throw new MatterFlowError("Key pair already exists.");
    }
    const result = this.#fabricBuilder.createCertificateSigningRequest();
    this.#csrSessionId = sessionId;
    this.#forUpdateNoc = isForUpdateNoc;
    return result;
  }
  async removePaseSession() {
    const session = this.#sessions.getPaseSession();
    if (session) {
      await session.close(true);
    }
  }
  async close() {
    await this.#construction;
    await this.#construction.close(async () => {
      if (this.#failsafe) {
        await this.#failsafe.close();
        this.#failsafe = void 0;
        await this.rollback();
      }
    });
  }
  /** Handles adding a trusted root certificate from Operational Credentials cluster. */
  setRootCert(rootCert) {
    this.#fabricBuilder.setRootCert(rootCert);
    this.#rootCertSet = true;
  }
  /**
   * Build a new Fabric object based on an existing fabric for the "UpdateNoc" case of the Operational Credentials
   * cluster.
   */
  async buildUpdatedFabric(nocValue, icacValue) {
    if (this.associatedFabric === void 0) {
      throw new MatterFlowError("No fabric associated with failsafe context, but we prepare an Fabric update.");
    }
    this.#fabricBuilder.initializeFromFabricForUpdate(this.associatedFabric);
    this.#fabricBuilder.setOperationalCert(nocValue, icacValue);
    return await this.#fabricBuilder.build(this.associatedFabric.fabricIndex);
  }
  /** Build a new Fabric object for a new fabric for the "AddNoc" case of the Operational Credentials cluster. */
  async buildFabric(nocData) {
    const builder = this.#fabricBuilder;
    const { nocValue, icacValue, adminVendorId, ipkValue, caseAdminSubject } = nocData;
    if (!NodeId.isOperationalNodeId(caseAdminSubject) && !NodeId.isCaseAuthenticatedTag(caseAdminSubject)) {
      try {
        if (CaseAuthenticatedTag.getVersion(NodeId.extractAsCaseAuthenticatedTag(caseAdminSubject)) === 0) {
          throw new MatterFabricInvalidAdminSubjectError();
        }
      } catch (error) {
        if (error instanceof ValidationError || error instanceof UnexpectedDataError) {
          throw new MatterFabricInvalidAdminSubjectError();
        } else {
          throw error;
        }
      }
    }
    builder.setOperationalCert(nocValue, icacValue);
    const fabricAlreadyExisting = this.#fabrics.find((fabric) => builder.matchesToFabric(fabric));
    if (fabricAlreadyExisting) {
      throw new MatterFabricConflictError(
        `Fabric with Id ${builder.fabricId} and Node Id ${builder.nodeId} already exists.`
      );
    }
    return builder.setRootVendorId(adminVendorId).setIdentityProtectionKey(ipkValue).setRootNodeId(caseAdminSubject).build(this.#fabrics.allocateFabricIndex());
  }
  async #failSafeExpired() {
    logger.info("Failsafe timer expired; resetting fabric builder");
    await this.close();
  }
  async rollback() {
    if (this.fabricIndex !== void 0 && !this.#forUpdateNoc) {
      logger.debug(`Revoking fabric with index ${this.fabricIndex}`);
      await this.#fabrics.revokeFabric(this.fabricIndex);
    }
    await this.removePaseSession();
    let fabric = void 0;
    if (this.fabricIndex !== void 0) {
      const fabricIndex = this.fabricIndex;
      if (this.#fabrics.has(fabricIndex)) {
        fabric = this.#fabrics.for(fabricIndex);
        const session = this.#sessions.getSessionForNode(fabric.addressOf(fabric.rootNodeId));
        if (session !== void 0 && session.isSecure) {
          await session.close(false);
        }
      }
    }
    await this.restoreNetworkState();
    if (this.#forUpdateNoc && this.associatedFabric !== void 0) {
      await this.restoreFabric(this.associatedFabric);
    }
    if (!this.#forUpdateNoc && fabric !== void 0) {
      const fabricIndex = this.fabricIndex;
      if (fabricIndex !== void 0 && this.#fabrics.has(fabricIndex)) {
        await this.revokeFabric(this.#fabrics.for(fabricIndex));
      }
    }
    await this.restoreBreadcrumb();
  }
  async restoreFabric(fabric) {
    await this.updateFabric(fabric);
  }
}
export {
  FailsafeContext,
  MatterFabricInvalidAdminSubjectError
};
//# sourceMappingURL=FailsafeContext.js.map
