/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { InternalError, Logger, MaybePromise } from "#general";
const logger = Logger.get("BaseEventStore");
class BaseEventStore {
  #storage;
  #eventStorage;
  #nextNumber;
  constructor(storage) {
    this.#storage = storage;
    this.#eventStorage = storage.createContext(BaseEventStore.EVENTS_KEY);
  }
  clear() {
    return MaybePromise.then(
      this.close(),
      () => MaybePromise.then(
        this.#storage.clear(),
        () => MaybePromise.then(this.#eventStorage.clear(), () => {
          this.#nextNumber = 1n;
        })
      )
    );
  }
  async loadInitialState() {
    let reservationEnd;
    if (await this.#storage.has(BaseEventStore.LAST_RESERVED_NUMBER_KEY)) {
      reservationEnd = await this.#storage.get(BaseEventStore.LAST_RESERVED_NUMBER_KEY);
      if (reservationEnd !== void 0) {
        try {
          reservationEnd = BigInt(reservationEnd);
        } catch (e) {
          logger.warn(`Ignoring invalid value for last persisted event number: ${e}`);
          reservationEnd = void 0;
        }
      }
    }
    let nextNumber = reservationEnd;
    const eventNumbers = Array();
    for (const key of await this.#storage.createContext(BaseEventStore.EVENTS_KEY).keys()) {
      let number;
      try {
        number = BigInt(key);
      } catch (e) {
        if (e instanceof SyntaxError) {
          logger.warn(`Ignoring event stored with invalid key ${key}`);
          continue;
        }
        throw e;
      }
      eventNumbers.push(number);
      if (nextNumber === void 0 || nextNumber <= number) {
        nextNumber = number + 1n;
      }
    }
    this.#nextNumber = nextNumber ?? 1n;
    return { reservationEnd, eventIds: eventNumbers };
  }
  get nextNumber() {
    if (this.#nextNumber === void 0) {
      throw new InternalError("Event store numbering accessed before load");
    }
    return this.#nextNumber;
  }
  allocateNumber() {
    const number = this.nextNumber;
    this.#nextNumber = this.nextNumber + 1n;
    return number;
  }
  get storage() {
    return this.#storage;
  }
  get eventStorage() {
    return this.#eventStorage;
  }
  logLoad(type) {
    if (this.nextNumber === 1n) {
      logger.info(`Initialized new ${type} event store`);
    } else {
      logger.info(`Loaded ${type} event store with next number ${this.nextNumber}`);
    }
  }
  /**
   * If present in the store, this sub-context contains persisted events.
   */
  static EVENTS_KEY = "events";
  /**
   * If present in the store, this value designates the next event value to use on startup.
   *
   * This should really be "lastReservedNumber" but keeping old name for backwards compatibility.
   */
  static LAST_RESERVED_NUMBER_KEY = "lastEventNumber";
}
export {
  BaseEventStore
};
//# sourceMappingURL=BaseEventStore.js.map
