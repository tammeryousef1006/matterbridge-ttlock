/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Logger, MatterAggregateError, MaybePromise } from "#general";
import { BaseEventStore } from "./BaseEventStore.js";
import { OccurrenceSummary } from "./EventStore.js";
const logger = Logger.get("NonvolatileEventStore");
class NonvolatileEventStore extends BaseEventStore {
  #removeNumberReservation = false;
  #iops = /* @__PURE__ */ new Set();
  /**
   * Create new store that persistes events into {@link storage}.
   */
  constructor(storage) {
    super(storage);
  }
  async load() {
    const { reservationEnd, eventIds: eventNumbers } = await this.loadInitialState();
    if (reservationEnd !== void 0) {
      logger.warn("Converting volatile state store to non-volatile");
      this.#removeNumberReservation = true;
    }
    const index = Array();
    for (const number of eventNumbers) {
      const occurrence = await this.eventStorage.get(number.toString());
      if (typeof occurrence !== "object" || occurrence === null) {
        logger.warn("Ignoring invalid stored event occurrence");
        continue;
      }
      index.push(OccurrenceSummary(number, occurrence));
    }
    this.logLoad("non-volatile");
    return index;
  }
  add(occurrence) {
    const number = this.allocateNumber();
    const result = MaybePromise.then(this.eventStorage.set(number.toString(), occurrence), () => {
      const summary = OccurrenceSummary(number, occurrence);
      if (this.#removeNumberReservation) {
        this.#removeNumberReservation = false;
        const conversion = this.storage.delete(BaseEventStore.LAST_RESERVED_NUMBER_KEY);
        return MaybePromise.then(
          conversion,
          () => summary,
          (error) => {
            console.warn("Error clearing volatile event number reservation", error);
            return summary;
          }
        );
      }
      return summary;
    });
    return this.#trackIop(result);
  }
  get(number) {
    return this.#trackIop(this.eventStorage.get(number.toString()));
  }
  delete(number) {
    return this.#trackIop(this.eventStorage.delete(number.toString()));
  }
  clear() {
    this.#removeNumberReservation = false;
    return super.clear();
  }
  close() {
    if (this.#iops.size) {
      return MatterAggregateError.allSettled(this.#iops, "Error closing event store").then(() => {
      }).catch((error) => logger.error(error));
    }
  }
  /**
   * All operations may be async depending on storage so we track them in a set so we can ensure we don't close until
   * they complete.  This should happen at higher levels so this is just for completeness.
   */
  #trackIop(result) {
    if (MaybePromise.is(result)) {
      logger.warn("Waiting on ongoing write before event store closure");
      result = Promise.resolve(result).finally(() => this.#iops.delete(result));
      this.#iops.add(result);
    }
    return result;
  }
}
export {
  NonvolatileEventStore
};
//# sourceMappingURL=NonvolatileEventStore.js.map
