/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import {
  asyncNew,
  Construction,
  Diagnostic,
  ImplementationError,
  isObject,
  Logger,
  MatterAggregateError,
  MaybePromise
} from "#general";
import {
  EventNumber,
  EventPriority,
  resolveEventName
} from "#types";
const logger = Logger.get("OccurrenceManager");
class OccurrenceManager {
  #store;
  #storedEventCount = 0;
  #bufferConfig;
  #cull;
  // As we don't (yet) have storage with secondary indices we currently maintain indices in memory regardless of
  // whether underlying store is volatile
  #occurrences = {
    [EventPriority.Critical]: new Array(),
    [EventPriority.Info]: new Array(),
    [EventPriority.Debug]: new Array()
  };
  #construction;
  get construction() {
    return this.#construction;
  }
  static async create(context) {
    return asyncNew(OccurrenceManager, context);
  }
  constructor({ store, bufferConfig }) {
    if (bufferConfig === void 0) {
      bufferConfig = OccurrenceManager.DefaultBufferConfig;
    }
    const { minEventAllowance, maxEventAllowance } = bufferConfig;
    if (maxEventAllowance < minEventAllowance) {
      throw new ImplementationError(
        `Maximum allowance ${maxEventAllowance} is less than minimum allowance ${minEventAllowance}`
      );
    }
    const totalPriorityAllowance = Object.values(bufferConfig.minPriorityEventAllowance).reduce(
      (sum, value) => sum + value,
      0
    );
    if (totalPriorityAllowance > minEventAllowance) {
      throw new ImplementationError(
        `Total priority allowance ${totalPriorityAllowance} is greater than minimum allowance of ${minEventAllowance}`
      );
    }
    this.#store = store;
    this.#bufferConfig = bufferConfig;
    this.#construction = Construction(this, () => {
      return MaybePromise.then(this.#store.load(), (index) => {
        this.#storedEventCount = index.length;
        for (const entry of index) {
          this.#occurrences[entry.priority].push(entry);
        }
      });
    });
  }
  async clear() {
    await this.construction;
    await this.#store.clear();
    this.#storedEventCount = 0;
    for (const list of Object.values(this.#occurrences)) {
      list.length = 0;
    }
  }
  query(eventPath, filters, filterForFabricIndex) {
    const entryFilter = filters !== void 0 && filters.length > 0 ? (event) => filters.some(
      (filter) => filter.eventMin !== void 0 && event.number >= EventNumber(filter.eventMin)
    ) : void 0;
    let isAsyncLoad = false;
    const occurrences = new Array();
    const { endpointId, clusterId, eventId } = eventPath;
    for (const priority of [EventPriority.Critical, EventPriority.Info, EventPriority.Debug]) {
      const entriesToCheck = this.#occurrences[priority];
      for (const entry of entriesToCheck) {
        if (endpointId === entry.endpointId && clusterId === entry.clusterId && eventId === entry.eventId) {
          if (entryFilter?.(entry) !== false) {
            let occurrence = this.#store.get(entry.number);
            occurrence = MaybePromise.then(occurrence, (occurrence2) => {
              occurrence2.number = entry.number;
              return occurrence2;
            });
            occurrences.push(occurrence);
            if (MaybePromise.is(occurrence)) {
              isAsyncLoad = true;
            }
          }
        }
      }
    }
    logger.debug(
      `Got ${occurrences.length} events for ${resolveEventName(eventPath)} with filters: ${Diagnostic.json(filters)}`
    );
    let result;
    if (isAsyncLoad) {
      result = Promise.all(occurrences);
    } else {
      result = occurrences;
    }
    if (filterForFabricIndex !== void 0) {
      result = MaybePromise.then(
        result,
        (occurrences2) => occurrences2.filter(({ payload }) => {
          if (!isObject(payload)) {
            return true;
          }
          const { fabricIndex } = payload;
          return fabricIndex === void 0 || fabricIndex === filterForFabricIndex;
        })
      );
    }
    result = MaybePromise.then(result, (occurrences2) => {
      let filterDesc;
      if (filters?.length) {
        filterDesc = filters.map(({ nodeId, eventMin }) => `${nodeId}:${eventMin}`).join(",");
      }
      if (filterForFabricIndex) {
        if (filterDesc !== void 0) {
          filterDesc = `${filterDesc} and fabric #${filterForFabricIndex}`;
        } else {
          filterDesc = `fabric #${filterForFabricIndex}`;
        }
      }
      if (filterDesc) {
        filterDesc = ` (filters: ${filterDesc})`;
      } else {
        filterDesc = "";
      }
      logger.debug(
        `Loaded ${occurrences2.length} occurrence${occurrences2.length === 1 ? "" : "s"} for ${resolveEventName(eventPath)}${filterDesc}`
      );
      return occurrences2;
    });
    return result;
  }
  close() {
    MaybePromise.then(this.#cull, () => this.#store.close());
  }
  add(occurrence) {
    return MaybePromise.then(this.#store.add(occurrence), (entry) => {
      logger.debug(`Recorded event #${entry.number}: ${Diagnostic.json(occurrence)}`);
      this.#occurrences[occurrence.priority].push(entry);
      this.#storedEventCount++;
      if (this.#storedEventCount > this.#bufferConfig.maxEventAllowance) {
        this.#startCull();
      }
      return {
        number: entry.number,
        ...occurrence
      };
    });
  }
  #startCull() {
    if (this.#cull) {
      return;
    }
    const cull = this.#dropOldOccurrences();
    if (MaybePromise.is(cull)) {
      this.#cull = Promise.resolve(cull).finally(() => this.#cull = void 0);
    }
  }
  #dropOldOccurrences() {
    let count = this.#storedEventCount - this.#bufferConfig.minEventAllowance;
    if (count <= 0) {
      return;
    }
    logger.debug(`Event store is full; dropping ${count} old occurrence${count === 1 ? "s" : ""}`);
    const asyncDrops = Array();
    let totalCulled = 0;
    for (const priority of [EventPriority.Debug, EventPriority.Info, EventPriority.Critical]) {
      const occurrences = this.#occurrences[priority];
      const reservation = this.#bufferConfig.minPriorityEventAllowance[PriorityNames[priority]];
      let countThisPriority = 0;
      while (count && occurrences.length > reservation) {
        count--;
        countThisPriority++;
      }
      totalCulled += countThisPriority;
      for (const entry of occurrences.splice(0, countThisPriority)) {
        const drop = MaybePromise.catch(
          this.#store.delete(entry.number),
          (error) => logger.warn(`Error dropping occurrence #${entry}: ${error}`)
        );
        if (MaybePromise.is(drop)) {
          asyncDrops.push(drop);
        }
      }
      if (!count) {
        break;
      }
    }
    this.#storedEventCount -= totalCulled;
    if (asyncDrops.length) {
      return MatterAggregateError.allSettled(asyncDrops, "Error dropping occurrences").then(() => {
      }).catch((error) => logger.error(error));
    }
  }
}
const PriorityNames = {
  [EventPriority.Critical]: "critical",
  [EventPriority.Info]: "info",
  [EventPriority.Debug]: "debug"
};
((OccurrenceManager2) => {
  OccurrenceManager2.DefaultBufferConfig = {
    minEventAllowance: 1e4,
    maxEventAllowance: 11e3,
    minPriorityEventAllowance: {
      critical: 2e3,
      info: 2e3,
      debug: 2e3
    }
  };
})(OccurrenceManager || (OccurrenceManager = {}));
export {
  OccurrenceManager
};
//# sourceMappingURL=OccurrenceManager.js.map
