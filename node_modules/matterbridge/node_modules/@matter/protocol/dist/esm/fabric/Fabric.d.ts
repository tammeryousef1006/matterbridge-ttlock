/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { GroupKeyManagement } from "#clusters/group-key-management";
import { BinaryKeyPair, Key, MatterError, MaybePromise, PrivateKey, SupportedStorageTypes } from "#general";
import { PeerAddress } from "#peer/PeerAddress.js";
import { Cluster, FabricId, FabricIndex, NodeId, VendorId } from "#types";
import { SecureSession } from "../session/SecureSession.js";
export declare class PublicKeyError extends MatterError {
}
export type ExposedFabricInformation = {
    fabricIndex: FabricIndex;
    fabricId: FabricId;
    nodeId: NodeId;
    rootNodeId: NodeId;
    rootVendorId: VendorId;
    label: string;
};
export declare class Fabric {
    #private;
    readonly fabricIndex: FabricIndex;
    readonly fabricId: FabricId;
    readonly nodeId: NodeId;
    readonly rootNodeId: NodeId;
    readonly operationalId: Uint8Array;
    readonly rootPublicKey: Uint8Array;
    readonly rootVendorId: VendorId;
    readonly rootCert: Uint8Array;
    readonly identityProtectionKey: Uint8Array;
    readonly operationalIdentityProtectionKey: Uint8Array;
    readonly intermediateCACert: Uint8Array | undefined;
    readonly operationalCert: Uint8Array;
    constructor(config: Fabric.Config);
    get config(): Fabric.Config;
    get label(): string;
    setLabel(label: string): Promise<void>;
    get publicKey(): Uint8Array<ArrayBufferLike>;
    sign(data: Uint8Array): Uint8Array<ArrayBufferLike>;
    verifyCredentials(operationalCert: Uint8Array, intermediateCACert?: Uint8Array): void;
    matchesFabricIdAndRootPublicKey(fabricId: FabricId, rootPublicKey: Uint8Array): boolean;
    matchesKeyPair(keyPair: Key): boolean;
    getDestinationId(nodeId: NodeId, random: Uint8Array): Uint8Array<ArrayBufferLike>;
    addSession(session: SecureSession): void;
    removeSession(session: SecureSession): void;
    addRemoveCallback(callback: () => MaybePromise<void>): void;
    deleteRemoveCallback(callback: () => MaybePromise<void>): void;
    set persistCallback(callback: (isUpdate?: boolean) => MaybePromise<void>);
    remove(currentSessionId?: number): Promise<void>;
    persist(isUpdate?: boolean): MaybePromise<void> | undefined;
    getScopedClusterDataValue<T>(cluster: Cluster<any, any, any, any, any>, clusterDataKey: string): T | undefined;
    setScopedClusterDataValue<T>(cluster: Cluster<any, any, any, any, any>, clusterDataKey: string, value: T): MaybePromise<void> | undefined;
    deleteScopedClusterDataValue(cluster: Cluster<any, any, any, any, any>, clusterDataKey: string): MaybePromise<void>;
    hasScopedClusterDataValue(cluster: Cluster<any, any, any, any, any>, clusterDataKey: string): boolean;
    deleteScopedClusterData(cluster: Cluster<any, any, any, any, any>): MaybePromise<void> | undefined;
    getScopedClusterDataKeys(cluster: Cluster<any, any, any, any, any>): string[];
    getGroupKeySet(groupKeySetId: number): import("#types").TypeFromFields<{
        groupKeySetId: import("#types").FieldType<number>;
        groupKeySecurityPolicy: import("#types").FieldType<GroupKeyManagement.GroupKeySecurityPolicy>;
        epochKey0: import("#types").FieldType<Uint8Array<ArrayBufferLike> | null>;
        epochStartTime0: import("#types").FieldType<number | bigint | null>;
        epochKey1: import("#types").FieldType<Uint8Array<ArrayBufferLike> | null>;
        epochStartTime1: import("#types").FieldType<number | bigint | null>;
        epochKey2: import("#types").FieldType<Uint8Array<ArrayBufferLike> | null>;
        epochStartTime2: import("#types").FieldType<number | bigint | null>;
        groupKeyMulticastPolicy: import("#types").OptionalFieldType<GroupKeyManagement.GroupKeyMulticastPolicy>;
    }> | undefined;
    private getGroupSetForIpk;
    getAllGroupKeySets(): import("#types").TypeFromFields<{
        groupKeySetId: import("#types").FieldType<number>;
        groupKeySecurityPolicy: import("#types").FieldType<GroupKeyManagement.GroupKeySecurityPolicy>;
        epochKey0: import("#types").FieldType<Uint8Array<ArrayBufferLike> | null>;
        epochStartTime0: import("#types").FieldType<number | bigint | null>;
        epochKey1: import("#types").FieldType<Uint8Array<ArrayBufferLike> | null>;
        epochStartTime1: import("#types").FieldType<number | bigint | null>;
        epochKey2: import("#types").FieldType<Uint8Array<ArrayBufferLike> | null>;
        epochStartTime2: import("#types").FieldType<number | bigint | null>;
        groupKeyMulticastPolicy: import("#types").OptionalFieldType<GroupKeyManagement.GroupKeyMulticastPolicy>;
    }>[];
    get externalInformation(): ExposedFabricInformation;
    addressOf(nodeId: NodeId): PeerAddress;
}
export declare class FabricBuilder {
    #private;
    get publicKey(): Uint8Array<ArrayBufferLike>;
    get fabricIndex(): FabricIndex | undefined;
    createCertificateSigningRequest(): Uint8Array<ArrayBufferLike>;
    setRootCert(rootCert: Uint8Array): this;
    get rootCert(): Uint8Array<ArrayBufferLike> | undefined;
    setOperationalCert(operationalCert: Uint8Array, intermediateCACert?: Uint8Array): this;
    setRootVendorId(rootVendorId: VendorId): this;
    setRootNodeId(rootNodeId: NodeId): this;
    setIdentityProtectionKey(key: Uint8Array): this;
    setLabel(label: string): this;
    initializeFromFabricForUpdate(fabric: Fabric): void;
    matchesToFabric(fabric: Fabric): boolean;
    get nodeId(): NodeId | undefined;
    get fabricId(): FabricId | undefined;
    get keyPair(): PrivateKey;
    build(fabricIndex: FabricIndex): Promise<Fabric>;
}
export declare namespace Fabric {
    interface ScopedClusterData extends Map<number, Map<string, SupportedStorageTypes>> {
    }
    type Config = {
        fabricIndex: FabricIndex;
        fabricId: FabricId;
        nodeId: NodeId;
        rootNodeId: NodeId;
        operationalId: Uint8Array;
        rootPublicKey: Uint8Array;
        keyPair: BinaryKeyPair;
        rootVendorId: VendorId;
        rootCert: Uint8Array;
        identityProtectionKey: Uint8Array;
        operationalIdentityProtectionKey: Uint8Array;
        intermediateCACert: Uint8Array | undefined;
        operationalCert: Uint8Array;
        label: string;
        scopedClusterData?: ScopedClusterData;
    };
}
//# sourceMappingURL=Fabric.d.ts.map