/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import {
  CertificateManager,
  TlvIntermediateCertificate,
  TlvOperationalCertificate,
  TlvRootCertificate
} from "#certificate/CertificateManager.js";
import { GroupKeyManagement } from "#clusters/group-key-management";
import {
  Bytes,
  Crypto,
  DataWriter,
  Endian,
  ImplementationError,
  InternalError,
  Logger,
  MatterError,
  MatterFlowError,
  PrivateKey
} from "#general";
import { PeerAddress } from "#peer/PeerAddress.js";
import { CaseAuthenticatedTag, FabricId } from "#types";
const logger = Logger.get("Fabric");
const COMPRESSED_FABRIC_ID_INFO = Bytes.fromString("CompressedFabric");
const GROUP_SECURITY_INFO = Bytes.fromString("GroupKey v1.0");
class PublicKeyError extends MatterError {
}
var OperationalGroupKeySet;
((OperationalGroupKeySet2) => {
  OperationalGroupKeySet2.asTlvGroupSet = (operationalGroupSet) => {
    const {
      groupKeySetId,
      epochKey0,
      epochStartTime0,
      epochKey1,
      epochStartTime1,
      epochKey2,
      epochStartTime2,
      groupKeySecurityPolicy,
      groupKeyMulticastPolicy
    } = operationalGroupSet;
    return {
      groupKeySetId,
      epochKey0,
      epochStartTime0,
      epochKey1,
      epochStartTime1,
      epochKey2,
      epochStartTime2,
      groupKeySecurityPolicy,
      groupKeyMulticastPolicy
    };
  };
})(OperationalGroupKeySet || (OperationalGroupKeySet = {}));
class Fabric {
  fabricIndex;
  fabricId;
  nodeId;
  rootNodeId;
  operationalId;
  rootPublicKey;
  rootVendorId;
  rootCert;
  identityProtectionKey;
  operationalIdentityProtectionKey;
  intermediateCACert;
  operationalCert;
  #scopedClusterData;
  #keyPair;
  #sessions = /* @__PURE__ */ new Set();
  #label;
  #removeCallbacks = new Array();
  #persistCallback;
  constructor(config) {
    this.fabricIndex = config.fabricIndex;
    this.fabricId = config.fabricId;
    this.nodeId = config.nodeId;
    this.rootNodeId = config.rootNodeId;
    this.operationalId = config.operationalId;
    this.rootPublicKey = config.rootPublicKey;
    this.rootVendorId = config.rootVendorId;
    this.rootCert = config.rootCert;
    this.identityProtectionKey = config.identityProtectionKey;
    this.operationalIdentityProtectionKey = config.operationalIdentityProtectionKey;
    this.intermediateCACert = config.intermediateCACert;
    this.operationalCert = config.operationalCert;
    this.#label = config.label;
    this.#keyPair = PrivateKey(config.keyPair);
    this.#scopedClusterData = config.scopedClusterData ?? /* @__PURE__ */ new Map();
  }
  get config() {
    return {
      fabricIndex: this.fabricIndex,
      fabricId: this.fabricId,
      nodeId: this.nodeId,
      rootNodeId: this.rootNodeId,
      operationalId: this.operationalId,
      rootPublicKey: this.rootPublicKey,
      keyPair: this.#keyPair.keyPair,
      rootVendorId: this.rootVendorId,
      rootCert: this.rootCert,
      identityProtectionKey: this.identityProtectionKey,
      operationalIdentityProtectionKey: this.operationalIdentityProtectionKey,
      intermediateCACert: this.intermediateCACert,
      operationalCert: this.operationalCert,
      label: this.#label,
      scopedClusterData: this.#scopedClusterData
    };
  }
  get label() {
    return this.#label;
  }
  async setLabel(label) {
    if (label.length === 0 || label.length > 32) {
      throw new ImplementationError("Fabric label must be between 1 and 32 characters long.");
    }
    if (this.#label === label) {
      return;
    }
    this.#label = label;
    await this.persist();
  }
  get publicKey() {
    return this.#keyPair.publicKey;
  }
  sign(data) {
    return Crypto.sign(this.#keyPair, data);
  }
  verifyCredentials(operationalCert, intermediateCACert) {
    const rootCert = TlvRootCertificate.decode(this.rootCert);
    const nocCert = TlvOperationalCertificate.decode(operationalCert);
    const icaCert = intermediateCACert !== void 0 ? TlvIntermediateCertificate.decode(intermediateCACert) : void 0;
    if (icaCert !== void 0) {
      CertificateManager.verifyIntermediateCaCertificate(rootCert, icaCert);
    }
    CertificateManager.verifyNodeOperationalCertificate(nocCert, rootCert, icaCert);
  }
  matchesFabricIdAndRootPublicKey(fabricId, rootPublicKey) {
    return this.fabricId === fabricId && Bytes.areEqual(this.rootPublicKey, rootPublicKey);
  }
  matchesKeyPair(keyPair) {
    return Bytes.areEqual(this.#keyPair.publicKey, keyPair.publicKey) && Bytes.areEqual(this.#keyPair.privateKey, keyPair.privateKey);
  }
  getDestinationId(nodeId, random) {
    const writer = new DataWriter(Endian.Little);
    writer.writeByteArray(random);
    writer.writeByteArray(this.rootPublicKey);
    writer.writeUInt64(this.fabricId);
    writer.writeUInt64(nodeId);
    return Crypto.hmac(this.operationalIdentityProtectionKey, writer.toByteArray());
  }
  addSession(session) {
    this.#sessions.add(session);
  }
  removeSession(session) {
    this.#sessions.delete(session);
  }
  addRemoveCallback(callback) {
    this.#removeCallbacks.push(callback);
  }
  deleteRemoveCallback(callback) {
    const index = this.#removeCallbacks.indexOf(callback);
    if (index >= 0) {
      this.#removeCallbacks.splice(index, 1);
    }
  }
  set persistCallback(callback) {
    this.#persistCallback = callback;
  }
  async remove(currentSessionId) {
    for (const callback of this.#removeCallbacks) {
      await callback();
    }
    for (const session of [...this.#sessions]) {
      await session.destroy(false, session.id === currentSessionId);
    }
  }
  persist(isUpdate = true) {
    return this.#persistCallback?.(isUpdate);
  }
  getScopedClusterDataValue(cluster, clusterDataKey) {
    const dataMap = this.#scopedClusterData.get(cluster.id);
    if (dataMap === void 0) {
      return void 0;
    }
    return dataMap.get(clusterDataKey);
  }
  setScopedClusterDataValue(cluster, clusterDataKey, value) {
    if (!this.#scopedClusterData.has(cluster.id)) {
      this.#scopedClusterData.set(cluster.id, /* @__PURE__ */ new Map());
    }
    this.#scopedClusterData.get(cluster.id).set(clusterDataKey, value);
    return this.persist(false);
  }
  deleteScopedClusterDataValue(cluster, clusterDataKey) {
    if (!this.#scopedClusterData.has(cluster.id)) {
      return;
    }
    this.#scopedClusterData.get(cluster.id).delete(clusterDataKey);
    return this.persist(false);
  }
  hasScopedClusterDataValue(cluster, clusterDataKey) {
    return this.#scopedClusterData.has(cluster.id) && this.#scopedClusterData.get(cluster.id).has(clusterDataKey);
  }
  deleteScopedClusterData(cluster) {
    this.#scopedClusterData.delete(cluster.id);
    return this.persist(false);
  }
  getScopedClusterDataKeys(cluster) {
    if (!this.#scopedClusterData.has(cluster.id)) {
      return [];
    }
    return Array.from(this.#scopedClusterData.get(cluster.id).keys());
  }
  getGroupKeySet(groupKeySetId) {
    if (groupKeySetId === 0) {
      return OperationalGroupKeySet.asTlvGroupSet(this.getGroupSetForIpk());
    }
    return void 0;
  }
  getGroupSetForIpk() {
    return {
      groupKeySetId: 0,
      epochKey0: this.identityProtectionKey,
      operationalEpochKey0: this.operationalIdentityProtectionKey,
      epochStartTime0: 0,
      // or do we need to track Fabric creation date?
      groupSessionId0: null,
      epochKey1: null,
      operationalEpochKey1: null,
      epochStartTime1: null,
      groupSessionId1: null,
      epochKey2: null,
      operationalEpochKey2: null,
      epochStartTime2: null,
      groupSessionId2: null,
      groupKeySecurityPolicy: GroupKeyManagement.GroupKeySecurityPolicy.TrustFirst,
      groupKeyMulticastPolicy: GroupKeyManagement.GroupKeyMulticastPolicy.PerGroupId
    };
  }
  getAllGroupKeySets() {
    return [OperationalGroupKeySet.asTlvGroupSet(this.getGroupSetForIpk())];
  }
  get externalInformation() {
    return {
      fabricIndex: this.fabricIndex,
      fabricId: this.fabricId,
      nodeId: this.nodeId,
      rootNodeId: this.rootNodeId,
      rootVendorId: this.rootVendorId,
      label: this.#label
    };
  }
  addressOf(nodeId) {
    return PeerAddress({ fabricIndex: this.fabricIndex, nodeId });
  }
}
class FabricBuilder {
  #keyPair = Crypto.createKeyPair();
  #rootVendorId;
  #rootCert;
  #intermediateCACert;
  #operationalCert;
  #fabricId;
  #nodeId;
  #rootNodeId;
  #rootPublicKey;
  #identityProtectionKey;
  #fabricIndex;
  #label = "";
  get publicKey() {
    return this.#keyPair.publicKey;
  }
  get fabricIndex() {
    return this.#fabricIndex;
  }
  createCertificateSigningRequest() {
    return CertificateManager.createCertificateSigningRequest(this.#keyPair);
  }
  setRootCert(rootCert) {
    const decodedRootCertificate = TlvRootCertificate.decode(rootCert);
    CertificateManager.verifyRootCertificate(decodedRootCertificate);
    this.#rootCert = rootCert;
    this.#rootPublicKey = decodedRootCertificate.ellipticCurvePublicKey;
    return this;
  }
  get rootCert() {
    return this.#rootCert;
  }
  setOperationalCert(operationalCert, intermediateCACert) {
    if (intermediateCACert !== void 0 && intermediateCACert.length === 0) {
      intermediateCACert = void 0;
    }
    const {
      subject: { nodeId, fabricId, caseAuthenticatedTags },
      ellipticCurvePublicKey
    } = TlvOperationalCertificate.decode(operationalCert);
    logger.debug(
      `FabricBuilder setOperationalCert: nodeId=${nodeId}, fabricId=${fabricId}, caseAuthenticatedTags=${caseAuthenticatedTags}`
    );
    if (caseAuthenticatedTags !== void 0) {
      CaseAuthenticatedTag.validateNocTagList(caseAuthenticatedTags);
    }
    if (!Bytes.areEqual(ellipticCurvePublicKey, this.#keyPair.publicKey)) {
      throw new PublicKeyError("Operational Certificate does not match public key.");
    }
    if (this.#rootCert === void 0) {
      throw new MatterFlowError("Root Certificate needs to be set first.");
    }
    const rootCert = TlvRootCertificate.decode(this.#rootCert);
    const nocCert = TlvOperationalCertificate.decode(operationalCert);
    const icaCert = intermediateCACert !== void 0 ? TlvIntermediateCertificate.decode(intermediateCACert) : void 0;
    if (icaCert !== void 0) {
      CertificateManager.verifyIntermediateCaCertificate(rootCert, icaCert);
    }
    CertificateManager.verifyNodeOperationalCertificate(nocCert, rootCert, icaCert);
    this.#operationalCert = operationalCert;
    this.#intermediateCACert = intermediateCACert;
    this.#fabricId = FabricId(fabricId);
    this.#nodeId = nodeId;
    return this;
  }
  setRootVendorId(rootVendorId) {
    this.#rootVendorId = rootVendorId;
    return this;
  }
  setRootNodeId(rootNodeId) {
    this.#rootNodeId = rootNodeId;
    return this;
  }
  setIdentityProtectionKey(key) {
    this.#identityProtectionKey = key;
    return this;
  }
  setLabel(label) {
    if (label.length === 0 || label.length > 32) {
      throw new ImplementationError("Fabric label must be between 1 and 32 characters long.");
    }
    this.#label = label;
    return this;
  }
  initializeFromFabricForUpdate(fabric) {
    this.#rootVendorId = fabric.rootVendorId;
    this.#rootNodeId = fabric.rootNodeId;
    this.#identityProtectionKey = fabric.identityProtectionKey;
    this.#rootCert = fabric.rootCert;
    this.#rootPublicKey = fabric.rootPublicKey;
    this.#label = fabric.label;
  }
  matchesToFabric(fabric) {
    if (this.#fabricId === void 0 || this.#rootPublicKey === void 0) {
      throw new MatterFlowError("Node Operational Data needs to be set first.");
    }
    return fabric.matchesFabricIdAndRootPublicKey(this.#fabricId, this.#rootPublicKey);
  }
  get nodeId() {
    return this.#nodeId;
  }
  get fabricId() {
    return this.#fabricId;
  }
  get keyPair() {
    return this.#keyPair;
  }
  async build(fabricIndex) {
    if (this.#fabricIndex !== void 0) throw new InternalError("FabricBuilder can only be built once");
    if (this.#rootNodeId === void 0) throw new InternalError("rootNodeId needs to be set");
    if (this.#rootVendorId === void 0) throw new InternalError("vendorId needs to be set");
    if (this.#rootCert === void 0 || this.#rootPublicKey === void 0)
      throw new InternalError("rootCert needs to be set");
    if (this.#identityProtectionKey === void 0) throw new InternalError("identityProtectionKey needs to be set");
    if (this.#operationalCert === void 0 || this.#fabricId === void 0 || this.#nodeId === void 0)
      throw new InternalError("operationalCert needs to be set");
    this.#fabricIndex = fabricIndex;
    const saltWriter = new DataWriter(Endian.Big);
    saltWriter.writeUInt64(this.#fabricId);
    const operationalId = await Crypto.hkdf(
      this.#rootPublicKey.slice(1),
      saltWriter.toByteArray(),
      COMPRESSED_FABRIC_ID_INFO,
      8
    );
    return new Fabric({
      fabricIndex: this.#fabricIndex,
      fabricId: this.#fabricId,
      nodeId: this.#nodeId,
      rootNodeId: this.#rootNodeId,
      operationalId,
      rootPublicKey: this.#rootPublicKey,
      keyPair: this.#keyPair,
      rootVendorId: this.#rootVendorId,
      rootCert: this.#rootCert,
      identityProtectionKey: this.#identityProtectionKey,
      // Epoch Key
      operationalIdentityProtectionKey: await Crypto.hkdf(
        this.#identityProtectionKey,
        operationalId,
        GROUP_SECURITY_INFO
      ),
      intermediateCACert: this.#intermediateCACert,
      operationalCert: this.#operationalCert,
      label: this.#label
    });
  }
}
export {
  Fabric,
  FabricBuilder,
  PublicKeyError
};
//# sourceMappingURL=Fabric.js.map
