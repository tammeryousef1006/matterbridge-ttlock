/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { CertificateAuthority } from "#certificate/CertificateAuthority.js";
import {
  Bytes,
  Crypto,
  CRYPTO_SYMMETRIC_KEY_LENGTH,
  Environmental,
  ImplementationError,
  Logger
} from "#general";
import { FabricId, NodeId, VendorId } from "#types";
import { FabricBuilder } from "./Fabric.js";
import { FabricManager } from "./FabricManager.js";
const logger = Logger.get("FabricAuthority");
class FabricAuthorityConfigurationProvider {
  get adminFabricLabel() {
    throw new ImplementationError("Admin Fabric Label must be set for FabricAuthorityConfigurationProvider.");
  }
}
const DEFAULT_ADMIN_VENDOR_ID = VendorId(65521);
const DEFAULT_FABRIC_ID = FabricId(1);
class FabricAuthority {
  #ca;
  #fabrics;
  #config;
  constructor(context) {
    this.#ca = context.ca;
    this.#fabrics = context.fabrics;
    this.#config = context.config;
  }
  /**
   * Obtain the default fabric for this authority.
   */
  async defaultFabric() {
    const fabric = this.fabrics[0];
    if (fabric !== void 0) {
      if (fabric.label !== this.#config.adminFabricLabel) {
        await fabric.setLabel(this.#config.adminFabricLabel);
      }
      return fabric;
    }
    return await this.createFabric();
  }
  /**
   * List all controlled fabrics.
   */
  get fabrics() {
    return Array.from(this.#fabrics).filter(this.hasControlOf.bind(this));
  }
  /**
   * Determine whether a fabric belongs to this authority.
   */
  hasControlOf(fabric) {
    return Bytes.areEqual(fabric.rootCert, this.#ca.rootCert);
  }
  /**
   * Create a new fabric under our control.
   */
  async createFabric() {
    const rootNodeId = NodeId.randomOperationalNodeId();
    const ipkValue = Crypto.getRandomData(CRYPTO_SYMMETRIC_KEY_LENGTH);
    let vendorId = this.#config.adminVendorId;
    if (vendorId === void 0) {
      vendorId = DEFAULT_ADMIN_VENDOR_ID;
      logger.warn(`Using test vendor ID 0x${vendorId.toString(16)} for controller fabric`);
    }
    const fabricBuilder = new FabricBuilder().setRootCert(this.#ca.rootCert).setRootNodeId(rootNodeId).setIdentityProtectionKey(ipkValue).setRootVendorId(this.#config.adminVendorId ?? DEFAULT_ADMIN_VENDOR_ID).setLabel(this.#config.adminFabricLabel);
    fabricBuilder.setOperationalCert(
      this.#ca.generateNoc(
        fabricBuilder.publicKey,
        this.#config.fabricId ?? DEFAULT_FABRIC_ID,
        rootNodeId,
        this.#config.caseAuthenticatedTags
      )
    );
    let index = this.#config.fabricIndex;
    if (index === void 0) {
      index = this.#fabrics.allocateFabricIndex();
    } else if (this.#fabrics.findByIndex(index) !== void 0) {
      throw new ImplementationError(`Cannot allocate controller fabric ${index} because index is in use`);
    }
    const fabric = await fabricBuilder.build(index);
    this.#fabrics.addFabric(fabric);
    logger.debug(`Created new controller fabric ${index}`);
    return fabric;
  }
  static [Environmental.create](env) {
    const instance = new FabricAuthority({
      ca: env.get(CertificateAuthority),
      fabrics: env.get(FabricManager),
      config: env.get(FabricAuthorityConfigurationProvider)
    });
    env.set(FabricAuthority, instance);
    return instance;
  }
}
export {
  DEFAULT_ADMIN_VENDOR_ID,
  DEFAULT_FABRIC_ID,
  FabricAuthority,
  FabricAuthorityConfigurationProvider
};
//# sourceMappingURL=FabricAuthority.js.map
