/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Construction, Environment, Environmental, Key, MatterError, MaybePromise, Observable, StorageContext } from "#general";
import { PeerAddress } from "#peer/PeerAddress.js";
import { FabricIndex } from "#types";
import { Fabric } from "./Fabric.js";
/** Specific Error for when a fabric is not found. */
export declare class FabricNotFoundError extends MatterError {
}
export declare class FabricTableFullError extends MatterError {
}
export declare enum FabricAction {
    Added = 0,
    Removed = 1,
    Updated = 2
}
export declare class FabricManager {
    #private;
    constructor(storage?: StorageContext);
    get construction(): Construction<FabricManager>;
    [Construction.construct](): Promise<void>;
    static [Environmental.create](env: Environment): FabricManager;
    get events(): {
        added: Observable<[fabric: Fabric], void>;
        updated: Observable<[fabric: Fabric], void>;
        deleted: Observable<[fabric: Fabric], void>;
        failsafeClosed: Observable<[], void>;
    };
    clear(): Promise<void>;
    has(address: FabricIndex | PeerAddress): boolean;
    for(address: FabricIndex | PeerAddress): Fabric;
    allocateFabricIndex(): FabricIndex;
    persistFabrics(): MaybePromise<void>;
    addFabric(fabric: Fabric): void;
    removeFabric(fabricIndex: FabricIndex): Promise<void>;
    [Symbol.iterator](): MapIterator<Fabric>;
    get fabrics(): Fabric[];
    get length(): number;
    find(predicate: (fabric: Fabric) => boolean): Fabric | undefined;
    map<T>(translator: (fabric: Fabric) => T): T[];
    findFabricFromDestinationId(destinationId: Uint8Array, initiatorRandom: Uint8Array): Fabric;
    findByKeypair(keypair: Key): Fabric | undefined;
    findByIndex(index: FabricIndex): Fabric | undefined;
    updateFabric(fabric: Fabric): Promise<void>;
    revokeFabric(fabricIndex: FabricIndex): Promise<void>;
}
//# sourceMappingURL=FabricManager.d.ts.map