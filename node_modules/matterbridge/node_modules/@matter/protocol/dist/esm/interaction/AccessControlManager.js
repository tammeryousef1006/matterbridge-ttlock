/**
 * @license
 * Copyright 2022-2023 Project CHIP Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { AccessControl } from "#clusters/access-control";
import { Logger, MatterFlowError, toHex } from "#general";
import { AccessLevel } from "#model";
import {
  CaseAuthenticatedTag,
  FabricIndex,
  NodeId,
  StatusCode,
  StatusResponseError
} from "#types";
const logger = Logger.get("AccessControlManager");
const ImplicitDefaultPaseAclEntry = {
  fabricIndex: FabricIndex.NO_FABRIC,
  // not fabric-specific
  privilege: AccessLevel.Administer,
  authMode: AccessControl.AccessControlEntryAuthMode.Pase,
  subjects: [],
  targets: []
  // entire node
};
var AuthModeNone = /* @__PURE__ */ ((AuthModeNone2) => {
  AuthModeNone2[AuthModeNone2["None"] = 0] = "None";
  return AuthModeNone2;
})(AuthModeNone || {});
class AccessDeniedError extends StatusResponseError {
  constructor(message) {
    super(message ?? "Unauthorized", StatusCode.UnsupportedAccess);
  }
}
class AccessControlManager {
  #aclList;
  #extensionEntryAccessCheck = () => true;
  constructor(aclList = [], extensionEntryAccessCheck) {
    this.#aclList = aclList;
    if (extensionEntryAccessCheck !== void 0) {
      this.#extensionEntryAccessCheck = extensionEntryAccessCheck;
    }
  }
  /**
   * Public method used to update the Access Control List on changes.
   */
  updateAccessControlList(aclList = []) {
    this.#aclList = [...aclList];
  }
  /**
   * Get the Access Control List for a given fabric.
   */
  #getAccessControlEntriesForFabric(fabric) {
    return this.#aclList.filter((entry) => entry.fabricIndex === fabric.fabricIndex);
  }
  /**
   * Subjects must match exactly, or both are CAT with matching CAT ID and acceptable CAT version
   */
  #subjectMatches(aclSubject, isdSubject) {
    if (aclSubject === isdSubject) {
      return true;
    }
    if (!NodeId.isCaseAuthenticatedTag(aclSubject) || !NodeId.isCaseAuthenticatedTag(isdSubject)) {
      return false;
    }
    const aclSubjectCat = NodeId.extractAsCaseAuthenticatedTag(aclSubject);
    const isdSubjectCat = NodeId.extractAsCaseAuthenticatedTag(isdSubject);
    return CaseAuthenticatedTag.getIdentifyValue(aclSubjectCat) === CaseAuthenticatedTag.getIdentifyValue(isdSubjectCat) && CaseAuthenticatedTag.getVersion(isdSubjectCat) >= CaseAuthenticatedTag.getVersion(aclSubjectCat);
  }
  /**
   * Add the new privilege to the granted privileges set and also add any privileges subsumed by the new privilege.
   */
  #addGrantedPrivilege(grantedPrivileges, privilege) {
    grantedPrivileges.add(privilege);
    switch (privilege) {
      case AccessLevel.ProxyView:
        grantedPrivileges.add(AccessLevel.View);
        break;
      case AccessLevel.Operate:
        grantedPrivileges.add(AccessLevel.View);
        break;
      case AccessLevel.Manage:
        grantedPrivileges.add(AccessLevel.Operate);
        grantedPrivileges.add(AccessLevel.View);
        break;
      case AccessLevel.Administer:
        grantedPrivileges.add(AccessLevel.Manage);
        grantedPrivileges.add(AccessLevel.Operate);
        grantedPrivileges.add(AccessLevel.ProxyView);
        grantedPrivileges.add(AccessLevel.View);
        break;
    }
  }
  /**
   * Check if the given ACL entry is allowed to be used for the given subject descriptor, endpoint, and cluster ID.
   */
  allowsPrivilege(session, endpoint, clusterId, privilege) {
    const grantedPrivileges = this.getGrantedPrivileges(session, endpoint, clusterId);
    if (grantedPrivileges.includes(privilege)) {
      return true;
    }
    logger.notice(
      `Failed access control check for ${endpoint.id}/0x${toHex(clusterId)} and fabricIndex ${session.associatedFabric.fabricIndex}, acl=`,
      this.#getAccessControlEntriesForFabric(session.associatedFabric),
      "with ISD=",
      this.#getIsdFromMessage(session),
      "granted privileges=",
      grantedPrivileges,
      "not contains",
      privilege
    );
    return false;
  }
  /**
   * Determines the granted privileges for the given session, endpoint, and cluster ID and returns them.
   */
  getGrantedPrivileges(session, endpoint, clusterId) {
    const endpointId = endpoint.id;
    const fabric = session.fabric;
    const subjectDesc = this.#getIsdFromMessage(session);
    const acl = fabric ? this.#getAccessControlEntriesForFabric(fabric) : [ImplicitDefaultPaseAclEntry];
    const grantedPrivileges = /* @__PURE__ */ new Set();
    if (subjectDesc.authMode === AccessControl.AccessControlEntryAuthMode.Pase && subjectDesc.isCommissioning) {
      this.#addGrantedPrivilege(grantedPrivileges, AccessLevel.Administer);
    }
    for (const aclEntry of acl) {
      if (grantedPrivileges.has(AccessLevel.Administer)) {
        break;
      }
      if (aclEntry.fabricIndex === FabricIndex.NO_FABRIC || aclEntry.fabricIndex !== subjectDesc.fabricIndex) {
        logger.debug(
          "Skipping ACL entry with mismatched fabric index",
          aclEntry.fabricIndex,
          subjectDesc.fabricIndex
        );
        continue;
      }
      if (aclEntry.authMode !== subjectDesc.authMode) {
        logger.debug("Skipping ACL entry with mismatched auth mode", aclEntry.authMode, subjectDesc.authMode);
        continue;
      }
      if (aclEntry.subjects === null || aclEntry.subjects.length === 0) {
        if (aclEntry.authMode !== AccessControl.AccessControlEntryAuthMode.Case && aclEntry.authMode !== AccessControl.AccessControlEntryAuthMode.Group) {
          throw new MatterFlowError("ACL error: only CASE and Group auth can have empty subjects");
        }
      } else {
        let matchedSubject = false;
        subjectLoop: for (const aclSubject of aclEntry.subjects) {
          for (const isdSubject of subjectDesc.subjects) {
            if (this.#subjectMatches(aclSubject, isdSubject)) {
              matchedSubject = true;
              break subjectLoop;
            }
          }
        }
        if (!matchedSubject) {
          continue;
        }
      }
      if (aclEntry.targets === null || aclEntry.targets.length === 0) {
      } else {
        let matchedTarget = false;
        for (const {
          cluster: targetClusterId,
          endpoint: targetEndpointId,
          deviceType: targetDeviceType
        } of aclEntry.targets) {
          if (targetClusterId === null && targetEndpointId === null && targetDeviceType === null) {
            throw new MatterFlowError("ACL error: target cannot be empty");
          }
          if (targetEndpointId !== null && targetDeviceType !== null) {
            throw new MatterFlowError("ACL error: target cannot specify both endpoint and device type");
          }
          if (targetClusterId !== null && targetClusterId !== clusterId) {
            continue;
          }
          if (targetEndpointId !== null && targetEndpointId !== endpointId) {
            continue;
          }
          if (targetDeviceType !== null && !endpoint.deviceTypes.includes(targetDeviceType)) {
            continue;
          }
          matchedTarget = true;
          break;
        }
        if (!matchedTarget) {
          continue;
        }
      }
      if (!this.#extensionEntryAccessCheck(acl, aclEntry, subjectDesc, endpoint, clusterId)) {
        continue;
      }
      this.#addGrantedPrivilege(grantedPrivileges, aclEntry.privilege);
    }
    if (subjectDesc.authMode === AccessControl.AccessControlEntryAuthMode.Group && grantedPrivileges.has(AccessLevel.Administer)) {
      throw new MatterFlowError("ACL error: should never grant Administer privilege to a Group");
    }
    return [...grantedPrivileges];
  }
  /**
   * Determines the Incoming Subject Descriptor (ISD) from the given session.
   */
  #getIsdFromMessage(session) {
    const fabric = session.fabric;
    const isd = {
      isCommissioning: false,
      authMode: 0 /* None */,
      subjects: new Array(),
      fabricIndex: FabricIndex.NO_FABRIC
    };
    if (session.isPase) {
      isd.authMode = AccessControl.AccessControlEntryAuthMode.Pase;
      isd.isCommissioning = true;
      isd.subjects.push(NodeId(0));
      if (fabric) {
        isd.fabricIndex = fabric.fabricIndex;
      }
    } else {
      isd.authMode = AccessControl.AccessControlEntryAuthMode.Case;
      isd.subjects.push(session.peerNodeId);
      session.caseAuthenticatedTags.forEach((cat) => isd.subjects.push(NodeId.fromCaseAuthenticatedTag(cat)));
      if (fabric === void 0) {
        throw new MatterFlowError("ACL error: fabric is undefined");
      }
      isd.fabricIndex = fabric.fabricIndex;
    }
    return isd;
  }
}
export {
  AccessControlManager,
  AccessDeniedError
};
//# sourceMappingURL=AccessControlManager.js.map
