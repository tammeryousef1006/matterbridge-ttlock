/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { ArraySchema, AttributeId, ClusterId, EndpointNumber, NodeId, Status, TlvAttributeData, TlvAttributeReport, TlvAttributeStatus, TlvSchema, TypeFromSchema } from "#types";
type DecodedAttributeReportEntry = {
    path: {
        nodeId?: NodeId;
        endpointId: EndpointNumber;
        clusterId: ClusterId;
        attributeId: AttributeId;
        attributeName: string;
    };
};
/** Represents a fully qualified and decoded attribute value from a received DataReport */
export type DecodedAttributeReportValue<T> = DecodedAttributeReportEntry & {
    version: number;
    value: T;
};
/** Represents a fully qualified and decoded attribute status from a received DataReport */
export type DecodedAttributeReportStatus = DecodedAttributeReportEntry & {
    status?: Status;
    clusterStatus?: number;
};
/** Represents a decoded attribute value from a received DataReport where data version could be optional. */
export type DecodedAttributeValue<T> = Omit<DecodedAttributeReportValue<T>, "version"> & {
    version?: number;
};
/**
 * Parses, normalizes (e.g. un-chunk arrays and resolve Tag compression if used) and decodes the attribute data from
 * a received DataReport.
 * TODO: Convert into a Generator function once we migrate Reading Data for controller to also be streaming
 */
export declare function normalizeAndDecodeReadAttributeReport(data: TypeFromSchema<typeof TlvAttributeReport>[]): {
    attributeData: DecodedAttributeReportValue<any>[];
    attributeStatus: DecodedAttributeReportStatus[];
};
export declare function expandPathsInAttributeData(data: TypeFromSchema<typeof TlvAttributeData>[], acceptWildcardPaths?: boolean): TypeFromSchema<typeof TlvAttributeData>[];
/**
 * Normalizes (e.g. prepare data for array un-chinking and resolve Tag compression if used) the attribute details from
 * a received DataReport.
 */
export declare function normalizeAttributeData(data: TypeFromSchema<typeof TlvAttributeData>[], acceptWildcardPaths?: boolean): TypeFromSchema<typeof TlvAttributeData>[][];
/**
 * Normalizes (e.g. un-chunk arrays and resolve Tag compression if used) and decodes the attribute data from a received
 * DataReport.
 */
export declare function normalizeAttributeStatus(data: TypeFromSchema<typeof TlvAttributeStatus>[]): DecodedAttributeReportStatus[];
/**
 * Normalizes (e.g. un-chunk arrays and resolve Tag compression if used) and decodes the attribute data from a received
 * DataReport.
 */
export declare function normalizeAndDecodeAttributeData(data: TypeFromSchema<typeof TlvAttributeData>[]): DecodedAttributeValue<any>[];
export declare function decodeListAttributeValueWithSchema<T>(schema: ArraySchema<T>, values: TypeFromSchema<typeof TlvAttributeData>[], currentValue?: T[]): T[] | undefined;
/** Decodes the data for one attribute via a schema including array un-chunking. */
export declare function decodeAttributeValueWithSchema<T>(schema: TlvSchema<T>, values: TypeFromSchema<typeof TlvAttributeData>[], defaultValue?: T): T | undefined;
/** Decodes the data for one unknown attribute via the AnySchema including array un-chunking. */
export declare function decodeUnknownAttributeValue(values: TypeFromSchema<typeof TlvAttributeData>[]): any;
/** Structure the data of a received DataReport into an endpointId/clusterId/attributeName object structure. */
export declare function structureReadAttributeDataToClusterObject(data: DecodedAttributeReportValue<any>[]): {
    [key: number]: {
        [key: number]: {
            [key: string]: any;
        };
    };
};
export {};
//# sourceMappingURL=AttributeDataDecoder.d.ts.map