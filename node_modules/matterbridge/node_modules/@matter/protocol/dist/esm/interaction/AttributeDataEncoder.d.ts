import { AttributeId, ClusterId, EndpointNumber, NodeId, TlvAttributeReport, TlvAttributeReportData, TlvDataReport, TlvEncodingOptions, TlvEventData, TlvEventReport, TlvSchema, TlvStream, TypeFromSchema } from "#types";
/** Type for TlvAttributeReportData where the real data are represented with the schema and the JS value. */
type AttributeDataPayload = Omit<TypeFromSchema<typeof TlvAttributeReportData>, "data"> & {
    schema: TlvSchema<any>;
    payload: any;
};
/** Type for TlvAttributeReport where the real data are represented with the schema and the JS value. */
export type AttributeReportPayload = Omit<TypeFromSchema<typeof TlvAttributeReport>, "attributeData"> & {
    attributeData?: AttributeDataPayload;
    hasFabricSensitiveData: boolean;
};
/** Type for TlvEventData where the real data are represented with the schema and the JS value. */
export type EventDataPayload = Omit<TypeFromSchema<typeof TlvEventData>, "data"> & {
    schema: TlvSchema<any>;
    payload: any;
};
/** Type for TlvEventReport where the real data are represented with the schema and the JS value. */
export type EventReportPayload = Omit<TypeFromSchema<typeof TlvEventReport>, "eventData"> & {
    eventData?: EventDataPayload;
    hasFabricSensitiveData: boolean;
};
export type EventOrAttributeDataPayload = AttributeReportPayload | EventReportPayload;
/** A base type for a DataReport which removes the fields of the actual attribute or event content */
export type BaseDataReport = Omit<TypeFromSchema<typeof TlvDataReport>, "attributeReports" | "eventReports">;
/** Type for TlvDataReport where the real data are represented with the schema and the JS value. */
export type DataReportPayload = BaseDataReport & {
    attributeReportsPayload?: AttributeReportPayload[];
    eventReportsPayload?: EventReportPayload[];
};
/**
 * Type for the DataReport Generator function to send all data
 */
export type DataReportPayloadIterator = IterableIterator<EventOrAttributeDataPayload>;
export declare function encodeAttributePayloadData(attributePayload: AttributeReportPayload, options?: TlvEncodingOptions): TlvStream;
/** Encodes an AttributeReportPayload into a TlvStream (used for TlvAny type). */
export declare function encodeAttributePayload(attributePayload: AttributeReportPayload, options?: TlvEncodingOptions): TlvStream;
/** Encodes an EventReportPayload into a TlvStream (used for TlvAny type). */
export declare function encodeEventPayload(eventPayload: EventReportPayload, options?: TlvEncodingOptions): TlvStream;
/** Return if an AttributeReportPayload can be chunked or not. */
export declare function canAttributePayloadBeChunked(attributePayload: AttributeReportPayload): boolean;
/** Chunk an AttributeReportPayload into multiple AttributeReportPayloads. */
export declare function chunkAttributePayload(attributePayload: AttributeReportPayload): AttributeReportPayload[];
/**
 * Sort function to sort AttributeReportPayloads by nodeId/EndpointId/clusterId/attributeId to generate an ideal
 * ground for tag compression.
 */
export declare function sortAttributeDataByPath(data1: AttributeReportPayload, data2: AttributeReportPayload): 0 | 1 | -1;
/** Sort and use Tag compression to compress a list of AttributeReportPayloads. */
export declare function compressAttributeDataReportTags(data: AttributeReportPayload[]): {
    hasFabricSensitiveData: boolean;
    attributeData: AttributeDataPayload | undefined;
    attributeStatus: import("#types").TypeFromFields<{
        path: import("#types").FieldType<import("#types").TypeFromFields<{
            enableTagCompression: import("#types").OptionalFieldType<boolean>;
            nodeId: import("#types").OptionalFieldType<import("#types").NodeId>;
            endpointId: import("#types").OptionalFieldType<import("#types").EndpointNumber>;
            clusterId: import("#types").OptionalFieldType<import("#types").ClusterId>;
            attributeId: import("#types").OptionalFieldType<import("#types").AttributeId>;
            listIndex: import("#types").OptionalFieldType<number | null>;
            wildcardPathFlags: import("#types").OptionalFieldType<import("#types").TypeFromPartialBitSchema<{
                skipRootNode: import("#types").BitFlag;
                skipGlobalAttributes: import("#types").BitFlag;
                skipAttributeList: import("#types").BitFlag;
                reserved1: import("#types").BitFlag;
                skipCommandLists: import("#types").BitFlag;
                skipCustomElements: import("#types").BitFlag;
                skipFixedAttributes: import("#types").BitFlag;
                skipChangesOmittedAttributes: import("#types").BitFlag;
                skipDiagnosticsClusters: import("#types").BitFlag;
            }>>;
        }>>;
        status: import("#types").FieldType<import("#types").TypeFromFields<{
            status: import("#types").OptionalFieldType<import("#types").Status>;
            clusterStatus: import("#types").OptionalFieldType<import("#types").Status>;
        }>>;
    }> | undefined;
}[];
export {};
//# sourceMappingURL=AttributeDataEncoder.d.ts.map