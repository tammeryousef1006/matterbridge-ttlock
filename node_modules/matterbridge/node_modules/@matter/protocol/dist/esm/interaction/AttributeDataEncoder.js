/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Diagnostic, MatterFlowError } from "#general";
import {
  ArraySchema,
  TlvAttributeReport,
  TlvEventReport
} from "#types";
function encodeAttributePayloadData(attributePayload, options) {
  const { attributeData } = attributePayload;
  if (attributeData === void 0) {
    throw new MatterFlowError(
      `Cannot encode Attribute Payload data with just a attributeStatus: ${Diagnostic.json(attributePayload)}`
    );
  }
  const { schema, payload } = attributeData;
  return schema.encodeTlv(payload, options);
}
function encodeAttributePayload(attributePayload, options) {
  const { attributeData, attributeStatus } = attributePayload;
  if (attributeData === void 0) {
    return TlvAttributeReport.encodeTlv({ attributeStatus });
  }
  const { path, schema, payload, dataVersion } = attributeData;
  return TlvAttributeReport.encodeTlv({
    attributeData: { path, data: schema.encodeTlv(payload, options), dataVersion }
  });
}
function encodeEventPayload(eventPayload, options) {
  const { eventData, eventStatus } = eventPayload;
  if (eventData === void 0) {
    return TlvEventReport.encodeTlv({ eventStatus });
  }
  const {
    path,
    schema,
    payload,
    eventNumber,
    deltaEpochTimestamp,
    epochTimestamp,
    deltaSystemTimestamp,
    systemTimestamp,
    priority
  } = eventData;
  return TlvEventReport.encodeTlv({
    eventData: {
      path,
      data: schema.encodeTlv(payload, options),
      priority,
      systemTimestamp,
      deltaSystemTimestamp,
      deltaEpochTimestamp,
      epochTimestamp,
      eventNumber
    }
  });
}
function canAttributePayloadBeChunked(attributePayload) {
  const { attributeData } = attributePayload;
  if (attributeData === void 0) {
    return false;
  }
  const {
    schema,
    payload,
    path: { listIndex }
  } = attributeData;
  return schema instanceof ArraySchema && Array.isArray(payload) && payload.length > 0 && listIndex === void 0;
}
function chunkAttributePayload(attributePayload) {
  const { hasFabricSensitiveData, attributeData } = attributePayload;
  if (attributeData === void 0) {
    throw new MatterFlowError(
      `Cannot chunk an AttributePayload with just a attributeStatus: ${Diagnostic.json(attributePayload)}`
    );
  }
  const { schema, path, dataVersion, payload } = attributeData;
  if (!(schema instanceof ArraySchema) || !Array.isArray(payload)) {
    throw new MatterFlowError(
      `Cannot chunk an AttributePayload with attributeData that is not an array: ${Diagnostic.json(
        attributePayload
      )}`
    );
  }
  const chunks = new Array();
  chunks.push({
    hasFabricSensitiveData,
    attributeData: { schema, path: { ...path, listIndex: void 0 }, payload: [], dataVersion }
  });
  payload.forEach((element) => {
    chunks.push({
      hasFabricSensitiveData,
      attributeData: {
        schema: schema.elementSchema,
        path: { ...path, listIndex: null },
        payload: element,
        dataVersion
      }
    });
  });
  return chunks;
}
function sortAttributeDataByPath(data1, data2) {
  const { path: path1 } = data1.attributeData ?? data1.attributeStatus ?? {};
  const { path: path2 } = data2.attributeData ?? data2.attributeStatus ?? {};
  if (path1?.nodeId !== void 0 && path2?.nodeId !== void 0 && path1.nodeId !== path2.nodeId) {
    return path1.nodeId < path2.nodeId ? -1 : 1;
  }
  if (path1?.endpointId !== void 0 && path2?.endpointId !== void 0 && path1.endpointId !== path2.endpointId) {
    return path1.endpointId < path2.endpointId ? -1 : 1;
  }
  if (path1?.clusterId !== void 0 && path2?.clusterId !== void 0 && path1.clusterId !== path2.clusterId) {
    return path1.clusterId < path2.clusterId ? -1 : 1;
  }
  if (path1?.attributeId !== void 0 && path2?.attributeId !== void 0 && path1.attributeId !== path2.attributeId) {
    return path1.attributeId < path2.attributeId ? -1 : 1;
  }
  return 0;
}
function compressAttributeDataReportTags(data) {
  let lastFullPath;
  return data.sort(sortAttributeDataByPath).map(({ hasFabricSensitiveData, attributeData, attributeStatus }) => {
    if (attributeData !== void 0) {
      const { path, dataVersion } = attributeData;
      const compressedPath = compressPath(path, dataVersion, lastFullPath);
      const { enableTagCompression } = compressedPath.path;
      attributeData = {
        ...attributeData,
        path: compressedPath.path,
        dataVersion: enableTagCompression ? void 0 : dataVersion
      };
      lastFullPath = compressedPath.lastFullPath;
    }
    if (attributeStatus !== void 0) {
      const { path } = attributeStatus;
      const compressedPath = compressPath(path, void 0, lastFullPath);
      attributeStatus = { ...attributeStatus, path: compressedPath.path };
      lastFullPath = compressedPath.lastFullPath;
    }
    return { hasFabricSensitiveData, attributeData, attributeStatus };
  });
}
function compressPath(path, dataVersion, lastFullPath) {
  const { nodeId, endpointId, clusterId, attributeId } = path;
  if (endpointId === void 0 || clusterId === void 0 || attributeId === void 0) {
    return { path, lastFullPath };
  }
  const newFullPath = {
    path: { ...path, enableTagCompression: void 0 },
    lastFullPath: { nodeId, endpointId, clusterId, attributeId, dataVersion }
  };
  if (lastFullPath === void 0) {
    return newFullPath;
  }
  if (dataVersion !== void 0 && dataVersion !== lastFullPath.dataVersion) {
    return newFullPath;
  }
  let compressedElements = 0;
  const compressedPath = { ...path, enableTagCompression: true };
  if (endpointId === lastFullPath.endpointId) {
    delete compressedPath.endpointId;
    compressedElements++;
  }
  if (nodeId === lastFullPath.nodeId && nodeId !== void 0) {
    delete compressedPath.nodeId;
    compressedElements++;
  }
  if (compressedElements === 0) {
    return newFullPath;
  }
  return { path: compressedPath, lastFullPath };
}
export {
  canAttributePayloadBeChunked,
  chunkAttributePayload,
  compressAttributeDataReportTags,
  encodeAttributePayload,
  encodeAttributePayloadData,
  encodeEventPayload,
  sortAttributeDataByPath
};
//# sourceMappingURL=AttributeDataEncoder.js.map
