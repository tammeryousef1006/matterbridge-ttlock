/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { ImplementationError, InternalError, Observable } from "#general";
import {
  AcceptedCommandList,
  AttributeList,
  AttributeModel,
  ClusterModel,
  GeneratedCommandList,
  MatterModel
} from "#model";
import {
  AttributeId,
  ClusterId,
  CommandId,
  EndpointNumber,
  EventId,
  Mei,
  StatusCode,
  StatusResponseError
} from "#types";
import {
  attributePathToId,
  commandPathToId,
  eventPathToId,
  genericElementPathToId
} from "./InteractionServer.js";
const GLOBAL_COMMANDLIST_IDS = [GeneratedCommandList.id, AcceptedCommandList.id];
const GLOBAL_ATTRIBUTES_LIST = [...GLOBAL_COMMANDLIST_IDS, AttributeList.id];
const DIAGNOSTICS_CLUSTER_IDS = MatterModel.standard.clusters.filter((cluster) => cluster.diagnostics && cluster.id !== void 0).map((cluster) => cluster.id);
class InteractionEndpointStructure {
  endpoints = /* @__PURE__ */ new Map();
  attributes = /* @__PURE__ */ new Map();
  attributePaths = new Array();
  events = /* @__PURE__ */ new Map();
  eventPaths = new Array();
  commands = /* @__PURE__ */ new Map();
  commandPaths = new Array();
  change = Observable();
  // TODO adjust to AsyncObservable when we remove legacy API
  clear() {
    this.endpoints.clear();
    this.attributes.clear();
    this.attributePaths.length = 0;
    this.events.clear();
    this.eventPaths.length = 0;
    this.commands.clear();
    this.commandPaths.length = 0;
  }
  close() {
    for (const endpoint of this.endpoints.values()) {
      endpoint.close();
    }
  }
  initializeFromEndpoint(endpoint) {
    this.clear();
    this.verifyAndInitializeStructureElementsFromEndpoint(endpoint);
    this.initializeStructureFromEndpoints(endpoint);
    this.change.emit();
  }
  initializeStructureFromEndpoints(endpoint) {
    const endpoints = endpoint.getChildEndpoints();
    for (let endpointIndex = 0; endpointIndex < endpoints.length; endpointIndex++) {
      this.verifyAndInitializeStructureElementsFromEndpoint(endpoints[endpointIndex]);
      this.initializeStructureFromEndpoints(endpoints[endpointIndex]);
    }
  }
  verifyAndInitializeStructureElementsFromEndpoint(endpoint) {
    if (endpoint.number === void 0) {
      throw new InternalError(`Endpoint ID is undefined. It needs to be initialized first!`);
    }
    endpoint.verifyRequiredClusters();
    const endpointId = endpoint.number;
    if (this.endpoints.has(endpoint.number)) {
      throw new ImplementationError(`Endpoint ID ${endpoint.number} exists twice`);
    }
    for (const cluster of endpoint.getAllClusterServers()) {
      const {
        id: clusterId,
        attributes: clusterAttributes,
        events: clusterEvents,
        commands: clusterCommands
      } = cluster;
      for (const name in clusterAttributes) {
        const attribute = clusterAttributes[name];
        const path = { endpointId, clusterId, attributeId: attribute.id };
        this.attributes.set(attributePathToId(path), attribute);
        this.attributePaths.push(path);
      }
      for (const name in clusterEvents) {
        const event = clusterEvents[name];
        const path = { endpointId, clusterId, eventId: event.id };
        this.events.set(eventPathToId(path), event);
        this.eventPaths.push(path);
      }
      for (const name in clusterCommands) {
        const command = clusterCommands[name];
        const path = { endpointId, clusterId, commandId: command.invokeId };
        this.commands.set(commandPathToId(path), command);
        this.commandPaths.push(path);
      }
    }
    this.endpoints.set(endpointId, endpoint);
  }
  toHex(value) {
    return value === void 0 ? "*" : `0x${value.toString(16)}`;
  }
  resolveGenericElementName(nodeId, endpointId, clusterId, elementId, elementMap) {
    const nodeIdPrefix = nodeId === void 0 ? "" : `${this.toHex(nodeId)}/`;
    if (endpointId === void 0) {
      return `${nodeIdPrefix}*/${this.toHex(clusterId)}/${this.toHex(elementId)}`;
    }
    const endpoint = this.endpoints.get(endpointId);
    if (endpoint === void 0) {
      return `${nodeIdPrefix}unknown(${this.toHex(endpointId)})/${this.toHex(clusterId)}/${this.toHex(
        elementId
      )}`;
    }
    const endpointName = `${endpoint.name}(${this.toHex(endpointId)})`;
    if (clusterId === void 0) {
      return `${nodeIdPrefix}${endpointName}/*/${this.toHex(elementId)}`;
    }
    const cluster = endpoint.getClusterServerById(clusterId);
    if (cluster === void 0) {
      return `${nodeIdPrefix}${endpointName}/unknown(${this.toHex(clusterId)})/${this.toHex(elementId)}`;
    }
    const clusterName = `${cluster.name}(${this.toHex(clusterId)})`;
    if (elementId === void 0) {
      return `${nodeIdPrefix}${endpointName}/${clusterName}/*`;
    }
    const element = elementMap.get(genericElementPathToId(endpointId, clusterId, elementId));
    const elementName = `${element?.name ?? "unknown"}(${this.toHex(elementId)})`;
    return `${nodeIdPrefix}${endpointName}/${clusterName}/${elementName}`;
  }
  resolveAttributeName({ nodeId, endpointId, clusterId, attributeId }) {
    return this.resolveGenericElementName(nodeId, endpointId, clusterId, attributeId, this.attributes);
  }
  resolveEventName({ nodeId, endpointId, clusterId, eventId, isUrgent }) {
    return `${isUrgent ? "!" : ""}${this.resolveGenericElementName(
      nodeId,
      endpointId,
      clusterId,
      eventId,
      this.events
    )}`;
  }
  resolveCommandName({ endpointId, clusterId, commandId }) {
    return this.resolveGenericElementName(void 0, endpointId, clusterId, commandId, this.commands);
  }
  getEndpoint(endpointId) {
    return this.endpoints.get(endpointId);
  }
  hasEndpoint(endpointId) {
    return this.endpoints.has(endpointId);
  }
  getClusterServer(endpointId, clusterId) {
    return this.endpoints.get(endpointId)?.getClusterServerById(clusterId);
  }
  hasClusterServer(endpointId, clusterId) {
    return !!this.getClusterServer(endpointId, clusterId);
  }
  getAttribute(endpointId, clusterId, attributeId) {
    return this.attributes.get(attributePathToId({ endpointId, clusterId, attributeId }));
  }
  hasAttribute(endpointId, clusterId, attributeId) {
    return !!this.getAttribute(endpointId, clusterId, attributeId);
  }
  validateConcreteAttributePath(endpointId, clusterId, attributeId) {
    if (!this.hasEndpoint(endpointId)) {
      throw new StatusResponseError(`Endpoint ${endpointId} does not exist.`, StatusCode.UnsupportedEndpoint);
    }
    if (!this.hasClusterServer(endpointId, clusterId)) {
      throw new StatusResponseError(`Cluster ${clusterId} does not exist.`, StatusCode.UnsupportedCluster);
    }
    if (this.hasAttribute(endpointId, clusterId, attributeId)) return true;
    throw new StatusResponseError(`Attribute ${attributeId} does not exist`, StatusCode.UnsupportedAttribute);
  }
  getEvent(endpointId, clusterId, eventId) {
    return this.events.get(eventPathToId({ endpointId, clusterId, eventId }));
  }
  hasEvent(endpointId, clusterId, eventId) {
    return !!this.getEvent(endpointId, clusterId, eventId);
  }
  validateConcreteEventPath(endpointId, clusterId, eventId) {
    if (!this.hasEndpoint(endpointId)) {
      throw new StatusResponseError(`Endpoint ${endpointId} does not exist.`, StatusCode.UnsupportedEndpoint);
    }
    if (!this.hasClusterServer(endpointId, clusterId)) {
      throw new StatusResponseError(`Cluster ${clusterId} does not exist.`, StatusCode.UnsupportedCluster);
    }
    if (this.hasEvent(endpointId, clusterId, eventId)) return true;
    throw new StatusResponseError(`Event ${eventId} does not exist`, StatusCode.UnsupportedEvent);
  }
  getCommand(endpointId, clusterId, commandId) {
    return this.commands.get(commandPathToId({ endpointId, clusterId, commandId }));
  }
  hasCommand(endpointId, clusterId, commandId) {
    return !!this.getCommand(endpointId, clusterId, commandId);
  }
  validateConcreteCommandPath(endpointId, clusterId, commandId) {
    if (!this.hasEndpoint(endpointId)) {
      throw new StatusResponseError(`Endpoint ${endpointId} does not exist.`, StatusCode.UnsupportedEndpoint);
    }
    if (!this.hasClusterServer(endpointId, clusterId)) {
      throw new StatusResponseError(`Cluster ${clusterId} does not exist.`, StatusCode.UnsupportedCluster);
    }
    if (this.hasCommand(endpointId, clusterId, commandId)) return true;
    throw new StatusResponseError(`Command ${commandId} does not exist`, StatusCode.UnsupportedCommand);
  }
  /** Checks if the given attribute matches the wildcard path flags */
  attributePathMatchesWildcardPathFlags({ endpointId, clusterId, attributeId }, wildcardPathFlags) {
    if (wildcardPathFlags === void 0) return false;
    if (wildcardPathFlags.skipRootNode && endpointId === 0) {
      return true;
    }
    if (attributeId >= 65528 && attributeId <= 65531) {
      if (wildcardPathFlags.skipGlobalAttributes && GLOBAL_ATTRIBUTES_LIST.includes(attributeId)) {
        return true;
      }
      if (wildcardPathFlags.skipAttributeList && attributeId === AttributeList.id) {
        return true;
      }
      if (wildcardPathFlags.skipCommandLists && GLOBAL_COMMANDLIST_IDS.includes(attributeId)) {
        return true;
      }
    }
    if (wildcardPathFlags.skipCustomElements && (Mei.hasCustomMeiPrefix(clusterId) || Mei.hasCustomMeiPrefix(attributeId))) {
      return true;
    }
    const cluster = MatterModel.standard.get(ClusterModel, clusterId);
    if (cluster !== void 0) {
      const attribute = cluster.get(AttributeModel, attributeId);
      if (attribute !== void 0) {
        if (wildcardPathFlags.skipFixedAttributes && attribute.fixed) {
          return true;
        }
        if (wildcardPathFlags.skipChangesOmittedAttributes && attribute.changesOmitted) {
          return true;
        }
      }
      if (wildcardPathFlags.skipDiagnosticsClusters && DIAGNOSTICS_CLUSTER_IDS.includes(clusterId)) {
        return true;
      }
    }
    return false;
  }
  getAttributes(filters, onlyWritable = false) {
    const result = new Array();
    filters.forEach(({ endpointId, clusterId, attributeId, wildcardPathFlags }) => {
      this.validateAnyPathDataTypes({ endpointId, clusterId, attributeId });
      if (endpointId !== void 0 && clusterId !== void 0 && attributeId !== void 0) {
        const path = { endpointId, clusterId, attributeId };
        const attribute = this.attributes.get(attributePathToId(path));
        if (attribute === void 0) return;
        if (onlyWritable && !attribute.isWritable) return;
        if (this.attributePathMatchesWildcardPathFlags(path)) return;
        result.push({ path, attribute });
      } else {
        this.attributePaths.filter(
          (path) => (endpointId === void 0 || endpointId === path.endpointId) && (clusterId === void 0 || clusterId === path.clusterId) && (attributeId === void 0 || attributeId === path.attributeId)
        ).forEach((path) => {
          const attribute = this.attributes.get(attributePathToId(path));
          if (attribute === void 0) return;
          if (onlyWritable && !attribute.isWritable) return;
          if (this.attributePathMatchesWildcardPathFlags(path, wildcardPathFlags)) return;
          result.push({ path, attribute });
        });
      }
    });
    return result;
  }
  getEvents(filters) {
    const result = new Array();
    filters.forEach(({ endpointId, clusterId, eventId, isUrgent }) => {
      this.validateAnyPathDataTypes({ endpointId, clusterId, eventId });
      if (endpointId !== void 0 && clusterId !== void 0 && eventId !== void 0) {
        const path = { endpointId, clusterId, eventId, isUrgent };
        const event = this.events.get(eventPathToId(path));
        if (event === void 0) return;
        result.push({ path, event });
      } else {
        this.eventPaths.filter(
          (path) => (endpointId === void 0 || endpointId === path.endpointId) && (clusterId === void 0 || clusterId === path.clusterId) && (eventId === void 0 || eventId === path.eventId)
        ).forEach(({ endpointId: endpointId2, clusterId: clusterId2, eventId: eventId2 }) => {
          const path = { endpointId: endpointId2, clusterId: clusterId2, eventId: eventId2, isUrgent };
          const event = this.events.get(eventPathToId(path));
          if (event === void 0) return;
          result.push({ path, event });
        });
      }
    });
    return result;
  }
  getCommands(filters) {
    const result = new Array();
    filters.forEach(({ endpointId, clusterId, commandId }) => {
      this.validateAnyPathDataTypes({ endpointId, clusterId, commandId });
      if (endpointId !== void 0 && clusterId !== void 0 && commandId !== void 0) {
        const path = { endpointId, clusterId, commandId };
        const command = this.commands.get(commandPathToId(path));
        if (command === void 0) return;
        result.push({ path, command });
      } else {
        this.commandPaths.filter(
          (path) => (endpointId === void 0 || endpointId === path.endpointId) && (clusterId === void 0 || clusterId === path.clusterId) && (commandId === void 0 || commandId === path.commandId)
        ).forEach((path) => {
          const command = this.commands.get(commandPathToId(path));
          if (command === void 0) return;
          result.push({ path, command });
        });
      }
    });
    return result;
  }
  // ValidationError will return ConstraintError ... we need to see if this is correct always
  validateAnyPathDataTypes(data) {
    const { endpointId, clusterId, attributeId, eventId, commandId } = data;
    if (endpointId !== void 0) {
      EndpointNumber(endpointId);
    }
    if (clusterId !== void 0) {
      ClusterId(clusterId);
    }
    if (attributeId !== void 0) {
      AttributeId(attributeId);
    }
    if (eventId !== void 0) {
      EventId(eventId);
    }
    if (commandId !== void 0) {
      CommandId(commandId);
    }
  }
}
export {
  InteractionEndpointStructure
};
//# sourceMappingURL=InteractionEndpointStructure.js.map
