/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import {
  Diagnostic,
  InternalError,
  Logger,
  MatterFlowError,
  NoResponseTimeoutError,
  UnexpectedDataError
} from "#general";
import { Specification } from "#model";
import {
  ReceivedStatusResponseError,
  Status,
  StatusCode,
  StatusResponseError,
  TlvAny,
  TlvDataReport,
  TlvDataReportForSend,
  TlvDataVersionFilter,
  TlvInvokeRequest,
  TlvInvokeResponse,
  TlvReadRequest,
  TlvStatusResponse,
  TlvSubscribeRequest,
  TlvSubscribeResponse,
  TlvTimedRequest,
  TlvWriteRequest,
  TlvWriteResponse
} from "#types";
import { SessionType } from "../codec/MessageCodec.js";
import { ChannelNotConnectedError } from "../protocol/ExchangeManager.js";
import {
  RetransmissionLimitReachedError,
  UnexpectedMessageError
} from "../protocol/MessageExchange.js";
import {
  canAttributePayloadBeChunked,
  chunkAttributePayload,
  encodeAttributePayload,
  encodeAttributePayloadData,
  encodeEventPayload
} from "./AttributeDataEncoder.js";
var MessageType = /* @__PURE__ */ ((MessageType2) => {
  MessageType2[MessageType2["StatusResponse"] = 1] = "StatusResponse";
  MessageType2[MessageType2["ReadRequest"] = 2] = "ReadRequest";
  MessageType2[MessageType2["SubscribeRequest"] = 3] = "SubscribeRequest";
  MessageType2[MessageType2["SubscribeResponse"] = 4] = "SubscribeResponse";
  MessageType2[MessageType2["ReportData"] = 5] = "ReportData";
  MessageType2[MessageType2["WriteRequest"] = 6] = "WriteRequest";
  MessageType2[MessageType2["WriteResponse"] = 7] = "WriteResponse";
  MessageType2[MessageType2["InvokeRequest"] = 8] = "InvokeRequest";
  MessageType2[MessageType2["InvokeResponse"] = 9] = "InvokeResponse";
  MessageType2[MessageType2["TimedRequest"] = 10] = "TimedRequest";
  return MessageType2;
})(MessageType || {});
const logger = Logger.get("InteractionMessenger");
const DATA_REPORT_MAX_QUEUED_ATTRIBUTE_MESSAGES = 20;
const DATA_REPORT_MIN_AVAILABLE_BYTES_BEFORE_SENDING = 40;
class InteractionMessenger {
  constructor(exchange) {
    this.exchange = exchange;
  }
  calculateMaximumPeerResponseTime(expectedProcessingTimeMs) {
    return this.exchange.calculateMaximumPeerResponseTime(expectedProcessingTimeMs);
  }
  send(messageType, payload, options) {
    return this.exchange.send(messageType, payload, options);
  }
  sendStatus(status, options) {
    return this.send(
      1 /* StatusResponse */,
      TlvStatusResponse.encode({ status, interactionModelRevision: Specification.INTERACTION_MODEL_REVISION }),
      {
        ...options,
        logContext: {
          for: options?.logContext?.for ? `I/Status-${options?.logContext?.for}` : void 0,
          status: `${StatusCode[status] ?? "unknown"}(${Diagnostic.hex(status)})`,
          ...options?.logContext
        }
      }
    );
  }
  async waitForSuccess(expectedMessageInfo, options) {
    await this.nextMessage(1 /* StatusResponse */, options, `Success-${expectedMessageInfo}`);
  }
  async nextMessage(expectedMessageType, options, expectedMessageInfo) {
    return this.#nextMessage(expectedMessageType, options, expectedMessageInfo);
  }
  async anyNextMessage(expectedMessageInfo, options) {
    return this.#nextMessage(void 0, options, expectedMessageInfo);
  }
  async #nextMessage(expectedMessageType, options, expectedMessageInfo) {
    const { expectedProcessingTimeMs, timeoutMs } = options ?? {};
    const message = await this.exchange.nextMessage({ expectedProcessingTimeMs, timeoutMs });
    const messageType = message.payloadHeader.messageType;
    if (expectedMessageType !== void 0 && expectedMessageInfo === void 0) {
      expectedMessageInfo = MessageType[expectedMessageType];
    }
    this.throwIfErrorStatusMessage(message, expectedMessageInfo);
    if (expectedMessageType !== void 0 && messageType !== expectedMessageType) {
      throw new UnexpectedDataError(
        `Received unexpected message for ${expectedMessageInfo} type: ${messageType}, expected: ${expectedMessageType}`
      );
    }
    return message;
  }
  async close() {
    await this.exchange.close();
  }
  throwIfErrorStatusMessage(message, logHint) {
    const {
      payloadHeader: { messageType },
      payload
    } = message;
    if (messageType !== 1 /* StatusResponse */) return;
    const { status } = TlvStatusResponse.decode(payload);
    if (status !== StatusCode.Success)
      throw new ReceivedStatusResponseError(
        `Received error status: ${status}${logHint ? ` (${logHint})` : ""}`,
        status
      );
  }
  getExchangeChannelName() {
    return this.exchange.channel.name;
  }
}
class InteractionServerMessenger extends InteractionMessenger {
  async handleRequest(recipient) {
    let continueExchange = true;
    let isGroupSession = false;
    try {
      while (continueExchange) {
        const message = await this.exchange.nextMessage();
        isGroupSession = message.packetHeader.sessionType === SessionType.Group;
        continueExchange = false;
        switch (message.payloadHeader.messageType) {
          case 2 /* ReadRequest */: {
            if (isGroupSession) {
              throw new StatusResponseError(
                `ReadRequest is not supported in group sessions`,
                Status.InvalidAction
              );
            }
            const readRequest = TlvReadRequest.decode(message.payload);
            const { dataReport, payload } = await recipient.handleReadRequest(
              this.exchange,
              readRequest,
              message
            );
            await this.sendDataReport(dataReport, readRequest.isFabricFiltered, payload);
            break;
          }
          case 6 /* WriteRequest */: {
            const writeRequest = TlvWriteRequest.decode(message.payload);
            const { suppressResponse } = writeRequest;
            const writeResponse = await recipient.handleWriteRequest(this.exchange, writeRequest, message);
            if (!suppressResponse && !isGroupSession) {
              await this.send(7 /* WriteResponse */, TlvWriteResponse.encode(writeResponse));
            }
            break;
          }
          case 3 /* SubscribeRequest */: {
            const subscribeRequest = TlvSubscribeRequest.decode(message.payload);
            await recipient.handleSubscribeRequest(this.exchange, subscribeRequest, this, message);
            break;
          }
          case 8 /* InvokeRequest */: {
            const invokeRequest = TlvInvokeRequest.decode(message.payload);
            await recipient.handleInvokeRequest(this.exchange, invokeRequest, this, message);
            break;
          }
          case 10 /* TimedRequest */: {
            const timedRequest = TlvTimedRequest.decode(message.payload);
            recipient.handleTimedRequest(this.exchange, timedRequest, message);
            await this.sendStatus(StatusCode.Success, {
              logContext: { for: "TimedRequest" }
            });
            continueExchange = true;
            break;
          }
          default:
            throw new StatusResponseError(
              `Unsupported message type ${message.payloadHeader.messageType}`,
              Status.InvalidAction
            );
        }
      }
    } catch (error) {
      let errorStatusCode = StatusCode.Failure;
      if (error instanceof StatusResponseError) {
        logger.info(`Sending status response ${error.code} for interaction error: ${error.message}`);
        errorStatusCode = error.code;
      } else if (error instanceof NoResponseTimeoutError) {
        logger.info(error);
      } else {
        logger.warn(error);
      }
      if (!isGroupSession && !(error instanceof NoResponseTimeoutError)) {
        await this.sendStatus(errorStatusCode);
      }
    } finally {
      await this.exchange.close();
    }
  }
  /**
   * Handle a DataReport with a Payload Iterator for a DataReport to send, split them into multiple DataReport
   * messages and send them out based on the size.
   */
  async sendDataReport(baseDataReport, forFabricFilteredRead, payload, waitForAck = true) {
    const { subscriptionId, suppressResponse, interactionModelRevision } = baseDataReport;
    const dataReport = {
      subscriptionId,
      suppressResponse,
      interactionModelRevision,
      attributeReports: void 0,
      eventReports: void 0
    };
    if (payload !== void 0) {
      dataReport.moreChunkedMessages = true;
      const emptyDataReportBytes = TlvDataReportForSend.encode(dataReport);
      let allDataReceived = false;
      let processQueueFirst = true;
      const sendAndResetReport = async () => {
        await this.sendDataReportMessage(dataReport, waitForAck);
        delete dataReport.attributeReports;
        delete dataReport.eventReports;
        messageSize = emptyDataReportBytes.length;
        processQueueFirst = true;
      };
      let messageSize = emptyDataReportBytes.length;
      const attributeReportsToSend = new Array();
      const eventReportsToSend = new Array();
      while (true) {
        if (!allDataReceived && (attributeReportsToSend.length === 0 && eventReportsToSend.length === 0 || attributeReportsToSend.length <= DATA_REPORT_MAX_QUEUED_ATTRIBUTE_MESSAGES && !processQueueFirst && !attributeReportsToSend[0].needSendNext)) {
          const { done, value } = payload.next();
          if (done) {
            allDataReceived = true;
            if (attributeReportsToSend.length === 0 && eventReportsToSend.length === 0) {
              delete dataReport.moreChunkedMessages;
              break;
            } else {
              for (const attributeReport of attributeReportsToSend) {
                attributeReport.needSendNext = true;
              }
              continue;
            }
          }
          if (value === void 0) {
            continue;
          }
          if ("attributeData" in value || "attributeStatus" in value) {
            const allowMissingFieldsForNonFabricFilteredRead = !forFabricFilteredRead && value.hasFabricSensitiveData;
            const encoded = encodeAttributePayload(value, {
              allowMissingFieldsForNonFabricFilteredRead
            });
            const encodedSize = TlvAny.getEncodedByteLength(encoded);
            if (attributeReportsToSend.length === 0) {
              attributeReportsToSend.push({
                attributeReport: value,
                encoded,
                encodedSize
              });
            } else {
              const firstQueuedAttributeData = attributeReportsToSend[0].attributeReport.attributeData;
              if (firstQueuedAttributeData !== void 0 && value.attributeData !== void 0 && firstQueuedAttributeData.path.nodeId === value.attributeData.path.nodeId && firstQueuedAttributeData.path.endpointId === value.attributeData.path.endpointId && firstQueuedAttributeData.path.clusterId === value.attributeData.path.clusterId) {
                attributeReportsToSend.unshift({
                  attributeReport: value,
                  encoded,
                  encodedSize
                });
              } else {
                for (const attributeReport of attributeReportsToSend) {
                  attributeReport.needSendNext = true;
                }
                attributeReportsToSend.push({
                  attributeReport: value,
                  encoded,
                  encodedSize
                });
              }
            }
          } else if ("eventData" in value || "eventStatus" in value) {
            const allowMissingFieldsForNonFabricFilteredRead = !forFabricFilteredRead && value.hasFabricSensitiveData;
            const encoded = encodeEventPayload(value, { allowMissingFieldsForNonFabricFilteredRead });
            const encodedSize = TlvAny.getEncodedByteLength(encoded);
            eventReportsToSend.push({
              eventReport: value,
              encoded,
              encodedSize
            });
          } else {
            throw new InternalError(`Invalid report type: ${value}`);
          }
        }
        if (attributeReportsToSend.length > 0) {
          const attributeToSend = attributeReportsToSend.shift();
          if (attributeToSend === void 0) {
            continue;
          }
          const { attributeReport, encoded, encodedSize, needSendNext } = attributeToSend;
          let availableBytes = this.exchange.maxPayloadSize - messageSize - 3;
          let sendOutTheMessage = false;
          if (encodedSize > availableBytes) {
            if ((allDataReceived || needSendNext) && canAttributePayloadBeChunked(attributeReport)) {
              const chunks = chunkAttributePayload(attributeReport);
              const initialChunk = chunks.shift();
              const firstDataChunk = chunks.shift();
              if (initialChunk === void 0 || firstDataChunk === void 0) {
                throw new InternalError(
                  "Chunked attribute payload is unexpected. This should not happen!"
                );
              }
              initialChunk.attributeData.payload.push(firstDataChunk.attributeData.payload);
              const allowMissingFieldsForNonFabricFilteredRead = !forFabricFilteredRead && attributeReport.hasFabricSensitiveData;
              const encodedInitialChunk = encodeAttributePayload(initialChunk, {
                allowMissingFieldsForNonFabricFilteredRead
              });
              const encodedInitialChunkSize = TlvAny.getEncodedByteLength(encodedInitialChunk);
              if (availableBytes > encodedInitialChunkSize) {
                availableBytes -= encodedInitialChunkSize;
                messageSize += encodedInitialChunkSize;
                while (chunks.length > 0) {
                  const nextChunk = chunks.shift();
                  if (nextChunk === void 0) {
                    throw new InternalError(
                      "Chunked attribute payload is undefined. This should not happen!"
                    );
                  }
                  const encodedChunkData = encodeAttributePayloadData(nextChunk, {
                    allowMissingFieldsForNonFabricFilteredRead
                  });
                  const encodedChunkDataSize = TlvAny.getEncodedByteLength(encodedChunkData);
                  if (encodedChunkDataSize > availableBytes) {
                    chunks.unshift(nextChunk);
                    for (let i = chunks.length - 1; i >= 0; i--) {
                      const chunk = chunks[i];
                      const encodedChunk = encodeAttributePayload(chunk, {
                        allowMissingFieldsForNonFabricFilteredRead
                      });
                      const encodedChunkSize = TlvAny.getEncodedByteLength(encodedChunk);
                      attributeReportsToSend.unshift({
                        attributeReport: chunk,
                        encoded: encodedChunk,
                        encodedSize: encodedChunkSize,
                        needSendNext: true
                      });
                    }
                    if (dataReport.attributeReports === void 0) {
                      dataReport.attributeReports = [];
                    }
                    dataReport.attributeReports.push(
                      encodeAttributePayload(initialChunk, {
                        allowMissingFieldsForNonFabricFilteredRead
                      })
                    );
                    break;
                  }
                  availableBytes -= encodedChunkDataSize;
                  messageSize += encodedChunkDataSize;
                  initialChunk.attributeData.payload.push(nextChunk.attributeData.payload);
                }
                continue;
              } else if (needSendNext) {
                sendOutTheMessage = true;
              }
            } else {
              if (needSendNext) {
                sendOutTheMessage = true;
              } else {
                processQueueFirst = false;
              }
            }
            let messageWasSent = false;
            if (sendOutTheMessage || availableBytes < DATA_REPORT_MIN_AVAILABLE_BYTES_BEFORE_SENDING || attributeReportsToSend.length > 0 && attributeReportsToSend[0].needSendNext || attributeReportsToSend.length >= DATA_REPORT_MAX_QUEUED_ATTRIBUTE_MESSAGES) {
              await sendAndResetReport();
              messageWasSent = true;
            }
            if (!messageWasSent) {
              attributeReportsToSend.push(attributeToSend);
              continue;
            }
            if (encodedSize > this.exchange.maxPayloadSize - emptyDataReportBytes.length - 3) {
              attributeReportsToSend.unshift(attributeToSend);
              continue;
            }
          }
          messageSize += encodedSize;
          if (dataReport.attributeReports === void 0) {
            dataReport.attributeReports = [];
          }
          dataReport.attributeReports.push(encoded);
        } else if (eventReportsToSend.length > 0) {
          const eventToSend = eventReportsToSend.shift();
          if (eventToSend === void 0) {
            continue;
          }
          const { encoded, encodedSize } = eventToSend;
          if (messageSize + 3 + (dataReport.attributeReports ? 3 : 0) + encodedSize > this.exchange.maxPayloadSize) {
            await sendAndResetReport();
          }
          messageSize += encodedSize;
          if (dataReport.eventReports === void 0) {
            dataReport.eventReports = [];
          }
          dataReport.eventReports.push(encoded);
        } else if (allDataReceived) {
          delete dataReport.moreChunkedMessages;
          break;
        }
      }
    }
    await this.sendDataReportMessage(dataReport, waitForAck);
  }
  async sendDataReportMessage(dataReport, waitForAck = true) {
    const dataReportToSend = {
      ...dataReport,
      suppressResponse: dataReport.moreChunkedMessages ? false : dataReport.suppressResponse
      // always false when moreChunkedMessages is true
    };
    const encodedMessage = TlvDataReportForSend.encode(dataReportToSend);
    if (encodedMessage.length > this.exchange.maxPayloadSize) {
      throw new MatterFlowError(
        `DataReport with ${encodedMessage.length}bytes is too long to fit in a single chunk (${this.exchange.maxPayloadSize}bytes), This should not happen! Data: ${Diagnostic.json(
          dataReportToSend
        )}`
      );
    }
    const logContext = {
      subId: dataReportToSend.subscriptionId,
      interactionFlags: Diagnostic.asFlags({
        empty: !dataReportToSend.attributeReports?.length && !dataReportToSend.eventReports?.length,
        suppressResponse: dataReportToSend.suppressResponse,
        moreChunkedMessages: dataReportToSend.moreChunkedMessages
      }),
      attr: dataReportToSend.attributeReports?.length,
      ev: dataReportToSend.eventReports?.length
    };
    if (dataReportToSend.suppressResponse) {
      try {
        await this.exchange.send(5 /* ReportData */, encodedMessage, {
          expectAckOnly: true,
          disableMrpLogic: !waitForAck,
          logContext
        });
      } catch (e) {
        UnexpectedMessageError.accept(e);
        const { receivedMessage } = e;
        this.throwIfErrorStatusMessage(receivedMessage);
      }
    } else {
      await this.exchange.send(5 /* ReportData */, encodedMessage, {
        disableMrpLogic: !waitForAck,
        logContext
      });
      await this.waitForSuccess("DataReport", { timeoutMs: waitForAck ? void 0 : 500 });
    }
  }
}
class IncomingInteractionClientMessenger extends InteractionMessenger {
  async waitFor(expectedMessageInfo, messageType, timeoutMs) {
    const message = await this.anyNextMessage(expectedMessageInfo, { timeoutMs });
    const {
      payloadHeader: { messageType: receivedMessageType }
    } = message;
    if (receivedMessageType !== messageType) {
      if (receivedMessageType === 1 /* StatusResponse */) {
        const statusCode = TlvStatusResponse.decode(message.payload).status;
        throw new ReceivedStatusResponseError(`Received status response ${statusCode}`, statusCode);
      }
      throw new MatterFlowError(
        `Received unexpected message type ${receivedMessageType.toString(16)}. Expected ${messageType.toString(
          16
        )}`
      );
    }
    return message;
  }
  async readAggregateDataReport(expectedSubscriptionIds) {
    let result;
    for await (const report of this.readDataReports()) {
      if (expectedSubscriptionIds !== void 0) {
        if (report.subscriptionId === void 0 || !expectedSubscriptionIds.includes(report.subscriptionId)) {
          await this.sendStatus(StatusCode.InvalidSubscription, {
            multipleMessageInteraction: true,
            logContext: {
              subId: report.subscriptionId
            }
          });
          throw new UnexpectedDataError(
            report.subscriptionId === void 0 ? "Invalid Data report without Subscription ID" : `Invalid Data report with unexpected subscription ID ${report.subscriptionId}`
          );
        }
      }
      if (result?.subscriptionId !== void 0 && report.subscriptionId !== result.subscriptionId) {
        throw new UnexpectedDataError(`Invalid subscription ID ${report.subscriptionId} received`);
      }
      if (!result) {
        result = report;
      } else {
        if (Array.isArray(report.attributeReports)) {
          if (!result.attributeReports) {
            result.attributeReports = report.attributeReports;
          } else {
            result.attributeReports.push(...report.attributeReports);
          }
        }
        if (Array.isArray(report.eventReports)) {
          if (!result.eventReports) {
            result.eventReports = report.eventReports;
          } else {
            result.eventReports.push(...report.eventReports);
          }
        }
      }
    }
    if (result === void 0) {
      throw new InternalError("No data reports loaded during read");
    }
    return result;
  }
  /**
   * Read data reports as they come in on the wire.
   *
   * Data reports payloads are decoded but list attributes may be split across messages; these will require reassembly.
   */
  async *readDataReports() {
    while (true) {
      const dataReportMessage = await this.waitFor("DataReport", 5 /* ReportData */);
      const report = TlvDataReport.decode(dataReportMessage.payload);
      yield report;
      if (report.moreChunkedMessages) {
        await this.sendStatus(StatusCode.Success, {
          multipleMessageInteraction: true,
          logContext: this.#logContextOf(report)
        });
      } else if (!report.suppressResponse) {
        this.sendStatus(StatusCode.Success, {
          multipleMessageInteraction: true,
          logContext: this.#logContextOf(report)
        }).catch((error) => logger.info("Error sending success after final data report chunk", error));
      }
      if (!report.moreChunkedMessages) {
        break;
      }
    }
  }
  #logContextOf(report) {
    return {
      subId: report.subscriptionId,
      dataReportFlags: Diagnostic.asFlags({
        empty: !report.attributeReports?.length && !report.eventReports?.length,
        suppressResponse: report.suppressResponse,
        moreChunkedMessages: report.moreChunkedMessages
      }),
      attr: report.attributeReports?.length,
      ev: report.eventReports?.length
    };
  }
}
class InteractionClientMessenger extends IncomingInteractionClientMessenger {
  constructor(exchange, exchangeProvider) {
    super(exchange);
    this.exchangeProvider = exchangeProvider;
  }
  static async create(exchangeProvider) {
    const exchange = await exchangeProvider.initiateExchange();
    return new this(exchange, exchangeProvider);
  }
  /** Implements a send method with an automatic reconnection mechanism */
  async send(messageType, payload, options) {
    try {
      if (this.exchange.channel.closed) {
        throw new ChannelNotConnectedError("The exchange channel is closed. Please connect the device first.");
      }
      return await this.exchange.send(messageType, payload, options);
    } catch (error) {
      if (this.exchangeProvider.supportsReconnect && (error instanceof RetransmissionLimitReachedError || error instanceof ChannelNotConnectedError) && !options?.multipleMessageInteraction) {
        logger.debug(
          `${error instanceof RetransmissionLimitReachedError ? "Retransmission limit reached" : "Channel not connected"}, trying to reconnect and resend the message.`
        );
        await this.exchange.close();
        if (await this.exchangeProvider.reconnectChannel()) {
          this.exchange = await this.exchangeProvider.initiateExchange();
          return await this.exchange.send(messageType, payload, options);
        }
      } else {
        throw error;
      }
    }
  }
  async sendReadRequest(readRequest) {
    await this.send(2 /* ReadRequest */, this.#encodeReadingRequest(TlvReadRequest, readRequest));
    return this.readAggregateDataReport();
  }
  #encodeReadingRequest(schema, request) {
    const encoded = schema.encode(request);
    if (encoded.length <= this.exchange.maxPayloadSize) {
      return encoded;
    }
    const originalDataVersionFilters = [...request.dataVersionFilters ?? []];
    const requestWithoutDataVersionFilters = schema.encode({
      ...request,
      dataVersionFilters: []
    });
    if (requestWithoutDataVersionFilters.length > this.exchange.maxPayloadSize) {
      throw new MatterFlowError(
        `Request is too long to fit in a single chunk, This should not happen! Data: ${Diagnostic.json(request)}`
      );
    }
    return schema.encode({
      ...request,
      dataVersionFilters: this.#shortenDataVersionFilters(
        originalDataVersionFilters,
        this.exchange.maxPayloadSize - requestWithoutDataVersionFilters.length
      )
    });
  }
  #shortenDataVersionFilters(originalDataVersionFilters, availableBytes) {
    const dataVersionFilters = new Array();
    while (availableBytes > 0 && originalDataVersionFilters.length > 0) {
      const dataVersionFilter = originalDataVersionFilters.shift();
      if (dataVersionFilter === void 0) {
        break;
      }
      const encodedDataVersionFilter = TlvDataVersionFilter.encode(dataVersionFilter);
      const encodedDataVersionFilterLength = encodedDataVersionFilter.length;
      if (encodedDataVersionFilterLength > availableBytes) {
        originalDataVersionFilters.unshift(dataVersionFilter);
        break;
      }
      dataVersionFilters.push(dataVersionFilter);
      availableBytes -= encodedDataVersionFilterLength;
    }
    logger.debug(
      `Removed ${originalDataVersionFilters.length} DataVersionFilters from Request to fit into a single message`
    );
    return dataVersionFilters;
  }
  async sendSubscribeRequest(subscribeRequest) {
    const request = this.#encodeReadingRequest(TlvSubscribeRequest, subscribeRequest);
    await this.send(3 /* SubscribeRequest */, request);
    const report = await this.readAggregateDataReport();
    const { subscriptionId } = report;
    if (subscriptionId === void 0) {
      throw new UnexpectedDataError(`Subscription ID not provided in report`);
    }
    const subscribeResponseMessage = await this.nextMessage(4 /* SubscribeResponse */);
    const subscribeResponse = TlvSubscribeResponse.decode(subscribeResponseMessage.payload);
    if (subscribeResponse.subscriptionId !== subscriptionId) {
      throw new MatterFlowError(
        `Received subscription ID ${subscribeResponse.subscriptionId} instead of ${subscriptionId}`
      );
    }
    return {
      subscribeResponse,
      report
    };
  }
  async sendInvokeCommand(invokeRequest, expectedProcessingTimeMs) {
    if (invokeRequest.suppressResponse) {
      await this.requestWithSuppressedResponse(
        8 /* InvokeRequest */,
        TlvInvokeRequest,
        invokeRequest,
        expectedProcessingTimeMs
      );
    } else {
      return await this.request(
        8 /* InvokeRequest */,
        TlvInvokeRequest,
        9 /* InvokeResponse */,
        TlvInvokeResponse,
        invokeRequest,
        expectedProcessingTimeMs
      );
    }
  }
  async sendWriteCommand(writeRequest) {
    if (writeRequest.suppressResponse) {
      await this.requestWithSuppressedResponse(6 /* WriteRequest */, TlvWriteRequest, writeRequest);
    } else {
      return await this.request(
        6 /* WriteRequest */,
        TlvWriteRequest,
        7 /* WriteResponse */,
        TlvWriteResponse,
        writeRequest
      );
    }
  }
  sendTimedRequest(timeoutSeconds) {
    return this.request(10 /* TimedRequest */, TlvTimedRequest, 1 /* StatusResponse */, TlvStatusResponse, {
      timeout: timeoutSeconds,
      interactionModelRevision: Specification.INTERACTION_MODEL_REVISION
    });
  }
  async requestWithSuppressedResponse(requestMessageType, requestSchema, request, expectedProcessingTimeMs) {
    await this.send(requestMessageType, requestSchema.encode(request), {
      expectAckOnly: true,
      expectedProcessingTimeMs,
      logContext: {
        invokeFlags: Diagnostic.asFlags({
          suppressResponse: true
        })
      }
    });
  }
  async request(requestMessageType, requestSchema, responseMessageType, responseSchema, request, expectedProcessingTimeMs) {
    await this.send(requestMessageType, requestSchema.encode(request), {
      expectAckOnly: false,
      expectedProcessingTimeMs
    });
    const responseMessage = await this.nextMessage(
      responseMessageType,
      { expectedProcessingTimeMs },
      MessageType[responseMessageType] ?? `Response-${Diagnostic.hex(responseMessageType)}`
    );
    return responseSchema.decode(responseMessage.payload);
  }
}
export {
  IncomingInteractionClientMessenger,
  InteractionClientMessenger,
  InteractionServerMessenger,
  MessageType
};
//# sourceMappingURL=InteractionMessenger.js.map
