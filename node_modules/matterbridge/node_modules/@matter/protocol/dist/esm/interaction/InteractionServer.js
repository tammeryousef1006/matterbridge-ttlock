/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import {
  Crypto,
  Diagnostic,
  ImplementationError,
  InternalError,
  Logger,
  MatterError,
  MatterFlowError,
  Observable
} from "#general";
import { AttributeModel, ClusterModel, CommandModel, GLOBAL_IDS, MatterModel, Specification } from "#model";
import {
  ArraySchema,
  DEFAULT_MAX_PATHS_PER_INVOKE,
  EventNumber,
  INTERACTION_PROTOCOL_ID,
  ReceivedStatusResponseError,
  StatusCode,
  StatusResponseError,
  TlvAny,
  TlvInvokeResponseData,
  TlvInvokeResponseForSend,
  TlvNoArguments,
  TlvNoResponse,
  TlvSubscribeResponse,
  ValidationError
} from "#types";
import { AttributeServer, FabricScopedAttributeServer } from "../cluster/server/AttributeServer.js";
import { SessionType } from "../codec/MessageCodec.js";
import { assertSecureSession, NoAssociatedFabricError } from "../session/SecureSession.js";
import {
  decodeAttributeValueWithSchema,
  decodeListAttributeValueWithSchema,
  expandPathsInAttributeData
} from "./AttributeDataDecoder.js";
import {
  InteractionServerMessenger,
  MessageType
} from "./InteractionMessenger.js";
import { ServerSubscription } from "./ServerSubscription.js";
import { ServerSubscriptionConfig } from "./SubscriptionOptions.js";
const logger = Logger.get("InteractionServer");
function genericElementPathToId(endpointId, clusterId, elementId) {
  return `${endpointId}/${clusterId}/${elementId}`;
}
function commandPathToId({ endpointId, clusterId, commandId }) {
  return genericElementPathToId(endpointId, clusterId, commandId);
}
function attributePathToId({ endpointId, clusterId, attributeId }) {
  return genericElementPathToId(endpointId, clusterId, attributeId);
}
function eventPathToId({ endpointId, clusterId, eventId }) {
  return genericElementPathToId(endpointId, clusterId, eventId);
}
function clusterPathToId({ nodeId, endpointId, clusterId }) {
  return `${nodeId}/${endpointId}/${clusterId}`;
}
function isConcreteAttributePath(path) {
  const { endpointId, clusterId, attributeId } = path;
  return endpointId !== void 0 && clusterId !== void 0 && attributeId !== void 0;
}
function validateReadAttributesPath(path, isGroupSession = false) {
  if (isGroupSession) {
    throw new StatusResponseError("Illegal read request with group session", StatusCode.InvalidAction);
  }
  const { clusterId, attributeId } = path;
  if (clusterId === void 0 && attributeId !== void 0) {
    if (!GLOBAL_IDS.has(attributeId)) {
      throw new StatusResponseError(
        `Illegal read request for wildcard cluster and non global attribute ${attributeId}`,
        StatusCode.InvalidAction
      );
    }
  }
}
function validateWriteAttributesPath(path, isGroupSession = false) {
  const { endpointId, clusterId, attributeId } = path;
  if (clusterId === void 0 || attributeId === void 0) {
    throw new StatusResponseError(
      "Illegal write request with wildcard cluster or attribute ID",
      StatusCode.InvalidAction
    );
  }
  if (isGroupSession && endpointId !== void 0) {
    throw new StatusResponseError("Illegal write request with group ID and endpoint ID", StatusCode.InvalidAction);
  }
}
function isConcreteEventPath(path) {
  const { endpointId, clusterId, eventId } = path;
  return endpointId !== void 0 && clusterId !== void 0 && eventId !== void 0;
}
function validateReadEventPath(path, isGroupSession = false) {
  const { clusterId, eventId } = path;
  if (clusterId === void 0 && eventId !== void 0) {
    throw new StatusResponseError("Illegal read request with wildcard cluster ID", StatusCode.InvalidAction);
  }
  if (isGroupSession) {
    throw new StatusResponseError("Illegal read request with group session", StatusCode.InvalidAction);
  }
}
function isConcreteCommandPath(path) {
  const { endpointId, clusterId, commandId } = path;
  return endpointId !== void 0 && clusterId !== void 0 && commandId !== void 0;
}
function validateCommandPath(path, isGroupSession = false) {
  const { endpointId, clusterId, commandId } = path;
  if (clusterId === void 0 || commandId === void 0) {
    throw new StatusResponseError(
      "Illegal write request with wildcard cluster or attribute ID",
      StatusCode.InvalidAction
    );
  }
  if (isGroupSession && endpointId !== void 0) {
    throw new StatusResponseError("Illegal write request with group ID and endpoint ID", StatusCode.InvalidAction);
  }
}
function getMatterModelCluster(clusterId) {
  return MatterModel.standard.get(ClusterModel, clusterId);
}
function getMatterModelClusterAttribute(clusterId, attributeId) {
  return getMatterModelCluster(clusterId)?.get(AttributeModel, attributeId);
}
function getMatterModelClusterCommand(clusterId, commandId) {
  return getMatterModelCluster(clusterId)?.get(CommandModel, commandId);
}
class InteractionServer {
  id = INTERACTION_PROTOCOL_ID;
  #context;
  #nextSubscriptionId = Crypto.getRandomUInt32();
  #isClosing = false;
  #clientHandler;
  #subscriptionConfig;
  #maxPathsPerInvoke;
  #subscriptionEstablishmentStarted = Observable();
  constructor(context) {
    this.#context = context;
    this.#subscriptionConfig = ServerSubscriptionConfig.of(context.subscriptionOptions);
    this.#maxPathsPerInvoke = context.maxPathsPerInvoke ?? DEFAULT_MAX_PATHS_PER_INVOKE;
    this.#context.structure.change.on(async () => {
      this.#context.sessions.updateAllSubscriptions();
    });
  }
  get isClosing() {
    return this.#isClosing;
  }
  get maxPathsPerInvoke() {
    return this.#maxPathsPerInvoke;
  }
  get subscriptionEstablishmentStarted() {
    return this.#subscriptionEstablishmentStarted;
  }
  async onNewExchange(exchange, message) {
    if (this.#isClosing) return;
    if (message.payloadHeader.messageType === MessageType.SubscribeRequest && this.#clientHandler) {
      return this.#clientHandler.onNewExchange(exchange, message);
    }
    await new InteractionServerMessenger(exchange).handleRequest(this);
  }
  get clientHandler() {
    return this.#clientHandler;
  }
  set clientHandler(clientHandler) {
    this.#clientHandler = clientHandler;
  }
  async #collectEventDataForRead({ eventRequests, eventFilters, isFabricFiltered }, exchange, message) {
    let eventReportsPayload;
    if (eventRequests) {
      eventReportsPayload = [];
      for (const requestPath of eventRequests) {
        validateReadEventPath(requestPath);
        const events = this.#endpointStructure.getEvents([requestPath]);
        if (events.length === 0) {
          if (isConcreteEventPath(requestPath)) {
            const { endpointId, clusterId, eventId } = requestPath;
            try {
              this.#endpointStructure.validateConcreteEventPath(endpointId, clusterId, eventId);
              throw new InternalError(
                "validateConcreteEventPath should throw StatusResponseError but did not."
              );
            } catch (e) {
              StatusResponseError.accept(e);
              logger.debug(
                `Read event from ${exchange.channel.name}: ${this.#endpointStructure.resolveEventName(requestPath)}: unsupported path: Status=${e.code}`
              );
              eventReportsPayload?.push({
                hasFabricSensitiveData: false,
                eventStatus: { path: requestPath, status: { status: e.code } }
              });
            }
          }
          logger.debug(
            `Read event from ${exchange.channel.name}: ${this.#endpointStructure.resolveEventName(
              requestPath
            )}: ignore non-existing event`
          );
          continue;
        }
        const reportsForPath = new Array();
        for (const { path, event } of events) {
          try {
            const matchingEvents = await this.readEvent(
              path,
              eventFilters,
              event,
              exchange,
              isFabricFiltered,
              message
            );
            logger.debug(
              `Read event from ${exchange.channel.name}: ${this.#endpointStructure.resolveEventName(
                path
              )}=${Diagnostic.json(matchingEvents)}`
            );
            const { schema } = event;
            reportsForPath.push(
              ...matchingEvents.map(({ number, priority, epochTimestamp, payload }) => ({
                hasFabricSensitiveData: event.hasFabricSensitiveData,
                eventData: {
                  path,
                  eventNumber: number,
                  priority,
                  epochTimestamp,
                  payload,
                  schema
                }
              }))
            );
          } catch (error) {
            logger.error(
              `Error while reading event from ${exchange.channel.name} to ${this.#endpointStructure.resolveEventName(path)}:`,
              error
            );
            StatusResponseError.accept(error);
            if (isConcreteEventPath(requestPath)) {
              eventReportsPayload?.push({
                hasFabricSensitiveData: false,
                eventStatus: { path, status: { status: error.code } }
              });
            }
          }
        }
        eventReportsPayload.push(
          ...reportsForPath.sort((a, b) => {
            const eventNumberA = a.eventData?.eventNumber ?? EventNumber(0);
            const eventNumberB = b.eventData?.eventNumber ?? EventNumber(0);
            if (eventNumberA > eventNumberB) {
              return 1;
            } else if (eventNumberA < eventNumberB) {
              return -1;
            } else {
              return 0;
            }
          })
        );
      }
    }
    return eventReportsPayload;
  }
  /**
   * Returns an iterator that yields the data reports and events data for the given read request.
   */
  *#iterateReadAttributesPaths({ attributeRequests, dataVersionFilters, isFabricFiltered }, eventReportsPayload, exchange, message) {
    const dataVersionFilterMap = new Map(
      dataVersionFilters?.map(({ path, dataVersion }) => [clusterPathToId(path), dataVersion]) ?? []
    );
    if (dataVersionFilterMap.size > 0) {
      logger.debug(
        `DataVersionFilters: ${Array.from(dataVersionFilterMap.entries()).map(([path, version]) => `${path}=${version}`).join(", ")}`
      );
    }
    for (const requestPath of attributeRequests ?? []) {
      validateReadAttributesPath(requestPath);
      const attributes = this.#endpointStructure.getAttributes([requestPath]);
      if (attributes.length === 0) {
        if (isConcreteAttributePath(requestPath)) {
          const { endpointId, clusterId, attributeId } = requestPath;
          try {
            this.#endpointStructure.validateConcreteAttributePath(endpointId, clusterId, attributeId);
            throw new InternalError(
              "validateConcreteAttributePath should throw StatusResponseError but did not."
            );
          } catch (e) {
            StatusResponseError.accept(e);
            logger.debug(
              `Error reading attribute from ${exchange.channel.name}: ${this.#endpointStructure.resolveAttributeName(requestPath)}: unsupported path: Status=${e.code}`
            );
            yield {
              hasFabricSensitiveData: false,
              attributeStatus: { path: requestPath, status: { status: e.code } }
            };
          }
        }
        logger.debug(
          `Read from ${exchange.channel.name}: ${this.#endpointStructure.resolveAttributeName(
            requestPath
          )}: ${this.#endpointStructure.resolveAttributeName(requestPath)}: ignore non-existing attribute`
        );
        continue;
      }
      for (const { path, attribute } of attributes) {
        const { nodeId, endpointId, clusterId } = path;
        try {
          if (getMatterModelClusterAttribute(clusterId, attribute.id)?.readable === false) {
            throw new StatusResponseError(
              `Attribute ${attribute.id} is not readable.`,
              StatusCode.UnsupportedRead
            );
          }
          let value, version;
          try {
            ({ value, version } = this.readAttribute(path, attribute, exchange, isFabricFiltered, message));
          } catch (e) {
            NoAssociatedFabricError.accept(e);
            if (endpointId === void 0 || clusterId === void 0) {
              throw new MatterFlowError("Should never happen");
            }
            const cluster = this.#endpointStructure.getClusterServer(endpointId, clusterId);
            if (cluster === void 0 || cluster.datasource == void 0) {
              throw new MatterFlowError("Should never happen");
            }
            version = cluster.datasource.version;
            value = [];
          }
          const versionFilterValue = endpointId !== void 0 && clusterId !== void 0 ? dataVersionFilterMap.get(clusterPathToId({ nodeId, endpointId, clusterId })) : void 0;
          if (versionFilterValue !== void 0 && versionFilterValue === version) {
            logger.debug(
              `Read attribute from ${exchange.channel.name}: ${this.#endpointStructure.resolveAttributeName(
                path
              )}=${Diagnostic.json(value)} (version=${version}) ignored because of dataVersionFilter`
            );
            continue;
          }
          logger.debug(
            `Read attribute from ${exchange.channel.name}: ${this.#endpointStructure.resolveAttributeName(
              path
            )}=${Diagnostic.json(value)} (version=${version})`
          );
          const { schema } = attribute;
          yield {
            hasFabricSensitiveData: attribute.hasFabricSensitiveData,
            attributeData: { path, dataVersion: version, payload: value, schema }
          };
        } catch (error) {
          const what = `reading ${this.#endpointStructure.resolveAttributeName(path)} from ${exchange.channel.name}`;
          if (!(error instanceof StatusResponseError)) {
            const wrappedError = new ImplementationError(`Unhandled error ${what}`);
            wrappedError.cause = error;
            throw wrappedError;
          }
          logger.error(`Error ${what}:`, error.message);
          if (isConcreteAttributePath(requestPath)) {
            yield {
              hasFabricSensitiveData: false,
              attributeStatus: { path, status: { status: error.code } }
            };
          }
        }
      }
    }
    if (eventReportsPayload !== void 0) {
      for (const eventReport of eventReportsPayload) {
        yield eventReport;
      }
    }
  }
  async handleReadRequest(exchange, readRequest, message) {
    const { attributeRequests, eventRequests, isFabricFiltered, interactionModelRevision } = readRequest;
    logger.debug(
      `Received read request from ${exchange.channel.name}: attributes:${attributeRequests?.map((path) => this.#endpointStructure.resolveAttributeName(path)).join(", ") ?? "none"}, events:${eventRequests?.map((path) => this.#endpointStructure.resolveEventName(path)).join(", ") ?? "none"} isFabricFiltered=${isFabricFiltered}`
    );
    if (interactionModelRevision > Specification.INTERACTION_MODEL_REVISION) {
      logger.debug(
        `Interaction model revision of sender ${interactionModelRevision} is higher than supported ${Specification.INTERACTION_MODEL_REVISION}.`
      );
    }
    if (attributeRequests === void 0 && eventRequests === void 0) {
      return {
        dataReport: {
          interactionModelRevision: Specification.INTERACTION_MODEL_REVISION,
          suppressResponse: true
        }
      };
    }
    if (message.packetHeader.sessionType !== SessionType.Unicast) {
      throw new StatusResponseError(
        "Subscriptions are only allowed on unicast sessions",
        StatusCode.InvalidAction
      );
    }
    return {
      dataReport: {
        interactionModelRevision: Specification.INTERACTION_MODEL_REVISION,
        suppressResponse: true
      },
      payload: this.#iterateReadAttributesPaths(
        readRequest,
        await this.#collectEventDataForRead(readRequest, exchange, message),
        exchange,
        message
      )
    };
  }
  readAttribute(_path, attribute, exchange, isFabricFiltered, message, offline = false) {
    return attribute.getWithVersion(exchange.session, isFabricFiltered, offline ? void 0 : message);
  }
  /**
   * Reads the attributes for the given endpoint.
   * This can currently only be used for subscriptions because errors are ignored!
   */
  readEndpointAttributesForSubscription(attributes, exchange, isFabricFiltered, message, offline = false) {
    const result = new Array();
    for (const { path, attribute } of attributes) {
      try {
        const { version, value } = this.readAttribute(
          path,
          attribute,
          exchange,
          isFabricFiltered,
          message,
          offline
        );
        result.push({ path, value, version, attribute });
      } catch (error) {
        if (StatusResponseError.is(error, StatusCode.UnsupportedAccess)) {
          logger.warn(
            `Permission denied reading attribute ${this.#endpointStructure.resolveAttributeName(path)}`
          );
        } else {
          logger.warn(
            `Error reading attribute ${this.#endpointStructure.resolveAttributeName(path)}:`,
            error
          );
        }
      }
    }
    return result;
  }
  async readEvent(_path, eventFilters, event, exchange, isFabricFiltered, message) {
    return event.get(exchange.session, isFabricFiltered, message, eventFilters);
  }
  async handleWriteRequest(exchange, { suppressResponse, timedRequest, writeRequests, interactionModelRevision, moreChunkedMessages }, message) {
    const sessionType = message.packetHeader.sessionType;
    logger.debug(
      `Received write request from ${exchange.channel.name}: ${writeRequests.map((req) => this.#endpointStructure.resolveAttributeName(req.path)).join(", ")}, suppressResponse=${suppressResponse}, moreChunkedMessages=${moreChunkedMessages}`
    );
    if (moreChunkedMessages && suppressResponse) {
      throw new StatusResponseError(
        "MoreChunkedMessages and SuppressResponse cannot be used together in write messages",
        StatusCode.InvalidAction
      );
    }
    if (interactionModelRevision > Specification.INTERACTION_MODEL_REVISION) {
      logger.debug(
        `Interaction model revision of sender ${interactionModelRevision} is higher than supported ${Specification.INTERACTION_MODEL_REVISION}.`
      );
    }
    const receivedWithinTimedInteraction = exchange.hasActiveTimedInteraction();
    if (receivedWithinTimedInteraction && moreChunkedMessages) {
      throw new StatusResponseError(
        "Write Request action that is part of a Timed Write Interaction SHALL NOT be chunked.",
        StatusCode.InvalidAction
      );
    }
    if (exchange.hasExpiredTimedInteraction()) {
      exchange.clearTimedInteraction();
      throw new StatusResponseError(`Timed request window expired. Decline write request.`, StatusCode.Timeout);
    }
    if (timedRequest !== exchange.hasTimedInteraction()) {
      throw new StatusResponseError(
        `timedRequest flag of write interaction (${timedRequest}) mismatch with expected timed interaction (${receivedWithinTimedInteraction}).`,
        StatusCode.TimedRequestMismatch
      );
    }
    if (receivedWithinTimedInteraction) {
      logger.debug(
        `Write request from ${exchange.channel.name} successfully received while timed interaction is running.`
      );
      exchange.clearTimedInteraction();
      if (sessionType !== SessionType.Unicast) {
        throw new StatusResponseError(
          "Write requests are only allowed on unicast sessions when a timed interaction is running.",
          StatusCode.InvalidAction
        );
      }
    }
    if (sessionType === SessionType.Group && !suppressResponse) {
      throw new StatusResponseError(
        "Write requests are only allowed as group casts when suppressResponse=true.",
        StatusCode.InvalidAction
      );
    }
    const writeData = expandPathsInAttributeData(writeRequests, true);
    const writeResults = new Array();
    const attributeListWrites = /* @__PURE__ */ new Set();
    const clusterDataVersionInfo = /* @__PURE__ */ new Map();
    const inaccessiblePaths = /* @__PURE__ */ new Set();
    for (const writeRequest of writeData) {
      const { path: writePath, dataVersion } = writeRequest;
      validateWriteAttributesPath(writePath);
      const attributes = this.#endpointStructure.getAttributes([writePath], true);
      if (attributes.length === 0) {
        if (isConcreteAttributePath(writePath)) {
          const { endpointId, clusterId, attributeId } = writePath;
          try {
            this.#endpointStructure.validateConcreteAttributePath(endpointId, clusterId, attributeId);
            throw new StatusResponseError(
              `Attribute ${attributeId} is not writable.`,
              StatusCode.UnsupportedWrite
            );
          } catch (e) {
            StatusResponseError.accept(e);
            logger.debug(
              `Write from ${exchange.channel.name}: ${this.#endpointStructure.resolveAttributeName(
                writePath
              )} not allowed: Status=${e.code}`
            );
            writeResults.push({ path: writePath, statusCode: e.code });
          }
        } else {
          logger.debug(
            `Write from ${exchange.channel.name}: ${this.#endpointStructure.resolveAttributeName(
              writePath
            )}: ignore non-existing (wildcard) attribute`
          );
        }
        continue;
      }
      if (attributes.length === 1 && isConcreteAttributePath(writePath)) {
        const { endpointId, clusterId } = writePath;
        const { attribute } = attributes[0];
        if (attribute.requiresTimedInteraction && !receivedWithinTimedInteraction) {
          logger.debug(`This write requires a timed interaction which is not initialized.`);
          writeResults.push({ path: writePath, statusCode: StatusCode.NeedsTimedInteraction });
          continue;
        }
        if (attribute instanceof FabricScopedAttributeServer && (!exchange.session.isSecure || !exchange.session.fabric)) {
          logger.debug(`This write requires a secure session with a fabric assigned which is missing.`);
          writeResults.push({ path: writePath, statusCode: StatusCode.UnsupportedAccess });
          continue;
        }
        if (dataVersion !== void 0) {
          const datasource = this.#endpointStructure.getClusterServer(endpointId, clusterId)?.datasource;
          const { nodeId } = writePath;
          const clusterKey = clusterPathToId({ nodeId, endpointId, clusterId });
          const currentDataVersion = clusterDataVersionInfo.get(clusterKey) ?? datasource?.version;
          if (currentDataVersion !== void 0) {
            if (dataVersion !== currentDataVersion) {
              logger.debug(
                `This write requires a specific data version (${dataVersion}) which do not match the current cluster data version (${currentDataVersion}).`
              );
              writeResults.push({ path: writePath, statusCode: StatusCode.DataVersionMismatch });
              continue;
            }
            clusterDataVersionInfo.set(clusterKey, currentDataVersion);
          }
        }
      }
      for (const { path, attribute } of attributes) {
        const { schema, defaultValue } = attribute;
        const pathId = attributePathToId(path);
        try {
          if (!(attribute instanceof AttributeServer) && !(attribute instanceof FabricScopedAttributeServer)) {
            throw new StatusResponseError(
              "Fixed attributes cannot be written",
              StatusCode.UnsupportedWrite
            );
          }
          if (inaccessiblePaths.has(pathId)) {
            logger.debug(`This write is not allowed due to previous access denied.`);
            continue;
          }
          const { endpointId } = path;
          const { listIndex } = writePath;
          const value = listIndex === void 0 ? decodeAttributeValueWithSchema(schema, [writeRequest], defaultValue) : decodeListAttributeValueWithSchema(
            schema,
            [writeRequest],
            this.readAttribute(path, attribute, exchange, true, message).value ?? defaultValue
          );
          logger.debug(
            `Handle write request from ${exchange.channel.name} resolved to: ${this.#endpointStructure.resolveAttributeName(path)}=${Diagnostic.json(
              value
            )} (listIndex=${listIndex}, for-version=${dataVersion})`
          );
          if (attribute.requiresTimedInteraction && !receivedWithinTimedInteraction) {
            logger.debug(`This write requires a timed interaction which is not initialized.`);
            throw new StatusResponseError(
              "This write requires a timed interaction which is not initialized.",
              StatusCode.NeedsTimedInteraction
            );
          }
          await this.writeAttribute(
            path,
            attribute,
            value,
            exchange,
            message,
            this.#endpointStructure.getEndpoint(endpointId),
            receivedWithinTimedInteraction,
            schema instanceof ArraySchema
          );
          if (schema instanceof ArraySchema && !attributeListWrites.has(attribute)) {
            attributeListWrites.add(attribute);
          }
        } catch (error) {
          if (StatusResponseError.is(error, StatusCode.UnsupportedAccess)) {
            inaccessiblePaths.add(pathId);
          }
          if (attributes.length === 1 && isConcreteAttributePath(writePath)) {
            logger.error(
              `Error while handling write request from ${exchange.channel.name} to ${this.#endpointStructure.resolveAttributeName(path)}:`,
              error instanceof StatusResponseError ? error.message : error
            );
            if (error instanceof StatusResponseError) {
              writeResults.push({ path, statusCode: error.code, clusterStatusCode: error.clusterCode });
              continue;
            }
            writeResults.push({ path, statusCode: StatusCode.ConstraintError });
            continue;
          } else {
            logger.debug(
              `While handling write request from ${exchange.channel.name} to ${this.#endpointStructure.resolveAttributeName(path)} ignored: ${error.message}`
            );
          }
        }
        writeResults.push({ path, statusCode: StatusCode.Success });
      }
    }
    const errorResults = writeResults.filter(({ statusCode }) => statusCode !== StatusCode.Success);
    logger.debug(
      `Write request from ${exchange.channel.name} done ${errorResults.length ? `with following errors: ${errorResults.map(
        ({ path, statusCode }) => `${this.#endpointStructure.resolveAttributeName(path)}=${Diagnostic.json(statusCode)}`
      ).join(", ")}` : "without errors"}`
    );
    const response = {
      interactionModelRevision: Specification.INTERACTION_MODEL_REVISION,
      writeResponses: writeResults.map(({ path, statusCode, clusterStatusCode }) => ({
        path,
        status: { status: statusCode, clusterStatus: clusterStatusCode }
      }))
    };
    for (const attribute of attributeListWrites.values()) {
      try {
        attribute.triggerDelayedChangeEvents();
      } catch (error) {
        logger.error(
          `Ignored Error while writing attribute from ${exchange.channel.name} to ${attribute.name}:`,
          error
        );
      }
    }
    return response;
  }
  async writeAttribute(_path, attribute, value, exchange, message, _endpoint, _receivedWithinTimedInteraction, isListWrite = false) {
    attribute.set(value, exchange.session, message, isListWrite);
  }
  async handleSubscribeRequest(exchange, request, messenger, message) {
    const {
      minIntervalFloorSeconds,
      maxIntervalCeilingSeconds,
      attributeRequests,
      dataVersionFilters,
      eventRequests,
      eventFilters,
      keepSubscriptions,
      isFabricFiltered,
      interactionModelRevision
    } = request;
    logger.debug(
      `Received subscribe request from ${exchange.channel.name} (keepSubscriptions=${keepSubscriptions}, isFabricFiltered=${isFabricFiltered})`
    );
    if (interactionModelRevision > Specification.INTERACTION_MODEL_REVISION) {
      logger.debug(
        `Interaction model revision of sender ${interactionModelRevision} is higher than supported ${Specification.INTERACTION_MODEL_REVISION}.`
      );
    }
    if (message.packetHeader.sessionType !== SessionType.Unicast) {
      throw new StatusResponseError(
        "Subscriptions are only allowed on unicast sessions",
        StatusCode.InvalidAction
      );
    }
    assertSecureSession(exchange.session, "Subscriptions are only implemented on secure sessions");
    const session = exchange.session;
    const fabric = session.fabric;
    if (fabric === void 0)
      throw new StatusResponseError(
        "Subscriptions are only implemented after a fabric has been assigned",
        StatusCode.InvalidAction
      );
    if (!keepSubscriptions) {
      const clearedCount = await this.#context.sessions.clearSubscriptionsForNode(
        fabric.addressOf(session.peerNodeId),
        true
      );
      if (clearedCount > 0) {
        logger.debug(
          `Cleared ${clearedCount} subscriptions for Subscriber node ${session.peerNodeId} because keepSubscriptions=false`
        );
      }
    }
    if ((!Array.isArray(attributeRequests) || attributeRequests.length === 0) && (!Array.isArray(eventRequests) || eventRequests.length === 0)) {
      throw new StatusResponseError("No attributes or events requested", StatusCode.InvalidAction);
    }
    logger.debug(
      `Subscribe to attributes:${attributeRequests?.map((path) => this.#endpointStructure.resolveAttributeName(path)).join(", ") ?? "none"}, events:${eventRequests?.map((path) => this.#endpointStructure.resolveEventName(path)).join(", ") ?? "none"}`
    );
    if (dataVersionFilters !== void 0 && dataVersionFilters.length > 0) {
      logger.debug(
        `DataVersionFilters: ${dataVersionFilters.map(
          ({ path: { nodeId, endpointId, clusterId }, dataVersion }) => `${clusterPathToId({ nodeId, endpointId, clusterId })}=${dataVersion}`
        ).join(", ")}`
      );
    }
    if (eventFilters !== void 0 && eventFilters.length > 0)
      logger.debug(
        `Event filters: ${eventFilters.map((filter) => `${filter.nodeId}/${filter.eventMin}`).join(", ")}`
      );
    attributeRequests?.forEach((path) => validateReadAttributesPath(path));
    eventRequests?.forEach((path) => validateReadEventPath(path));
    if (minIntervalFloorSeconds < 0) {
      throw new StatusResponseError(
        "minIntervalFloorSeconds should be greater or equal to 0",
        StatusCode.InvalidAction
      );
    }
    if (maxIntervalCeilingSeconds < 0) {
      throw new StatusResponseError(
        "maxIntervalCeilingSeconds should be greater or equal to 1",
        StatusCode.InvalidAction
      );
    }
    if (maxIntervalCeilingSeconds < minIntervalFloorSeconds) {
      throw new StatusResponseError(
        "maxIntervalCeilingSeconds should be greater or equal to minIntervalFloorSeconds",
        StatusCode.InvalidAction
      );
    }
    if (this.#nextSubscriptionId === 4294967295) this.#nextSubscriptionId = 0;
    const subscriptionId = this.#nextSubscriptionId++;
    this.#subscriptionEstablishmentStarted.emit(session.peerAddress);
    let subscription;
    try {
      subscription = await this.#establishSubscription(
        subscriptionId,
        request,
        messenger,
        session,
        exchange,
        message
      );
    } catch (error) {
      logger.error(
        `Subscription ${subscriptionId} for Session ${session.id}: Error while sending initial data reports`,
        error instanceof MatterError ? error.message : error
      );
      if (error instanceof StatusResponseError && !(error instanceof ReceivedStatusResponseError)) {
        logger.info(`Sending status response ${error.code} for interaction error: ${error.message}`);
        await messenger.sendStatus(error.code, {
          logContext: {
            for: "I/SubscriptionSeed-Status"
          }
        });
      }
      await messenger.close();
      return;
    }
    const maxInterval = subscription.maxInterval;
    await messenger.send(
      MessageType.SubscribeResponse,
      TlvSubscribeResponse.encode({
        subscriptionId,
        maxInterval,
        interactionModelRevision: Specification.INTERACTION_MODEL_REVISION
      }),
      {
        logContext: {
          subId: subscriptionId,
          maxInterval
        }
      }
    );
    subscription.activate();
  }
  async #establishSubscription(id, {
    minIntervalFloorSeconds,
    maxIntervalCeilingSeconds,
    attributeRequests,
    dataVersionFilters,
    eventRequests,
    eventFilters,
    isFabricFiltered
  }, messenger, session, exchange, message) {
    const context = {
      session,
      structure: this.#endpointStructure,
      readAttribute: (path, attribute, offline) => this.readAttribute(path, attribute, exchange, isFabricFiltered, message, offline),
      readEndpointAttributesForSubscription: (attributes) => this.readEndpointAttributesForSubscription(attributes, exchange, isFabricFiltered, message),
      readEvent: (path, event, eventFilters2) => this.readEvent(path, eventFilters2, event, exchange, isFabricFiltered, message),
      initiateExchange: (address, protocolId) => this.#context.initiateExchange(address, protocolId)
    };
    const subscription = new ServerSubscription({
      id,
      context,
      criteria: {
        attributeRequests,
        dataVersionFilters,
        eventRequests,
        eventFilters,
        isFabricFiltered
      },
      minIntervalFloorSeconds,
      maxIntervalCeilingSeconds,
      subscriptionOptions: this.#subscriptionConfig
    });
    try {
      await subscription.sendInitialReport(messenger);
    } catch (error) {
      await subscription.close();
      throw error;
    }
    logger.info(
      `Successfully created subscription ${id} for Session ${session.id} to ${session.peerAddress}. Updates: ${minIntervalFloorSeconds} - ${maxIntervalCeilingSeconds} => ${subscription.maxInterval} seconds (sendInterval = ${subscription.sendInterval} seconds)`
    );
    return subscription;
  }
  async establishFormerSubscription({
    subscriptionId,
    attributeRequests,
    eventRequests,
    isFabricFiltered,
    minIntervalFloorSeconds,
    maxIntervalCeilingSeconds,
    maxInterval,
    sendInterval
  }, session) {
    const exchange = this.#context.initiateExchange(session.peerAddress, INTERACTION_PROTOCOL_ID);
    const message = {};
    logger.debug(
      `Send DataReports to re-establish subscription ${subscriptionId} to `,
      Diagnostic.dict({ isFabricFiltered, maxInterval, sendInterval })
    );
    const context = {
      session,
      structure: this.#endpointStructure,
      readAttribute: (path, attribute, offline) => this.readAttribute(path, attribute, exchange, isFabricFiltered, message, offline),
      readEndpointAttributesForSubscription: (attributes) => this.readEndpointAttributesForSubscription(attributes, exchange, isFabricFiltered, message),
      readEvent: (path, event, eventFilters) => this.readEvent(path, eventFilters, event, exchange, isFabricFiltered, message),
      initiateExchange: (address, protocolId) => this.#context.initiateExchange(address, protocolId)
    };
    const subscription = new ServerSubscription({
      id: subscriptionId,
      context,
      minIntervalFloorSeconds,
      maxIntervalCeilingSeconds,
      criteria: {
        attributeRequests,
        eventRequests,
        isFabricFiltered
      },
      subscriptionOptions: this.#subscriptionConfig,
      useAsMaxInterval: maxInterval,
      useAsSendInterval: sendInterval
    });
    try {
      await subscription.sendInitialReport(new InteractionServerMessenger(exchange));
      subscription.activate();
      logger.info(
        `Successfully re-established subscription ${subscriptionId} for Session ${session.id} to ${session.peerAddress}. Updates: ${minIntervalFloorSeconds} - ${maxIntervalCeilingSeconds} => ${subscription.maxInterval} seconds (sendInterval = ${subscription.sendInterval} seconds)`
      );
    } catch (error) {
      await subscription.close();
      throw error;
    }
    return subscription;
  }
  async handleInvokeRequest(exchange, { invokeRequests, timedRequest, suppressResponse, interactionModelRevision }, messenger, message) {
    logger.debug(
      `Received invoke request from ${exchange.channel.name}${invokeRequests.length > 0 ? ` with ${invokeRequests.length} commands` : ""}: ${invokeRequests.map(
        ({ commandPath: { endpointId, clusterId, commandId } }) => this.#endpointStructure.resolveCommandName({ endpointId, clusterId, commandId })
      ).join(", ")}, suppressResponse=${suppressResponse}`
    );
    if (interactionModelRevision > Specification.INTERACTION_MODEL_REVISION) {
      logger.debug(
        `Interaction model revision of sender ${interactionModelRevision} is higher than supported ${Specification.INTERACTION_MODEL_REVISION}.`
      );
    }
    const receivedWithinTimedInteraction = exchange.hasActiveTimedInteraction();
    if (exchange.hasExpiredTimedInteraction()) {
      exchange.clearTimedInteraction();
      throw new StatusResponseError(`Timed request window expired. Decline invoke request.`, StatusCode.Timeout);
    }
    if (timedRequest !== exchange.hasTimedInteraction()) {
      throw new StatusResponseError(
        `timedRequest flag of invoke interaction (${timedRequest}) mismatch with expected timed interaction (${receivedWithinTimedInteraction}).`,
        StatusCode.TimedRequestMismatch
      );
    }
    if (receivedWithinTimedInteraction) {
      logger.debug(`Invoke request from ${exchange.channel.name} received while timed interaction is running.`);
      exchange.clearTimedInteraction();
      if (message.packetHeader.sessionType !== SessionType.Unicast) {
        throw new StatusResponseError(
          "Invoke requests are only allowed on unicast sessions when a timed interaction is running.",
          StatusCode.InvalidAction
        );
      }
    }
    if (invokeRequests.length > this.#maxPathsPerInvoke) {
      throw new StatusResponseError(
        `Only ${this.#maxPathsPerInvoke} invoke requests are supported in one message. This message contains ${invokeRequests.length}`,
        StatusCode.InvalidAction
      );
    }
    invokeRequests.forEach(({ commandPath }) => validateCommandPath(commandPath));
    if (invokeRequests.length > 1) {
      const pathsUsed = /* @__PURE__ */ new Set();
      const commandRefsUsed = /* @__PURE__ */ new Set();
      invokeRequests.forEach(({ commandPath, commandRef }) => {
        if (!isConcreteCommandPath(commandPath)) {
          throw new StatusResponseError("Illegal wildcard path in batch invoke", StatusCode.InvalidAction);
        }
        const commandPathId = commandPathToId(commandPath);
        if (pathsUsed.has(commandPathId)) {
          throw new StatusResponseError(
            `Duplicate command path (${commandPathId}) in batch invoke`,
            StatusCode.InvalidAction
          );
        }
        if (commandRef === void 0) {
          throw new StatusResponseError(
            `Command reference missing in batch invoke of ${commandPathId}`,
            StatusCode.InvalidAction
          );
        }
        if (commandRefsUsed.has(commandRef)) {
          throw new StatusResponseError(
            `Duplicate command reference ${commandRef} in invoke of ${commandPathId}`,
            StatusCode.InvalidAction
          );
        }
        pathsUsed.add(commandPathId);
        commandRefsUsed.add(commandRef);
      });
    }
    const isGroupSession = message.packetHeader.sessionType === SessionType.Group;
    const invokeResponseMessage = {
      suppressResponse: false,
      // Deprecated but must be present
      interactionModelRevision: Specification.INTERACTION_MODEL_REVISION,
      invokeResponses: [],
      moreChunkedMessages: invokeRequests.length > 1
      // Assume for now we have multiple responses when having multiple invokes
    };
    const emptyInvokeResponseBytes = TlvInvokeResponseForSend.encode(invokeResponseMessage);
    let messageSize = emptyInvokeResponseBytes.length;
    let invokeResultsProcessed = 0;
    const processResponseResult = async (invokeResponse) => {
      invokeResultsProcessed++;
      if (isGroupSession) {
        return;
      }
      const encodedInvokeResponse = TlvInvokeResponseData.encodeTlv(invokeResponse);
      const invokeResponseBytes = TlvAny.getEncodedByteLength(encodedInvokeResponse);
      if (messageSize + invokeResponseBytes > exchange.maxPayloadSize || invokeResultsProcessed === invokeRequests.length) {
        let lastMessageProcessed = false;
        if (messageSize + invokeResponseBytes <= exchange.maxPayloadSize) {
          invokeResponseMessage.invokeResponses.push(encodedInvokeResponse);
          lastMessageProcessed = true;
        }
        if (invokeResponseMessage.invokeResponses.length > 0) {
          if (invokeRequests.length > 1) {
            logger.debug(
              `Send ${lastMessageProcessed ? "final " : ""}invoke response for ${invokeResponseMessage.invokeResponses} commands`
            );
          }
          const moreChunkedMessages = lastMessageProcessed ? void 0 : true;
          await messenger.send(
            MessageType.InvokeResponse,
            TlvInvokeResponseForSend.encode({
              ...invokeResponseMessage,
              moreChunkedMessages
            }),
            {
              logContext: {
                invokeMsgFlags: Diagnostic.asFlags({
                  suppressResponse,
                  moreChunkedMessages
                })
              }
            }
          );
          invokeResponseMessage.invokeResponses = [];
          messageSize = emptyInvokeResponseBytes.length;
        }
        if (!lastMessageProcessed) {
          invokeResultsProcessed--;
          return processResponseResult(invokeResponse);
        }
      } else {
        invokeResponseMessage.invokeResponses.push(encodedInvokeResponse);
        messageSize += invokeResponseBytes;
      }
    };
    for (const { commandPath, commandFields, commandRef } of invokeRequests) {
      const commands = this.#endpointStructure.getCommands([commandPath]);
      if (commands.length === 0) {
        if (isConcreteCommandPath(commandPath)) {
          const { endpointId, clusterId, commandId } = commandPath;
          let result;
          try {
            this.#endpointStructure.validateConcreteCommandPath(endpointId, clusterId, commandId);
            throw new InternalError(
              "validateConcreteCommandPath should throw StatusResponseError but did not."
            );
          } catch (e) {
            StatusResponseError.accept(e);
            logger.debug(
              `Invoke from ${exchange.channel.name}: ${this.#endpointStructure.resolveCommandName(
                commandPath
              )} unsupported path: Status=${e.code}`
            );
            result = { status: { commandPath, status: { status: e.code }, commandRef } };
          }
          await processResponseResult(result);
        } else {
          logger.debug(
            `Invoke from ${exchange.channel.name}: ${this.#endpointStructure.resolveCommandName(
              commandPath
            )} ignore non-existing command`
          );
        }
        continue;
      }
      const isConcretePath = isConcreteCommandPath(commandPath);
      for (const { command, path } of commands) {
        const { endpointId, clusterId, commandId } = path;
        if (endpointId === void 0) {
          logger.error(
            `Invoke from ${exchange.channel.name}: ${this.#endpointStructure.resolveCommandName(
              path
            )} invalid path because empty endpoint!`
          );
          if (isConcretePath) {
            await processResponseResult({
              status: {
                commandPath: path,
                status: { status: StatusCode.UnsupportedEndpoint },
                commandRef
              }
            });
          }
          continue;
        }
        const endpoint = this.#endpointStructure.getEndpoint(endpointId);
        if (endpoint === void 0) {
          logger.error(
            `Invoke from ${exchange.channel.name}: ${this.#endpointStructure.resolveCommandName(
              path
            )} invalid path because endpoint not found!`
          );
          if (isConcretePath) {
            await processResponseResult({
              status: {
                commandPath: path,
                status: { status: StatusCode.UnsupportedEndpoint },
                commandRef
              }
            });
          }
          continue;
        }
        if (command.requiresTimedInteraction && !receivedWithinTimedInteraction) {
          logger.debug(`This invoke requires a timed interaction which is not initialized.`);
          if (isConcretePath) {
            await processResponseResult({
              status: {
                commandPath: path,
                status: { status: StatusCode.NeedsTimedInteraction },
                commandRef
              }
            });
          }
          continue;
        }
        if (getMatterModelClusterCommand(clusterId, commandId)?.fabricScoped && (!exchange.session.isSecure || !exchange.session.fabric)) {
          logger.debug(`This invoke requires a secure session with a fabric assigned which is missing.`);
          if (isConcretePath) {
            await processResponseResult({
              status: { commandPath: path, status: { status: StatusCode.UnsupportedAccess }, commandRef }
            });
          }
          continue;
        }
        let result;
        try {
          result = await this.invokeCommand(
            path,
            command,
            exchange,
            commandFields ?? TlvNoArguments.encodeTlv(commandFields),
            message,
            endpoint,
            receivedWithinTimedInteraction
          );
        } catch (e) {
          StatusResponseError.accept(e);
          let errorCode = e.code;
          const errorLogText = `Error ${Diagnostic.hex(errorCode)}${e.clusterCode !== void 0 ? `/${Diagnostic.hex(e.clusterCode)}` : ""} while invoking command: ${e.message}`;
          if (e instanceof ValidationError) {
            logger.info(
              `Validation-${errorLogText}${e.fieldName !== void 0 ? ` in field ${e.fieldName}` : ""}`
            );
            if (errorCode === StatusCode.InvalidAction) {
              errorCode = StatusCode.InvalidCommand;
            }
          } else {
            logger.info(errorLogText);
          }
          result = {
            code: errorCode,
            clusterCode: e.clusterCode,
            responseId: command.responseId,
            response: TlvNoResponse.encodeTlv()
          };
        }
        const { code, clusterCode, responseId, response } = result;
        if (response.length === 0) {
          await processResponseResult({
            status: { commandPath: path, status: { status: code, clusterStatus: clusterCode }, commandRef }
          });
        } else {
          await processResponseResult({
            command: {
              commandPath: { ...path, commandId: responseId },
              commandFields: response,
              commandRef
            }
          });
        }
      }
    }
  }
  async invokeCommand(_path, command, exchange, commandFields, message, endpoint, _receivedWithinTimedInteraction = false) {
    return command.invoke(exchange.session, commandFields, message, endpoint);
  }
  handleTimedRequest(exchange, { timeout, interactionModelRevision }) {
    logger.debug(`Received timed request (${timeout}ms) from ${exchange.channel.name}`);
    if (interactionModelRevision > Specification.INTERACTION_MODEL_REVISION) {
      logger.debug(
        `Interaction model revision of sender ${interactionModelRevision} is higher than supported ${Specification.INTERACTION_MODEL_REVISION}.`
      );
    }
    exchange.startTimedInteraction(timeout);
  }
  async close() {
    this.#isClosing = true;
  }
  get #endpointStructure() {
    return this.#context.structure;
  }
}
export {
  InteractionServer,
  attributePathToId,
  clusterPathToId,
  commandPathToId,
  eventPathToId,
  genericElementPathToId,
  validateReadAttributesPath,
  validateReadEventPath
};
//# sourceMappingURL=InteractionServer.js.map
