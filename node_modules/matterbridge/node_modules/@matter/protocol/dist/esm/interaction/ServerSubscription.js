/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import {
  Diagnostic,
  InternalError,
  Logger,
  MatterAggregateError,
  MatterError,
  MaybePromise,
  NetworkError,
  NoResponseTimeoutError,
  Time,
  isObject
} from "#general";
import { Specification } from "#model";
import {
  EventNumber,
  INTERACTION_PROTOCOL_ID,
  StatusCode,
  StatusResponseError
} from "#types";
import { FabricScopedAttributeServer } from "../cluster/server/AttributeServer.js";
import { FabricSensitiveEventServer } from "../cluster/server/EventServer.js";
import { NoChannelError } from "../protocol/ChannelManager.js";
import { InteractionServerMessenger } from "./InteractionMessenger.js";
import {
  attributePathToId,
  clusterPathToId,
  eventPathToId
} from "./InteractionServer.js";
import { Subscription } from "./Subscription.js";
const logger = Logger.get("ServerSubscription");
const MAX_INTERVAL_PUBLISHER_LIMIT_S = 60 * 60;
const INTERNAL_INTERVAL_PUBLISHER_LIMIT_S = 3 * 60;
const MIN_INTERVAL_S = 2;
const DEFAULT_RANDOMIZATION_WINDOW_S = 10;
var ServerSubscriptionConfig;
((ServerSubscriptionConfig2) => {
  function of(options) {
    return {
      maxIntervalSeconds: options?.maxIntervalSeconds ?? INTERNAL_INTERVAL_PUBLISHER_LIMIT_S,
      minIntervalSeconds: Math.max(options?.minIntervalSeconds ?? MIN_INTERVAL_S, MIN_INTERVAL_S),
      randomizationWindowSeconds: options?.randomizationWindowSeconds ?? DEFAULT_RANDOMIZATION_WINDOW_S
    };
  }
  ServerSubscriptionConfig2.of = of;
})(ServerSubscriptionConfig || (ServerSubscriptionConfig = {}));
class ServerSubscription extends Subscription {
  #context;
  #structure;
  #lastUpdateTimeMs = 0;
  #updateTimer;
  #sendDelayTimer = Time.getTimer(
    `Subscription ${this.id} delay`,
    50,
    () => this.#triggerSendUpdate()
  );
  #outstandingAttributeUpdates = /* @__PURE__ */ new Map();
  #outstandingEventUpdates = /* @__PURE__ */ new Set();
  #attributeListeners = /* @__PURE__ */ new Map();
  #eventListeners = /* @__PURE__ */ new Map();
  #sendUpdatesActivated = false;
  #sendIntervalMs;
  #minIntervalFloorMs;
  #maxIntervalCeilingMs;
  #peerAddress;
  #sendNextUpdateImmediately = false;
  #sendUpdateErrorCounter = 0;
  #attributeUpdatePromises = /* @__PURE__ */ new Set();
  #currentUpdatePromise;
  constructor(options) {
    const {
      id,
      context,
      criteria,
      minIntervalFloorSeconds,
      maxIntervalCeilingSeconds,
      subscriptionOptions,
      useAsMaxInterval,
      useAsSendInterval
    } = options;
    super(context.session, id, criteria);
    this.#context = context;
    this.#structure = context.structure;
    this.#peerAddress = this.session.peerAddress;
    this.#minIntervalFloorMs = minIntervalFloorSeconds * 1e3;
    this.#maxIntervalCeilingMs = maxIntervalCeilingSeconds * 1e3;
    let maxInterval;
    let sendInterval;
    if (useAsMaxInterval !== void 0 && useAsSendInterval !== void 0) {
      maxInterval = useAsMaxInterval * 1e3;
      sendInterval = useAsSendInterval * 1e3;
    } else {
      ({ maxInterval, sendInterval } = this.#determineSendingIntervals(
        subscriptionOptions.minIntervalSeconds * 1e3,
        subscriptionOptions.maxIntervalSeconds * 1e3,
        subscriptionOptions.randomizationWindowSeconds * 1e3
      ));
    }
    this.maxIntervalMs = maxInterval;
    this.#sendIntervalMs = sendInterval;
    this.#updateTimer = Time.getTimer(
      `Subscription ${this.id} update`,
      this.#sendIntervalMs,
      () => this.#prepareDataUpdate()
    );
  }
  #determineSendingIntervals(subscriptionMinIntervalMs, subscriptionMaxIntervalMs, subscriptionRandomizationWindowMs) {
    const maxInterval = Math.min(
      Math.max(
        subscriptionMinIntervalMs,
        Math.max(this.#minIntervalFloorMs, Math.min(subscriptionMaxIntervalMs, this.#maxIntervalCeilingMs))
      ) + Math.floor(subscriptionRandomizationWindowMs * Math.random()),
      MAX_INTERVAL_PUBLISHER_LIMIT_S * 1e3
    );
    let sendInterval = Math.floor(maxInterval / 2);
    if (sendInterval < 6e4) {
      sendInterval = Math.max(this.#minIntervalFloorMs, Math.floor(maxInterval * 0.8));
    }
    if (sendInterval < subscriptionMinIntervalMs) {
      logger.warn(
        `Determined subscription send interval of ${sendInterval}ms is too low. Using maxInterval (${maxInterval}ms) instead.`
      );
      sendInterval = subscriptionMinIntervalMs;
    }
    return { maxInterval, sendInterval };
  }
  #registerNewAttributes() {
    const newAttributes = new Array();
    const attributeErrors = new Array();
    const formerAttributes = new Set(this.#attributeListeners.keys());
    if (this.criteria.attributeRequests !== void 0) {
      this.criteria.attributeRequests.forEach((path) => {
        const attributes = this.#structure.getAttributes([path]);
        if (attributes.length === 0) {
          const { endpointId, clusterId, attributeId } = path;
          if (endpointId === void 0 || clusterId === void 0 || attributeId === void 0) {
            logger.debug(
              `Subscription attribute ${this.#structure.resolveAttributeName(
                path
              )}: ignore non-existing attribute`
            );
          } else {
            try {
              this.#structure.validateConcreteAttributePath(endpointId, clusterId, attributeId);
              throw new InternalError(
                "validateConcreteAttributePath check should throw StatusResponseError but did not."
              );
            } catch (e) {
              StatusResponseError.accept(e);
              logger.debug(
                `Subscription attribute ${this.#structure.resolveAttributeName(
                  path
                )}: unsupported path: Status=${e.code}`
              );
              attributeErrors.push({ path, status: { status: e.code } });
            }
          }
          return;
        }
        attributes.forEach(({ path: path2, attribute }) => {
          formerAttributes.delete(attributePathToId(path2));
          const existingAttributeListener = this.#attributeListeners.get(attributePathToId(path2));
          if (existingAttributeListener !== void 0) {
            const { attribute: existingAttribute, listener: existingListener } = existingAttributeListener;
            if (existingAttribute !== attribute) {
              if (existingListener !== void 0) {
                existingAttribute.removeValueChangeListener(existingListener);
              }
              this.#attributeListeners.delete(attributePathToId(path2));
            } else {
              return;
            }
          }
          if (attribute.isSubscribable) {
            const listener = (value, version) => this.attributeChangeListener(path2, attribute.schema, version, value);
            attribute.addValueChangeListener(listener);
            this.#attributeListeners.set(attributePathToId(path2), { attribute, listener });
          } else {
            this.#attributeListeners.set(attributePathToId(path2), { attribute });
          }
          newAttributes.push({ path: path2, attribute });
        });
      });
    }
    this.unregisterAttributeListeners(Array.from(formerAttributes.values()));
    return { newAttributes, attributeErrors };
  }
  unregisterAttributeListeners(list) {
    for (const pathId of list) {
      const existingAttributeListener = this.#attributeListeners.get(pathId);
      if (existingAttributeListener !== void 0) {
        const { attribute, listener } = existingAttributeListener;
        if (listener !== void 0) {
          attribute.removeValueChangeListener(listener);
        }
        this.#attributeListeners.delete(pathId);
      }
    }
  }
  #registerNewEvents() {
    const newEvents = new Array();
    const eventErrors = new Array();
    const formerEvents = new Set(this.#eventListeners.keys());
    if (this.criteria.eventRequests !== void 0) {
      this.criteria.eventRequests.forEach((path) => {
        const events = this.#structure.getEvents([path]);
        if (events.length === 0) {
          const { endpointId, clusterId, eventId } = path;
          if (endpointId === void 0 || clusterId === void 0 || eventId === void 0) {
            logger.debug(
              `Subscription event ${this.#structure.resolveEventName(path)}: ignore non-existing event`
            );
          } else {
            try {
              this.#structure.validateConcreteEventPath(endpointId, clusterId, eventId);
              throw new InternalError(
                "validateConcreteEventPath should throw StatusResponseError but did not."
              );
            } catch (e) {
              StatusResponseError.accept(e);
              logger.debug(
                `Subscription event ${this.#structure.resolveEventName(
                  path
                )}: unsupported path: Status=${e.code}`
              );
              eventErrors.push({ path, status: { status: e.code } });
            }
          }
          return;
        }
        events.forEach(({ path: path2, event }) => {
          formerEvents.delete(eventPathToId(path2));
          const existingEventListener = this.#eventListeners.get(eventPathToId(path2));
          if (existingEventListener !== void 0) {
            const { event: existingEvent, listener: existingListener } = existingEventListener;
            if (existingEvent !== event) {
              if (existingListener !== void 0) {
                existingEvent.removeListener(existingListener);
              }
              this.#eventListeners.delete(eventPathToId(path2));
            } else {
              return;
            }
          }
          const listener = (newEvent) => this.eventChangeListener(path2, event.schema, newEvent);
          event.addListener(listener);
          newEvents.push({ path: path2, event });
          this.#eventListeners.set(eventPathToId(path2), { event, listener });
        });
      });
    }
    this.unregisterEventListeners(Array.from(formerEvents.values()));
    return { newEvents, eventErrors };
  }
  unregisterEventListeners(list) {
    for (const pathId of list) {
      const existingEventListener = this.#eventListeners.get(pathId);
      if (existingEventListener !== void 0) {
        const { event, listener } = existingEventListener;
        if (listener !== void 0) {
          event.removeListener(listener);
        }
        this.#eventListeners.delete(pathId);
      }
    }
  }
  /**
   * Update the session after an endpoint structure change. The method will initialize all missing new attributes and
   * events and will remove listeners no longer needed.
   * Newly added attributes are then treated as "changed values" and will be sent as subscription data update to the
   * controller. The data of newly added events are not sent automatically.
   */
  async updateSubscription() {
    const { newAttributes } = this.#registerNewAttributes();
    for (const { path, attribute } of newAttributes) {
      const { version, value } = this.#context.readAttribute(path, attribute);
      this.#outstandingAttributeUpdates.set(attributePathToId(path), {
        attribute,
        path,
        schema: attribute.schema,
        version,
        value
      });
    }
    const { newEvents } = this.#registerNewEvents();
    const occurrences = Array();
    for (const { path, event } of newEvents) {
      const { schema } = event;
      let eventOccurrences = event.get(
        this.session,
        this.criteria.isFabricFiltered,
        void 0,
        this.criteria.eventFilters
      );
      if (MaybePromise.is(eventOccurrences)) {
        eventOccurrences = await eventOccurrences;
      }
      occurrences.push(
        ...eventOccurrences.map((data) => ({
          event,
          schema,
          path,
          data
        }))
      );
    }
    occurrences.sort((a, b) => {
      const eventNumberA = a.data?.number ?? EventNumber(0);
      const eventNumberB = b.data?.number ?? EventNumber(0);
      if (eventNumberA > eventNumberB) {
        return 1;
      } else if (eventNumberA < eventNumberB) {
        return -1;
      } else {
        return 0;
      }
    });
    for (const occurrence of occurrences) {
      this.#outstandingEventUpdates.add(occurrence);
    }
    this.#prepareDataUpdate();
  }
  get sendInterval() {
    return Math.ceil(this.#sendIntervalMs / 1e3);
  }
  get minIntervalFloorSeconds() {
    return Math.ceil(this.#minIntervalFloorMs / 1e3);
  }
  get maxIntervalCeilingSeconds() {
    return Math.ceil(this.#maxIntervalCeilingMs / 1e3);
  }
  activate() {
    super.activate();
    if (this.criteria.eventFilters !== void 0) this.criteria.eventFilters.length = 0;
    if (this.criteria.dataVersionFilters !== void 0) this.criteria.dataVersionFilters.length = 0;
    this.#sendUpdatesActivated = true;
    if (this.#outstandingAttributeUpdates.size > 0 || this.#outstandingEventUpdates.size > 0) {
      this.#triggerSendUpdate();
    }
    this.#updateTimer = Time.getTimer(
      "Subscription update",
      this.#sendIntervalMs,
      () => this.#prepareDataUpdate()
    ).start();
    this.#structure.change.on(() => {
      if (this.isClosed) {
        return;
      }
      this.updateSubscription().catch(
        (error) => logger.error("Error updating subscription after structure change:", error)
      );
    });
  }
  /**
   * Check if data should be sent straight away or delayed because the minimum interval is not reached. Delay real
   * sending by 50ms in any case to mke sure to catch all updates.
   */
  #prepareDataUpdate() {
    if (this.#sendDelayTimer.isRunning || this.isClosed) {
      return;
    }
    if (!this.#sendUpdatesActivated) {
      return;
    }
    this.#updateTimer.stop();
    const now = Time.nowMs();
    const timeSinceLastUpdateMs = now - this.#lastUpdateTimeMs;
    if (timeSinceLastUpdateMs < this.#minIntervalFloorMs) {
      this.#updateTimer = Time.getTimer(
        "Subscription update",
        this.#minIntervalFloorMs - timeSinceLastUpdateMs,
        () => this.#prepareDataUpdate()
      ).start();
      return;
    }
    this.#sendDelayTimer.start();
    this.#updateTimer = Time.getTimer(
      `Subscription update ${this.id}`,
      this.#sendIntervalMs,
      () => this.#prepareDataUpdate()
    ).start();
  }
  #triggerSendUpdate() {
    if (this.#currentUpdatePromise !== void 0) {
      logger.debug("Sending update already in progress, delaying update ...");
      this.#sendNextUpdateImmediately = true;
      return;
    }
    this.#currentUpdatePromise = this.#sendUpdate().catch((error) => logger.warn("Sending subscription update failed:", error)).finally(() => this.#currentUpdatePromise = void 0);
  }
  /**
   * Determine all attributes that have changed since the last update and send them tout to the subscriber.
   * Important: This method MUST NOT be called directly. Use triggerSendUpdate() instead!
   */
  async #sendUpdate(onlyWithData = false) {
    const attributeUpdatesToSend = new Array();
    const attributeUpdates = {};
    Array.from(this.#outstandingAttributeUpdates.values()).forEach((entry) => {
      const {
        path: { nodeId, endpointId, clusterId }
      } = entry;
      const pathId = `${nodeId}-${endpointId}-${clusterId}`;
      attributeUpdates[pathId] = attributeUpdates[pathId] ?? [];
      attributeUpdates[pathId].push(entry);
    });
    this.#outstandingAttributeUpdates.clear();
    Object.values(attributeUpdates).forEach(
      (data) => attributeUpdatesToSend.push(
        ...data.sort(({ version: versionA }, { version: versionB }) => versionA - versionB)
      )
    );
    const eventUpdatesToSend = Array.from(this.#outstandingEventUpdates.values());
    this.#outstandingEventUpdates.clear();
    if (onlyWithData && attributeUpdatesToSend.length === 0 && eventUpdatesToSend.length === 0) {
      return;
    }
    this.#lastUpdateTimeMs = Time.nowMs();
    try {
      await this.#sendUpdateMessage(attributeUpdatesToSend, eventUpdatesToSend);
      this.#sendUpdateErrorCounter = 0;
    } catch (error) {
      if (this.isClosed) {
        return;
      }
      this.#sendUpdateErrorCounter++;
      logger.info(
        `Error sending subscription update message (error count=${this.#sendUpdateErrorCounter}):`,
        error instanceof MatterError && error.message || error
      );
      if (this.#sendUpdateErrorCounter <= 2) {
        const newAttributeUpdatesToSend = Array.from(this.#outstandingAttributeUpdates.values());
        this.#outstandingAttributeUpdates.clear();
        const newEventUpdatesToSend = Array.from(this.#outstandingEventUpdates.values());
        this.#outstandingEventUpdates.clear();
        [...attributeUpdatesToSend, ...newAttributeUpdatesToSend].forEach(
          (update) => this.#outstandingAttributeUpdates.set(attributePathToId(update.path), update)
        );
        [...eventUpdatesToSend, ...newEventUpdatesToSend].forEach(
          (update) => this.#outstandingEventUpdates.add(update)
        );
      } else {
        logger.info(
          `Sending update failed 3 times in a row, canceling subscription ${this.id} and let controller subscribe again.`
        );
        this.#sendNextUpdateImmediately = false;
        if (error instanceof NoResponseTimeoutError || error instanceof NetworkError || error instanceof NoChannelError) {
          this.isCanceledByPeer = true;
          await this.destroy();
          return;
        } else {
          throw error;
        }
      }
    }
    if (this.#sendNextUpdateImmediately) {
      logger.debug("Sending delayed update immediately after last one was sent.");
      this.#sendNextUpdateImmediately = false;
      await this.#sendUpdate(true);
    }
  }
  async #collectInitialEventReportPayloads(newEvents) {
    let eventsFiltered = false;
    const eventReportsPayload = new Array();
    for (const { path, event } of newEvents) {
      const { schema } = event;
      try {
        const matchingEvents = await this.#context.readEvent(path, event, this.criteria.eventFilters);
        if (matchingEvents.length === 0) {
          eventsFiltered = true;
        } else {
          matchingEvents.forEach(({ number, priority, epochTimestamp, payload }) => {
            eventReportsPayload.push({
              hasFabricSensitiveData: event.hasFabricSensitiveData,
              eventData: {
                path,
                eventNumber: number,
                priority,
                epochTimestamp,
                payload,
                schema
              }
            });
          });
        }
      } catch (error) {
        if (StatusResponseError.is(error, StatusCode.UnsupportedAccess)) {
          logger.warn(`Permission denied reading event ${this.#structure.resolveEventName(path)}`);
        } else {
          logger.warn(`Error reading event ${this.#structure.resolveEventName(path)}:`, error);
        }
      }
    }
    eventReportsPayload.sort((a, b) => {
      const eventNumberA = a.eventData?.eventNumber ?? 0;
      const eventNumberB = b.eventData?.eventNumber ?? 0;
      if (eventNumberA > eventNumberB) {
        return 1;
      } else if (eventNumberA < eventNumberB) {
        return -1;
      } else {
        return 0;
      }
    });
    return { eventReportsPayload, eventsFiltered };
  }
  /**
   * Returns an iterator that yields the initial subscription data to be sent to the controller.
   * The iterator will yield all attributes and events that match the subscription criteria.
   * A thrown exception will cancel the sending process immediately.
   * TODO: Streamline all this with the normal Read flow to also handle Concrete Path subscriptions with errors correctly
   */
  *#iterateInitialSubscriptionData(attributesToSend, eventsToSend) {
    const dataVersionFilterMap = new Map(
      this.criteria.dataVersionFilters?.map(({ path, dataVersion }) => [clusterPathToId(path), dataVersion]) ?? []
    );
    const { newAttributes, attributeErrors } = attributesToSend;
    const { eventReportsPayload, eventsFiltered, eventErrors } = eventsToSend;
    logger.debug(
      `Initializes Subscription with ${newAttributes.length} attributes and ${eventReportsPayload.length} events.`
    );
    let attributesFilteredWithVersion = false;
    const attributesPerCluster = /* @__PURE__ */ new Map();
    for (const { path, attribute } of newAttributes) {
      const { endpointId } = path;
      const endpointAttributes = attributesPerCluster.get(endpointId) ?? new Array();
      endpointAttributes.push({ path, attribute });
      attributesPerCluster.set(endpointId, endpointAttributes);
    }
    let attributesCounter = 0;
    for (const endpointId of attributesPerCluster.keys()) {
      const endpointAttributes = attributesPerCluster.get(endpointId);
      attributesPerCluster.delete(endpointId);
      for (const { path, attribute, value, version } of this.#context.readEndpointAttributesForSubscription(
        endpointAttributes
      )) {
        if (value === void 0) continue;
        const { nodeId, endpointId: endpointId2, clusterId } = path;
        const versionFilterValue = endpointId2 !== void 0 && clusterId !== void 0 ? dataVersionFilterMap.get(clusterPathToId({ nodeId, endpointId: endpointId2, clusterId })) : void 0;
        if (versionFilterValue !== void 0 && versionFilterValue === version) {
          attributesFilteredWithVersion = true;
          continue;
        }
        attributesCounter++;
        yield {
          hasFabricSensitiveData: attribute.hasFabricSensitiveData,
          attributeData: {
            path,
            dataVersion: version,
            payload: value,
            schema: attribute.schema
          }
        };
      }
    }
    for (const attributeStatus of attributeErrors) {
      yield {
        hasFabricSensitiveData: false,
        attributeStatus
      };
    }
    if (attributesCounter === 0 && !attributesFilteredWithVersion && eventReportsPayload.length === 0 && !eventsFiltered) {
      throw new StatusResponseError(
        "Subscription failed because no attributes or events are matching the query",
        StatusCode.InvalidAction
      );
    }
    for (const eventReport of eventReportsPayload) {
      yield eventReport;
    }
    for (const eventStatus of eventErrors) {
      yield {
        hasFabricSensitiveData: false,
        eventStatus
      };
    }
    this.#lastUpdateTimeMs = Time.nowMs();
  }
  async sendInitialReport(messenger) {
    this.#updateTimer.stop();
    const { newAttributes, attributeErrors } = this.#registerNewAttributes();
    const { newEvents, eventErrors } = this.#registerNewEvents();
    const { eventReportsPayload, eventsFiltered } = await this.#collectInitialEventReportPayloads(newEvents);
    await messenger.sendDataReport(
      {
        suppressResponse: false,
        // we always need proper response for initial report
        subscriptionId: this.id,
        interactionModelRevision: Specification.INTERACTION_MODEL_REVISION
      },
      this.criteria.isFabricFiltered,
      this.#iterateInitialSubscriptionData(
        { newAttributes, attributeErrors },
        { eventReportsPayload, eventsFiltered, eventErrors }
      )
    );
  }
  attributeChangeListener(path, schema, version, value) {
    const changeResult = this.attributeChangeHandler(path, schema, version, value);
    if (MaybePromise.is(changeResult)) {
      const resolver = Promise.resolve(changeResult).catch((error) => logger.error(`Error handling attribute change:`, error)).finally(() => this.#attributeUpdatePromises.delete(resolver));
      this.#attributeUpdatePromises.add(resolver);
    }
  }
  attributeChangeHandler(path, schema, version, value) {
    const attributeListenerData = this.#attributeListeners.get(attributePathToId(path));
    if (attributeListenerData === void 0) return;
    const { attribute } = attributeListenerData;
    if (attribute instanceof FabricScopedAttributeServer) {
      const { value: value2 } = this.#context.readAttribute(path, attribute, true);
      this.#outstandingAttributeUpdates.set(attributePathToId(path), {
        attribute,
        path,
        schema,
        version,
        value: value2
      });
      this.#prepareDataUpdate();
    }
    this.#outstandingAttributeUpdates.set(attributePathToId(path), { attribute, path, schema, version, value });
    this.#prepareDataUpdate();
  }
  eventChangeListener(path, schema, newEvent) {
    const eventListenerData = this.#eventListeners.get(eventPathToId(path));
    if (eventListenerData === void 0) return;
    const { event } = eventListenerData;
    if (event instanceof FabricSensitiveEventServer) {
      const { payload } = newEvent;
      if (isObject(payload) && "fabricIndex" in payload && payload.fabricIndex !== this.session.fabric?.fabricIndex) {
        return;
      }
    }
    this.#outstandingEventUpdates.add({ event, path, schema, data: newEvent });
    if (path.isUrgent) {
      this.#prepareDataUpdate();
    }
  }
  async #flush() {
    this.#sendDelayTimer.stop();
    if (this.#outstandingAttributeUpdates.size > 0 || this.#outstandingEventUpdates.size > 0) {
      logger.debug(
        `Flushing subscription ${this.id} with ${this.#outstandingAttributeUpdates.size} attributes and ${this.#outstandingEventUpdates.size} events${this.isClosed ? " (for closing)" : ""}`
      );
      this.#triggerSendUpdate();
      if (this.#currentUpdatePromise) {
        await this.#currentUpdatePromise;
      }
    }
  }
  async destroy() {
    this.#sendUpdatesActivated = false;
    this.unregisterAttributeListeners(Array.from(this.#attributeListeners.keys()));
    this.unregisterEventListeners(Array.from(this.#eventListeners.keys()));
    if (this.#attributeUpdatePromises.size) {
      const resolvers = [...this.#attributeUpdatePromises.values()];
      this.#attributeUpdatePromises.clear();
      await MatterAggregateError.allSettled(resolvers, "Error receiving all outstanding attribute values").catch(
        (error) => logger.error(error)
      );
    }
    this.#updateTimer.stop();
    this.#sendDelayTimer.stop();
    await super.destroy();
  }
  /**
   * Closes the subscription and flushes all outstanding data updates if requested.
   */
  async close(graceful = false, cancelledByPeer = false) {
    if (this.isClosed) {
      return;
    }
    if (cancelledByPeer) {
      this.isCanceledByPeer = true;
    }
    await this.destroy();
    if (graceful) {
      await this.#flush();
    }
    if (this.#currentUpdatePromise) {
      await this.#currentUpdatePromise;
    }
  }
  /**
   * Iterates over all attributes and events that have changed since the last update and sends them to
   * the controller.
   * A thrown exception will cancel the sending process immediately.
   */
  *#iterateDataUpdate(attributes, events) {
    for (const {
      path,
      schema,
      value: payload,
      version: dataVersion,
      attribute: { hasFabricSensitiveData }
    } of attributes) {
      yield {
        hasFabricSensitiveData,
        attributeData: { path, dataVersion, schema, payload }
      };
    }
    for (const {
      path,
      schema,
      event,
      data: { number: eventNumber, priority, epochTimestamp, payload }
    } of events) {
      yield {
        hasFabricSensitiveData: event.hasFabricSensitiveData,
        eventData: { path, eventNumber, priority, epochTimestamp, schema, payload }
      };
    }
  }
  async #sendUpdateMessage(attributes, events) {
    const exchange = this.#context.initiateExchange(this.#peerAddress, INTERACTION_PROTOCOL_ID);
    if (exchange === void 0) return;
    if (attributes.length) {
      logger.debug(
        `Subscription attribute changes for ID ${this.id}: ${attributes.map(
          ({ path, value, version }) => `${this.#structure.resolveAttributeName(path)}=${Diagnostic.json(value)} (${version})`
        ).join(", ")}`
      );
    }
    const messenger = new InteractionServerMessenger(exchange);
    try {
      if (attributes.length === 0 && events.length === 0) {
        await messenger.sendDataReport(
          {
            suppressResponse: true,
            // suppressResponse true for empty DataReports
            subscriptionId: this.id,
            interactionModelRevision: Specification.INTERACTION_MODEL_REVISION
          },
          this.criteria.isFabricFiltered,
          void 0,
          !this.isClosed
          // Do not wait for ack when closed
        );
      } else {
        await messenger.sendDataReport(
          {
            suppressResponse: false,
            // Non-empty data reports always need to send response
            subscriptionId: this.id,
            interactionModelRevision: Specification.INTERACTION_MODEL_REVISION
          },
          this.criteria.isFabricFiltered,
          this.#iterateDataUpdate(attributes, events),
          !this.isClosed
          // Do not wait for ack when closed
        );
      }
    } catch (error) {
      if (StatusResponseError.is(error, StatusCode.InvalidSubscription, StatusCode.Failure)) {
        logger.info(`Subscription ${this.id} cancelled by peer.`);
        this.isCanceledByPeer = true;
        await this.close(false);
      } else {
        StatusResponseError.accept(error);
        logger.info(`Subscription ${this.id} update failed:`, error);
        await this.close(false);
      }
    } finally {
      await messenger.close();
    }
  }
}
export {
  DEFAULT_RANDOMIZATION_WINDOW_S,
  INTERNAL_INTERVAL_PUBLISHER_LIMIT_S,
  MAX_INTERVAL_PUBLISHER_LIMIT_S,
  MIN_INTERVAL_S,
  ServerSubscription,
  ServerSubscriptionConfig
};
//# sourceMappingURL=ServerSubscription.js.map
