/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { AsyncObservable } from "#general";
import { type SecureSession } from "#session/SecureSession.js";
import { TlvAttributePath, TlvDataVersionFilter, TlvEventFilter, TlvEventPath, TypeFromSchema } from "#types";
export type SubscriptionId = number;
export interface SubscriptionCriteria {
    attributeRequests?: TypeFromSchema<typeof TlvAttributePath>[];
    dataVersionFilters?: TypeFromSchema<typeof TlvDataVersionFilter>[];
    eventRequests?: TypeFromSchema<typeof TlvEventPath>[];
    eventFilters?: TypeFromSchema<typeof TlvEventFilter>[];
    isFabricFiltered: boolean;
}
/**
 * A single active subscription.
 */
export declare abstract class Subscription {
    #private;
    constructor(session: SecureSession, id: SubscriptionId, criteria: SubscriptionCriteria);
    get id(): number;
    get criteria(): SubscriptionCriteria;
    get isClosed(): boolean;
    get isCanceledByPeer(): boolean;
    get session(): SecureSession;
    get cancelled(): AsyncObservable<[subscription: Subscription], void>;
    get maxIntervalMs(): number;
    set maxIntervalMs(value: number);
    get maxInterval(): number;
    /**
     * Update session state.  This probably is meaningless except in a server context.
     */
    update(): Promise<void>;
    /**
     * This flag is set on closed sessions when the close was initiated by the peer.
     */
    protected set isCanceledByPeer(value: boolean);
    protected set isClosed(value: boolean);
    /** Close the subscription with the option to gracefully flush outstanding data. */
    abstract close(graceful: boolean, cancelledByPeer?: boolean): Promise<void>;
    /**
     * Destroy the subscription. Unsubscribe from all attributes and events and stop all timers.
     */
    protected destroy(): Promise<void>;
    protected activate(): void;
}
//# sourceMappingURL=Subscription.d.ts.map