/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Environmental, Logger, Time } from "@matter/general";
import { INTERACTION_PROTOCOL_ID } from "@matter/types";
import { IncomingInteractionClientMessenger } from "./InteractionMessenger.js";
const logger = Logger.get("SubscriptionClient");
class SubscriptionClient {
  #listeners = /* @__PURE__ */ new Map();
  #timeouts = /* @__PURE__ */ new Map();
  constructor() {
  }
  static [Environmental.create](env) {
    const client = new SubscriptionClient();
    env.set(SubscriptionClient, client);
    return client;
  }
  id = INTERACTION_PROTOCOL_ID;
  /**
   * Register a subscription.
   */
  add(subscription) {
    const { id, onData, onTimeout } = subscription;
    this.#listeners.set(id, onData);
    if (onTimeout) {
      let timer = this.#timeouts.get(id);
      if (timer !== void 0) {
        timer.stop();
        this.#timeouts.delete(id);
      }
      const maxIntervalMs = subscription.maxIntervalS * 1e3 + subscription.maximumPeerResponseTime;
      timer = Time.getTimer("Subscription timeout", maxIntervalMs, () => {
        logger.info(`Subscription ${id} timed out after ${maxIntervalMs}ms`);
        this.delete(id);
        onTimeout();
      }).start();
      this.#timeouts.set(id, timer);
    }
  }
  /**
   * Unregister a subscription.
   */
  delete(id) {
    this.#listeners.delete(id);
    const timer = this.#timeouts.get(id);
    if (timer !== void 0) {
      timer.stop();
      this.#timeouts.delete(id);
    }
  }
  async onNewExchange(exchange) {
    const messenger = new IncomingInteractionClientMessenger(exchange);
    let dataReport;
    try {
      dataReport = await messenger.readAggregateDataReport([...this.#listeners.keys()]);
    } finally {
      messenger.close().catch((error) => logger.info("Error closing client messenger", error));
    }
    const subscriptionId = dataReport.subscriptionId;
    const listener = this.#listeners.get(subscriptionId);
    const timer = this.#timeouts.get(subscriptionId);
    if (timer !== void 0) {
      timer.stop().start();
    }
    await listener?.(dataReport);
  }
  async close() {
    this.#listeners.clear();
    this.#timeouts.forEach((timer) => timer.stop());
    this.#timeouts.clear();
  }
}
export {
  SubscriptionClient
};
//# sourceMappingURL=SubscriptionClient.js.map
