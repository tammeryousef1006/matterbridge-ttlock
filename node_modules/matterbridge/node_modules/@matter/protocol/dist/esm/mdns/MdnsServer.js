/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import {
  AsyncCache,
  Diagnostic,
  DnsCodec,
  DnsMessageType,
  DnsRecordType,
  isDeepEqual,
  Logger,
  MatterAggregateError,
  MAX_MDNS_MESSAGE_SIZE,
  Time,
  UdpMulticastServer
} from "#general";
const logger = Logger.get("MdnsServer");
const MDNS_BROADCAST_IPV4 = "224.0.0.251";
const MDNS_BROADCAST_IPV6 = "ff02::fb";
const MDNS_BROADCAST_PORT = 5353;
var AnnouncementType = /* @__PURE__ */ ((AnnouncementType2) => {
  AnnouncementType2[AnnouncementType2["Commissionable"] = 0] = "Commissionable";
  AnnouncementType2[AnnouncementType2["Operative"] = 1] = "Operative";
  return AnnouncementType2;
})(AnnouncementType || {});
class MdnsServer {
  static async create(network, options) {
    const { enableIpv4 = true, netInterface } = options ?? {};
    return new MdnsServer(
      network,
      await UdpMulticastServer.create({
        network,
        netInterface,
        broadcastAddressIpv4: enableIpv4 ? MDNS_BROADCAST_IPV4 : void 0,
        broadcastAddressIpv6: MDNS_BROADCAST_IPV6,
        listeningPort: MDNS_BROADCAST_PORT
      }),
      netInterface
    );
  }
  #recordsGenerator = /* @__PURE__ */ new Map();
  #records = new AsyncCache(
    "MDNS discovery",
    async (multicastInterface) => {
      const portTypeMap = /* @__PURE__ */ new Map();
      for (const [announceTypePort, generator] of this.#recordsGenerator) {
        portTypeMap.set(announceTypePort, await generator(multicastInterface));
      }
      return portTypeMap;
    },
    15 * 60 * 1e3
  );
  #recordLastSentAsMulticastAnswer = /* @__PURE__ */ new Map();
  #recordLastSentAsUnicastAnswer = /* @__PURE__ */ new Map();
  #network;
  #multicastServer;
  #netInterface;
  constructor(network, multicastServer, netInterface) {
    multicastServer.onMessage(
      (message, remoteIp, netInterface2) => void this.#handleDnsMessage(message, remoteIp, netInterface2)
    );
    this.#network = network;
    this.#multicastServer = multicastServer;
    this.#netInterface = netInterface;
  }
  buildDnsRecordKey(record, netInterface, unicastTarget) {
    return `${record.name}-${record.recordClass}-${record.recordType}-${netInterface}-${unicastTarget}`;
  }
  buildTypePortKey(type, port) {
    return `${port}-${type}`;
  }
  isKeyForPort(key, port) {
    return key.startsWith(`${port}-`);
  }
  async #handleDnsMessage(messageBytes, remoteIp, netInterface) {
    if (netInterface === void 0) return;
    const records = await this.#records.get(netInterface);
    if (records.size === 0) return;
    const message = DnsCodec.decode(messageBytes);
    if (message === void 0) return;
    const { transactionId, messageType, queries, answers: knownAnswers } = message;
    if (messageType !== DnsMessageType.Query && messageType !== DnsMessageType.TruncatedQuery) return;
    if (queries.length === 0) return;
    for (const portRecords of records.values()) {
      let answers = queries.flatMap((query) => this.#queryRecords(query, portRecords));
      if (answers.length === 0) continue;
      let additionalRecords = queries.find(
        (query) => query.recordType !== DnsRecordType.A && query.recordType !== DnsRecordType.AAAA
      ) !== void 0 ? portRecords.filter((record) => !answers.includes(record) && record.recordType !== DnsRecordType.PTR) : [];
      if (knownAnswers.length > 0) {
        for (const knownAnswersRecord of knownAnswers) {
          answers = answers.filter((record) => !isDeepEqual(record, knownAnswersRecord, true));
          if (answers.length === 0) break;
        }
        if (answers.length === 0) continue;
        if (additionalRecords.length > 0) {
          for (const knownAnswersRecord of knownAnswers) {
            additionalRecords = additionalRecords.filter(
              (record) => !isDeepEqual(record, knownAnswersRecord, true)
            );
          }
        }
      }
      const now = Time.nowMs();
      let uniCastResponse = queries.filter((query) => !query.uniCastResponse).length === 0;
      const answersTimeSinceLastSent = answers.map((answer) => ({
        timeSinceLastMultiCast: now - (this.#recordLastSentAsMulticastAnswer.get(this.buildDnsRecordKey(answer, netInterface)) ?? 0),
        timeSinceLastUniCast: now - (this.#recordLastSentAsUnicastAnswer.get(this.buildDnsRecordKey(answer, netInterface, remoteIp)) ?? 0),
        ttl: answer.ttl
      }));
      if (uniCastResponse && answersTimeSinceLastSent.some(
        ({ timeSinceLastMultiCast, ttl }) => timeSinceLastMultiCast > ttl / 4 * 1e3
      )) {
        uniCastResponse = false;
      }
      if (!uniCastResponse) {
        answers = answers.filter((_, index) => answersTimeSinceLastSent[index].timeSinceLastMultiCast > 1e3);
        if (answers.length === 0) continue;
        answers.forEach(
          (answer) => this.#recordLastSentAsMulticastAnswer.set(this.buildDnsRecordKey(answer, netInterface), now)
        );
      } else {
        answers = answers.filter((_, index) => answersTimeSinceLastSent[index].timeSinceLastUniCast > 1e3);
        if (answers.length === 0) continue;
        answers.forEach(
          (answer) => this.#recordLastSentAsUnicastAnswer.set(
            this.buildDnsRecordKey(answer, netInterface, remoteIp),
            now
          )
        );
      }
      this.#sendRecords(
        {
          messageType: DnsMessageType.Response,
          transactionId,
          answers,
          additionalRecords
        },
        netInterface,
        uniCastResponse ? remoteIp : void 0
      ).catch((error) => {
        logger.warn(`Failed to send mDNS response to ${remoteIp}`, error);
      });
      await Time.sleep("MDNS delay", 20 + Math.floor(Math.random() * 100));
    }
  }
  async #announceRecordsForInterface(netInterface, records) {
    const answers = records.filter(({ recordType }) => recordType === DnsRecordType.PTR);
    const additionalRecords = records.filter(({ recordType }) => recordType !== DnsRecordType.PTR);
    await this.#sendRecords(
      {
        messageType: DnsMessageType.Response,
        answers,
        additionalRecords
      },
      netInterface
    );
  }
  async #sendRecords(dnsMessageData, netInterface, unicastTarget) {
    const { answers = [], additionalRecords = [] } = dnsMessageData;
    const answersToSend = [...answers];
    const additionalRecordsToSend = [...additionalRecords];
    const dnsMessageDataToSend = {
      ...dnsMessageData,
      answers: [],
      additionalRecords: []
    };
    const emptyDnsMessage = DnsCodec.encode(dnsMessageDataToSend);
    let dnsMessageSize = emptyDnsMessage.length;
    while (true) {
      if (answersToSend.length > 0) {
        const nextAnswer = answersToSend.shift();
        if (nextAnswer === void 0) {
          break;
        }
        const nextAnswerEncoded = DnsCodec.encodeRecord(nextAnswer);
        dnsMessageSize += nextAnswerEncoded.length;
        if (dnsMessageSize > MAX_MDNS_MESSAGE_SIZE) {
          await this.#multicastServer.send(
            DnsCodec.encode(dnsMessageDataToSend),
            netInterface,
            unicastTarget
          );
          dnsMessageDataToSend.answers.length = 0;
          dnsMessageSize = emptyDnsMessage.length + nextAnswerEncoded.length;
        }
        dnsMessageDataToSend.answers.push(nextAnswerEncoded);
      } else {
        break;
      }
    }
    for (const additionalRecord of additionalRecordsToSend) {
      const additionalRecordEncoded = DnsCodec.encodeRecord(additionalRecord);
      dnsMessageSize += additionalRecordEncoded.length;
      if (dnsMessageSize > MAX_MDNS_MESSAGE_SIZE) {
        break;
      }
      dnsMessageDataToSend.additionalRecords.push(additionalRecordEncoded);
    }
    await this.#multicastServer.send(DnsCodec.encode(dnsMessageDataToSend), netInterface, unicastTarget);
  }
  async announce(announcedNetPort) {
    await MatterAggregateError.allSettled(
      (await this.#getMulticastInterfacesForAnnounce()).map(async ({ name: netInterface }) => {
        const records = await this.#records.get(netInterface);
        for (const [portType, portTypeRecords] of records) {
          if (announcedNetPort !== void 0 && !this.isKeyForPort(portType, announcedNetPort)) continue;
          await this.#announceRecordsForInterface(netInterface, portTypeRecords);
          await Time.sleep("MDNS delay", 20 + Math.floor(Math.random() * 100));
        }
      }),
      "Error happened when announcing MDNS messages"
    ).catch((error) => logger.error(error));
  }
  async expireAnnouncements(options) {
    const { announcedNetPort, type, forInstance: instanceToExpire } = options ?? {};
    await MatterAggregateError.allSettled(
      this.#records.keys().map(async (netInterface) => {
        const records = await this.#records.get(netInterface);
        for (const [portType, portTypeRecords] of records) {
          if (announcedNetPort !== void 0 && !this.isKeyForPort(portType, announcedNetPort)) continue;
          if (announcedNetPort !== void 0 && type !== void 0 && portType !== this.buildTypePortKey(type, announcedNetPort))
            continue;
          const recordsToProcess = instanceToExpire !== void 0 ? portTypeRecords.filter(
            ({ forInstance }) => forInstance !== void 0 && instanceToExpire === forInstance
          ) : portTypeRecords;
          const instanceSet = /* @__PURE__ */ new Set();
          recordsToProcess.forEach((record) => {
            record.ttl = 0;
            if (record.recordType === DnsRecordType.TXT) {
              instanceSet.add(record.name);
            }
          });
          const instanceName = instanceSet.size > 1 ? "multiple" : instanceSet.size === 1 ? Array.from(instanceSet.values())[0] : "";
          logger.debug(
            `Expiring records`,
            Diagnostic.dict({
              instanceName,
              port: announcedNetPort,
              netInterface
            })
          );
          await this.#announceRecordsForInterface(netInterface, portTypeRecords);
          this.#recordsGenerator.delete(portType);
          await Time.sleep("MDNS delay", 20 + Math.floor(Math.random() * 100));
        }
      }),
      "Error happened when expiring MDNS announcements"
    ).catch((error) => logger.error(error));
    await this.#records.clear();
    this.#recordLastSentAsMulticastAnswer.clear();
    this.#recordLastSentAsUnicastAnswer.clear();
  }
  async setRecordsGenerator(hostPort, type, generator) {
    await this.#records.clear();
    this.#recordLastSentAsMulticastAnswer.clear();
    this.#recordLastSentAsUnicastAnswer.clear();
    this.#recordsGenerator.set(this.buildTypePortKey(type, hostPort), generator);
  }
  async close() {
    await this.#records.close();
    this.#recordLastSentAsMulticastAnswer.clear();
    this.#recordLastSentAsUnicastAnswer.clear();
    await this.#multicastServer.close();
  }
  #getMulticastInterfacesForAnnounce() {
    return this.#netInterface === void 0 ? this.#network.getNetInterfaces() : [{ name: this.#netInterface }];
  }
  #queryRecords({ name, recordType }, records) {
    if (recordType === DnsRecordType.ANY) {
      return records.filter((record) => record.name === name);
    } else {
      return records.filter((record) => record.name === name && record.recordType === recordType);
    }
  }
}
export {
  AnnouncementType,
  MDNS_BROADCAST_IPV4,
  MDNS_BROADCAST_IPV6,
  MDNS_BROADCAST_PORT,
  MdnsServer
};
//# sourceMappingURL=MdnsServer.js.map
