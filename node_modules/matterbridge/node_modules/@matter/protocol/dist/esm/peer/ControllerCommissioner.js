/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { CertificateAuthority } from "#certificate/CertificateAuthority.js";
import { GeneralCommissioning } from "#clusters/general-commissioning";
import { ScannerSet } from "#common/Scanner.js";
import {
  ChannelType,
  Diagnostic,
  Environmental,
  isIPv6,
  Logger,
  NetInterfaceSet,
  NoResponseTimeoutError,
  serverAddressToString
} from "#general";
import { MdnsScanner } from "#mdns/MdnsScanner.js";
import {
  CommissioningError,
  ControllerCommissioningFlow
} from "#peer/ControllerCommissioningFlow.js";
import { ControllerDiscovery, PairRetransmissionLimitReachedError } from "#peer/ControllerDiscovery.js";
import { ChannelStatusResponseError } from "#securechannel/index.js";
import { PaseClient } from "#session/index.js";
import { SessionManager } from "#session/SessionManager.js";
import { NodeId, SECURE_CHANNEL_PROTOCOL_ID } from "#types";
import { InteractionClient, InteractionClientProvider } from "../interaction/InteractionClient.js";
import { ExchangeManager, MessageChannel } from "../protocol/ExchangeManager.js";
import { DedicatedChannelExchangeProvider } from "../protocol/ExchangeProvider.js";
import { NodeDiscoveryType, PeerSet } from "./PeerSet.js";
const logger = Logger.get("PeerCommissioner");
class ControllerCommissioner {
  #context;
  #paseClient;
  constructor(context) {
    this.#context = context;
    this.#paseClient = new PaseClient(context.sessions);
  }
  static [Environmental.create](env) {
    const instance = new ControllerCommissioner({
      peers: env.get(PeerSet),
      clients: env.get(InteractionClientProvider),
      scanners: env.get(ScannerSet),
      netInterfaces: env.get(NetInterfaceSet),
      sessions: env.get(SessionManager),
      exchanges: env.get(ExchangeManager),
      ca: env.get(CertificateAuthority)
    });
    env.set(ControllerCommissioner, instance);
    return instance;
  }
  /**
   * Commmission a previously discovered node.
   */
  async commission(options) {
    const { passcode, addresses, discoveryData, fabric, nodeId } = options;
    if (nodeId !== void 0) {
      this.#assertPeerAddress(fabric.addressOf(nodeId));
    }
    addresses.sort((a) => a.type === "udp" ? -1 : 1);
    let channel;
    for (const address of addresses) {
      try {
        channel = await this.#initializePaseSecureChannel(address, passcode, discoveryData);
      } catch (e) {
        NoResponseTimeoutError.accept(e);
        logger.warn(`Could not connect to ${serverAddressToString(address)}: ${e.message}`);
      }
    }
    if (channel === void 0) {
      throw new NoResponseTimeoutError("Could not connect to device");
    }
    return await this.#commissionConnectedNode(channel, options, discoveryData);
  }
  /**
   * Discover and establish a PASE channel with a device.
   */
  async discoverAndEstablishPase(options) {
    const {
      discovery: { timeoutSeconds = 30 },
      passcode
    } = options;
    const commissionableDevice = "commissionableDevice" in options.discovery ? options.discovery.commissionableDevice : void 0;
    let {
      discovery: { discoveryCapabilities = {}, knownAddress }
    } = options;
    let identifierData = "identifierData" in options.discovery ? options.discovery.identifierData : {};
    if (this.#context.scanners.hasScannerFor(ChannelType.UDP) && this.#context.netInterfaces.hasInterfaceFor(ChannelType.UDP, "::") !== void 0) {
      discoveryCapabilities.onIpNetwork = true;
    }
    if (commissionableDevice !== void 0) {
      let { addresses } = commissionableDevice;
      if (discoveryCapabilities.ble === true) {
        discoveryCapabilities = { onIpNetwork: true, ble: addresses.some((address) => address.type === "ble") };
      } else if (discoveryCapabilities.onIpNetwork === true) {
        addresses = addresses.filter((address) => address.type !== "ble");
      }
      addresses.sort((a) => a.type === "udp" ? -1 : 1);
      knownAddress = addresses[0];
      if ("instanceId" in commissionableDevice && commissionableDevice.instanceId !== void 0) {
        identifierData = { instanceId: commissionableDevice.instanceId };
      } else {
        identifierData = { longDiscriminator: commissionableDevice.D };
      }
    }
    const scannersToUse = this.#context.scanners.select(discoveryCapabilities);
    logger.info(
      `Connecting to device with identifier ${Diagnostic.json(identifierData)} and ${scannersToUse.length} scanners and knownAddress ${Diagnostic.json(knownAddress)}`
    );
    let paseSecureChannel;
    let discoveryData;
    if (knownAddress !== void 0) {
      try {
        paseSecureChannel = await this.#initializePaseSecureChannel(knownAddress, passcode);
      } catch (error) {
        NoResponseTimeoutError.accept(error);
      }
    }
    if (paseSecureChannel === void 0) {
      const discoveredDevices = await ControllerDiscovery.discoverDeviceAddressesByIdentifier(
        scannersToUse,
        identifierData,
        timeoutSeconds
      );
      const { result } = await ControllerDiscovery.iterateServerAddresses(
        discoveredDevices,
        NoResponseTimeoutError,
        async () => scannersToUse.flatMap((scanner) => scanner.getDiscoveredCommissionableDevices(identifierData)),
        async (address, device) => {
          const channel = await this.#initializePaseSecureChannel(address, passcode, device);
          discoveryData = device;
          return channel;
        }
      );
      paseSecureChannel = result;
    }
    return { paseSecureChannel, discoveryData };
  }
  /**
   * Commission a node with discovery.
   */
  async commissionWithDiscovery(options) {
    const { fabric, nodeId } = options;
    if (nodeId !== void 0) {
      this.#assertPeerAddress(fabric.addressOf(nodeId));
    }
    const { paseSecureChannel, discoveryData } = await this.discoverAndEstablishPase(options);
    return await this.#commissionConnectedNode(paseSecureChannel, options, discoveryData);
  }
  /**
   * Method to start commission process with a PASE pairing.
   * If this not successful and throws an RetransmissionLimitReachedError the address is invalid or the passcode
   * is wrong.
   */
  async #initializePaseSecureChannel(address, passcode, device) {
    let paseChannel;
    if (device !== void 0) {
      logger.info(`Establish PASE to device`, MdnsScanner.discoveryDataDiagnostics(device));
    }
    if (address.type === "udp") {
      const { ip } = address;
      const isIpv6Address = isIPv6(ip);
      const paseInterface = this.#context.netInterfaces.interfaceFor(
        ChannelType.UDP,
        isIpv6Address ? "::" : "0.0.0.0"
      );
      if (paseInterface === void 0) {
        throw new PairRetransmissionLimitReachedError(
          `IPv${isIpv6Address ? "6" : "4"} interface not initialized. Cannot use ${ip} for commissioning.`
        );
      }
      paseChannel = await paseInterface.openChannel(address);
    } else {
      const ble = this.#context.netInterfaces.interfaceFor(ChannelType.BLE);
      if (!ble) {
        throw new PairRetransmissionLimitReachedError(
          `BLE interface not initialized. Cannot use ${address.peripheralAddress} for commissioning.`
        );
      }
      paseChannel = await ble.openChannel(address);
    }
    const unsecureSession = this.#context.sessions.createInsecureSession({
      // Use the session parameters from MDNS announcements when available and rest is assumed to be fallbacks
      sessionParameters: {
        idleIntervalMs: device?.SII,
        activeIntervalMs: device?.SAI,
        activeThresholdMs: device?.SAT
      },
      isInitiator: true
    });
    const paseUnsecureMessageChannel = new MessageChannel(paseChannel, unsecureSession);
    const paseExchange = this.#context.exchanges.initiateExchangeWithChannel(
      paseUnsecureMessageChannel,
      SECURE_CHANNEL_PROTOCOL_ID
    );
    let paseSecureSession;
    try {
      paseSecureSession = await this.#paseClient.pair(
        this.#context.sessions.sessionParameters,
        paseExchange,
        passcode
      );
    } catch (e) {
      await paseExchange.close();
      if (e instanceof ChannelStatusResponseError) {
        throw new NoResponseTimeoutError(
          `Establishing PASE channel failed with channel status response error ${e.message}`
        );
      }
      throw e;
    }
    await unsecureSession.destroy();
    return new MessageChannel(paseChannel, paseSecureSession);
  }
  /** Validate if a Peert Address is already known and commissioned */
  #assertPeerAddress(address) {
    if (this.#context.peers.has(address)) {
      throw new CommissioningError(`Node ID ${address.nodeId} is already commissioned and can not be reused.`);
    }
  }
  /** Finds an unused random Node-ID to use for commissioning if not already provided. */
  #determineAddress(fabric, nodeId) {
    while (true) {
      const address = fabric.addressOf(nodeId ?? NodeId.randomOperationalNodeId());
      try {
        this.#assertPeerAddress(address);
      } catch (error) {
        if (error instanceof CommissioningError && nodeId !== void 0) {
          throw error;
        }
        continue;
      }
      return address;
    }
  }
  /**
   * Method to commission a device with a PASE secure channel. It returns the NodeId of the commissioned device on
   * success.
   */
  async #commissionConnectedNode(paseSecureMessageChannel, options, discoveryData) {
    const {
      fabric,
      finalizeCommissioning: performCaseCommissioning,
      commissioningFlowImpl = ControllerCommissioningFlow
    } = options;
    const commissioningOptions = {
      regulatoryLocation: GeneralCommissioning.RegulatoryLocationType.Outdoor,
      // Set to the most restrictive if relevant
      regulatoryCountryCode: "XX",
      ...options
    };
    const address = this.#determineAddress(fabric, commissioningOptions.nodeId);
    logger.info(
      `Start commissioning of node ${address.nodeId} into fabric ${fabric.fabricId} (index ${address.fabricIndex})`
    );
    const commissioningManager = new commissioningFlowImpl(
      // Use the created secure session to do the commissioning
      new InteractionClient(
        new DedicatedChannelExchangeProvider(this.#context.exchanges, paseSecureMessageChannel),
        this.#context.clients.peers.subscriptionClient,
        address
      ),
      this.#context.ca,
      fabric,
      commissioningOptions,
      async (address2, supportsConcurrentConnections) => {
        if (!supportsConcurrentConnections) {
          await paseSecureMessageChannel.close();
        }
        if (performCaseCommissioning !== void 0) {
          await performCaseCommissioning(address2, discoveryData);
          return;
        }
        return await this.#context.clients.connect(address2, {
          discoveryOptions: {
            discoveryType: NodeDiscoveryType.TimedDiscovery,
            timeoutSeconds: 120,
            discoveryData
          },
          allowUnknownPeer: true
        });
      }
    );
    try {
      await commissioningManager.executeCommissioning();
    } catch (error) {
      await this.#context.clients.peers.delete(address);
      throw error;
    } finally {
      if (!paseSecureMessageChannel.closed) {
        await paseSecureMessageChannel.close();
      }
    }
    return address;
  }
}
export {
  ControllerCommissioner
};
//# sourceMappingURL=ControllerCommissioner.js.map
