/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { ClassExtends } from "#general";
import { NodeId } from "#types";
import { AddressTypeFromDevice, CommissionableDevice, CommissionableDeviceIdentifiers, DiscoverableDevice, OperationalDevice, Scanner } from "../common/Scanner.js";
import { Fabric } from "../fabric/Fabric.js";
import { MdnsScanner } from "../mdns/MdnsScanner.js";
import { RetransmissionLimitReachedError } from "../protocol/MessageExchange.js";
export declare class DiscoveryError extends RetransmissionLimitReachedError {
}
/**
 * Special Error instance used to detect if the retransmission limit was reached during pairing for case or pase.
 * Mainly means that the device was not responding to the pairing request.
 */
export declare class PairRetransmissionLimitReachedError extends RetransmissionLimitReachedError {
}
export declare class ControllerDiscovery {
    /**
     * Discovers devices by a provided identifier and a list of scanners (e.g. IP and BLE in parallel).
     * It returns after the timeout or if at least one device was found.
     * The method returns a list of addresses of the discovered devices.
     */
    static discoverDeviceAddressesByIdentifier(scanners: Array<Scanner>, identifier: CommissionableDeviceIdentifiers, timeoutSeconds?: number): Promise<CommissionableDevice[]>;
    static discoverCommissionableDevices(scanners: Array<Scanner>, timeoutSeconds: number, identifier?: CommissionableDeviceIdentifiers, discoveredCallback?: (device: CommissionableDevice) => void): Promise<CommissionableDevice[]>;
    static discoverOperationalDevice(fabric: Fabric, peerNodeId: NodeId, scanner: MdnsScanner, timeoutSeconds?: number, ignoreExistingRecords?: boolean): Promise<OperationalDevice>;
    static cancelOperationalDeviceDiscovery(fabric: Fabric, peerNodeId: NodeId, scanner: MdnsScanner): void;
    static cancelCommissionableDeviceDiscovery(scanner: Scanner, identifier?: CommissionableDeviceIdentifiers): void;
    /**
     * Helper method to iterate through a list of server addresses and try to execute a method on each of them. If the
     * method throws a configurable error (or EHOSTUNREACH), the server address list is updated (to also add later
     * discovered addresses or devices) and then next server address is tried.The result of the first successful method
     * call is returned. The logic makes sure to only try each unique address (IP/port) once.
     */
    static iterateServerAddresses<DD extends DiscoverableDevice<any>, T, E extends Error>(devices: DD[], errorType: ClassExtends<E>, updateDevicesFunc: () => Promise<DD[]>, func: (address: AddressTypeFromDevice<DD>, device?: DD) => Promise<T>, lastKnownAddress?: AddressTypeFromDevice<DD>): Promise<{
        result: T;
        resultAddress: AddressTypeFromDevice<DD>;
        resultDevice?: DD;
    }>;
}
//# sourceMappingURL=ControllerDiscovery.d.ts.map