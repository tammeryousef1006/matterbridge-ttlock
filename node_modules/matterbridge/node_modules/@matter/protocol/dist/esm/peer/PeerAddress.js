/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const interned = Symbol("interned-logical-address");
const internedAddresses = /* @__PURE__ */ new Map();
function PeerAddress(address) {
  if (interned in address) {
    return address;
  }
  let internedFabric = internedAddresses.get(address.fabricIndex);
  if (internedFabric === void 0) {
    internedAddresses.set(address.fabricIndex, internedFabric = /* @__PURE__ */ new Map());
  }
  let internedAddress = internedFabric.get(address.nodeId);
  if (internedAddress) {
    return internedAddress;
  }
  internedFabric.set(
    address.nodeId,
    internedAddress = {
      ...address,
      [interned]: true,
      toString() {
        const nodeStr = this.nodeId > 65535 ? `0x${this.nodeId.toString(16)}` : this.nodeId;
        return `peer@${this.fabricIndex}:${nodeStr}`;
      }
    }
  );
  return internedAddress;
}
((PeerAddress2) => {
  function is(addr1, addr2) {
    if (addr1 === void 0 || addr2 === void 0) {
      return false;
    }
    return addr1.fabricIndex === addr2.fabricIndex && addr1.nodeId === addr2.nodeId;
  }
  PeerAddress2.is = is;
})(PeerAddress || (PeerAddress = {}));
class PeerAddressMap extends Map {
  delete(key) {
    return super.delete(PeerAddress(key));
  }
  has(key) {
    return super.has(PeerAddress(key));
  }
  set(key, value) {
    return super.set(PeerAddress(key), value);
  }
  get(key) {
    return super.get(PeerAddress(key));
  }
}
class PeerAddressSet extends Set {
  add(value) {
    return super.add(PeerAddress(value));
  }
  has(value) {
    return super.has(PeerAddress(value));
  }
  delete(value) {
    return super.delete(PeerAddress(value));
  }
}
export {
  PeerAddress,
  PeerAddressMap,
  PeerAddressSet
};
//# sourceMappingURL=PeerAddress.js.map
