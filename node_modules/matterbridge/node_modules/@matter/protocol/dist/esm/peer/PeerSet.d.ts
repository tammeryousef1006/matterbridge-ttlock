/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { DiscoveryData, ScannerSet } from "#common/Scanner.js";
import { AsyncObservable, BasicSet, Construction, Environment, Environmental, ImmutableSet, MatterError, NetInterfaceSet, ObservableSet, ServerAddressIp } from "#general";
import { SubscriptionClient } from "#interaction/SubscriptionClient.js";
import { PeerAddress } from "#peer/PeerAddress.js";
import { SessionManager } from "#session/SessionManager.js";
import { ChannelManager } from "../protocol/ChannelManager.js";
import { ExchangeManager, MessageChannel } from "../protocol/ExchangeManager.js";
import { DedicatedChannelExchangeProvider, ReconnectableExchangeProvider } from "../protocol/ExchangeProvider.js";
import { InteractionQueue } from "./InteractionQueue.js";
import { OperationalPeer } from "./OperationalPeer.js";
import { PeerAddressStore } from "./PeerAddressStore.js";
/**
 * Types of discovery that may be performed when connecting operationally.
 */
export declare enum NodeDiscoveryType {
    /** No discovery is done, in calls means that only known addresses are tried. */
    None = 0,
    /** Retransmission discovery means that we ignore known addresses and start a query for 5s. */
    RetransmissionDiscovery = 1,
    /** Timed discovery means that the device is discovered for a defined timeframe, including known addresses. */
    TimedDiscovery = 2,
    /** Full discovery means that the device is discovered until it is found, excluding known addresses. */
    FullDiscovery = 3
}
/** Error when an unknown node is tried to be connected or any other action done with it. */
export declare class UnknownNodeError extends MatterError {
}
/**
 * Configuration for discovering when establishing a peer connection.
 */
export interface DiscoveryOptions {
    discoveryType?: NodeDiscoveryType;
    timeoutSeconds?: number;
    discoveryData?: DiscoveryData;
}
/**
 * Interfaces {@link PeerSet} with other components.
 */
export interface PeerSetContext {
    sessions: SessionManager;
    channels: ChannelManager;
    exchanges: ExchangeManager;
    subscriptionClient: SubscriptionClient;
    scanners: ScannerSet;
    netInterfaces: NetInterfaceSet;
    store: PeerAddressStore;
}
/**
 * Manages operational connections to peers on shared fabric.
 */
export declare class PeerSet implements ImmutableSet<OperationalPeer>, ObservableSet<OperationalPeer> {
    #private;
    constructor(context: PeerSetContext);
    get added(): import("#general").Observable<[OperationalPeer], void>;
    get deleted(): import("#general").Observable<[OperationalPeer], void>;
    get disconnected(): AsyncObservable<[address: PeerAddress], void>;
    has(item: PeerAddress | OperationalPeer): boolean;
    get size(): number;
    find(predicate: (item: OperationalPeer) => boolean | undefined): OperationalPeer | undefined;
    filter(predicate: (item: OperationalPeer) => boolean | undefined): OperationalPeer[];
    map<T>(mapper: (item: OperationalPeer) => T): T[];
    [Symbol.iterator](): SetIterator<OperationalPeer>;
    get construction(): Construction<PeerSet>;
    static [Environmental.create](env: Environment): PeerSet;
    get peers(): BasicSet<OperationalPeer, OperationalPeer>;
    get subscriptionClient(): SubscriptionClient;
    get interactionQueue(): InteractionQueue;
    /**
     * Ensure there is a channel to the designated peer.
     */
    ensureConnection(address: PeerAddress, options: {
        discoveryOptions: DiscoveryOptions;
        allowUnknownPeer?: boolean;
        operationalAddress?: ServerAddressIp;
    }): Promise<MessageChannel | undefined>;
    /**
     * Obtain an exchange provider for the designated peer.
     */
    exchangeProviderFor(addressOrChannel: PeerAddress | MessageChannel, discoveryOptions?: DiscoveryOptions): Promise<DedicatedChannelExchangeProvider | ReconnectableExchangeProvider>;
    /**
     * Retrieve a peer by address.
     */
    get(peer: PeerAddress | OperationalPeer): OperationalPeer | undefined;
    /**
     * Terminate any active peer connection.
     */
    disconnect(peer: PeerAddress | OperationalPeer, sendSessionClose?: boolean): Promise<void>;
    /**
     * Forget a known peer.
     */
    delete(peer: PeerAddress | OperationalPeer): Promise<void>;
    close(): Promise<void>;
}
//# sourceMappingURL=PeerSet.d.ts.map