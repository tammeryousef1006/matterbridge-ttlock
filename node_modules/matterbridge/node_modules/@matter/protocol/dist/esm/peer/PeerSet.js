/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { ScannerSet } from "#common/Scanner.js";
import {
  anyPromise,
  AsyncObservable,
  BasicSet,
  ChannelType,
  Construction,
  createPromise,
  Environmental,
  ImplementationError,
  isIpNetworkChannel,
  isIPv6,
  Logger,
  MatterError,
  NetInterfaceSet,
  NoResponseTimeoutError,
  serverAddressToString,
  Time
} from "#general";
import { SubscriptionClient } from "#interaction/SubscriptionClient.js";
import { PeerAddress, PeerAddressMap } from "#peer/PeerAddress.js";
import { CaseClient } from "#session/index.js";
import { SessionManager } from "#session/SessionManager.js";
import { SECURE_CHANNEL_PROTOCOL_ID } from "@matter/types";
import { ChannelManager } from "../protocol/ChannelManager.js";
import { ChannelNotConnectedError, ExchangeManager, MessageChannel } from "../protocol/ExchangeManager.js";
import { DedicatedChannelExchangeProvider, ReconnectableExchangeProvider } from "../protocol/ExchangeProvider.js";
import { RetransmissionLimitReachedError } from "../protocol/MessageExchange.js";
import { ControllerDiscovery, DiscoveryError, PairRetransmissionLimitReachedError } from "./ControllerDiscovery.js";
import { InteractionQueue } from "./InteractionQueue.js";
import { PeerAddressStore } from "./PeerAddressStore.js";
const logger = Logger.get("PeerSet");
const RECONNECTION_POLLING_INTERVAL_MS = 6e5;
const RETRANSMISSION_DISCOVERY_TIMEOUT_S = 5;
var NodeDiscoveryType = /* @__PURE__ */ ((NodeDiscoveryType2) => {
  NodeDiscoveryType2[NodeDiscoveryType2["None"] = 0] = "None";
  NodeDiscoveryType2[NodeDiscoveryType2["RetransmissionDiscovery"] = 1] = "RetransmissionDiscovery";
  NodeDiscoveryType2[NodeDiscoveryType2["TimedDiscovery"] = 2] = "TimedDiscovery";
  NodeDiscoveryType2[NodeDiscoveryType2["FullDiscovery"] = 3] = "FullDiscovery";
  return NodeDiscoveryType2;
})(NodeDiscoveryType || {});
class UnknownNodeError extends MatterError {
}
class PeerSet {
  #sessions;
  #channels;
  #exchanges;
  #subscriptionClient;
  #scanners;
  #netInterfaces;
  #caseClient;
  #peers = new BasicSet();
  #peersByAddress = new PeerAddressMap();
  #runningPeerDiscoveries = new PeerAddressMap();
  #runningPeerReconnections = new PeerAddressMap();
  #construction;
  #store;
  #interactionQueue = new InteractionQueue();
  #nodeCachedData = new PeerAddressMap();
  // Temporarily until we store it in new API
  #disconnected = AsyncObservable();
  constructor(context) {
    const { sessions, channels, exchanges, subscriptionClient, scanners, netInterfaces, store } = context;
    this.#sessions = sessions;
    this.#channels = channels;
    this.#exchanges = exchanges;
    this.#subscriptionClient = subscriptionClient;
    this.#scanners = scanners;
    this.#netInterfaces = netInterfaces;
    this.#store = store;
    this.#caseClient = new CaseClient(this.#sessions);
    this.#peers.added.on((peer) => {
      peer.address = PeerAddress(peer.address);
      this.#peersByAddress.set(peer.address, peer);
    });
    this.#peers.deleted.on((peer) => {
      this.#peersByAddress.delete(peer.address);
    });
    this.#sessions.resubmissionStarted.on(this.#handleResubmissionStarted.bind(this));
    this.#channels.added.on((address, msgChannel) => {
      if (isIpNetworkChannel(msgChannel.channel)) {
        return this.#addOrUpdatePeer(address, msgChannel.channel.networkAddress);
      }
    });
    this.#construction = Construction(this, async () => {
      for (const peer of await this.#store.loadPeers()) {
        this.#peers.add(peer);
      }
    });
  }
  get added() {
    return this.#peers.added;
  }
  get deleted() {
    return this.#peers.deleted;
  }
  get disconnected() {
    return this.#disconnected;
  }
  has(item) {
    if ("address" in item) {
      return this.#peers.has(item);
    }
    return this.#peersByAddress.has(item);
  }
  get size() {
    return this.#peers.size;
  }
  find(predicate) {
    return this.#peers.find(predicate);
  }
  filter(predicate) {
    return this.#peers.filter(predicate);
  }
  map(mapper) {
    return this.#peers.map(mapper);
  }
  [Symbol.iterator]() {
    return this.#peers[Symbol.iterator]();
  }
  get construction() {
    return this.#construction;
  }
  static [Environmental.create](env) {
    const instance = new PeerSet({
      sessions: env.get(SessionManager),
      channels: env.get(ChannelManager),
      exchanges: env.get(ExchangeManager),
      subscriptionClient: env.get(SubscriptionClient),
      scanners: env.get(ScannerSet),
      netInterfaces: env.get(NetInterfaceSet),
      store: env.get(PeerAddressStore)
    });
    env.set(PeerSet, instance);
    return instance;
  }
  get peers() {
    return this.#peers;
  }
  get subscriptionClient() {
    return this.#subscriptionClient;
  }
  get interactionQueue() {
    return this.#interactionQueue;
  }
  /**
   * Ensure there is a channel to the designated peer.
   */
  async ensureConnection(address, options) {
    const { discoveryOptions, allowUnknownPeer, operationalAddress } = options;
    if (!this.#peersByAddress.has(address) && !allowUnknownPeer) {
      throw new UnknownNodeError(`Cannot connect to unknown device ${PeerAddress(address)}`);
    }
    address = PeerAddress(address);
    if (!this.#channels.hasChannel(address)) {
      const { promise: existingReconnectPromise } = this.#runningPeerReconnections.get(address) ?? {};
      if (existingReconnectPromise !== void 0) {
        return existingReconnectPromise;
      }
      const { promise, resolver, rejecter } = createPromise();
      this.#runningPeerReconnections.set(address, { promise, rejecter });
      this.#resume(address, discoveryOptions, operationalAddress).then((channel) => {
        this.#runningPeerReconnections.delete(address);
        resolver(channel);
      }).catch((error) => {
        this.#runningPeerReconnections.delete(address);
        rejecter(error);
      });
      return promise;
    }
  }
  /**
   * Obtain an exchange provider for the designated peer.
   */
  async exchangeProviderFor(addressOrChannel, discoveryOptions) {
    if (addressOrChannel instanceof MessageChannel) {
      return new DedicatedChannelExchangeProvider(this.#exchanges, addressOrChannel);
    }
    const address = addressOrChannel;
    let initiallyConnected = this.#channels.hasChannel(address);
    return new ReconnectableExchangeProvider(this.#exchanges, this.#channels, address, async () => {
      if (!initiallyConnected && !this.#channels.hasChannel(address)) {
        await this.ensureConnection(address, {
          discoveryOptions: { discoveryType: 0 /* None */ }
        });
        initiallyConnected = true;
        if (this.#channels.hasChannel(address)) {
          return;
        }
      }
      if (!this.#channels.hasChannel(address)) {
        throw new RetransmissionLimitReachedError(`Device ${PeerAddress(address)} is currently not reachable.`);
      }
      await this.#channels.removeAllNodeChannels(address);
      const { discoveryData } = discoveryOptions ?? {
        discoveryData: this.#peersByAddress.get(address)?.discoveryData
      };
      const operationalAddress = this.#knownOperationalAddressFor(address, true);
      if (operationalAddress === void 0) {
        logger.info(
          `Re-discovering device failed (no address found), remove all sessions for ${PeerAddress(address)}`
        );
        await this.#sessions.removeAllSessionsForNode(address);
        throw new RetransmissionLimitReachedError(`No operational address found for ${PeerAddress(address)}`);
      }
      if (await this.#reconnectKnownAddress(address, operationalAddress, discoveryData, 2e3) === void 0) {
        throw new RetransmissionLimitReachedError(`${PeerAddress(address)} is not reachable.`);
      }
    });
  }
  /**
   * Retrieve a peer by address.
   */
  get(peer) {
    if ("address" in peer) {
      return this.#peersByAddress.get(peer.address);
    }
    return this.#peersByAddress.get(peer);
  }
  /**
   * Terminate any active peer connection.
   */
  async disconnect(peer, sendSessionClose = true) {
    const address = this.get(peer)?.address;
    if (address === void 0) {
      return;
    }
    await this.#sessions.removeAllSessionsForNode(address, sendSessionClose);
    await this.#channels.removeAllNodeChannels(address);
    await this.#disconnected.emit(address);
  }
  /**
   * Forget a known peer.
   */
  async delete(peer) {
    const actual = this.get(peer);
    if (actual === void 0) {
      return;
    }
    const { address } = actual;
    logger.info(`Removing ${address}`);
    this.#peers.delete(actual);
    await this.#store.deletePeer(address);
    await this.disconnect(address, false);
    await this.#sessions.deleteResumptionRecord(address);
  }
  async close() {
    for (const [address, { stopTimerFunc, mdnsScanner }] of this.#runningPeerDiscoveries.entries()) {
      stopTimerFunc?.();
      mdnsScanner?.cancelOperationalDeviceDiscovery(this.#sessions.fabricFor(address), address.nodeId, false);
    }
    for (const { address } of this.#peers) {
      await this.disconnect(address, false);
    }
    this.#interactionQueue.close();
    this.#runningPeerReconnections.forEach(
      ({ rejecter }) => rejecter(new ChannelNotConnectedError("PeerSet closed"))
    );
    this.#runningPeerReconnections.clear();
  }
  /**
   * Resume a device connection and establish a CASE session that was previously paired with the controller. This
   * method will try to connect to the device using the previously used server address (if set). If that fails, the
   * device is discovered again using its operational instance details.
   * It returns the operational MessageChannel on success.
   */
  async #resume(address, discoveryOptions, tryOperationalAddress) {
    const { discoveryType } = discoveryOptions ?? {};
    const operationalAddress = tryOperationalAddress ?? (discoveryType === 0 /* None */ ? this.#getLastOperationalAddress(address) : this.#knownOperationalAddressFor(address));
    try {
      return await this.#connectOrDiscoverNode(address, operationalAddress, discoveryOptions);
    } catch (error) {
      if ((error instanceof DiscoveryError || error instanceof NoResponseTimeoutError) && this.#peersByAddress.has(address) && tryOperationalAddress === void 0) {
        logger.info(`Resume failed, remove all sessions for ${PeerAddress(address)}`);
        await this.#sessions.removeAllSessionsForNode(address);
      }
      throw error;
    }
  }
  async #connectOrDiscoverNode(address, operationalAddress, discoveryOptions = {}) {
    address = PeerAddress(address);
    const {
      discoveryType: requestedDiscoveryType = 3 /* FullDiscovery */,
      timeoutSeconds,
      discoveryData = this.#peersByAddress.get(address)?.discoveryData
    } = discoveryOptions;
    if (timeoutSeconds !== void 0 && requestedDiscoveryType !== 2 /* TimedDiscovery */) {
      throw new ImplementationError("Cannot set timeout without timed discovery.");
    }
    if (requestedDiscoveryType === 1 /* RetransmissionDiscovery */) {
      throw new ImplementationError("Cannot set retransmission discovery type.");
    }
    const mdnsScanner = this.#scanners.scannerFor(ChannelType.UDP);
    if (!mdnsScanner) {
      throw new ImplementationError("Cannot discover device without mDNS scanner.");
    }
    const existingDiscoveryDetails = this.#runningPeerDiscoveries.get(address) ?? {
      type: 0 /* None */
    };
    if (existingDiscoveryDetails.type !== 0 /* None */ && existingDiscoveryDetails.type < requestedDiscoveryType) {
      mdnsScanner.cancelOperationalDeviceDiscovery(this.#sessions.fabricFor(address), address.nodeId);
      this.#runningPeerDiscoveries.delete(address);
      existingDiscoveryDetails.type = 0 /* None */;
    }
    const { type: runningDiscoveryType, promises } = existingDiscoveryDetails;
    if (operationalAddress !== void 0 && (runningDiscoveryType === 0 /* None */ || requestedDiscoveryType === 0 /* None */)) {
      const directReconnection = await this.#reconnectKnownAddress(
        address,
        operationalAddress,
        discoveryData,
        // When we use a timeout for discovery also use this for reconnecting to the node
        timeoutSeconds ? timeoutSeconds * 1e3 : void 0
      );
      if (directReconnection !== void 0) {
        return directReconnection;
      }
      if (requestedDiscoveryType === 0 /* None */) {
        throw new DiscoveryError(`${address} is not reachable right now.`);
      }
    }
    if (operationalAddress === void 0 && requestedDiscoveryType === 0 /* None */) {
      throw new DiscoveryError(`${address} has no known address and No discovery was requested.`);
    }
    if (promises !== void 0) {
      if (runningDiscoveryType > requestedDiscoveryType) {
        throw new DiscoveryError(`${address} is not reachable right now and discovery already running.`);
      } else {
        return await anyPromise(promises);
      }
    }
    const discoveryPromises = new Array();
    let reconnectionPollingTimer;
    let stopTimerFunc;
    const lastOperationalAddress = this.#getLastOperationalAddress(address);
    if (lastOperationalAddress !== void 0) {
      if (requestedDiscoveryType === 3 /* FullDiscovery */) {
        const { promise, resolver, rejecter } = createPromise();
        logger.debug(
          `Starting reconnection polling for ${serverAddressToString(lastOperationalAddress)} (Interval ${RECONNECTION_POLLING_INTERVAL_MS / 1e3}s)`
        );
        reconnectionPollingTimer = Time.getPeriodicTimer(
          "Controller reconnect",
          RECONNECTION_POLLING_INTERVAL_MS,
          async () => {
            try {
              logger.debug(`Polling for device at ${serverAddressToString(lastOperationalAddress)} ...`);
              const result = await this.#reconnectKnownAddress(
                address,
                lastOperationalAddress,
                discoveryData
              );
              if (result !== void 0 && reconnectionPollingTimer?.isRunning) {
                reconnectionPollingTimer?.stop();
                mdnsScanner.cancelOperationalDeviceDiscovery(
                  this.#sessions.fabricFor(address),
                  address.nodeId
                );
                this.#runningPeerDiscoveries.delete(address);
                resolver(result);
              }
            } catch (error) {
              if (reconnectionPollingTimer?.isRunning) {
                reconnectionPollingTimer?.stop();
                mdnsScanner.cancelOperationalDeviceDiscovery(
                  this.#sessions.fabricFor(address),
                  address.nodeId
                );
                this.#runningPeerDiscoveries.delete(address);
                rejecter(error);
              }
            }
          }
        ).start();
        stopTimerFunc = () => {
          reconnectionPollingTimer?.stop();
          reconnectionPollingTimer = void 0;
          rejecter(new NoResponseTimeoutError("Reconnection polling cancelled"));
        };
        discoveryPromises.push(() => promise);
      }
    }
    discoveryPromises.push(async () => {
      const scanResult = await ControllerDiscovery.discoverOperationalDevice(
        this.#sessions.fabricFor(address),
        address.nodeId,
        mdnsScanner,
        timeoutSeconds,
        timeoutSeconds === void 0
      );
      const { stopTimerFunc: stopTimerFunc2 } = this.#runningPeerDiscoveries.get(address) ?? {};
      stopTimerFunc2?.();
      this.#runningPeerDiscoveries.delete(address);
      const { result } = await ControllerDiscovery.iterateServerAddresses(
        [scanResult],
        NoResponseTimeoutError,
        async () => {
          const device = mdnsScanner.getDiscoveredOperationalDevice(
            this.#sessions.fabricFor(address),
            address.nodeId
          );
          return device !== void 0 ? [device] : [];
        },
        async (operationalAddress2, peer) => {
          const result2 = await this.#pair(address, operationalAddress2, peer);
          await this.#addOrUpdatePeer(address, operationalAddress2, {
            ...discoveryData,
            ...peer
          });
          return result2;
        }
      );
      return result;
    });
    this.#runningPeerDiscoveries.set(address, {
      type: requestedDiscoveryType,
      promises: discoveryPromises,
      stopTimerFunc,
      mdnsScanner
    });
    return await anyPromise(discoveryPromises).finally(() => {
      this.#runningPeerDiscoveries.delete(address);
    });
  }
  async #reconnectKnownAddress(address, operationalAddress, discoveryData, expectedProcessingTimeMs) {
    address = PeerAddress(address);
    const { ip, port } = operationalAddress;
    const startTime = Time.nowMs();
    try {
      logger.debug(
        `Resuming connection to ${PeerAddress(address)} at ${ip}:${port}${expectedProcessingTimeMs !== void 0 ? ` with expected processing time of ${expectedProcessingTimeMs}ms` : ""}`
      );
      const channel = await this.#pair(address, operationalAddress, discoveryData, expectedProcessingTimeMs);
      await this.#addOrUpdatePeer(address, operationalAddress);
      return channel;
    } catch (error) {
      if (error instanceof NoResponseTimeoutError) {
        logger.debug(
          `Failed to resume connection to ${address} connection with ${ip}:${port}, discovering the node now:`,
          error.message ? error.message : error
        );
        await this.#sessions.removeAllSessionsForNode(address, false, startTime);
        return void 0;
      } else {
        throw error;
      }
    }
  }
  /** Pair with an operational device (already commissioned) and establish a CASE session. */
  async #pair(address, operationalServerAddress, discoveryData, expectedProcessingTimeMs) {
    logger.debug(`Pair with ${address} at ${serverAddressToString(operationalServerAddress)}`);
    const { ip, port } = operationalServerAddress;
    const isIpv6Address = isIPv6(ip);
    const operationalInterface = this.#netInterfaces.interfaceFor(
      ChannelType.UDP,
      isIpv6Address ? "::" : "0.0.0.0"
    );
    if (operationalInterface === void 0) {
      throw new PairRetransmissionLimitReachedError(
        `IPv${isIpv6Address ? "6" : "4"} interface not initialized for port ${port}. Cannot use ${ip} for pairing.`
      );
    }
    const operationalChannel = await operationalInterface.openChannel(operationalServerAddress);
    const { sessionParameters } = this.#sessions.findResumptionRecordByAddress(address) ?? {};
    const unsecureSession = this.#sessions.createInsecureSession({
      // Use the session parameters from MDNS announcements when available and rest is assumed to be fallbacks
      sessionParameters: {
        idleIntervalMs: discoveryData?.SII ?? sessionParameters?.idleIntervalMs,
        activeIntervalMs: discoveryData?.SAI ?? sessionParameters?.activeIntervalMs,
        activeThresholdMs: discoveryData?.SAT ?? sessionParameters?.activeThresholdMs
      },
      isInitiator: true
    });
    const operationalUnsecureMessageExchange = new MessageChannel(operationalChannel, unsecureSession);
    let operationalSecureSession;
    try {
      const exchange = this.#exchanges.initiateExchangeWithChannel(
        operationalUnsecureMessageExchange,
        SECURE_CHANNEL_PROTOCOL_ID
      );
      try {
        const { session, resumed } = await this.#caseClient.pair(
          exchange,
          this.#sessions.fabricFor(address),
          address.nodeId,
          expectedProcessingTimeMs
        );
        operationalSecureSession = session;
        if (!resumed) {
          this.#nodeCachedData.delete(address);
        }
      } catch (e) {
        await exchange.close();
        throw e;
      }
    } catch (e) {
      NoResponseTimeoutError.accept(e);
      throw new PairRetransmissionLimitReachedError(e.message);
    } finally {
      await unsecureSession.destroy();
    }
    const channel = new MessageChannel(operationalChannel, operationalSecureSession);
    await this.#channels.setChannel(address, channel);
    return channel;
  }
  /**
   * Obtain an operational address for a logical address from cache.
   */
  #knownOperationalAddressFor(address, ignoreDiscoveredAddresses = false) {
    const lastKnownAddress = this.#getLastOperationalAddress(address);
    if (lastKnownAddress !== void 0 && ignoreDiscoveredAddresses) {
      return lastKnownAddress;
    }
    const mdnsScanner = this.#scanners.scannerFor(ChannelType.UDP);
    const discoveredAddresses = mdnsScanner?.getDiscoveredOperationalDevice(
      this.#sessions.fabricFor(address),
      address.nodeId
    );
    if (lastKnownAddress !== void 0 && discoveredAddresses !== void 0 && discoveredAddresses.addresses.some(
      ({ ip, port }) => ip === lastKnownAddress.ip && port === lastKnownAddress.port
    )) {
      discoveredAddresses.addresses.length = 0;
    }
    return discoveredAddresses?.addresses[0];
  }
  async #addOrUpdatePeer(address, operationalServerAddress, discoveryData) {
    let peer = this.#peersByAddress.get(address);
    if (peer === void 0) {
      peer = { address, dataStore: await this.#store.createNodeStore(address) };
      this.#peers.add(peer);
    }
    peer.operationalAddress = operationalServerAddress;
    if (discoveryData !== void 0) {
      peer.discoveryData = {
        ...peer.discoveryData,
        ...discoveryData
      };
    }
    await this.#store.updatePeer(peer);
    if (this.#runningPeerDiscoveries.has(address)) {
      logger.info(`Found ${address} during discovery, cancel discovery.`);
      const { mdnsScanner } = this.#runningPeerDiscoveries.get(address) ?? {};
      mdnsScanner?.cancelOperationalDeviceDiscovery(this.#sessions.fabricFor(address), address.nodeId, true);
    }
  }
  #getLastOperationalAddress(address) {
    return this.#peersByAddress.get(address)?.operationalAddress;
  }
  #handleResubmissionStarted(session) {
    if (!session.isSecure || session.fabric === void 0) {
      return;
    }
    const { associatedFabric: fabric, peerNodeId: nodeId } = session;
    if (fabric === void 0 || nodeId === void 0) {
      return;
    }
    const address = fabric.addressOf(nodeId);
    if (this.#runningPeerDiscoveries.has(address)) {
      return;
    }
    this.#runningPeerDiscoveries.set(address, { type: 1 /* RetransmissionDiscovery */ });
    this.#scanners.scannerFor(ChannelType.UDP)?.findOperationalDevice(fabric, nodeId, RETRANSMISSION_DISCOVERY_TIMEOUT_S, true).catch((error) => {
      logger.error(`Failed to discover ${address} after resubmission started.`, error);
    }).finally(() => {
      if (this.#runningPeerDiscoveries.get(address)?.type === 1 /* RetransmissionDiscovery */) {
        this.#runningPeerDiscoveries.delete(address);
      }
    });
  }
}
export {
  NodeDiscoveryType,
  PeerSet,
  UnknownNodeError
};
//# sourceMappingURL=PeerSet.js.map
