/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { AsyncObservable, Environmental, Logger, MatterError } from "#general";
import { PeerAddress, PeerAddressMap } from "#peer/PeerAddress.js";
import { MessageChannel } from "./ExchangeManager.js";
const logger = Logger.get("ChannelManager");
class NoChannelError extends MatterError {
}
class ChannelManager {
  #channels = new PeerAddressMap();
  #paseChannels = /* @__PURE__ */ new Map();
  #caseSessionsPerFabricAndNode;
  #added = AsyncObservable();
  // TODO evaluate with controller the effects of limiting the entries just for FabricIndex and not also NodeId
  constructor(caseSessionsPerFabricAndNode = 3) {
    this.#caseSessionsPerFabricAndNode = caseSessionsPerFabricAndNode;
  }
  static [Environmental.create](env) {
    const instance = new ChannelManager();
    env.set(ChannelManager, instance);
    return instance;
  }
  get added() {
    return this.#added;
  }
  set caseSessionsPerFabricAndNode(count) {
    this.#caseSessionsPerFabricAndNode = count;
  }
  #findLeastActiveChannel(channels) {
    let oldest = channels[0];
    for (const channel of channels) {
      if (channel.session.timestamp < oldest.session.timestamp) {
        oldest = channel;
      }
    }
    return oldest;
  }
  async setChannel(address, channel) {
    channel.closeCallback = async () => this.removeChannel(address, channel.session);
    const currentChannels = this.#channels.get(address) ?? [];
    currentChannels.push(channel);
    this.#channels.set(address, currentChannels);
    await this.#added.emit(address, channel);
    if (currentChannels.length > this.#caseSessionsPerFabricAndNode) {
      const oldestChannel = this.#findLeastActiveChannel(currentChannels);
      const { session: oldSession } = oldestChannel;
      if (channel.session.id !== oldSession.id) {
        await oldSession.destroy(false, false);
      }
      logger.info(`Close oldest channel for fabric ${PeerAddress(address)} (from session ${oldSession.id})`);
      await oldestChannel.close();
    }
  }
  hasChannel(address) {
    return !!this.#channels.get(address)?.filter((channel) => !channel.closed && !channel.session.closingAfterExchangeFinished).length;
  }
  getChannel(address, session) {
    let results = this.#channels.get(address) ?? [];
    if (session !== void 0) {
      results = results.filter((channel) => channel.session.id === session.id);
    }
    results = results.filter((channel) => !channel.closed && !channel.session.closingAfterExchangeFinished);
    if (results.length === 0)
      throw new NoChannelError(
        `Can't find a channel to ${PeerAddress(address)}${session !== void 0 ? ` session ${session.id}` : ""}`
      );
    return results[results.length - 1];
  }
  /**
   * Returns the last established session for a Fabric and Node
   */
  getChannelForSession(session) {
    if (session.isSecure && !session.isPase) {
      const secureSession = session;
      const fabric = secureSession.fabric;
      const nodeId = secureSession.peerNodeId;
      if (fabric === void 0) {
        return this.#paseChannels.get(session);
      }
      return this.getChannel(fabric.addressOf(nodeId), session);
    }
    return this.#paseChannels.get(session);
  }
  async removeAllNodeChannels(address) {
    const channelsToRemove = this.#channels.get(address) ?? [];
    for (const channel of channelsToRemove) {
      await channel.close();
    }
  }
  async removeChannel(address, session) {
    const fabricChannels = this.#channels.get(address) ?? [];
    const channelEntryIndex = fabricChannels.findIndex(
      ({ session: entrySession }) => entrySession.id === session.id
    );
    if (channelEntryIndex === -1) {
      return;
    }
    const channelEntry = fabricChannels.splice(channelEntryIndex, 1)[0];
    if (channelEntry === void 0) {
      return;
    }
    await channelEntry.close();
    this.#channels.set(address, fabricChannels);
  }
  getOrCreateAsPaseChannel(byteArrayChannel, session) {
    const msgChannel = new MessageChannel(
      byteArrayChannel,
      session,
      async () => void this.#paseChannels.delete(session)
    );
    this.#paseChannels.set(session, msgChannel);
    if (session.isSecure) {
      session.destroyed.on(() => msgChannel.close());
    }
    return msgChannel;
  }
  async getOrCreateChannel(byteArrayChannel, session) {
    if (!session.isSecure) {
      return this.getOrCreateAsPaseChannel(byteArrayChannel, session);
    }
    const secureSession = session;
    const fabric = secureSession.fabric;
    const nodeId = secureSession.peerNodeId;
    if (fabric === void 0) {
      return this.getOrCreateAsPaseChannel(byteArrayChannel, session);
    }
    const address = fabric.addressOf(nodeId);
    try {
      return this.getChannel(address, session);
    } catch (e) {
      NoChannelError.accept(e);
    }
    const msgChannel = new MessageChannel(
      byteArrayChannel,
      session,
      async () => this.removeChannel(address, session)
    );
    await this.setChannel(address, msgChannel);
    session.destroyed.on(() => msgChannel.close());
    return msgChannel;
  }
  async close() {
    for (const channel of this.#paseChannels.values()) {
      await channel.close();
    }
    this.#paseChannels.clear();
    for (const channels of this.#channels.values()) {
      for (const channel of channels) {
        await channel.close();
      }
    }
    this.#channels.clear();
  }
}
export {
  ChannelManager,
  NoChannelError
};
//# sourceMappingURL=ChannelManager.js.map
