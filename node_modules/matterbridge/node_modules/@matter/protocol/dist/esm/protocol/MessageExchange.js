/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import {
  AsyncObservable,
  CRYPTO_AEAD_MIC_LENGTH_BYTES,
  DataReadQueue,
  Diagnostic,
  InternalError,
  Logger,
  MatterError,
  MatterFlowError,
  NoResponseTimeoutError,
  Time,
  createPromise
} from "#general";
import { SECURE_CHANNEL_PROTOCOL_ID, SecureMessageType, StatusCode, StatusResponseError } from "#types";
import { MessageCodec, SessionType } from "../codec/MessageCodec.js";
import { SecureChannelProtocol } from "../securechannel/SecureChannelProtocol.js";
import {
  SESSION_ACTIVE_INTERVAL_MS,
  SESSION_ACTIVE_THRESHOLD_MS,
  SESSION_IDLE_INTERVAL_MS
} from "../session/Session.js";
import { ChannelNotConnectedError } from "./ExchangeManager.js";
const logger = Logger.get("MessageExchange");
class RetransmissionLimitReachedError extends NoResponseTimeoutError {
}
class UnexpectedMessageError extends MatterError {
  constructor(message, receivedMessage) {
    super(`(${MessageCodec.messageDiagnostics(receivedMessage)}) ${message}`);
    this.receivedMessage = receivedMessage;
  }
}
const MRP_MAX_TRANSMISSIONS = 5;
const MRP_BACKOFF_BASE = 1.6;
const MRP_BACKOFF_JITTER = 0.25;
const MRP_BACKOFF_MARGIN = 1.1;
const MRP_BACKOFF_THRESHOLD = 1;
const MRP_STANDALONE_ACK_TIMEOUT_MS = 200;
const DEFAULT_EXPECTED_PROCESSING_TIME_MS = 2e3;
const PEER_RESPONSE_TIME_BUFFER_MS = 5e3;
const MATTER_MESSAGE_OVERHEAD = 26 + 12 + CRYPTO_AEAD_MIC_LENGTH_BYTES;
class MessageExchange {
  constructor(context, isInitiator, peerSessionId, nodeId, peerNodeId, exchangeId, protocolId) {
    this.context = context;
    this.isInitiator = isInitiator;
    const { channel } = context;
    const { session } = channel;
    this.#peerSessionId = peerSessionId;
    this.#nodeId = nodeId;
    this.#peerNodeId = peerNodeId;
    this.#exchangeId = exchangeId;
    this.#protocolId = protocolId;
    const { activeIntervalMs, idleIntervalMs, activeThresholdMs } = session.parameters;
    this.#activeIntervalMs = activeIntervalMs ?? SESSION_ACTIVE_INTERVAL_MS;
    this.#idleIntervalMs = idleIntervalMs ?? SESSION_IDLE_INTERVAL_MS;
    this.#activeThresholdMs = activeThresholdMs ?? SESSION_ACTIVE_THRESHOLD_MS;
    this.#maxTransmissions = MRP_MAX_TRANSMISSIONS;
    this.#useMRP = session.supportsMRP && !channel.isReliable;
    logger.debug(
      "New exchange",
      Diagnostic.dict({
        channel: channel.name,
        protocol: this.#protocolId,
        exId: this.#exchangeId,
        sess: session.name,
        peerSess: this.#peerSessionId,
        SAT: this.#activeThresholdMs,
        SAI: this.#activeIntervalMs,
        SII: this.#idleIntervalMs,
        maxTrans: this.#maxTransmissions,
        exchangeFlags: Diagnostic.asFlags({
          MRP: this.#useMRP,
          I: this.isInitiator
        })
      })
    );
  }
  static fromInitialMessage(context, initialMessage) {
    const {
      channel: { session }
    } = context;
    return new MessageExchange(
      context,
      false,
      session.id,
      initialMessage.packetHeader.destNodeId,
      initialMessage.packetHeader.sourceNodeId,
      initialMessage.payloadHeader.exchangeId,
      initialMessage.payloadHeader.protocolId
    );
  }
  static initiate(context, exchangeId, protocolId) {
    const {
      channel: { session }
    } = context;
    return new MessageExchange(
      context,
      true,
      session.peerSessionId,
      session.nodeId,
      session.peerNodeId,
      exchangeId,
      protocolId
    );
  }
  #activeIntervalMs;
  #idleIntervalMs;
  #activeThresholdMs;
  #maxTransmissions;
  #messagesQueue = new DataReadQueue();
  #receivedMessageToAck;
  #receivedMessageAckTimer = Time.getTimer("Ack receipt timeout", MRP_STANDALONE_ACK_TIMEOUT_MS, () => {
    if (this.#receivedMessageToAck !== void 0) {
      const messageToAck = this.#receivedMessageToAck;
      this.#receivedMessageToAck = void 0;
      this.sendStandaloneAckForMessage(messageToAck).catch(
        (error) => logger.error("An error happened when sending a standalone ack", error)
      );
    }
  });
  #sentMessageToAck;
  #sentMessageAckSuccess;
  #sentMessageAckFailure;
  #retransmissionTimer;
  #retransmissionCounter = 0;
  #closeTimer;
  #isClosing = false;
  #timedInteractionTimer;
  #peerSessionId;
  #nodeId;
  #peerNodeId;
  #exchangeId;
  #protocolId;
  #closed = AsyncObservable();
  #useMRP;
  get closed() {
    return this.#closed;
  }
  get isClosing() {
    return this.#isClosing;
  }
  get id() {
    return this.#exchangeId;
  }
  get channel() {
    return this.context.channel;
  }
  get session() {
    return this.channel.session;
  }
  /**
   * Max Payload size of the exchange which bases on the maximum payload size of the channel reduced by Matter
   * protocol overhead.
   */
  get maxPayloadSize() {
    return this.channel.maxPayloadSize - MATTER_MESSAGE_OVERHEAD;
  }
  async sendStandaloneAckForMessage(message) {
    const {
      packetHeader: { messageId },
      payloadHeader: { requiresAck }
    } = message;
    if (!requiresAck || !this.#useMRP) return;
    await this.send(SecureMessageType.StandaloneAck, new Uint8Array(0), { includeAcknowledgeMessageId: messageId });
  }
  async onMessageReceived(message, duplicate = false) {
    logger.debug("Message \xAB", MessageCodec.messageDiagnostics(message, { duplicate }));
    if (message.payloadHeader.requiresAck && !this.#useMRP) {
      logger.debug("Ignoring ack-required flag because MRP is not used for this exchange");
      message.payloadHeader.requiresAck = false;
    }
    const {
      packetHeader: { messageId },
      payloadHeader: { requiresAck, ackedMessageId, protocolId, messageType }
    } = message;
    const isStandaloneAck = SecureChannelProtocol.isStandaloneAck(protocolId, messageType);
    if (protocolId !== this.#protocolId && !isStandaloneAck) {
      throw new MatterFlowError(
        `Drop received a message for an unexpected protocol. Expected: ${this.#protocolId}, received: ${protocolId}`
      );
    }
    this.session.notifyActivity(true);
    if (duplicate) {
      if (requiresAck) {
        await this.sendStandaloneAckForMessage(message);
      }
      return;
    }
    if (messageId === this.#sentMessageToAck?.payloadHeader.ackedMessageId) {
      await this.channel.send(this.#sentMessageToAck);
      return;
    }
    const sentMessageIdToAck = this.#sentMessageToAck?.packetHeader.messageId;
    if (sentMessageIdToAck !== void 0) {
      if (ackedMessageId === void 0) {
        throw new MatterFlowError("Previous message ack is missing");
      } else if (ackedMessageId !== sentMessageIdToAck) {
        if (isStandaloneAck) {
        } else {
          throw new MatterFlowError(
            `Incorrect ack received. Expected ${sentMessageIdToAck}, received: ${ackedMessageId}`
          );
        }
      } else {
        this.#retransmissionTimer?.stop();
        this.#retransmissionCounter = 0;
        this.#sentMessageAckSuccess?.(message);
        this.#sentMessageAckSuccess = void 0;
        this.#sentMessageAckFailure = void 0;
        this.#sentMessageToAck = void 0;
        if (isStandaloneAck && this.#closeTimer !== void 0) {
          return this.#close();
        }
      }
    }
    if (isStandaloneAck) {
      return;
    }
    if (requiresAck) {
      if (this.#receivedMessageToAck !== void 0) {
        this.#receivedMessageAckTimer.stop();
        await this.sendStandaloneAckForMessage(this.#receivedMessageToAck);
        return;
      }
      this.#receivedMessageToAck = message;
      this.#receivedMessageAckTimer.start();
    }
    await this.#messagesQueue.write(message);
  }
  async send(messageType, payload, options) {
    if (options?.requiresAck && !this.#useMRP) {
      options.requiresAck = false;
    }
    const {
      expectAckOnly = false,
      disableMrpLogic,
      expectedProcessingTimeMs = DEFAULT_EXPECTED_PROCESSING_TIME_MS,
      requiresAck,
      includeAcknowledgeMessageId,
      logContext
    } = options ?? {};
    if (!this.#useMRP && includeAcknowledgeMessageId !== void 0) {
      throw new InternalError("Cannot include an acknowledge message ID when MRP is not used");
    }
    if (messageType === SecureMessageType.StandaloneAck) {
      if (!this.#useMRP) {
        return;
      }
      if (requiresAck) {
        throw new MatterFlowError("A standalone ack may not require acknowledgement.");
      }
    }
    if (this.#sentMessageToAck !== void 0 && messageType !== SecureMessageType.StandaloneAck)
      throw new MatterFlowError("The previous message has not been acked yet, cannot send a new message.");
    this.session.notifyActivity(false);
    let ackedMessageId = includeAcknowledgeMessageId;
    if (ackedMessageId === void 0 && this.#useMRP) {
      ackedMessageId = this.#receivedMessageToAck?.packetHeader.messageId;
      if (ackedMessageId !== void 0) {
        this.#receivedMessageAckTimer.stop();
        this.#receivedMessageToAck = void 0;
      }
    }
    const message = {
      packetHeader: {
        sessionId: this.#peerSessionId,
        sessionType: SessionType.Unicast,
        // TODO: support multicast/groups
        messageId: await this.session.getIncrementedMessageCounter(),
        destNodeId: this.#peerNodeId,
        sourceNodeId: this.#nodeId,
        hasPrivacyEnhancements: false,
        isControlMessage: false,
        hasMessageExtensions: false
      },
      payloadHeader: {
        exchangeId: this.#exchangeId,
        protocolId: messageType === SecureMessageType.StandaloneAck ? SECURE_CHANNEL_PROTOCOL_ID : this.#protocolId,
        messageType,
        isInitiatorMessage: this.isInitiator,
        requiresAck: requiresAck ?? (this.#useMRP && messageType !== SecureMessageType.StandaloneAck),
        ackedMessageId,
        hasSecuredExtension: false
      },
      payload
    };
    let ackPromise;
    if (this.#useMRP && message.payloadHeader.requiresAck && !disableMrpLogic) {
      this.#sentMessageToAck = message;
      this.#retransmissionTimer = Time.getTimer(
        `Message retransmission ${message.packetHeader.messageId}`,
        this.#getResubmissionBackOffTime(0),
        () => this.#retransmitMessage(message, expectedProcessingTimeMs)
      );
      const { promise, resolver, rejecter } = createPromise();
      ackPromise = promise;
      this.#sentMessageAckSuccess = resolver;
      this.#sentMessageAckFailure = rejecter;
    }
    await this.channel.send(message, logContext);
    if (ackPromise !== void 0) {
      this.#retransmissionCounter = 0;
      this.#retransmissionTimer?.start();
      const responseMessage = await ackPromise;
      this.#sentMessageAckSuccess = void 0;
      this.#sentMessageAckFailure = void 0;
      const {
        payloadHeader: { protocolId, messageType: messageType2 }
      } = responseMessage;
      if (expectAckOnly && !SecureChannelProtocol.isStandaloneAck(protocolId, messageType2)) {
        throw new UnexpectedMessageError("Expected ack only", responseMessage);
      }
    }
  }
  nextMessage(options) {
    let timeout;
    if (options?.timeoutMs !== void 0) {
      timeout = options.timeoutMs;
    } else {
      switch (this.channel.type) {
        case "tcp":
          timeout = 3e4;
          break;
        case "udp":
          if (!this.#useMRP) {
            throw new MatterFlowError(
              "No response expected for this message exchange because UDP and no MRP."
            );
          }
          const { expectedProcessingTimeMs } = options ?? {};
          timeout = this.calculateMaximumPeerResponseTime(expectedProcessingTimeMs);
          break;
        case "ble":
          timeout = 3e4;
          break;
        default:
          throw new MatterFlowError(
            `Can not calculate expected timeout for unknown channel type: ${this.channel.type}`
          );
      }
      timeout += PEER_RESPONSE_TIME_BUFFER_MS;
    }
    return this.#messagesQueue.read(timeout);
  }
  /**
   * Calculates the backoff time for a resubmission based on the current retransmission count.
   * If no session parameters are provided, the parameters of the current session are used.
   * If session parameters are provided, the method can be used to calculate the maximum backoff time for the other
   * side of the exchange.
   *
   * @see {@link MatterSpecification.v10.Core}, section 4.11.2.1
   */
  #getResubmissionBackOffTime(retransmissionCount, sessionParameters) {
    const { activeIntervalMs, idleIntervalMs } = sessionParameters ?? {
      activeIntervalMs: this.#activeIntervalMs,
      idleIntervalMs: this.#idleIntervalMs
    };
    const baseInterval = sessionParameters !== void 0 || this.session.isPeerActive() ? activeIntervalMs : idleIntervalMs;
    return Math.floor(
      MRP_BACKOFF_MARGIN * baseInterval * Math.pow(MRP_BACKOFF_BASE, Math.max(0, retransmissionCount - MRP_BACKOFF_THRESHOLD)) * (1 + (sessionParameters !== void 0 ? 1 : Math.random()) * MRP_BACKOFF_JITTER)
    );
  }
  calculateMaximumPeerResponseTime(expectedProcessingTimeMs = DEFAULT_EXPECTED_PROCESSING_TIME_MS) {
    let finalWaitTime = expectedProcessingTimeMs;
    for (let i = 0; i < this.#maxTransmissions; i++) {
      finalWaitTime += this.#getResubmissionBackOffTime(i, this.context.localSessionParameters);
    }
    return finalWaitTime;
  }
  #retransmitMessage(message, expectedProcessingTimeMs) {
    this.#retransmissionCounter++;
    if (this.#retransmissionCounter >= this.#maxTransmissions) {
      if (expectedProcessingTimeMs !== void 0) {
        const finalWaitTime = this.calculateMaximumPeerResponseTime(expectedProcessingTimeMs) - (this.#retransmissionTimer?.intervalMs ?? 0);
        if (finalWaitTime > 0) {
          this.#retransmissionCounter--;
          logger.debug(
            `Message ${message.packetHeader.messageId}: Wait additional ${finalWaitTime}ms for processing time and peer resubmissions after all our resubmissions`
          );
          this.#retransmissionTimer = Time.getTimer(
            `Message wait time after resubmissions ${message.packetHeader.messageId}`,
            finalWaitTime,
            () => this.#retransmitMessage(message)
          ).start();
          return;
        }
      }
      if (this.#sentMessageToAck !== void 0 && this.#sentMessageAckFailure !== void 0) {
        this.#receivedMessageToAck = void 0;
        this.#sentMessageAckFailure(new RetransmissionLimitReachedError());
        this.#sentMessageAckFailure = void 0;
        this.#sentMessageAckSuccess = void 0;
      }
      if (this.#closeTimer !== void 0) {
        this.#close().catch((error) => logger.error("An error happened when closing the exchange", error));
      }
      return;
    }
    this.session.notifyActivity(false);
    if (this.#retransmissionCounter === 1) {
      this.context.resubmissionStarted();
    }
    const resubmissionBackoffTime = this.#getResubmissionBackOffTime(this.#retransmissionCounter);
    logger.debug(
      `Resubmit message ${message.packetHeader.messageId} (retransmission attempt ${this.#retransmissionCounter}, backoff time ${resubmissionBackoffTime}ms))`
    );
    this.channel.send(message).then(() => this.#initializeResubmission(message, resubmissionBackoffTime, expectedProcessingTimeMs)).catch((error) => {
      logger.error("An error happened when retransmitting a message", error);
      if (error instanceof ChannelNotConnectedError) {
        this.#close().catch((error2) => logger.error("An error happened when closing the exchange", error2));
      } else {
        this.#initializeResubmission(message, resubmissionBackoffTime, expectedProcessingTimeMs);
      }
    });
  }
  #initializeResubmission(message, resubmissionBackoffTime, expectedProcessingTimeMs) {
    this.#retransmissionTimer = Time.getTimer(
      "Message retransmission",
      resubmissionBackoffTime,
      () => this.#retransmitMessage(message, expectedProcessingTimeMs)
    ).start();
  }
  async destroy() {
    if (this.#closeTimer === void 0 && this.#receivedMessageToAck !== void 0) {
      this.#receivedMessageAckTimer.stop();
      const messageToAck = this.#receivedMessageToAck;
      this.#receivedMessageToAck = void 0;
      try {
        await this.sendStandaloneAckForMessage(messageToAck);
      } catch (error) {
        logger.error("An error happened when closing the exchange", error);
      }
    }
    await this.#close();
  }
  startTimedInteraction(timeoutMs) {
    if (this.#timedInteractionTimer !== void 0 && this.#timedInteractionTimer.isRunning) {
      this.#timedInteractionTimer.stop();
      throw new StatusResponseError(
        "Timed interaction already running for this exchange",
        StatusCode.InvalidAction
      );
    }
    logger.debug(
      `Starting timed interaction with Transaction ID ${this.#exchangeId} for ${timeoutMs}ms from ${this.channel.name}`
    );
    this.#timedInteractionTimer = Time.getTimer("Timed interaction", timeoutMs, () => {
      logger.debug(
        `Timed interaction with Transaction ID ${this.#exchangeId} from ${this.channel.name} timed out`
      );
    }).start();
  }
  clearTimedInteraction() {
    if (this.#timedInteractionTimer !== void 0) {
      logger.debug(
        `Clearing timed interaction with Transaction ID ${this.#exchangeId} from ${this.channel.name}`
      );
      this.#timedInteractionTimer.stop();
      this.#timedInteractionTimer = void 0;
    }
  }
  hasTimedInteraction() {
    return this.#timedInteractionTimer !== void 0;
  }
  hasActiveTimedInteraction() {
    return this.#timedInteractionTimer !== void 0 && this.#timedInteractionTimer.isRunning;
  }
  hasExpiredTimedInteraction() {
    return this.#timedInteractionTimer !== void 0 && !this.#timedInteractionTimer.isRunning;
  }
  async close(force = false) {
    if (this.#closeTimer !== void 0) {
      if (force) {
        this.#closeTimer.stop();
        return this.#close();
      }
      return;
    }
    this.#isClosing = true;
    if (this.#receivedMessageToAck !== void 0) {
      this.#receivedMessageAckTimer.stop();
      const messageToAck = this.#receivedMessageToAck;
      this.#receivedMessageToAck = void 0;
      try {
        await this.sendStandaloneAckForMessage(messageToAck);
      } catch (error) {
        logger.error("An error happened when closing the exchange", error);
      }
      if (force) {
        return this.#close();
      }
    } else if (this.#sentMessageToAck === void 0 || force) {
      return this.#close();
    }
    let maxResubmissionTime = 0;
    for (let i = this.#retransmissionCounter; i <= this.#maxTransmissions; i++) {
      maxResubmissionTime += this.#getResubmissionBackOffTime(i);
    }
    this.#closeTimer = Time.getTimer(
      `Message exchange cleanup ${this.session.name} / ${this.#exchangeId}`,
      maxResubmissionTime,
      async () => await this.#close()
    ).start();
  }
  async #close() {
    this.#isClosing = true;
    this.#retransmissionTimer?.stop();
    this.#closeTimer?.stop();
    this.#timedInteractionTimer?.stop();
    this.#messagesQueue.close();
    await this.#closed.emit();
  }
}
export {
  DEFAULT_EXPECTED_PROCESSING_TIME_MS,
  MATTER_MESSAGE_OVERHEAD,
  MessageExchange,
  RetransmissionLimitReachedError,
  UnexpectedMessageError
};
//# sourceMappingURL=MessageExchange.js.map
