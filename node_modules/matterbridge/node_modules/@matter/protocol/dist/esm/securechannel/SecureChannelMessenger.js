/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Diagnostic, MatterError, UnexpectedDataError } from "#general";
import {
  GeneralStatusCode,
  ProtocolStatusCode,
  SECURE_CHANNEL_PROTOCOL_ID,
  SecureMessageType
} from "#types";
import { TlvSecureChannelStatusMessage } from "./SecureChannelStatusMessageSchema.js";
class ChannelStatusResponseError extends MatterError {
  constructor(message, generalStatusCode, protocolStatusCode) {
    super(`(${generalStatusCode}/${protocolStatusCode}) ${message}`);
    this.generalStatusCode = generalStatusCode;
    this.protocolStatusCode = protocolStatusCode;
  }
}
const EXPECTED_CRYPTO_PROCESSING_TIME_MS = 3e4;
const DEFAULT_NORMAL_PROCESSING_TIME_MS = 2e3;
class SecureChannelMessenger {
  constructor(exchange, defaultExpectedProcessingTimeMs = EXPECTED_CRYPTO_PROCESSING_TIME_MS) {
    this.exchange = exchange;
    this.#defaultExpectedProcessingTimeMs = defaultExpectedProcessingTimeMs;
  }
  #defaultExpectedProcessingTimeMs;
  get channel() {
    return this.exchange.channel;
  }
  async nextMessage(expectedMessageType, expectedProcessingTimeMs = this.#defaultExpectedProcessingTimeMs, expectedMessageInfo) {
    return this.#nextMessage(expectedMessageType, expectedProcessingTimeMs, expectedMessageInfo);
  }
  async anyNextMessage(expectedMessageInfo, expectedProcessingTimeMs = this.#defaultExpectedProcessingTimeMs) {
    return this.#nextMessage(void 0, expectedProcessingTimeMs, expectedMessageInfo);
  }
  /**
   * Waits for the next message and returns it.
   * When no expectedProcessingTimeMs is provided, the default value of EXPECTED_CRYPTO_PROCESSING_TIME_MS is used.
   */
  async #nextMessage(expectedMessageType, expectedProcessingTimeMs = this.#defaultExpectedProcessingTimeMs, expectedMessageInfo) {
    const message = await this.exchange.nextMessage({ expectedProcessingTimeMs });
    const messageType = message.payloadHeader.messageType;
    if (expectedMessageType !== void 0 && expectedMessageInfo === void 0) {
      expectedMessageInfo = SecureMessageType[expectedMessageType];
    }
    this.throwIfErrorStatusReport(message, expectedMessageInfo);
    if (expectedMessageType !== void 0 && messageType !== expectedMessageType)
      throw new UnexpectedDataError(
        `Received unexpected message type: ${messageType}, expected: ${expectedMessageType} (${expectedMessageInfo})`
      );
    return message;
  }
  /**
   * Waits for the next message and decodes it.
   * When no expectedProcessingTimeMs is provided, the default value of EXPECTED_CRYPTO_PROCESSING_TIME_MS is used.
   */
  async nextMessageDecoded(expectedMessageType, schema, expectedProcessingTimeMs = this.#defaultExpectedProcessingTimeMs) {
    return schema.decode((await this.nextMessage(expectedMessageType, expectedProcessingTimeMs)).payload);
  }
  /**
   * Waits for the next message and returns it.
   * When no expectedProcessingTimeMs is provided, the default value of EXPECTED_CRYPTO_PROCESSING_TIME_MS is used.
   */
  async waitForSuccess(expectedMessageInfo, expectedProcessingTimeMs = this.#defaultExpectedProcessingTimeMs) {
    await this.nextMessage(SecureMessageType.StatusReport, expectedProcessingTimeMs, expectedMessageInfo);
  }
  /**
   * Sends a message of the given type with the given payload.
   * If no ExchangeSendOptions are provided, the expectedProcessingTimeMs will be set to
   * EXPECTED_CRYPTO_PROCESSING_TIME_MS.
   */
  async send(message, type, schema, options) {
    options = {
      ...options,
      expectedProcessingTimeMs: options?.expectedProcessingTimeMs ?? this.#defaultExpectedProcessingTimeMs
    };
    const payload = schema.encode(message);
    await this.exchange.send(type, payload, options);
    return payload;
  }
  sendError(code) {
    return this.sendStatusReport(GeneralStatusCode.Failure, code);
  }
  sendSuccess() {
    return this.sendStatusReport(GeneralStatusCode.Success, ProtocolStatusCode.Success);
  }
  sendCloseSession() {
    return this.sendStatusReport(GeneralStatusCode.Success, ProtocolStatusCode.CloseSession, false);
  }
  getChannelName() {
    return this.exchange.channel.channel.name;
  }
  async close() {
    await this.exchange.close();
  }
  async sendStatusReport(generalStatus, protocolStatus, requiresAck) {
    await this.exchange.send(
      SecureMessageType.StatusReport,
      TlvSecureChannelStatusMessage.encode({
        generalStatus,
        protocolId: SECURE_CHANNEL_PROTOCOL_ID,
        protocolStatus
      }),
      {
        requiresAck,
        logContext: {
          generalStatus: GeneralStatusCode[generalStatus] ?? Diagnostic.hex(generalStatus),
          protocolStatus: ProtocolStatusCode[protocolStatus] ?? Diagnostic.hex(protocolStatus)
        }
      }
    );
  }
  throwIfErrorStatusReport(message, logHint) {
    const {
      payloadHeader: { messageType },
      payload
    } = message;
    if (messageType !== SecureMessageType.StatusReport) return;
    const { generalStatus, protocolId, protocolStatus } = TlvSecureChannelStatusMessage.decode(payload);
    if (generalStatus !== GeneralStatusCode.Success) {
      throw new ChannelStatusResponseError(
        `Received general error status for protocol ${protocolId}${logHint ? ` (${logHint})` : ""}`,
        generalStatus,
        protocolStatus
      );
    }
    if (protocolStatus !== ProtocolStatusCode.Success) {
      throw new ChannelStatusResponseError(
        `Received general success status, but protocol status is not Success${logHint ? ` (${logHint})` : ""}`,
        generalStatus,
        protocolStatus
      );
    }
  }
}
export {
  ChannelStatusResponseError,
  DEFAULT_NORMAL_PROCESSING_TIME_MS,
  EXPECTED_CRYPTO_PROCESSING_TIME_MS,
  SecureChannelMessenger
};
//# sourceMappingURL=SecureChannelMessenger.js.map
