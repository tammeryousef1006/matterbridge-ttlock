/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Logger, MatterFlowError } from "#general";
import { NodeId } from "#types";
import { MessageCodec } from "../codec/MessageCodec.js";
import { MessageReceptionStateUnencryptedWithRollover } from "../protocol/MessageReceptionState.js";
import { NoAssociatedFabricError } from "./SecureSession.js";
import { Session } from "./Session.js";
import { UNICAST_UNSECURE_SESSION_ID } from "./SessionManager.js";
const logger = Logger.get("InsecureSession");
class InsecureSession extends Session {
  #initiatorNodeId;
  closingAfterExchangeFinished = false;
  supportsMRP = true;
  constructor(args) {
    const { initiatorNodeId, isInitiator } = args;
    super({
      ...args,
      setActiveTimestamp: !isInitiator,
      // When we are the initiator we assume the node is in idle mode
      messageReceptionState: new MessageReceptionStateUnencryptedWithRollover()
    });
    this.#initiatorNodeId = initiatorNodeId ?? NodeId.randomOperationalNodeId();
  }
  get isSecure() {
    return false;
  }
  get isPase() {
    return false;
  }
  decode(packet) {
    return MessageCodec.decodePayload(packet);
  }
  encode(message) {
    return MessageCodec.encodePayload(message);
  }
  get attestationChallengeKey() {
    throw new MatterFlowError("Not supported on an unsecure session");
  }
  setFabric(_fabric) {
    throw new MatterFlowError("Not supported on an unsecure session");
  }
  get name() {
    return `insecure/${this.#initiatorNodeId}`;
  }
  get id() {
    return UNICAST_UNSECURE_SESSION_ID;
  }
  get peerSessionId() {
    return UNICAST_UNSECURE_SESSION_ID;
  }
  get nodeId() {
    return this.#initiatorNodeId;
  }
  get peerNodeId() {
    return void 0;
  }
  get associatedFabric() {
    throw new NoAssociatedFabricError("Session needs to be a secure session");
  }
  async destroy() {
    await this.end();
    await this.destroyed.emit();
  }
  async end() {
    logger.info(`End insecure session ${this.name}`);
    this.manager?.insecureSessions.delete(this.nodeId);
  }
}
export {
  InsecureSession
};
//# sourceMappingURL=InsecureSession.js.map
