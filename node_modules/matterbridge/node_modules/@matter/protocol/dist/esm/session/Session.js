/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { AsyncObservable, Time } from "#general";
const SESSION_ACTIVE_INTERVAL_MS = 300;
const SESSION_IDLE_INTERVAL_MS = 500;
const SESSION_ACTIVE_THRESHOLD_MS = 4e3;
const FALLBACK_DATAMODEL_REVISION = 17;
const FALLBACK_INTERACTIONMODEL_REVISION = 11;
const FALLBACK_SPECIFICATION_VERSION = 0;
const FALLBACK_MAX_PATHS_PER_INVOKE = 1;
const FALLBACK_MAX_TCP_MESSAGE_SIZE = 64e3;
class Session {
  #manager;
  timestamp = Time.nowMs();
  createdAt = Time.nowMs();
  activeTimestamp = 0;
  idleIntervalMs;
  activeIntervalMs;
  activeThresholdMs;
  dataModelRevision;
  interactionModelRevision;
  specificationVersion;
  maxPathsPerInvoke;
  messageCounter;
  messageReceptionState;
  supportedTransports;
  maxTcpMessageSize;
  /**
   * If the ExchangeManager performs async work to clean up a session it sets this promise.  This is because
   * historically we didn't return from destroy() until ExchangeManager was complete.  Not sure if this is entirely
   * necessary, but it makes sense so this allows us to maintain the old behavior.
   */
  closer;
  #destroyed = AsyncObservable();
  constructor(args) {
    const {
      manager,
      messageCounter,
      messageReceptionState,
      sessionParameters: {
        idleIntervalMs = SESSION_IDLE_INTERVAL_MS,
        activeIntervalMs = SESSION_ACTIVE_INTERVAL_MS,
        activeThresholdMs = SESSION_ACTIVE_THRESHOLD_MS,
        dataModelRevision = FALLBACK_DATAMODEL_REVISION,
        interactionModelRevision = FALLBACK_INTERACTIONMODEL_REVISION,
        specificationVersion = FALLBACK_SPECIFICATION_VERSION,
        maxPathsPerInvoke = FALLBACK_MAX_PATHS_PER_INVOKE,
        supportedTransports = {},
        // no TCP support by default
        maxTcpMessageSize = FALLBACK_MAX_TCP_MESSAGE_SIZE
      } = {},
      setActiveTimestamp
    } = args;
    this.#manager = manager;
    this.messageCounter = messageCounter;
    this.messageReceptionState = messageReceptionState;
    this.idleIntervalMs = idleIntervalMs;
    this.activeIntervalMs = activeIntervalMs;
    this.activeThresholdMs = activeThresholdMs;
    this.dataModelRevision = dataModelRevision;
    this.interactionModelRevision = interactionModelRevision;
    this.specificationVersion = specificationVersion;
    this.maxPathsPerInvoke = maxPathsPerInvoke;
    this.supportedTransports = supportedTransports;
    this.maxTcpMessageSize = maxTcpMessageSize;
    if (setActiveTimestamp) {
      this.activeTimestamp = this.timestamp;
    }
  }
  get destroyed() {
    return this.#destroyed;
  }
  notifyActivity(messageReceived) {
    this.timestamp = Time.nowMs();
    if (messageReceived) {
      this.activeTimestamp = this.timestamp;
    }
  }
  isPeerActive() {
    return Time.nowMs() - this.activeTimestamp < this.activeThresholdMs;
  }
  getIncrementedMessageCounter() {
    return this.messageCounter.getIncrementedCounter();
  }
  updateMessageCounter(messageCounter, _sourceNodeId) {
    this.messageReceptionState.updateMessageCounter(messageCounter);
  }
  /**
   * The peer's session parameters.
   */
  get parameters() {
    const {
      idleIntervalMs,
      activeIntervalMs,
      activeThresholdMs,
      dataModelRevision,
      interactionModelRevision,
      specificationVersion,
      maxPathsPerInvoke,
      supportedTransports,
      maxTcpMessageSize
    } = this;
    return {
      idleIntervalMs,
      activeIntervalMs,
      activeThresholdMs,
      dataModelRevision,
      interactionModelRevision,
      specificationVersion,
      maxPathsPerInvoke,
      supportedTransports,
      maxTcpMessageSize
    };
  }
  get manager() {
    return this.#manager;
  }
  /**
   * @deprecated
   */
  get owner() {
    return this.#manager?.owner;
  }
}
export {
  FALLBACK_DATAMODEL_REVISION,
  FALLBACK_INTERACTIONMODEL_REVISION,
  FALLBACK_MAX_PATHS_PER_INVOKE,
  FALLBACK_MAX_TCP_MESSAGE_SIZE,
  FALLBACK_SPECIFICATION_VERSION,
  SESSION_ACTIVE_INTERVAL_MS,
  SESSION_ACTIVE_THRESHOLD_MS,
  SESSION_IDLE_INTERVAL_MS,
  Session
};
//# sourceMappingURL=Session.js.map
