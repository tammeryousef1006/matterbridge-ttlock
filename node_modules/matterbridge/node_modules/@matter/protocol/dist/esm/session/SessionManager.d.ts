/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { FabricManager } from "#fabric/FabricManager.js";
import { BasicSet, Construction, Environment, Environmental, Observable, StorageContext } from "#general";
import { Subscription } from "#interaction/Subscription.js";
import { PeerAddress } from "#peer/PeerAddress.js";
import { CaseAuthenticatedTag, FabricIndex, NodeId } from "#types";
import { Fabric } from "../fabric/Fabric.js";
import { InsecureSession } from "./InsecureSession.js";
import { SecureSession } from "./SecureSession.js";
import { Session, SessionParameterOptions, SessionParameters } from "./Session.js";
export declare const UNICAST_UNSECURE_SESSION_ID = 0;
export interface ResumptionRecord {
    sharedSecret: Uint8Array;
    resumptionId: Uint8Array;
    fabric: Fabric;
    peerNodeId: NodeId;
    sessionParameters: SessionParameters;
    caseAuthenticatedTags?: CaseAuthenticatedTag[];
}
/**
 * Interfaces {@link SessionManager} with other components.
 */
export interface SessionManagerContext {
    fabrics: FabricManager;
    storage: StorageContext;
    /**
     * Parameter overrides.
     */
    parameters?: Partial<SessionParameters>;
    /**
     * This is an arbitrary contextual object attached to sessions used for compatibility with legacy APIs.
     *
     * @deprecated
     */
    owner?: unknown;
}
/**
 * Manages Matter sessions associated with peer connections.
 */
export declare class SessionManager {
    #private;
    constructor(context: SessionManagerContext);
    static [Environmental.create](env: Environment): SessionManager;
    get construction(): Construction<SessionManager>;
    get context(): SessionManagerContext;
    /**
     * Active secure sessions.
     */
    get sessions(): BasicSet<SecureSession, SecureSession>;
    /**
     * Active insecure sessions.
     */
    get insecureSessions(): Map<NodeId, InsecureSession>;
    /**
     * Our session parameters.  These are the parameters we provide during session negotiation.  The peer may specify
     * different parameters.
     */
    get sessionParameters(): SessionParameters;
    /**
     * Change session parameters.
     *
     * Parameters values you omit in {@link parameters} will retain their current values.  This only affects new
     * sessions.
     */
    set sessionParameters(parameters: Partial<SessionParameters>);
    /**
     * Emits when there is a change to the subscription set.
     */
    get subscriptionsChanged(): Observable<[session: SecureSession, subscription: Subscription], void>;
    /**
     * Emits when resubmission is necessary due to timeout or network error.
     */
    get resubmissionStarted(): Observable<[session: Session], void>;
    /**
     * Convenience function for accessing a fabric by address.
     */
    fabricFor(address: FabricIndex | PeerAddress): Fabric;
    /**
     * @deprecated
     */
    get owner(): unknown;
    createInsecureSession(options: {
        initiatorNodeId?: NodeId;
        sessionParameters?: SessionParameterOptions;
        isInitiator?: boolean;
    }): InsecureSession;
    createSecureSession(args: {
        sessionId: number;
        fabric: Fabric | undefined;
        peerNodeId: NodeId;
        peerSessionId: number;
        sharedSecret: Uint8Array;
        salt: Uint8Array;
        isInitiator: boolean;
        isResumption: boolean;
        peerSessionParameters?: SessionParameterOptions;
        caseAuthenticatedTags?: CaseAuthenticatedTag[];
    }): Promise<SecureSession>;
    deleteResumptionRecord(address: PeerAddress): Promise<void>;
    deleteResumptionRecordsForFabric(fabric: Fabric): Promise<void>;
    findOldestInactiveSession(): SecureSession;
    getNextAvailableSessionId(): Promise<number>;
    getSession(sessionId: number): SecureSession | undefined;
    getPaseSession(): SecureSession;
    getSessionForNode(address: PeerAddress): SecureSession | undefined;
    removeAllSessionsForNode(address: PeerAddress, sendClose?: boolean, closeBeforeCreatedTimestamp?: number): Promise<void>;
    getUnsecureSession(sourceNodeId?: NodeId): InsecureSession | undefined;
    findGroupSession(groupId: number, groupSessionId: number): void;
    findResumptionRecordById(resumptionId: Uint8Array): ResumptionRecord | undefined;
    findResumptionRecordByAddress(address: PeerAddress): ResumptionRecord | undefined;
    saveResumptionRecord(resumptionRecord: ResumptionRecord): Promise<void>;
    getActiveSessionInformation(): {
        name: string;
        nodeId: NodeId;
        peerNodeId: NodeId;
        fabric: import("../fabric/Fabric.js").ExposedFabricInformation | undefined;
        isPeerActive: boolean;
        secure: boolean;
        lastInteractionTimestamp: number | undefined;
        lastActiveTimestamp: number | undefined;
        numberOfActiveSubscriptions: number;
    }[];
    close(): Promise<void>;
    clear(): Promise<void>;
    updateAllSubscriptions(): void;
    /** Clears all subscriptions for a given node and returns how many were cleared. */
    clearSubscriptionsForNode(peerAddress: PeerAddress, flushSubscriptions?: boolean): Promise<number>;
}
//# sourceMappingURL=SessionManager.d.ts.map