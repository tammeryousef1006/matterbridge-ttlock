/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { FabricManager } from "#fabric/FabricManager.js";
import {
  BasicSet,
  Bytes,
  Construction,
  Crypto,
  Environmental,
  Lifecycle,
  Logger,
  MatterAggregateError,
  MatterFlowError,
  Mutex,
  Observable,
  ObserverGroup,
  StorageManager
} from "#general";
import { Specification } from "#model";
import { PeerAddress, PeerAddressMap } from "#peer/PeerAddress.js";
import { DEFAULT_MAX_PATHS_PER_INVOKE, NodeId } from "#types";
import { SupportedTransportsSchema } from "../common/Scanner.js";
import { MessageCounter } from "../protocol/MessageCounter.js";
import { InsecureSession } from "./InsecureSession.js";
import { SecureSession } from "./SecureSession.js";
import {
  FALLBACK_DATAMODEL_REVISION,
  FALLBACK_INTERACTIONMODEL_REVISION,
  FALLBACK_MAX_PATHS_PER_INVOKE,
  FALLBACK_MAX_TCP_MESSAGE_SIZE,
  FALLBACK_SPECIFICATION_VERSION,
  SESSION_ACTIVE_INTERVAL_MS,
  SESSION_ACTIVE_THRESHOLD_MS,
  SESSION_IDLE_INTERVAL_MS
} from "./Session.js";
const logger = Logger.get("SessionManager");
const DEFAULT_SESSION_PARAMETERS = {
  idleIntervalMs: SESSION_IDLE_INTERVAL_MS,
  activeIntervalMs: SESSION_ACTIVE_INTERVAL_MS,
  activeThresholdMs: SESSION_ACTIVE_THRESHOLD_MS,
  dataModelRevision: Specification.DATA_MODEL_REVISION,
  interactionModelRevision: Specification.INTERACTION_MODEL_REVISION,
  specificationVersion: Specification.SPECIFICATION_VERSION,
  maxPathsPerInvoke: DEFAULT_MAX_PATHS_PER_INVOKE,
  supportedTransports: {},
  maxTcpMessageSize: FALLBACK_MAX_TCP_MESSAGE_SIZE
};
const UNICAST_UNSECURE_SESSION_ID = 0;
class SessionManager {
  #context;
  #insecureSessions = /* @__PURE__ */ new Map();
  #sessions = new BasicSet();
  #nextSessionId = Crypto.getRandomUInt16();
  #resumptionRecords = new PeerAddressMap();
  #globalUnencryptedMessageCounter = new MessageCounter();
  #subscriptionsChanged = Observable();
  #sessionParameters;
  #resubmissionStarted = Observable();
  #construction;
  #observers = new ObserverGroup();
  #subscriptionUpdateMutex = new Mutex(this);
  constructor(context) {
    this.#context = context;
    this.#sessionParameters = { ...DEFAULT_SESSION_PARAMETERS, ...context.parameters };
    this.#observers.on(
      context.fabrics.events.deleted,
      async (fabric) => this.deleteResumptionRecordsForFabric(fabric)
    );
    this.#construction = Construction(this, () => this.#initialize());
  }
  static [Environmental.create](env) {
    const instance = new SessionManager({
      storage: env.get(StorageManager).createContext("sessions"),
      fabrics: env.get(FabricManager)
    });
    env.set(SessionManager, instance);
    return instance;
  }
  get construction() {
    return this.#construction;
  }
  get context() {
    return this.#context;
  }
  /**
   * Active secure sessions.
   */
  get sessions() {
    return this.#sessions;
  }
  /**
   * Active insecure sessions.
   */
  get insecureSessions() {
    return this.#insecureSessions;
  }
  /**
   * Our session parameters.  These are the parameters we provide during session negotiation.  The peer may specify
   * different parameters.
   */
  get sessionParameters() {
    return this.#sessionParameters;
  }
  /**
   * Change session parameters.
   *
   * Parameters values you omit in {@link parameters} will retain their current values.  This only affects new
   * sessions.
   */
  set sessionParameters(parameters) {
    this.#sessionParameters = {
      ...this.#sessionParameters,
      ...parameters
    };
  }
  /**
   * Emits when there is a change to the subscription set.
   */
  get subscriptionsChanged() {
    return this.#subscriptionsChanged;
  }
  /**
   * Emits when resubmission is necessary due to timeout or network error.
   */
  get resubmissionStarted() {
    return this.#resubmissionStarted;
  }
  /**
   * Convenience function for accessing a fabric by address.
   */
  fabricFor(address) {
    return this.#context.fabrics.for(address);
  }
  /**
   * @deprecated
   */
  get owner() {
    return this.#context.owner;
  }
  createInsecureSession(options) {
    this.#construction.assert();
    const { initiatorNodeId, sessionParameters, isInitiator } = options;
    if (initiatorNodeId !== void 0) {
      if (this.#insecureSessions.has(initiatorNodeId)) {
        throw new MatterFlowError(`UnsecureSession with NodeId ${initiatorNodeId} already exists.`);
      }
    }
    while (true) {
      const session = new InsecureSession({
        manager: this,
        messageCounter: this.#globalUnencryptedMessageCounter,
        initiatorNodeId,
        sessionParameters,
        isInitiator: isInitiator ?? false
      });
      const ephemeralNodeId = session.nodeId;
      if (this.#insecureSessions.has(ephemeralNodeId)) continue;
      this.#insecureSessions.set(ephemeralNodeId, session);
      return session;
    }
  }
  async createSecureSession(args) {
    await this.construction;
    const {
      sessionId,
      fabric,
      peerNodeId,
      peerSessionId,
      sharedSecret,
      salt,
      isInitiator,
      isResumption,
      peerSessionParameters,
      caseAuthenticatedTags
    } = args;
    const session = await SecureSession.create({
      manager: this,
      id: sessionId,
      fabric,
      peerNodeId,
      peerSessionId,
      sharedSecret,
      salt,
      isInitiator,
      isResumption,
      peerSessionParameters,
      caseAuthenticatedTags
    });
    const subscriptionsChanged = (subscription) => {
      if (session.isClosing) {
        return;
      }
      this.#subscriptionsChanged.emit(session, subscription);
    };
    session.subscriptions.added.on(subscriptionsChanged);
    session.subscriptions.deleted.on(subscriptionsChanged);
    this.#sessions.add(session);
    return session;
  }
  async deleteResumptionRecord(address) {
    await this.#construction;
    this.#resumptionRecords.delete(address);
    await this.#storeResumptionRecords();
  }
  async deleteResumptionRecordsForFabric(fabric) {
    await this.#construction;
    for (const address of this.#resumptionRecords.keys()) {
      if (address.fabricIndex === fabric.fabricIndex) {
        this.#resumptionRecords.delete(address);
      }
    }
    await this.#storeResumptionRecords();
  }
  findOldestInactiveSession() {
    this.#construction.assert();
    let oldestSession = void 0;
    for (const session of this.#sessions) {
      if (!oldestSession || session.activeTimestamp < oldestSession.activeTimestamp) {
        oldestSession = session;
      }
    }
    if (oldestSession === void 0) {
      throw new MatterFlowError("No session found to close and all session ids are taken.");
    }
    return oldestSession;
  }
  async getNextAvailableSessionId() {
    await this.#construction;
    for (let i = 0; i < 65535; i++) {
      const id = this.#nextSessionId;
      this.#nextSessionId = this.#nextSessionId + 1 & 65535;
      if (this.#nextSessionId === 0) this.#nextSessionId++;
      if (this.getSession(id) === void 0) {
        return id;
      }
    }
    const oldestSession = this.findOldestInactiveSession();
    await oldestSession.end(true, false);
    this.#nextSessionId = oldestSession.id;
    return this.#nextSessionId++;
  }
  getSession(sessionId) {
    this.#construction.assert();
    return this.#sessions.get("id", sessionId);
  }
  getPaseSession() {
    this.#construction.assert();
    return [...this.#sessions].find(
      (session) => session.isSecure && session.isPase && !session.closingAfterExchangeFinished
    );
  }
  getSessionForNode(address) {
    this.#construction.assert();
    return [...this.#sessions].find((session) => {
      if (!session.isSecure) return false;
      const secureSession = session;
      return secureSession.peerIs(address);
    });
  }
  async removeAllSessionsForNode(address, sendClose = false, closeBeforeCreatedTimestamp) {
    await this.#construction;
    for (const session of this.#sessions) {
      if (!session.isSecure) continue;
      if (closeBeforeCreatedTimestamp !== void 0 && session.createdAt >= closeBeforeCreatedTimestamp) continue;
      const secureSession = session;
      if (secureSession.peerIs(address)) {
        await secureSession.destroy(sendClose, false);
        this.#sessions.delete(session);
      }
    }
  }
  getUnsecureSession(sourceNodeId) {
    this.#construction.assert();
    if (sourceNodeId === void 0) {
      return this.#insecureSessions.get(NodeId.UNSPECIFIED_NODE_ID);
    }
    return this.#insecureSessions.get(sourceNodeId);
  }
  findGroupSession(groupId, groupSessionId) {
    this.#construction.assert();
    throw new Error(`Not implemented ${groupId} ${groupSessionId}`);
  }
  findResumptionRecordById(resumptionId) {
    this.#construction.assert();
    return [...this.#resumptionRecords.values()].find((record) => Bytes.areEqual(record.resumptionId, resumptionId));
  }
  findResumptionRecordByAddress(address) {
    this.#construction.assert();
    return this.#resumptionRecords.get(address);
  }
  async saveResumptionRecord(resumptionRecord) {
    await this.#construction;
    this.#resumptionRecords.set(resumptionRecord.fabric.addressOf(resumptionRecord.peerNodeId), resumptionRecord);
    await this.#storeResumptionRecords();
  }
  async #storeResumptionRecords() {
    await this.#construction;
    await this.#context.storage.set(
      "resumptionRecords",
      [...this.#resumptionRecords].map(
        ([
          address,
          { sharedSecret, resumptionId, peerNodeId, fabric, sessionParameters, caseAuthenticatedTags }
        ]) => ({
          nodeId: address.nodeId,
          sharedSecret,
          resumptionId,
          fabricId: fabric.fabricId,
          peerNodeId,
          sessionParameters: {
            ...sessionParameters,
            supportedTransports: sessionParameters.supportedTransports ? SupportedTransportsSchema.encode(sessionParameters.supportedTransports) : void 0
          },
          caseAuthenticatedTags
        })
      )
    );
  }
  async #initialize() {
    await this.#context.fabrics.construction;
    const storedResumptionRecords = await this.#context.storage.get(
      "resumptionRecords",
      []
    );
    storedResumptionRecords.forEach(
      ({
        nodeId,
        sharedSecret,
        resumptionId,
        fabricId,
        peerNodeId,
        sessionParameters: {
          idleIntervalMs,
          activeIntervalMs,
          activeThresholdMs,
          dataModelRevision,
          interactionModelRevision,
          specificationVersion,
          maxPathsPerInvoke,
          supportedTransports,
          maxTcpMessageSize
        } = {},
        caseAuthenticatedTags
      }) => {
        const fabric = this.#context.fabrics.find((fabric2) => fabric2.fabricId === fabricId);
        logger.info(
          "restoring resumption record for node",
          nodeId,
          "and peer node",
          peerNodeId,
          "for fabric index",
          fabric?.fabricIndex
        );
        if (!fabric) {
          logger.error("fabric not found for resumption record", fabricId);
          return;
        }
        this.#resumptionRecords.set(fabric.addressOf(nodeId), {
          sharedSecret,
          resumptionId,
          fabric,
          peerNodeId,
          sessionParameters: {
            // Make sure to initialize default values when restoring an older resumption record
            idleIntervalMs: idleIntervalMs ?? SESSION_IDLE_INTERVAL_MS,
            activeIntervalMs: activeIntervalMs ?? SESSION_ACTIVE_INTERVAL_MS,
            activeThresholdMs: activeThresholdMs ?? SESSION_ACTIVE_THRESHOLD_MS,
            dataModelRevision: dataModelRevision ?? FALLBACK_DATAMODEL_REVISION,
            interactionModelRevision: interactionModelRevision ?? FALLBACK_INTERACTIONMODEL_REVISION,
            specificationVersion: specificationVersion ?? FALLBACK_SPECIFICATION_VERSION,
            maxPathsPerInvoke: maxPathsPerInvoke ?? FALLBACK_MAX_PATHS_PER_INVOKE,
            supportedTransports: supportedTransports !== void 0 ? SupportedTransportsSchema.decode(supportedTransports) : {},
            maxTcpMessageSize: maxTcpMessageSize ?? FALLBACK_MAX_TCP_MESSAGE_SIZE
          },
          caseAuthenticatedTags
        });
      }
    );
  }
  getActiveSessionInformation() {
    this.#construction.assert();
    return [...this.#sessions].filter((session) => session.isSecure && !session.isPase).map((session) => ({
      name: session.name,
      nodeId: session.nodeId,
      peerNodeId: session.peerNodeId,
      fabric: session instanceof SecureSession ? session.fabric?.externalInformation : void 0,
      isPeerActive: session.isPeerActive(),
      secure: session.isSecure,
      lastInteractionTimestamp: session instanceof SecureSession ? session.timestamp : void 0,
      lastActiveTimestamp: session instanceof SecureSession ? session.activeTimestamp : void 0,
      numberOfActiveSubscriptions: session instanceof SecureSession ? session.subscriptions.size : 0
    }));
  }
  async close() {
    if (this.#construction.status === Lifecycle.Status.Initializing) {
      await this.#construction;
    }
    await this.#subscriptionUpdateMutex;
    this.#observers.close();
    await this.#storeResumptionRecords();
    const closePromises = this.#sessions.map(async (session) => {
      await session?.end(false);
      this.#sessions.delete(session);
    });
    for (const session of this.#insecureSessions.values()) {
      closePromises.push(session?.end());
    }
    await MatterAggregateError.allSettled(closePromises, "Error closing sessions").catch(
      (error) => logger.error(error)
    );
  }
  async clear() {
    await this.close();
    await this.#context.storage.clear();
    this.#resumptionRecords.clear();
  }
  updateAllSubscriptions() {
    this.#subscriptionUpdateMutex.run(async () => {
      for (const session of this.#sessions) {
        for (const subscription of session.subscriptions) {
          await subscription.update();
        }
      }
    });
  }
  /** Clears all subscriptions for a given node and returns how many were cleared. */
  async clearSubscriptionsForNode(peerAddress, flushSubscriptions) {
    let clearedCount = 0;
    for (const session of this.#sessions) {
      if (PeerAddress.is(session.peerAddress, peerAddress)) {
        clearedCount += await session.clearSubscriptions(flushSubscriptions, true);
      }
    }
    return clearedCount;
  }
}
export {
  SessionManager,
  UNICAST_UNSECURE_SESSION_ID
};
//# sourceMappingURL=SessionManager.js.map
