/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { MatterError, Merge } from "#general";
import { AccessLevel } from "#model";
import { AttributeId } from "../datatype/AttributeId.js";
import { ClusterId } from "../datatype/ClusterId.js";
import { CommandId } from "../datatype/CommandId.js";
import { EventId } from "../datatype/EventId.js";
import { BitSchema, TypeFromPartialBitSchema } from "../schema/BitmapSchema.js";
import { TlvSchema } from "../tlv/TlvSchema.js";
export declare class AttributeError extends MatterError {
}
export declare class EventError extends MatterError {
}
export type ConditionalFeatureList<F extends BitSchema> = TypeFromPartialBitSchema<F>[];
export interface Attribute<T, F extends BitSchema> {
    id: AttributeId;
    schema: TlvSchema<T>;
    optional: boolean;
    readAcl: AccessLevel;
    writable: boolean;
    scene: boolean;
    persistent: boolean;
    timed: boolean;
    fixed: boolean;
    fabricScoped: boolean;
    omitChanges: boolean;
    writeAcl?: AccessLevel;
    default?: T;
    isConditional: boolean;
    optionalIf: ConditionalFeatureList<F>;
    mandatoryIf: ConditionalFeatureList<F>;
    unknown: boolean;
}
export interface OptionalAttribute<T, F extends BitSchema> extends Attribute<T, F> {
    optional: true;
}
export interface ConditionalAttribute<T, F extends BitSchema> extends OptionalAttribute<T, F> {
    isConditional: true;
}
export interface WritableAttribute<T, F extends BitSchema> extends Attribute<T, F> {
    writable: true;
}
export interface OptionalWritableAttribute<T, F extends BitSchema> extends OptionalAttribute<T, F> {
    writable: true;
}
export interface ConditionalWritableAttribute<T, F extends BitSchema> extends OptionalWritableAttribute<T, F> {
    isConditional: true;
}
export interface FabricScopedAttribute<T, F extends BitSchema> extends Attribute<T, F> {
    fabricScoped: true;
}
export interface WritableFabricScopedAttribute<T, F extends BitSchema> extends WritableAttribute<T, F> {
    fabricScoped: true;
}
export interface OptionalWritableFabricScopedAttribute<T, F extends BitSchema> extends OptionalWritableAttribute<T, F> {
    fabricScoped: true;
}
export interface ConditionalWritableFabricScopedAttribute<T, F extends BitSchema> extends OptionalWritableFabricScopedAttribute<T, F> {
    isConditional: true;
}
export interface FixedAttribute<T, F extends BitSchema> extends Attribute<T, F> {
    fixed: true;
}
export interface WritableFixedAttribute<T, F extends BitSchema> extends WritableAttribute<T, F> {
    fixed: true;
}
export interface OptionalFixedAttribute<T, F extends BitSchema> extends OptionalAttribute<T, F> {
    fixed: true;
}
export interface ConditionalFixedAttribute<T, F extends BitSchema> extends OptionalFixedAttribute<T, F> {
    isConditional: true;
}
export type AttributeJsType<T extends Attribute<any, any>> = T extends Attribute<infer JsType, any> ? JsType : never;
interface AttributeOptions<T> {
    scene?: boolean;
    persistent?: boolean;
    omitChanges?: boolean;
    timed?: boolean;
    default?: T;
    readAcl?: AccessLevel;
    writeAcl?: AccessLevel;
}
interface ConditionalAttributeOptions<T, F extends BitSchema> extends AttributeOptions<T> {
    optionalIf?: ConditionalFeatureList<F>;
    mandatoryIf?: ConditionalFeatureList<F>;
}
export declare const Attribute: <T, V extends T, F extends BitSchema>(id: number, schema: TlvSchema<T>, { scene, persistent, omitChanges, default: conformanceValue, readAcl, timed, }?: AttributeOptions<V>) => Attribute<T, F>;
export declare const OptionalAttribute: <T, V extends T, F extends BitSchema>(id: number, schema: TlvSchema<T>, { scene, persistent, omitChanges, default: conformanceValue, readAcl, timed, }?: AttributeOptions<V>) => OptionalAttribute<T, F>;
export declare const ConditionalAttribute: <T, V extends T, F extends BitSchema>(id: number, schema: TlvSchema<T>, { scene, persistent, omitChanges, default: conformanceValue, readAcl, optionalIf, mandatoryIf, timed, }: ConditionalAttributeOptions<V, F>) => ConditionalAttribute<T, F>;
export declare const WritableAttribute: <T, V extends T, F extends BitSchema>(id: number, schema: TlvSchema<T>, { scene, persistent, omitChanges, default: conformanceValue, readAcl, writeAcl, timed, }?: AttributeOptions<V>) => WritableAttribute<T, F>;
export declare const OptionalWritableAttribute: <T, V extends T, F extends BitSchema>(id: number, schema: TlvSchema<T>, { scene, persistent, omitChanges, default: conformanceValue, readAcl, writeAcl, timed, }?: AttributeOptions<V>) => OptionalWritableAttribute<T, F>;
export declare const ConditionalWritableAttribute: <T, V extends T, F extends BitSchema>(id: number, schema: TlvSchema<T>, { scene, persistent, omitChanges, default: conformanceValue, readAcl, writeAcl, optionalIf, mandatoryIf, timed, }: ConditionalAttributeOptions<V, F>) => ConditionalWritableAttribute<T, F>;
export declare const FabricScopedAttribute: <T, V extends T, F extends BitSchema>(id: number, schema: TlvSchema<T>, { scene, persistent, omitChanges, default: conformanceValue, readAcl, timed, }?: AttributeOptions<V>) => FabricScopedAttribute<T, F>;
export declare const WritableFabricScopedAttribute: <T, V extends T, F extends BitSchema>(id: number, schema: TlvSchema<T>, { scene, persistent, omitChanges, default: conformanceValue, readAcl, writeAcl, timed, }?: AttributeOptions<V>) => WritableFabricScopedAttribute<T, F>;
export declare const OptionalWritableFabricScopedAttribute: <T, V extends T, F extends BitSchema>(id: number, schema: TlvSchema<T>, { scene, persistent, omitChanges, default: conformanceValue, readAcl, writeAcl, timed, }?: AttributeOptions<V>) => OptionalWritableFabricScopedAttribute<T, F>;
export declare const ConditionalWritableFabricScopedAttribute: <T, V extends T, F extends BitSchema>(id: number, schema: TlvSchema<T>, { scene, persistent, omitChanges, default: conformanceValue, readAcl, writeAcl, optionalIf, mandatoryIf, timed, }?: ConditionalAttributeOptions<V, F>) => ConditionalWritableFabricScopedAttribute<T, F>;
export declare const FixedAttribute: <T, V extends T, F extends BitSchema>(id: number, schema: TlvSchema<T>, { scene, persistent, omitChanges, default: conformanceValue, readAcl, timed, }?: AttributeOptions<V>) => FixedAttribute<T, F>;
export declare const WritableFixedAttribute: <T, V extends T, F extends BitSchema>(id: number, schema: TlvSchema<T>, { scene, persistent, omitChanges, default: conformanceValue, readAcl, timed, }?: AttributeOptions<V>) => FixedAttribute<T, F>;
export declare const OptionalFixedAttribute: <T, V extends T, F extends BitSchema>(id: number, schema: TlvSchema<T>, { scene, persistent, omitChanges, default: conformanceValue, readAcl, timed, }?: AttributeOptions<V>) => OptionalFixedAttribute<T, F>;
export declare const ConditionalFixedAttribute: <T, V extends T, F extends BitSchema>(id: number, schema: TlvSchema<T>, { scene, persistent, omitChanges, default: conformanceValue, readAcl, timed, optionalIf, mandatoryIf, }: ConditionalAttributeOptions<V, F>) => ConditionalFixedAttribute<T, F>;
export interface UnknownAttribute<T, F extends BitSchema> extends Attribute<T, F> {
    unknown: true;
}
export declare const UnknownAttribute: <F extends BitSchema>(id: number) => UnknownAttribute<any, F>;
export type MandatoryAttributeNames<A extends Attributes> = {
    [K in keyof A]: A[K] extends OptionalAttribute<any, any> ? never : K;
}[keyof A];
export type OptionalAttributeNames<A extends Attributes> = {
    [K in keyof A]: A[K] extends OptionalAttribute<any, any> ? K : never;
}[keyof A];
export type GlobalAttributeNames<F extends BitSchema> = keyof GlobalAttributes<F>;
export declare const TlvNoResponse: import("../tlv/TlvVoid.js").VoidSchema;
export interface Command<RequestT, ResponseT, F extends BitSchema> {
    optional: boolean;
    requestId: CommandId;
    requestSchema: TlvSchema<RequestT>;
    responseId: CommandId;
    responseSchema: TlvSchema<ResponseT>;
    invokeAcl: AccessLevel;
    timed: boolean;
    isConditional: boolean;
    mandatoryIf: ConditionalFeatureList<F>;
    optionalIf: ConditionalFeatureList<F>;
}
export interface OptionalCommand<RequestT, ResponseT, F extends BitSchema> extends Command<RequestT, ResponseT, F> {
    optional: true;
}
export interface ConditionalCommand<RequestT, ResponseT, F extends BitSchema> extends OptionalCommand<RequestT, ResponseT, F> {
    isConditional: true;
}
export type ResponseType<T extends Command<any, any, any>> = T extends OptionalCommand<any, infer ResponseT, any> ? ResponseT : T extends Command<any, infer ResponseT, any> ? ResponseT : never;
export type RequestType<T extends Command<any, any, any>> = T extends OptionalCommand<infer RequestT, any, any> ? RequestT : T extends Command<infer RequestT, any, any> ? RequestT : never;
interface CommandOptions {
    invokeAcl?: AccessLevel;
    timed?: boolean;
}
interface ConditionalCommandOptions<F extends BitSchema> extends CommandOptions {
    optionalIf?: ConditionalFeatureList<F>;
    mandatoryIf?: ConditionalFeatureList<F>;
}
export declare const Command: <RequestT, ResponseT, F extends BitSchema>(requestId: number, requestSchema: TlvSchema<RequestT>, responseId: number, responseSchema: TlvSchema<ResponseT>, { invokeAcl, timed }?: CommandOptions) => Command<RequestT, ResponseT, F>;
export declare const OptionalCommand: <RequestT, ResponseT, F extends BitSchema>(requestId: number, requestSchema: TlvSchema<RequestT>, responseId: number, responseSchema: TlvSchema<ResponseT>, { invokeAcl, timed }?: CommandOptions) => OptionalCommand<RequestT, ResponseT, F>;
export declare const ConditionalCommand: <RequestT, ResponseT, F extends BitSchema>(requestId: number, requestSchema: TlvSchema<RequestT>, responseId: number, responseSchema: TlvSchema<ResponseT>, { invokeAcl, timed, optionalIf, mandatoryIf, }?: ConditionalCommandOptions<F>) => ConditionalCommand<RequestT, ResponseT, F>;
/**
 * Interfaces and helper methods to define a cluster event
 * @see {@link MatterSpecification.v11.Core} § 7.18.2.25
 */
export declare enum EventPriority {
    Debug = 0,
    Info = 1,
    Critical = 2
}
export interface Event<T, F extends BitSchema> {
    id: EventId;
    schema: TlvSchema<T>;
    priority: EventPriority;
    optional: boolean;
    readAcl: AccessLevel;
    isConditional: boolean;
    optionalIf: ConditionalFeatureList<F>;
    mandatoryIf: ConditionalFeatureList<F>;
    unknown: boolean;
}
export interface UnknownEvent<F extends BitSchema> extends Event<any, F> {
    unknown: true;
}
interface EventOptions {
    readAcl?: AccessLevel;
}
interface ConditionalEventOptions<F extends BitSchema> extends EventOptions {
    optionalIf?: ConditionalFeatureList<F>;
    mandatoryIf?: ConditionalFeatureList<F>;
}
export interface OptionalEvent<T, F extends BitSchema> extends Event<T, F> {
    optional: true;
}
export interface ConditionalEvent<T, F extends BitSchema> extends OptionalEvent<T, F> {
    isConditional: true;
}
export declare const Event: <T, F extends BitSchema>(id: number, priority: EventPriority, schema: TlvSchema<T>, { readAcl }?: EventOptions) => Event<T, F>;
export declare const OptionalEvent: <T, F extends BitSchema>(id: number, priority: EventPriority, schema: TlvSchema<T>, { readAcl }?: EventOptions) => OptionalEvent<T, F>;
export declare const ConditionalEvent: <T, F extends BitSchema>(id: EventId, priority: EventPriority, schema: TlvSchema<T>, { readAcl, optionalIf, mandatoryIf }: ConditionalEventOptions<F>) => ConditionalEvent<T, F>;
export declare const UnknownEvent: <F extends BitSchema>(id: number) => Event<unknown, F>;
export type EventType<T extends Event<any, any>> = T extends OptionalEvent<infer EventT, any> ? EventT : T extends Event<infer EventT, any> ? EventT : never;
export type MandatoryEventNames<E extends Events> = {
    [K in keyof E]: E[K] extends OptionalEvent<any, any> ? never : K;
}[keyof E];
export type OptionalEventNames<E extends Events> = {
    [K in keyof E]: E[K] extends OptionalEvent<any, any> ? K : never;
}[keyof E];
export interface Attributes {
    [key: string]: Attribute<any, any>;
}
export interface Commands {
    [key: string]: Command<any, any, any>;
}
export interface Events {
    [key: string]: Event<any, any>;
}
/** @see {@link MatterSpecification.v11.Core} § 7.13 */
export type GlobalAttributes<F extends BitSchema> = {
    /** Indicates the revision of the server cluster specification supported by the cluster instance. */
    clusterRevision: Attribute<number, never>;
    /** Indicates whether the server supports zero or more optional cluster features. */
    featureMap: Attribute<TypeFromPartialBitSchema<F>, never>;
    /** List of the attribute IDs of the attributes supported by the cluster instance. */
    attributeList: Attribute<AttributeId[], never>;
    /** List of client generated commands which are supported by this cluster server instance. */
    acceptedCommandList: Attribute<CommandId[], never>;
    /** List of server generated commands (server to client commands). */
    generatedCommandList: Attribute<CommandId[], never>;
};
export declare const GlobalAttributes: <F extends BitSchema>(features: F) => GlobalAttributes<F>;
export interface Cluster<F extends BitSchema, SF extends TypeFromPartialBitSchema<F>, A extends Attributes, C extends Commands, E extends Events> {
    id: ClusterId;
    name: string;
    revision: number;
    features: F;
    supportedFeatures: SF;
    attributes: A;
    commands: C;
    events: E;
    unknown: boolean;
}
export declare const Cluster: <F extends BitSchema, SF extends TypeFromPartialBitSchema<F>, A extends Attributes = {}, C extends Commands = {}, E extends Events = {}>({ id, name, revision, features, supportedFeatures, attributes, commands, events, unknown, }: {
    id: number;
    name: string;
    revision: number;
    features?: F;
    supportedFeatures?: SF;
    attributes?: A;
    commands?: C;
    events?: E;
    unknown?: boolean;
}) => Cluster<F, SF, Merge<A, GlobalAttributes<F>>, C, E>;
export type ClusterExtend<F extends BitSchema, SF extends TypeFromPartialBitSchema<F>, A extends Attributes, C extends Commands, E extends Events> = {
    supportedFeatures: SF;
    attributes?: A;
    commands?: C;
    events?: E;
};
export declare const ClusterExtend: <F extends BitSchema, SF_BASE extends TypeFromPartialBitSchema<F>, SF_EXTEND extends TypeFromPartialBitSchema<F>, A_BASE extends Attributes = {}, C_BASE extends Commands = {}, E_BASE extends Events = {}, A_EXTEND extends Attributes = {}, C_EXTEND extends Commands = {}, E_EXTEND extends Events = {}>({ id, name, revision, features, supportedFeatures, attributes, commands, events, unknown, }: Cluster<F, SF_BASE, A_BASE, C_BASE, E_BASE>, { supportedFeatures: supportedFeaturesExtend, attributes: attributesExtend, commands: commandsExtend, events: eventsExtend, }: ClusterExtend<F, SF_EXTEND, A_EXTEND, C_EXTEND, E_EXTEND>) => Cluster<F, Merge<SF_BASE, SF_EXTEND>, Merge<A_BASE, A_EXTEND>, Merge<C_BASE, C_EXTEND>, Merge<E_BASE, E_EXTEND>>;
export {};
//# sourceMappingURL=Cluster.d.ts.map