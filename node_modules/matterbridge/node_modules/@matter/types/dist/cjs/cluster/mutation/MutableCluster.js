"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var MutableCluster_exports = {};
__export(MutableCluster_exports, {
  MutableCluster: () => MutableCluster
});
module.exports = __toCommonJS(MutableCluster_exports);
var import_ClusterType = require("../ClusterType.js");
var import_ClusterComposer = require("./ClusterComposer.js");
var import_ElementModifier = require("./ElementModifier.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
function MutableCluster(options, ...components) {
  const cluster = (0, import_ClusterType.ClusterType)(options);
  for (const component of components) {
    import_ClusterComposer.ClusterComposer.injectElements(cluster, component);
  }
  Object.assign(cluster, {
    with(...features) {
      return new import_ClusterComposer.ClusterComposer(cluster).compose(features);
    },
    alter(alterations) {
      return new import_ElementModifier.ElementModifier(cluster).alter(alterations);
    },
    set(values) {
      return new import_ElementModifier.ElementModifier(cluster).set(values);
    },
    enable(flags) {
      return new import_ElementModifier.ElementModifier(cluster).enable(flags);
    }
  });
  return cluster;
}
((MutableCluster2) => {
  function Component(elements) {
    return elements;
  }
  MutableCluster2.Component = Component;
  function Extensions(...extensions) {
    return extensions;
  }
  MutableCluster2.Extensions = Extensions;
  function ExtensibleOnly(options) {
    return {
      id: options.id,
      name: options.name,
      with(...features) {
        return new import_ClusterComposer.ClusterComposer((0, import_ClusterType.ClusterType)(options)).compose(features);
      }
    };
  }
  MutableCluster2.ExtensibleOnly = ExtensibleOnly;
  function AsConditional(element, { optionalIf, mandatoryIf }) {
    return {
      ...element,
      optional: true,
      isConditional: true,
      optionalIf: optionalIf ?? [],
      mandatoryIf: mandatoryIf ?? []
    };
  }
  MutableCluster2.AsConditional = AsConditional;
})(MutableCluster || (MutableCluster = {}));
//# sourceMappingURL=MutableCluster.js.map
