"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var application_launcher_exports = {};
__export(application_launcher_exports, {
  ApplicationLauncher: () => ApplicationLauncher,
  ApplicationLauncherCluster: () => ApplicationLauncherCluster
});
module.exports = __toCommonJS(application_launcher_exports);
var import_MutableCluster = require("../cluster/mutation/MutableCluster.js");
var import_Cluster = require("../cluster/Cluster.js");
var import_TlvArray = require("../tlv/TlvArray.js");
var import_TlvNumber = require("../tlv/TlvNumber.js");
var import_BitmapSchema = require("../schema/BitmapSchema.js");
var import_TlvObject = require("../tlv/TlvObject.js");
var import_TlvString = require("../tlv/TlvString.js");
var import_EndpointNumber = require("../datatype/EndpointNumber.js");
var import_TlvNullable = require("../tlv/TlvNullable.js");
var import_ClusterRegistry = require("../cluster/ClusterRegistry.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
var ApplicationLauncher;
((ApplicationLauncher2) => {
  let Feature;
  ((Feature2) => {
    Feature2["ApplicationPlatform"] = "ApplicationPlatform";
  })(Feature = ApplicationLauncher2.Feature || (ApplicationLauncher2.Feature = {}));
  ApplicationLauncher2.TlvApplication = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the CSA-issued vendor ID for the catalog. The DIAL registry shall use value 0x0000.
     *
     * Content App Platform providers will have their own catalog vendor ID (set to their own Vendor ID) and will
     * assign an ApplicationID to each Content App.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.4.5.2.1
     */
    catalogVendorId: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt16),
    /**
     * This field shall indicate the application identifier, expressed as a string, such as "PruneVideo" or "Company
     * X". This field shall be unique within a catalog.
     *
     * For the DIAL registry catalog, this value shall be the DIAL prefix (see [DIAL Registry]).
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.4.5.2.2
     */
    applicationId: (0, import_TlvObject.TlvField)(1, import_TlvString.TlvString)
  });
  ApplicationLauncher2.TlvApplicationEp = (0, import_TlvObject.TlvObject)({
    application: (0, import_TlvObject.TlvField)(0, ApplicationLauncher2.TlvApplication),
    endpoint: (0, import_TlvObject.TlvOptionalField)(1, import_EndpointNumber.TlvEndpointNumber)
  });
  ApplicationLauncher2.TlvLaunchAppRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall specify the Application to launch.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.4.7.1.1
     */
    application: (0, import_TlvObject.TlvOptionalField)(0, ApplicationLauncher2.TlvApplication),
    /**
     * This field shall specify optional app-specific data to be sent to the app.
     *
     * NOTE
     *
     * This format and meaning of this value is proprietary and outside the specification. It provides a transition
     * path for device makers that use other protocols (like DIAL) which allow for proprietary data. Apps that are
     * not yet Matter aware can be launched via Matter, while retaining the existing ability to launch with
     * proprietary data.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.4.7.1.2
     */
    data: (0, import_TlvObject.TlvOptionalField)(1, import_TlvString.TlvByteString)
  });
  let Status;
  ((Status2) => {
    Status2[Status2["Success"] = 0] = "Success";
    Status2[Status2["AppNotAvailable"] = 1] = "AppNotAvailable";
    Status2[Status2["SystemBusy"] = 2] = "SystemBusy";
    Status2[Status2["PendingUserApproval"] = 3] = "PendingUserApproval";
    Status2[Status2["Downloading"] = 4] = "Downloading";
    Status2[Status2["Installing"] = 5] = "Installing";
  })(Status = ApplicationLauncher2.Status || (ApplicationLauncher2.Status = {}));
  ApplicationLauncher2.TlvLauncherResponse = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the status of the command which resulted in this response.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.4.7.4.1
     */
    status: (0, import_TlvObject.TlvField)(0, (0, import_TlvNumber.TlvEnum)()),
    /**
     * This field shall specify Optional app-specific data.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.4.7.4.2
     */
    data: (0, import_TlvObject.TlvOptionalField)(1, import_TlvString.TlvByteString)
  });
  ApplicationLauncher2.TlvStopAppRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall specify the Application to stop.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.4.7.2.1
     */
    application: (0, import_TlvObject.TlvOptionalField)(0, ApplicationLauncher2.TlvApplication)
  });
  ApplicationLauncher2.TlvHideAppRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall specify the Application to hide.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.4.7.3.1
     */
    application: (0, import_TlvObject.TlvOptionalField)(0, ApplicationLauncher2.TlvApplication)
  });
  ApplicationLauncher2.ApplicationPlatformComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * This attribute shall specify the list of supported application catalogs, where each entry in the list is
       * the CSA-issued vendor ID for the catalog. The DIAL registry (see [DIAL Registry]) shall use value 0x0000.
       *
       * It is expected that Content App Platform providers will have their own catalog vendor ID (set to their
       * own Vendor ID) and will assign an ApplicationID to each Content App.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.4.6.1
       */
      catalogList: (0, import_Cluster.Attribute)(0, (0, import_TlvArray.TlvArray)(import_TlvNumber.TlvUInt16), { persistent: true, default: [] })
    }
  });
  ApplicationLauncher2.Base = import_MutableCluster.MutableCluster.Component({
    id: 1292,
    name: "ApplicationLauncher",
    revision: 2,
    features: {
      /**
       * ApplicationPlatform
       *
       * Support for attributes and commands required for endpoint to support launching any application within the
       * supported application catalogs
       */
      applicationPlatform: (0, import_BitmapSchema.BitFlag)(0)
    },
    attributes: {
      /**
       * This attribute shall specify the current in-focus application, identified using an Application ID,
       * catalog vendor ID and the corresponding endpoint number when the application is represented by a Content
       * App endpoint. A null shall be used to indicate there is no current in-focus application.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.4.6.2
       */
      currentApp: (0, import_Cluster.OptionalAttribute)(1, (0, import_TlvNullable.TlvNullable)(ApplicationLauncher2.TlvApplicationEp), { default: null })
    },
    commands: {
      /**
       * Upon receipt of this command, the server shall launch the application with optional data. The application
       * shall be either
       *
       *   • the specified application, if the Application Platform feature is supported;
       *
       *   • otherwise the application corresponding to the endpoint.
       *
       * The endpoint shall launch and bring to foreground the requisite application if the application is not
       * already launched and in foreground. The Status attribute shall be updated to ActiveVisibleFocus on the
       * Application Basic cluster of the Endpoint corresponding to the launched application. The Status attribute
       * shall be updated on any other application whose Status may have changed as a result of this command. The
       * CurrentApp attribute, if supported, shall be updated to reflect the new application in the foreground.
       *
       * This command returns a Launcher Response.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.4.7.1
       */
      launchApp: (0, import_Cluster.Command)(0, ApplicationLauncher2.TlvLaunchAppRequest, 3, ApplicationLauncher2.TlvLauncherResponse),
      /**
       * Upon receipt of this command, the server shall stop the application if it is running. The application
       * shall be either
       *
       *   • the specified application, if the Application Platform feature is supported;
       *
       *   • otherwise the application corresponding to the endpoint.
       *
       * The Status attribute shall be updated to Stopped on the Application Basic cluster of the Endpoint
       * corresponding to the stopped application. The Status attribute shall be updated on any other application
       * whose Status may have changed as a result of this command.
       *
       * This command returns a Launcher Response.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.4.7.2
       */
      stopApp: (0, import_Cluster.Command)(1, ApplicationLauncher2.TlvStopAppRequest, 3, ApplicationLauncher2.TlvLauncherResponse),
      /**
       * Upon receipt of this command, the server shall hide the application. The application shall be either
       *
       *   • the specified application, if the Application Platform feature is supported;
       *
       *   • otherwise the application corresponding to the endpoint.
       *
       * The endpoint may decide to stop the application based on manufacturer specific behavior or resource
       * constraints if any. The Status attribute shall be updated to ActiveHidden or Stopped, depending on the
       * action taken, on the Application Basic cluster of the Endpoint corresponding to the application on which
       * the action was taken. The Status attribute shall be updated on any other application whose Status may
       * have changed as a result of this command.
       *
       * This command returns a Launcher Response.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.4.7.3
       */
      hideApp: (0, import_Cluster.Command)(2, ApplicationLauncher2.TlvHideAppRequest, 3, ApplicationLauncher2.TlvLauncherResponse)
    },
    /**
     * This metadata controls which ApplicationLauncherCluster elements matter.js activates for specific feature
     * combinations.
     */
    extensions: import_MutableCluster.MutableCluster.Extensions(
      { flags: { applicationPlatform: true }, component: ApplicationLauncher2.ApplicationPlatformComponent }
    )
  });
  ApplicationLauncher2.ClusterInstance = (0, import_MutableCluster.MutableCluster)(ApplicationLauncher2.Base);
  ApplicationLauncher2.Cluster = ApplicationLauncher2.ClusterInstance;
  const AP = { applicationPlatform: true };
  ApplicationLauncher2.CompleteInstance = (0, import_MutableCluster.MutableCluster)({
    id: ApplicationLauncher2.Cluster.id,
    name: ApplicationLauncher2.Cluster.name,
    revision: ApplicationLauncher2.Cluster.revision,
    features: ApplicationLauncher2.Cluster.features,
    attributes: {
      ...ApplicationLauncher2.Cluster.attributes,
      catalogList: import_MutableCluster.MutableCluster.AsConditional(
        ApplicationLauncher2.ApplicationPlatformComponent.attributes.catalogList,
        { mandatoryIf: [AP] }
      )
    },
    commands: ApplicationLauncher2.Cluster.commands
  });
  ApplicationLauncher2.Complete = ApplicationLauncher2.CompleteInstance;
})(ApplicationLauncher || (ApplicationLauncher = {}));
const ApplicationLauncherCluster = ApplicationLauncher.Cluster;
import_ClusterRegistry.ClusterRegistry.register(ApplicationLauncher.Complete);
//# sourceMappingURL=application-launcher.js.map
