"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var commissioner_control_exports = {};
__export(commissioner_control_exports, {
  CommissionerControl: () => CommissionerControl,
  CommissionerControlCluster: () => CommissionerControlCluster
});
module.exports = __toCommonJS(commissioner_control_exports);
var import_MutableCluster = require("../cluster/mutation/MutableCluster.js");
var import_Cluster = require("../cluster/Cluster.js");
var import_BitmapSchema = require("../schema/BitmapSchema.js");
var import_TlvNumber = require("../tlv/TlvNumber.js");
var import_model = require("#model");
var import_TlvObject = require("../tlv/TlvObject.js");
var import_VendorId = require("../datatype/VendorId.js");
var import_TlvString = require("../tlv/TlvString.js");
var import_NodeId = require("../datatype/NodeId.js");
var import_FabricIndex = require("../datatype/FabricIndex.js");
var import_ClusterRegistry = require("../cluster/ClusterRegistry.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
var CommissionerControl;
((CommissionerControl2) => {
  CommissionerControl2.SupportedDeviceCategory = {
    /**
     * Aggregators which support Fabric Synchronization may be commissioned.
     *
     * The FabricSynchronization bit shall be set to 1 if and only if the server supports commissioning nodes that
     * support Fabric Synchronization.
     *
     * @see {@link MatterSpecification.v14.Core} § 11.26.4.1.1
     */
    fabricSynchronization: (0, import_BitmapSchema.BitFlag)(0)
  };
  CommissionerControl2.TlvRequestCommissioningApprovalRequest = (0, import_TlvObject.TlvObject)({
    requestId: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt64),
    vendorId: (0, import_TlvObject.TlvField)(1, import_VendorId.TlvVendorId),
    productId: (0, import_TlvObject.TlvField)(2, import_TlvNumber.TlvUInt16),
    label: (0, import_TlvObject.TlvOptionalField)(3, import_TlvString.TlvString.bound({ maxLength: 64 }))
  });
  CommissionerControl2.TlvCommissionNodeRequest = (0, import_TlvObject.TlvObject)({
    requestId: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt64),
    responseTimeoutSeconds: (0, import_TlvObject.TlvField)(1, import_TlvNumber.TlvUInt16.bound({ min: 30, max: 120 }))
  });
  CommissionerControl2.TlvReverseOpenCommissioningWindowResponse = (0, import_TlvObject.TlvObject)({
    commissioningTimeout: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt16),
    pakePasscodeVerifier: (0, import_TlvObject.TlvField)(1, import_TlvString.TlvByteString),
    discriminator: (0, import_TlvObject.TlvField)(2, import_TlvNumber.TlvUInt16.bound({ max: 4095 })),
    iterations: (0, import_TlvObject.TlvField)(3, import_TlvNumber.TlvUInt32.bound({ min: 1e3, max: 1e5 })),
    salt: (0, import_TlvObject.TlvField)(4, import_TlvString.TlvByteString.bound({ minLength: 16, maxLength: 32 }))
  });
  CommissionerControl2.TlvCommissioningRequestResultEvent = (0, import_TlvObject.TlvObject)({
    requestId: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt64),
    clientNodeId: (0, import_TlvObject.TlvField)(1, import_NodeId.TlvNodeId),
    statusCode: (0, import_TlvObject.TlvField)(2, (0, import_TlvNumber.TlvEnum)()),
    fabricIndex: (0, import_TlvObject.TlvField)(254, import_FabricIndex.TlvFabricIndex)
  });
  CommissionerControl2.ClusterInstance = (0, import_MutableCluster.MutableCluster)({
    id: 1873,
    name: "CommissionerControl",
    revision: 1,
    attributes: {
      /**
       * Indicates the device categories specified in SupportedDeviceCategoryBitmap that are supported by this
       * Commissioner Control Cluster server.
       *
       * A client shall NOT send the RequestCommissioningApproval command if the intended node to be commissioned
       * does not conform to any of the values specified in SupportedDeviceCategories.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.26.5.1
       */
      supportedDeviceCategories: (0, import_Cluster.Attribute)(
        0,
        (0, import_TlvNumber.TlvBitmap)(import_TlvNumber.TlvUInt32, CommissionerControl2.SupportedDeviceCategory),
        { readAcl: import_model.AccessLevel.Manage, writeAcl: import_model.AccessLevel.Manage }
      )
    },
    commands: {
      /**
       * This command is sent by a client to request approval for a future CommissionNode call. This is required
       * to be a separate step in order to provide the server time for interacting with a user before informing
       * the client that the CommissionNode operation may be successful.
       *
       * If the command is not executed via a CASE session, the command shall fail with a status code of
       * UNSUPPORTED_ACCESS.
       *
       * The server may request approval from the user, but it is not required.
       *
       * The server shall always return SUCCESS to a correctly formatted RequestCommissioningApproval command, and
       * then generate a CommissioningRequestResult event associated with the command’s
       *
       * accessing fabric once the result is ready.
       *
       * Clients SHOULD avoid using the same RequestID. If the RequestID and client NodeID of a
       * RequestCommissioningApproval match a previously received RequestCommissioningApproval and the server has
       * not returned an error or completed commissioning of a device for the prior request, then the server
       * SHOULD return FAILURE.
       *
       * The parameters for RequestCommissioningApproval command are as follows:
       *
       * @see {@link MatterSpecification.v14.Core} § 11.26.6.1
       */
      requestCommissioningApproval: (0, import_Cluster.Command)(
        0,
        CommissionerControl2.TlvRequestCommissioningApprovalRequest,
        0,
        import_Cluster.TlvNoResponse,
        { invokeAcl: import_model.AccessLevel.Manage }
      ),
      /**
       * This command is sent by a client to request that the server begins commissioning a previously approved
       * request.
       *
       * The server shall return FAILURE if the CommissionNode command is not sent from the same NodeID and on the
       * same fabric as the RequestCommissioningApproval or if the provided RequestID to CommissionNode does not
       * match the value provided to RequestCommissioningApproval.
       *
       * If the command is not executed via a CASE session, the command shall fail with a status code of
       *
       * UNSUPPORTED_ACCESS.
       *
       * Upon receipt, the server shall respond with ReverseOpenCommissioningWindow if CommissioningRequestResult
       * was generated with StatusCode of SUCCESS for the matching RequestID field and NodeID of the client.
       *
       * The server shall return FAILURE if the CommissionNode command is received after the server has already
       * responded to a client with ReverseOpenCommissioningWindow for a matching RequestID field and NodeID of
       * the client unless the client has sent another RequestCommissioningApproval and received an additional
       * CommissioningRequestResult.
       *
       * The parameters for CommissionNode command are as follows:
       *
       * @see {@link MatterSpecification.v14.Core} § 11.26.6.5
       */
      commissionNode: (0, import_Cluster.Command)(
        1,
        CommissionerControl2.TlvCommissionNodeRequest,
        2,
        CommissionerControl2.TlvReverseOpenCommissioningWindowResponse,
        { invokeAcl: import_model.AccessLevel.Manage }
      )
    },
    events: {
      /**
       * This event shall be generated by the server following a RequestCommissioningApproval command which the
       * server responded to with SUCCESS.
       *
       * NOTE
       *
       * The approval is valid for a period determined by the manufacturer and characteristics of the node
       * presenting the Commissioner Control Cluster. Clients SHOULD send the CommissionNode command immediately
       * upon receiving a CommissioningRequestResult event.
       *
       * 11.26.7.2. RequestID / ClientNodeID Fields
       *
       * The RequestID shall match the RequestID provided to RequestCommissioningApproval and the ClientNodeID
       * shall match the NodeID of the client which generated the RequestCommissioningAp
       *
       * proval command.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.26.7.1
       */
      commissioningRequestResult: (0, import_Cluster.Event)(
        0,
        import_Cluster.EventPriority.Info,
        CommissionerControl2.TlvCommissioningRequestResultEvent,
        { readAcl: import_model.AccessLevel.Manage }
      )
    }
  });
  CommissionerControl2.Cluster = CommissionerControl2.ClusterInstance;
  CommissionerControl2.Complete = CommissionerControl2.Cluster;
})(CommissionerControl || (CommissionerControl = {}));
const CommissionerControlCluster = CommissionerControl.Cluster;
import_ClusterRegistry.ClusterRegistry.register(CommissionerControl.Complete);
//# sourceMappingURL=commissioner-control.js.map
