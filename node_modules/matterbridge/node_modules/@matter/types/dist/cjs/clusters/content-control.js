"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var content_control_exports = {};
__export(content_control_exports, {
  ContentControl: () => ContentControl,
  ContentControlCluster: () => ContentControlCluster
});
module.exports = __toCommonJS(content_control_exports);
var import_MutableCluster = require("../cluster/mutation/MutableCluster.js");
var import_Cluster = require("../cluster/Cluster.js");
var import_TlvArray = require("../tlv/TlvArray.js");
var import_TlvObject = require("../tlv/TlvObject.js");
var import_TlvString = require("../tlv/TlvString.js");
var import_model = require("#model");
var import_TlvNumber = require("../tlv/TlvNumber.js");
var import_TlvNoArguments = require("../tlv/TlvNoArguments.js");
var import_TlvBoolean = require("../tlv/TlvBoolean.js");
var import_TlvNullable = require("../tlv/TlvNullable.js");
var import_BitmapSchema = require("../schema/BitmapSchema.js");
var import_ClusterRegistry = require("../cluster/ClusterRegistry.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
var ContentControl;
((ContentControl2) => {
  let Feature;
  ((Feature2) => {
    Feature2["ScreenTime"] = "ScreenTime";
    Feature2["PinManagement"] = "PinManagement";
    Feature2["BlockUnrated"] = "BlockUnrated";
    Feature2["OnDemandContentRating"] = "OnDemandContentRating";
    Feature2["ScheduledContentRating"] = "ScheduledContentRating";
    Feature2["BlockChannels"] = "BlockChannels";
    Feature2["BlockApplications"] = "BlockApplications";
    Feature2["BlockContentTimeWindow"] = "BlockContentTimeWindow";
  })(Feature = ContentControl2.Feature || (ContentControl2.Feature = {}));
  ContentControl2.TlvRatingName = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the name of the rating level of the applied rating system. The applied rating
     * system is dependent upon the region or country where the Node has been provisioned, and may vary from one
     * country to another.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.13.5.2.1
     */
    ratingName: (0, import_TlvObject.TlvField)(0, import_TlvString.TlvString.bound({ maxLength: 8 })),
    /**
     * This field shall specify a human readable (displayable) description for RatingName.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.13.5.2.2
     */
    ratingNameDesc: (0, import_TlvObject.TlvOptionalField)(1, import_TlvString.TlvString.bound({ maxLength: 64 }))
  });
  ContentControl2.TlvSetOnDemandRatingThresholdRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field indicates a threshold rating for filtering on-demand content. This field shall be set to one of
     * the values present in the OnDemandRatings attribute
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.13.8.10.1
     */
    rating: (0, import_TlvObject.TlvField)(0, import_TlvString.TlvString.bound({ maxLength: 8 }))
  });
  ContentControl2.TlvSetScheduledContentRatingThresholdRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field indicates a threshold rating for filtering scheduled content. This field shall be set to one of
     * the values present in the ScheduledContentRatings attribute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.13.8.11.1
     */
    rating: (0, import_TlvObject.TlvField)(0, import_TlvString.TlvString.bound({ maxLength: 8 }))
  });
  ContentControl2.TlvAddBonusTimeRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the PIN.
     *
     * This field shall be optional for clients with Manage or greater privilege but shall be mandatory for clients
     * with Operate privilege. The PIN provided in this field shall be used to guarantee that a client with Operate
     * permission is allowed to invoke this command only if the PIN passed in this command is equal to the current
     * PIN value.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.13.8.6.1
     */
    pinCode: (0, import_TlvObject.TlvOptionalField)(0, import_TlvString.TlvString.bound({ maxLength: 6 })),
    /**
     * This field shall indicate the amount of extra time (in seconds) to increase RemainingScreenTime. This field
     * shall NOT exceed the remaining time of this day.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.13.8.6.2
     */
    bonusTime: (0, import_TlvObject.TlvField)(1, import_TlvNumber.TlvUInt32)
  });
  ContentControl2.TlvSetScreenDailyTimeRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the time (in seconds) which the User is allowed to spend watching TV on this media
     * device within one day.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.13.8.7.1
     */
    screenTime: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt32.bound({ max: 86400 }))
  });
  ContentControl2.TlvBlockChannel = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate a unique index value for a blocked channel. This value may be used to indicate one
     * selected channel which will be removed from BlockChannelList attribute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.13.5.3.1
     */
    blockChannelIndex: (0, import_TlvObject.TlvField)(0, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt16)),
    /**
     * This field shall indicate the channel major number value (for example, using ATSC format). When the channel
     * number is expressed as a string, such as "13.1" or "256", the major number would be 13 or 256, respectively.
     * This field is required but shall be set to 0 for channels such as over-the-top channels that are not
     * represented by a major or minor number.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.13.5.3.2
     */
    majorNumber: (0, import_TlvObject.TlvField)(1, import_TlvNumber.TlvUInt16),
    /**
     * This field shall indicate the channel minor number value (for example, using ATSC format). When the channel
     * number is expressed as a string, such as "13.1" or "256", the minor number would be 1 or 0, respectively.
     * This field is required but shall be set to 0 for channels such as over-the-top channels that are not
     * represented by a major or minor number.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.13.5.3.3
     */
    minorNumber: (0, import_TlvObject.TlvField)(2, import_TlvNumber.TlvUInt16),
    /**
     * This field shall indicate the unique identifier for a specific channel. This field is optional, but SHOULD be
     * provided when MajorNumber and MinorNumber are not available.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.13.5.3.4
     */
    identifier: (0, import_TlvObject.TlvOptionalField)(3, import_TlvString.TlvString)
  });
  ContentControl2.TlvAddBlockChannelsRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field indicates a set of channels that shall be blocked when the Content Control feature is activated.
     * This field shall be set to values present in ChannelList attribute in the Channel cluster. The
     * BlockChannelIndex field passed in this command shall be NULL.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.13.8.12.1
     */
    channels: (0, import_TlvObject.TlvField)(0, (0, import_TlvArray.TlvArray)(ContentControl2.TlvBlockChannel))
  });
  ContentControl2.TlvRemoveBlockChannelsRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall specify a set of indexes indicating Which channels shall be removed from the
     * BlockChannelList attribute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.13.8.13.1
     */
    channelIndexes: (0, import_TlvObject.TlvField)(0, (0, import_TlvArray.TlvArray)(import_TlvNumber.TlvUInt16))
  });
  ContentControl2.TlvAppInfo = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the CSA-issued vendor ID for the catalog. The DIAL registry shall use value 0x0000.
     *
     * Content App Platform providers will have their own catalog vendor ID (set to their own Vendor ID) and will
     * assign an ApplicationID to each Content App.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.13.5.4.1
     */
    catalogVendorId: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt16),
    /**
     * This field shall indicate the application identifier, expressed as a string, such as "PruneVideo" or "Company
     * X". This field shall be unique within a catalog.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.13.5.4.2
     */
    applicationId: (0, import_TlvObject.TlvField)(1, import_TlvString.TlvString)
  });
  ContentControl2.TlvAddBlockApplicationsRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field indicates a set of applications that shall be blocked when the Content Control feature is
     * activated.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.13.8.14.1
     */
    applications: (0, import_TlvObject.TlvField)(0, (0, import_TlvArray.TlvArray)(ContentControl2.TlvAppInfo))
  });
  ContentControl2.TlvRemoveBlockApplicationsRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field indicates a set of applications which shall be removed from BlockApplicationList attribute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.13.8.15.1
     */
    applications: (0, import_TlvObject.TlvField)(0, (0, import_TlvArray.TlvArray)(ContentControl2.TlvAppInfo))
  });
  ContentControl2.DayOfWeek = {
    /**
     * Sunday
     */
    sunday: (0, import_BitmapSchema.BitFlag)(0),
    /**
     * Monday
     */
    monday: (0, import_BitmapSchema.BitFlag)(1),
    /**
     * Tuesday
     */
    tuesday: (0, import_BitmapSchema.BitFlag)(2),
    /**
     * Wednesday
     */
    wednesday: (0, import_BitmapSchema.BitFlag)(3),
    /**
     * Thursday
     */
    thursday: (0, import_BitmapSchema.BitFlag)(4),
    /**
     * Friday
     */
    friday: (0, import_BitmapSchema.BitFlag)(5),
    /**
     * Saturday
     */
    saturday: (0, import_BitmapSchema.BitFlag)(6)
  };
  ContentControl2.TlvTimePeriod = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the starting hour.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.13.5.6.1
     */
    startHour: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt8.bound({ max: 23 })),
    /**
     * This field shall indicate the starting minute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.13.5.6.2
     */
    startMinute: (0, import_TlvObject.TlvField)(1, import_TlvNumber.TlvUInt8.bound({ max: 59 })),
    /**
     * This field shall indicate the ending hour. EndHour shall be equal to or greater than StartHour
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.13.5.6.3
     */
    endHour: (0, import_TlvObject.TlvField)(2, import_TlvNumber.TlvUInt8.bound({ max: 23 })),
    /**
     * This field shall indicate the ending minute. If EndHour is equal to StartHour then EndMinute shall be greater
     * than StartMinute. If the EndHour is equal to 23 and the EndMinute is equal to 59, all contents shall be
     * blocked until 23:59:59.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.13.5.6.4
     */
    endMinute: (0, import_TlvObject.TlvField)(3, import_TlvNumber.TlvUInt8.bound({ max: 59 }))
  });
  ContentControl2.TlvTimeWindow = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate a unique index of a specific time window. This value may be used to indicate a
     * selected time window which will be removed from the BlockContentTimeWindow attribute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.13.5.5.1
     */
    timeWindowIndex: (0, import_TlvObject.TlvField)(0, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt16)),
    /**
     * This field shall indicate a day of week.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.13.5.5.2
     */
    dayOfWeek: (0, import_TlvObject.TlvField)(1, (0, import_TlvNumber.TlvBitmap)(import_TlvNumber.TlvUInt8, ContentControl2.DayOfWeek)),
    /**
     * This field shall indicate one or more discrete time periods.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.13.5.5.3
     */
    timePeriod: (0, import_TlvObject.TlvField)(2, (0, import_TlvArray.TlvArray)(ContentControl2.TlvTimePeriod))
  });
  ContentControl2.TlvSetBlockContentTimeWindowRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate a time window requested to set to the BlockContentTimeWindow attribute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.13.8.16.1
     */
    timeWindow: (0, import_TlvObject.TlvField)(0, ContentControl2.TlvTimeWindow)
  });
  ContentControl2.TlvRemoveBlockContentTimeWindowRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall specify a set of time window indexes indicating which time windows will be removed from the
     * BlockContentTimeWindow attribute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.13.8.17.1
     */
    timeWindowIndexes: (0, import_TlvObject.TlvField)(0, (0, import_TlvArray.TlvArray)(import_TlvNumber.TlvUInt16))
  });
  ContentControl2.TlvUpdatePinRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall specify the original PIN. Once the UpdatePIN command is performed successfully, it shall be
     * invalid.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.13.8.1.1
     */
    oldPin: (0, import_TlvObject.TlvField)(0, import_TlvString.TlvString.bound({ maxLength: 6 })),
    /**
     * This field shall indicate a new PIN for the Content Control feature.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.13.8.1.2
     */
    newPin: (0, import_TlvObject.TlvField)(1, import_TlvString.TlvString.bound({ maxLength: 6 }))
  });
  ContentControl2.TlvResetPinResponse = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate a new PIN of the Content Control feature.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.13.8.3.1
     */
    pinCode: (0, import_TlvObject.TlvField)(0, import_TlvString.TlvString.bound({ maxLength: 6 }))
  });
  let StatusCode;
  ((StatusCode2) => {
    StatusCode2[StatusCode2["InvalidPinCode"] = 2] = "InvalidPinCode";
    StatusCode2[StatusCode2["InvalidRating"] = 3] = "InvalidRating";
    StatusCode2[StatusCode2["InvalidChannel"] = 4] = "InvalidChannel";
    StatusCode2[StatusCode2["ChannelAlreadyExist"] = 5] = "ChannelAlreadyExist";
    StatusCode2[StatusCode2["ChannelNotExist"] = 6] = "ChannelNotExist";
    StatusCode2[StatusCode2["UnidentifiableApplication"] = 7] = "UnidentifiableApplication";
    StatusCode2[StatusCode2["ApplicationAlreadyExist"] = 8] = "ApplicationAlreadyExist";
    StatusCode2[StatusCode2["ApplicationNotExist"] = 9] = "ApplicationNotExist";
    StatusCode2[StatusCode2["TimeWindowAlreadyExist"] = 10] = "TimeWindowAlreadyExist";
    StatusCode2[StatusCode2["TimeWindowNotExist"] = 11] = "TimeWindowNotExist";
  })(StatusCode = ContentControl2.StatusCode || (ContentControl2.StatusCode = {}));
  ContentControl2.OnDemandContentRatingComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * This attribute shall provide the collection of ratings that are currently valid for this media device.
       * The items should honor the metadata of the on-demand content (e.g. Movie) rating system for one country
       * or region where the media device has been provisioned. For example, for the MPAA system, RatingName may
       * be one value out of "G", "PG", "PG-13", "R", "NC-17".
       *
       * The media device shall have a way to determine which rating system applies for the on-demand content and
       * then populate this attribute. For example, it can do it through examining the Location attribute in the
       * Basic Information cluster, and then determining which rating system applies.
       *
       * The ratings in this collection shall be in order from a rating for the youngest viewers to the one for
       * the oldest viewers. Each rating in the list shall be unique.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.13.7.2
       */
      onDemandRatings: (0, import_Cluster.Attribute)(1, (0, import_TlvArray.TlvArray)(ContentControl2.TlvRatingName), { default: [] }),
      /**
       * Indicates a threshold rating as a content filter which is compared with the rating for on-demand content.
       * For example, if the on-demand content rating is greater than or equal to OnDemandRatingThreshold, for a
       * rating system that is ordered from lower viewer age to higher viewer age, then on-demand content is not
       * appropriate for the User and the Node shall prevent the playback of content.
       *
       * This attribute shall be set to one of the values present in the OnDemandRatings attribute.
       *
       * When this attribute changes, the device SHOULD make the user aware of any limits of this feature. For
       * example, if the feature does not control content within apps, then the device should make this clear to
       * the user when the attribute changes.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.13.7.3
       */
      onDemandRatingThreshold: (0, import_Cluster.Attribute)(2, import_TlvString.TlvString.bound({ maxLength: 8 }))
    },
    commands: {
      /**
       * The purpose of this command is to set the OnDemandRatingThreshold attribute.
       *
       * Upon receipt of the SetOnDemandRatingThreshold command, the media device shall check if the Rating field
       * is one of values present in the OnDemandRatings attribute. If not, then a response with InvalidRating
       * error status shall be returned.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.13.8.10
       */
      setOnDemandRatingThreshold: (0, import_Cluster.Command)(
        9,
        ContentControl2.TlvSetOnDemandRatingThresholdRequest,
        9,
        import_Cluster.TlvNoResponse,
        { invokeAcl: import_model.AccessLevel.Manage }
      )
    }
  });
  ContentControl2.ScheduledContentRatingComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * Indicates a collection of ratings which ScheduledContentRatingThreshold can be set to. The items should
       * honor metadata of the scheduled content rating system for the country or region where the media device
       * has been provisioned.
       *
       * The media device shall have a way to determine which scheduled content rating system applies and then
       * populate this attribute. For example, this can be done by examining the Location attribute in Basic
       * Information cluster, and then determining which rating system applies.
       *
       * The ratings in this collection shall be in order from a rating for the youngest viewers to the one for
       * the oldest viewers. Each rating in the list shall be unique.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.13.7.4
       */
      scheduledContentRatings: (0, import_Cluster.Attribute)(3, (0, import_TlvArray.TlvArray)(ContentControl2.TlvRatingName), { default: [] }),
      /**
       * Indicates a threshold rating as a content filter which is used to compare with the rating for scheduled
       * content. For example, if the scheduled content rating is greater than or equal to
       * ScheduledContentRatingThreshold for a rating system that is ordered from lower viewer age to higher
       * viewer age, then the scheduled content is not appropriate for the User and shall be blocked.
       *
       * This attribute shall be set to one of the values present in the ScheduledContentRatings attribute.
       *
       * When this attribute changes, the device SHOULD make the user aware of any limits of this feature. For
       * example, if the feature does not control content within apps, then the device should make this clear to
       * the user when the attribute changes.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.13.7.5
       */
      scheduledContentRatingThreshold: (0, import_Cluster.Attribute)(4, import_TlvString.TlvString.bound({ maxLength: 8 }))
    },
    commands: {
      /**
       * The purpose of this command is to set ScheduledContentRatingThreshold attribute.
       *
       * Upon receipt of the SetScheduledContentRatingThreshold command, the media device shall check if the
       * Rating field is one of values present in the ScheduledContentRatings attribute. If not, then a response
       * with InvalidRating error status shall be returned.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.13.8.11
       */
      setScheduledContentRatingThreshold: (0, import_Cluster.Command)(
        10,
        ContentControl2.TlvSetScheduledContentRatingThresholdRequest,
        10,
        import_Cluster.TlvNoResponse,
        { invokeAcl: import_model.AccessLevel.Manage }
      )
    }
  });
  ContentControl2.ScreenTimeComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * Indicates the amount of time (in seconds) which the User is allowed to spend watching TV within one day
       * when the Content Control feature is activated.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.13.7.6
       */
      screenDailyTime: (0, import_Cluster.Attribute)(5, import_TlvNumber.TlvUInt32.bound({ max: 86400 })),
      /**
       * Indicates the remaining screen time (in seconds) which the User is allowed to spend watching TV for the
       * current day when the Content Control feature is activated. When this value equals 0, the media device
       * shall terminate the playback of content.
       *
       * This attribute shall be updated when the AddBonusTime command is received and processed successfully
       * (with the correct PIN).
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.13.7.7
       */
      remainingScreenTime: (0, import_Cluster.Attribute)(6, import_TlvNumber.TlvUInt32.bound({ max: 86400 }))
    },
    commands: {
      /**
       * The purpose of this command is to add the extra screen time for the user.
       *
       * If a client with Operate privilege invokes this command, the media device shall check whether the PINCode
       * passed in the command matches the current PINCode value. If these match, then the RemainingScreenTime
       * attribute shall be increased by the specified BonusTime value.
       *
       * If the PINs do not match, then a response with InvalidPINCode error status shall be returned, and no
       * changes shall be made to RemainingScreenTime.
       *
       * If a client with Manage privilege or greater invokes this command, the media device shall ignore the
       * PINCode field and directly increase the RemainingScreenTime attribute by the specified BonusTime value.
       *
       * A server that does not support the PM feature shall respond with InvalidPINCode to clients that only have
       * Operate privilege unless:
       *
       *   • It has been provided with the PIN value to expect via an out of band mechanism, and
       *
       *   • The client has provided a PINCode that matches the expected PIN value.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.13.8.6
       */
      addBonusTime: (0, import_Cluster.Command)(5, ContentControl2.TlvAddBonusTimeRequest, 5, import_Cluster.TlvNoResponse),
      /**
       * The purpose of this command is to set the ScreenDailyTime attribute.
       *
       * Upon receipt of the SetScreenDailyTime command, the media device shall set the ScreenDailyTime attribute
       * to the ScreenTime value.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.13.8.7
       */
      setScreenDailyTime: (0, import_Cluster.Command)(
        6,
        ContentControl2.TlvSetScreenDailyTimeRequest,
        6,
        import_Cluster.TlvNoResponse,
        { invokeAcl: import_model.AccessLevel.Manage }
      )
    },
    events: {
      /**
       * This event shall be generated when the RemainingScreenTime equals 0.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.13.9.1
       */
      remainingScreenTimeExpired: (0, import_Cluster.Event)(0, import_Cluster.EventPriority.Info, import_TlvNoArguments.TlvNoArguments)
    }
  });
  ContentControl2.BlockUnratedComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * Indicates whether the playback of unrated content is allowed when the Content Control feature is
       * activated. If this attribute equals FALSE, then playback of unrated content shall be permitted.
       * Otherwise, the media device shall prevent the playback of unrated content.
       *
       * When this attribute changes, the device SHOULD make the user aware of any limits of this feature. For
       * example, if the feature does not control content within apps, then the device should make this clear to
       * the user when the attribute changes.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.13.7.8
       */
      blockUnrated: (0, import_Cluster.Attribute)(7, import_TlvBoolean.TlvBoolean)
    },
    commands: {
      /**
       * The purpose of this command is to specify whether programs with no Content rating must be blocked by this
       * media device.
       *
       * Upon receipt of the BlockUnratedContent command, the media device shall set the BlockUnrated attribute to
       * TRUE.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.13.8.8
       */
      blockUnratedContent: (0, import_Cluster.Command)(7, import_TlvNoArguments.TlvNoArguments, 7, import_Cluster.TlvNoResponse, { invokeAcl: import_model.AccessLevel.Manage }),
      /**
       * The purpose of this command is to specify whether programs with no Content rating must be blocked by this
       * media device.
       *
       * Upon receipt of the UnblockUnratedContent command, the media device shall set the BlockUnrated attribute
       * to FALSE.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.13.8.9
       */
      unblockUnratedContent: (0, import_Cluster.Command)(8, import_TlvNoArguments.TlvNoArguments, 8, import_Cluster.TlvNoResponse, { invokeAcl: import_model.AccessLevel.Manage })
    }
  });
  ContentControl2.BlockChannelsComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * Indicates a set of channels that shall be blocked when the Content Control feature is activated.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.13.7.9
       */
      blockChannelList: (0, import_Cluster.Attribute)(8, (0, import_TlvArray.TlvArray)(ContentControl2.TlvBlockChannel), { default: [] })
    },
    commands: {
      /**
       * The purpose of this command is to set BlockChannelList attribute.
       *
       * Upon receipt of the AddBlockChannels command, the media device shall check if the channels
       *
       * passed in this command are valid. If the channel is invalid, then a response with InvalidChannel error
       * Status shall be returned.
       *
       * If there is at least one channel in Channels field which is not in the BlockChannelList attribute, the
       * media device shall process the request by adding these new channels into the BlockChannelList attribute
       * and return a successful Status Response. During this process, the media device shall assign one unique
       * index to BlockChannelIndex field for every channel passed in this command.
       *
       * If all channels in Channel field already exist in the BlockChannelList attribute, then a response with
       * ChannelAlreadyExist error Status shall be returned.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.13.8.12
       */
      addBlockChannels: (0, import_Cluster.Command)(
        11,
        ContentControl2.TlvAddBlockChannelsRequest,
        11,
        import_Cluster.TlvNoResponse,
        { invokeAcl: import_model.AccessLevel.Manage }
      ),
      /**
       * The purpose of this command is to remove channels from the BlockChannelList attribute.
       *
       * Upon receipt of the RemoveBlockChannels command, the media device shall check if the channels indicated
       * by ChannelIndexes passed in this command are present in BlockChannelList attribute. If one or more
       * channels indicated by ChannelIndexes passed in this command field are not present in the BlockChannelList
       * attribute, then a response with ChannelNotExist error Status shall be returned.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.13.8.13
       */
      removeBlockChannels: (0, import_Cluster.Command)(
        12,
        ContentControl2.TlvRemoveBlockChannelsRequest,
        12,
        import_Cluster.TlvNoResponse,
        { invokeAcl: import_model.AccessLevel.Manage }
      )
    }
  });
  ContentControl2.BlockApplicationsComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * Indicates a set of applications that shall be blocked when the Content Control feature is activated.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.13.7.10
       */
      blockApplicationList: (0, import_Cluster.Attribute)(9, (0, import_TlvArray.TlvArray)(ContentControl2.TlvAppInfo), { default: [] })
    },
    commands: {
      /**
       * The purpose of this command is to set applications to the BlockApplicationList attribute.
       *
       * Upon receipt of the AddBlockApplications command, the media device shall check if the Applications passed
       * in this command are installed. If there is an application in Applications field which is not identified
       * by media device, then a response with UnidentifiableApplication error Status may be
       *
       * returned.
       *
       * If there is one or more applications which are not present in BlockApplicationList attribute, the media
       * device shall process the request by adding the new application to the BlockApplicationList attribute and
       * return a successful Status Response.
       *
       * If all applications in Applications field are already present in BlockApplicationList attribute, then a
       * response with ApplicationAlreadyExist error Status shall be returned.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.13.8.14
       */
      addBlockApplications: (0, import_Cluster.Command)(
        13,
        ContentControl2.TlvAddBlockApplicationsRequest,
        13,
        import_Cluster.TlvNoResponse,
        { invokeAcl: import_model.AccessLevel.Manage }
      ),
      /**
       * The purpose of this command is to remove applications from the BlockApplicationList attribute.
       *
       * Upon receipt of the RemoveBlockApplications command, the media device shall check if the applications
       * passed in this command present in the BlockApplicationList attribute. If one or more applications in
       * Applications field which are not present in the BlockApplicationList attribute, then a response with
       * ApplicationNotExist error Status shall be returned.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.13.8.15
       */
      removeBlockApplications: (0, import_Cluster.Command)(
        14,
        ContentControl2.TlvRemoveBlockApplicationsRequest,
        14,
        import_Cluster.TlvNoResponse,
        { invokeAcl: import_model.AccessLevel.Manage }
      )
    }
  });
  ContentControl2.BlockContentTimeWindowComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * Indicates a set of periods during which the playback of content on media device shall be blocked when the
       * Content Control feature is activated. The media device shall reject any request to play content during
       * one period of this attribute. If it is entering any one period of this attribute, the media device shall
       * block content which is playing and generate an event EnteringBlockContentTimeWindow. There shall NOT be
       * multiple entries in this attribute list for the same day of week.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.13.7.11
       */
      blockContentTimeWindow: (0, import_Cluster.Attribute)(10, (0, import_TlvArray.TlvArray)(ContentControl2.TlvTimeWindow, { maxLength: 7 }), { default: [] })
    },
    commands: {
      /**
       * The purpose of this command is to set the BlockContentTimeWindow attribute.
       *
       * Upon receipt of the SetBlockContentTimeWindow command, the media device shall check if the
       * TimeWindowIndex field passed in this command is NULL. If the TimeWindowIndex field is NULL, the media
       * device shall check if there is an entry in the BlockContentTimeWindow attribute which matches with the
       * TimePeriod and DayOfWeek fields passed in this command. * If Yes, then a response with
       * TimeWindowAlreadyExist error status shall be returned. * If No, then the media device shall assign one
       * unique index for this time window and add it into the BlockContentTimeWindow list attribute.
       *
       * If the TimeWindowIndex field is not NULL and presents in the BlockContentTimeWindow attribute, the media
       * device shall replace the original time window with the new time window passed in this command.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.13.8.16
       */
      setBlockContentTimeWindow: (0, import_Cluster.Command)(
        15,
        ContentControl2.TlvSetBlockContentTimeWindowRequest,
        15,
        import_Cluster.TlvNoResponse,
        { invokeAcl: import_model.AccessLevel.Manage }
      ),
      /**
       * The purpose of this command is to remove the selected time windows from the BlockContentTimeWindow
       * attribute.
       *
       * Upon receipt of the RemoveBlockContentTimeWindow command, the media device shall check if the time window
       * index passed in this command presents in the BlockContentTimeWindow attribute.
       *
       * If one or more time window indexes passed in this command are not present in BlockContentTimeWindow
       * attribute, then a response with TimeWindowNotExist error status shall be returned.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.13.8.17
       */
      removeBlockContentTimeWindow: (0, import_Cluster.Command)(
        16,
        ContentControl2.TlvRemoveBlockContentTimeWindowRequest,
        16,
        import_Cluster.TlvNoResponse,
        { invokeAcl: import_model.AccessLevel.Manage }
      )
    },
    events: {
      /**
       * This event shall be generated when entering a period of blocked content as configured in the
       * BlockContentTimeWindow attribute.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.13.9.2
       */
      enteringBlockContentTimeWindow: (0, import_Cluster.Event)(1, import_Cluster.EventPriority.Info, import_TlvNoArguments.TlvNoArguments)
    }
  });
  ContentControl2.PinManagementComponent = import_MutableCluster.MutableCluster.Component({
    commands: {
      /**
       * The purpose of this command is to update the PIN used for protecting configuration of the content control
       * settings. Upon success, the old PIN shall no longer work.
       *
       * The PIN is used to ensure that only the Node (or User) with the PIN code can make changes to the Content
       * Control settings, for example, turn off Content Controls or modify the ScreenDailyTime. The PIN is
       * composed of a numeric string of up to 6 human readable characters (displayable) .
       *
       * Upon receipt of this command, the media device shall check if the OldPIN field of this command is the
       * same as the current PIN. If the PINs are the same, then the PIN code shall be set to NewPIN. Otherwise a
       * response with InvalidPINCode error status shall be returned.
       *
       * The media device may provide a default PIN to the User via an out of band mechanism. For security
       * reasons, it is recommended that a client encourage the user to update the PIN from its default value when
       * performing configuration of the Content Control settings exposed by this cluster. The ResetPIN command
       * can also be used to obtain the default PIN.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.13.8.1
       */
      updatePin: (0, import_Cluster.Command)(
        0,
        ContentControl2.TlvUpdatePinRequest,
        0,
        import_Cluster.TlvNoResponse,
        { invokeAcl: import_model.AccessLevel.Manage, timed: true }
      ),
      /**
       * The purpose of this command is to reset the PIN.
       *
       * If this command is executed successfully, a ResetPINResponse command with a new PIN shall be returned.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.13.8.2
       */
      resetPin: (0, import_Cluster.Command)(
        1,
        import_TlvNoArguments.TlvNoArguments,
        2,
        ContentControl2.TlvResetPinResponse,
        { invokeAcl: import_model.AccessLevel.Administer, timed: true }
      )
    }
  });
  ContentControl2.Base = import_MutableCluster.MutableCluster.Component({
    id: 1295,
    name: "ContentControl",
    revision: 1,
    features: {
      /**
       * ScreenTime
       *
       * Supports managing screen time limits.
       */
      screenTime: (0, import_BitmapSchema.BitFlag)(0),
      /**
       * PinManagement
       *
       * Supports managing a PIN code which is used for restricting access to configuration of this feature.
       */
      pinManagement: (0, import_BitmapSchema.BitFlag)(1),
      /**
       * BlockUnrated
       *
       * Supports managing content controls for unrated content.
       */
      blockUnrated: (0, import_BitmapSchema.BitFlag)(2),
      /**
       * OnDemandContentRating
       *
       * Supports managing content controls based upon rating threshold for on demand content.
       */
      onDemandContentRating: (0, import_BitmapSchema.BitFlag)(3),
      /**
       * ScheduledContentRating
       *
       * Supports managing content controls based upon rating threshold for scheduled content.
       */
      scheduledContentRating: (0, import_BitmapSchema.BitFlag)(4),
      /**
       * BlockChannels
       *
       * Supports managing a set of channels that are prohibited.
       */
      blockChannels: (0, import_BitmapSchema.BitFlag)(5),
      /**
       * BlockApplications
       *
       * Supports managing a set of applications that are prohibited.
       */
      blockApplications: (0, import_BitmapSchema.BitFlag)(6),
      /**
       * BlockContentTimeWindow
       *
       * Supports managing content controls based upon setting time window in which all contents and applications
       * SHALL be blocked.
       */
      blockContentTimeWindow: (0, import_BitmapSchema.BitFlag)(7)
    },
    attributes: {
      /**
       * Indicates whether the Content Control feature implemented on a media device is turned off (FALSE) or
       * turned on (TRUE).
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.13.7.1
       */
      enabled: (0, import_Cluster.Attribute)(0, import_TlvBoolean.TlvBoolean)
    },
    commands: {
      /**
       * The purpose of this command is to turn on the Content Control feature on a media device.
       *
       * Upon receipt of the Enable command, the media device shall set the Enabled attribute to TRUE.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.13.8.4
       */
      enable: (0, import_Cluster.Command)(3, import_TlvNoArguments.TlvNoArguments, 3, import_Cluster.TlvNoResponse, { invokeAcl: import_model.AccessLevel.Manage, timed: true }),
      /**
       * The purpose of this command is to turn off the Content Control feature on a media device.
       *
       * On receipt of the Disable command, the media device shall set the Enabled attribute to FALSE.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.13.8.5
       */
      disable: (0, import_Cluster.Command)(4, import_TlvNoArguments.TlvNoArguments, 4, import_Cluster.TlvNoResponse, { invokeAcl: import_model.AccessLevel.Manage, timed: true })
    },
    /**
     * This metadata controls which ContentControlCluster elements matter.js activates for specific feature
     * combinations.
     */
    extensions: import_MutableCluster.MutableCluster.Extensions(
      { flags: { onDemandContentRating: true }, component: ContentControl2.OnDemandContentRatingComponent },
      { flags: { scheduledContentRating: true }, component: ContentControl2.ScheduledContentRatingComponent },
      { flags: { screenTime: true }, component: ContentControl2.ScreenTimeComponent },
      { flags: { blockUnrated: true }, component: ContentControl2.BlockUnratedComponent },
      { flags: { blockChannels: true }, component: ContentControl2.BlockChannelsComponent },
      { flags: { blockApplications: true }, component: ContentControl2.BlockApplicationsComponent },
      { flags: { blockContentTimeWindow: true }, component: ContentControl2.BlockContentTimeWindowComponent },
      { flags: { pinManagement: true }, component: ContentControl2.PinManagementComponent }
    )
  });
  ContentControl2.ClusterInstance = (0, import_MutableCluster.MutableCluster)(ContentControl2.Base);
  ContentControl2.Cluster = ContentControl2.ClusterInstance;
  const OCR = { onDemandContentRating: true };
  const SCR = { scheduledContentRating: true };
  const ST = { screenTime: true };
  const BU = { blockUnrated: true };
  const BC = { blockChannels: true };
  const BA = { blockApplications: true };
  const BTW = { blockContentTimeWindow: true };
  const PM = { pinManagement: true };
  ContentControl2.CompleteInstance = (0, import_MutableCluster.MutableCluster)({
    id: ContentControl2.Cluster.id,
    name: ContentControl2.Cluster.name,
    revision: ContentControl2.Cluster.revision,
    features: ContentControl2.Cluster.features,
    attributes: {
      ...ContentControl2.Cluster.attributes,
      onDemandRatings: import_MutableCluster.MutableCluster.AsConditional(
        ContentControl2.OnDemandContentRatingComponent.attributes.onDemandRatings,
        { mandatoryIf: [OCR] }
      ),
      onDemandRatingThreshold: import_MutableCluster.MutableCluster.AsConditional(
        ContentControl2.OnDemandContentRatingComponent.attributes.onDemandRatingThreshold,
        { mandatoryIf: [OCR] }
      ),
      scheduledContentRatings: import_MutableCluster.MutableCluster.AsConditional(
        ContentControl2.ScheduledContentRatingComponent.attributes.scheduledContentRatings,
        { mandatoryIf: [SCR] }
      ),
      scheduledContentRatingThreshold: import_MutableCluster.MutableCluster.AsConditional(
        ContentControl2.ScheduledContentRatingComponent.attributes.scheduledContentRatingThreshold,
        { mandatoryIf: [SCR] }
      ),
      screenDailyTime: import_MutableCluster.MutableCluster.AsConditional(
        ContentControl2.ScreenTimeComponent.attributes.screenDailyTime,
        { mandatoryIf: [ST] }
      ),
      remainingScreenTime: import_MutableCluster.MutableCluster.AsConditional(
        ContentControl2.ScreenTimeComponent.attributes.remainingScreenTime,
        { mandatoryIf: [ST] }
      ),
      blockUnrated: import_MutableCluster.MutableCluster.AsConditional(
        ContentControl2.BlockUnratedComponent.attributes.blockUnrated,
        { mandatoryIf: [BU] }
      ),
      blockChannelList: import_MutableCluster.MutableCluster.AsConditional(
        ContentControl2.BlockChannelsComponent.attributes.blockChannelList,
        { mandatoryIf: [BC] }
      ),
      blockApplicationList: import_MutableCluster.MutableCluster.AsConditional(
        ContentControl2.BlockApplicationsComponent.attributes.blockApplicationList,
        { mandatoryIf: [BA] }
      ),
      blockContentTimeWindow: import_MutableCluster.MutableCluster.AsConditional(
        ContentControl2.BlockContentTimeWindowComponent.attributes.blockContentTimeWindow,
        { mandatoryIf: [BTW] }
      )
    },
    commands: {
      ...ContentControl2.Cluster.commands,
      updatePin: import_MutableCluster.MutableCluster.AsConditional(ContentControl2.PinManagementComponent.commands.updatePin, { mandatoryIf: [PM] }),
      resetPin: import_MutableCluster.MutableCluster.AsConditional(ContentControl2.PinManagementComponent.commands.resetPin, { mandatoryIf: [PM] }),
      addBonusTime: import_MutableCluster.MutableCluster.AsConditional(
        ContentControl2.ScreenTimeComponent.commands.addBonusTime,
        { mandatoryIf: [ST] }
      ),
      setScreenDailyTime: import_MutableCluster.MutableCluster.AsConditional(
        ContentControl2.ScreenTimeComponent.commands.setScreenDailyTime,
        { mandatoryIf: [ST] }
      ),
      blockUnratedContent: import_MutableCluster.MutableCluster.AsConditional(
        ContentControl2.BlockUnratedComponent.commands.blockUnratedContent,
        { mandatoryIf: [BU] }
      ),
      unblockUnratedContent: import_MutableCluster.MutableCluster.AsConditional(
        ContentControl2.BlockUnratedComponent.commands.unblockUnratedContent,
        { mandatoryIf: [BU] }
      ),
      setOnDemandRatingThreshold: import_MutableCluster.MutableCluster.AsConditional(
        ContentControl2.OnDemandContentRatingComponent.commands.setOnDemandRatingThreshold,
        { mandatoryIf: [OCR] }
      ),
      setScheduledContentRatingThreshold: import_MutableCluster.MutableCluster.AsConditional(
        ContentControl2.ScheduledContentRatingComponent.commands.setScheduledContentRatingThreshold,
        { mandatoryIf: [SCR] }
      ),
      addBlockChannels: import_MutableCluster.MutableCluster.AsConditional(
        ContentControl2.BlockChannelsComponent.commands.addBlockChannels,
        { mandatoryIf: [BC] }
      ),
      removeBlockChannels: import_MutableCluster.MutableCluster.AsConditional(
        ContentControl2.BlockChannelsComponent.commands.removeBlockChannels,
        { mandatoryIf: [BC] }
      ),
      addBlockApplications: import_MutableCluster.MutableCluster.AsConditional(
        ContentControl2.BlockApplicationsComponent.commands.addBlockApplications,
        { mandatoryIf: [BA] }
      ),
      removeBlockApplications: import_MutableCluster.MutableCluster.AsConditional(
        ContentControl2.BlockApplicationsComponent.commands.removeBlockApplications,
        { mandatoryIf: [BA] }
      ),
      setBlockContentTimeWindow: import_MutableCluster.MutableCluster.AsConditional(
        ContentControl2.BlockContentTimeWindowComponent.commands.setBlockContentTimeWindow,
        { mandatoryIf: [BTW] }
      ),
      removeBlockContentTimeWindow: import_MutableCluster.MutableCluster.AsConditional(
        ContentControl2.BlockContentTimeWindowComponent.commands.removeBlockContentTimeWindow,
        { mandatoryIf: [BTW] }
      )
    },
    events: {
      remainingScreenTimeExpired: import_MutableCluster.MutableCluster.AsConditional(
        ContentControl2.ScreenTimeComponent.events.remainingScreenTimeExpired,
        { mandatoryIf: [ST] }
      ),
      enteringBlockContentTimeWindow: import_MutableCluster.MutableCluster.AsConditional(
        ContentControl2.BlockContentTimeWindowComponent.events.enteringBlockContentTimeWindow,
        { mandatoryIf: [BTW] }
      )
    }
  });
  ContentControl2.Complete = ContentControl2.CompleteInstance;
})(ContentControl || (ContentControl = {}));
const ContentControlCluster = ContentControl.Cluster;
import_ClusterRegistry.ClusterRegistry.register(ContentControl.Complete);
//# sourceMappingURL=content-control.js.map
