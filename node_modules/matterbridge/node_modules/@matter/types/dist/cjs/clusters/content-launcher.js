"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var content_launcher_exports = {};
__export(content_launcher_exports, {
  ContentLauncher: () => ContentLauncher,
  ContentLauncherCluster: () => ContentLauncherCluster
});
module.exports = __toCommonJS(content_launcher_exports);
var import_MutableCluster = require("../cluster/mutation/MutableCluster.js");
var import_Cluster = require("../cluster/Cluster.js");
var import_TlvArray = require("../tlv/TlvArray.js");
var import_TlvString = require("../tlv/TlvString.js");
var import_BitmapSchema = require("../schema/BitmapSchema.js");
var import_TlvNumber = require("../tlv/TlvNumber.js");
var import_TlvObject = require("../tlv/TlvObject.js");
var import_TlvNullable = require("../tlv/TlvNullable.js");
var import_TlvBoolean = require("../tlv/TlvBoolean.js");
var import_ClusterRegistry = require("../cluster/ClusterRegistry.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
var ContentLauncher;
((ContentLauncher2) => {
  let Feature;
  ((Feature2) => {
    Feature2["ContentSearch"] = "ContentSearch";
    Feature2["UrlPlayback"] = "UrlPlayback";
    Feature2["AdvancedSeek"] = "AdvancedSeek";
    Feature2["TextTracks"] = "TextTracks";
    Feature2["AudioTracks"] = "AudioTracks";
  })(Feature = ContentLauncher2.Feature || (ContentLauncher2.Feature = {}));
  ContentLauncher2.SupportedProtocols = {
    /**
     * Device supports Dynamic Adaptive Streaming over HTTP (DASH)
     */
    dash: (0, import_BitmapSchema.BitFlag)(0),
    /**
     * Device supports HTTP Live Streaming (HLS)
     */
    hls: (0, import_BitmapSchema.BitFlag)(1)
  };
  let MetricType;
  ((MetricType2) => {
    MetricType2[MetricType2["Pixels"] = 0] = "Pixels";
    MetricType2[MetricType2["Percentage"] = 1] = "Percentage";
  })(MetricType = ContentLauncher2.MetricType || (ContentLauncher2.MetricType = {}));
  ContentLauncher2.TlvDimension = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the width using the metric defined in Metric
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.7.5.8.1
     */
    width: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvDouble),
    /**
     * This field shall indicate the height using the metric defined in Metric
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.7.5.8.2
     */
    height: (0, import_TlvObject.TlvField)(1, import_TlvNumber.TlvDouble),
    /**
     * This field shall indicate metric used for defining Height/Width.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.7.5.8.3
     */
    metric: (0, import_TlvObject.TlvField)(2, (0, import_TlvNumber.TlvEnum)())
  });
  ContentLauncher2.TlvStyleInformation = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the URL of image used for Styling different Video Player sections like Logo,
     * Watermark etc. The syntax of this field shall follow the syntax as specified in RFC 1738 and shall use the
     * https scheme.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.7.5.9.1
     */
    imageUrl: (0, import_TlvObject.TlvOptionalField)(0, import_TlvString.TlvString.bound({ maxLength: 8192 })),
    /**
     * This field shall indicate the color, in RGB or RGBA, used for styling different Video Player sections like
     * Logo, Watermark, etc. The value shall conform to the 6-digit or 8-digit format defined for CSS sRGB
     * hexadecimal color notation [https://www.w3.org/TR/css-color-4/#hex-notation]. Examples:
     *
     *   • #76DE19 for R=0x76, G=0xDE, B=0x19, A absent
     *
     *   • #76DE1980 for R=0x76, G=0xDE, B=0x19, A=0x80
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.7.5.9.2
     */
    color: (0, import_TlvObject.TlvOptionalField)(1, import_TlvString.TlvString),
    /**
     * This field shall indicate the size of the image used for Styling different Video Player sections like
     *
     * Logo, Watermark etc.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.7.5.9.3
     */
    size: (0, import_TlvObject.TlvOptionalField)(2, ContentLauncher2.TlvDimension)
  });
  ContentLauncher2.TlvBrandingInformation = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate name of the provider for the given content.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.7.5.10.1
     */
    providerName: (0, import_TlvObject.TlvField)(0, import_TlvString.TlvString.bound({ maxLength: 256 })),
    /**
     * This field shall indicate background of the Video Player while content launch request is being processed by
     * it. This background information may also be used by the Video Player when it is in idle state.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.7.5.10.2
     */
    background: (0, import_TlvObject.TlvOptionalField)(1, ContentLauncher2.TlvStyleInformation),
    /**
     * This field shall indicate the logo shown when the Video Player is launching. This is also used when the Video
     * Player is in the idle state and Splash field is not available.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.7.5.10.3
     */
    logo: (0, import_TlvObject.TlvOptionalField)(2, ContentLauncher2.TlvStyleInformation),
    /**
     * This field shall indicate the style of progress bar for media playback.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.7.5.10.4
     */
    progressBar: (0, import_TlvObject.TlvOptionalField)(3, ContentLauncher2.TlvStyleInformation),
    /**
     * This field shall indicate the screen shown when the Video Player is in an idle state. If this property is not
     * populated, the Video Player shall default to logo or the provider name.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.7.5.10.5
     */
    splash: (0, import_TlvObject.TlvOptionalField)(4, ContentLauncher2.TlvStyleInformation),
    /**
     * This field shall indicate watermark shown when the media is playing.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.7.5.10.6
     */
    waterMark: (0, import_TlvObject.TlvOptionalField)(5, ContentLauncher2.TlvStyleInformation)
  });
  ContentLauncher2.TlvTrackPreference = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall contain one of the standard Tags for Identifying Languages RFC 5646, which identifies the
     * primary language used in the Track.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.7.5.12.1
     */
    languageCode: (0, import_TlvObject.TlvField)(0, import_TlvString.TlvString.bound({ maxLength: 32 })),
    /**
     * This field shall contain a list of enumerated CharacteristicEnum values that indicate a purpose, trait or
     * feature associated with the Track. A value of null shall indicate that there are no Characteristics
     * corresponding to the Track.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.7.5.12.2
     */
    characteristics: (0, import_TlvObject.TlvOptionalField)(1, (0, import_TlvNullable.TlvNullable)((0, import_TlvArray.TlvArray)((0, import_TlvNumber.TlvEnum)()))),
    /**
     * This field if present shall indicate the index of the OutputInfoStruct from the OutputList attribute (from
     * the AudioOutput cluster) and indicates which audio output the Audio Track should be played on.
     *
     * This field shall NOT be present if the track is not an audio track.
     *
     * If the track is an audio track, this field MUST be present. A value of null shall indicate that the server
     * can choose the audio output(s) to play the Audio Track on.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.7.5.12.3
     */
    audioOutputIndex: (0, import_TlvObject.TlvOptionalField)(2, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt8))
  });
  ContentLauncher2.TlvPlaybackPreferences = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the preferred position (in milliseconds) in the media to launch playback from. In
     * case the position falls in the middle of a frame, the server shall set the position to the beginning of that
     * frame and set the SampledPosition attribute on the MediaPlayback cluster accordingly. A value of null shall
     * indicate that playback position is not applicable for the current state of the media playback. (For example :
     * Live media with no known duration and where seek is not supported).
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.7.5.11.1
     */
    playbackPosition: (0, import_TlvObject.TlvOptionalField)(0, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt64)),
    /**
     * This field shall indicate the user’s preferred Text Track. A value of null shall indicate that the user did
     * not specify a preferred Text Track on the client. In such a case, the decision to display and select a Text
     * Track is up to the server.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.7.5.11.2
     */
    textTrack: (0, import_TlvObject.TlvOptionalField)(1, (0, import_TlvNullable.TlvNullable)(ContentLauncher2.TlvTrackPreference)),
    /**
     * This field shall indicate the list of the user’s preferred Audio Tracks. If the list contains multiple
     * values, each AudioTrack must also specify a unique audioOutputIndex to play the track on. A value of null
     * shall indicate that the user did not specify a preferred Audio Track on the client. In such a case, the
     * decision to play and select an Audio Track is up to the server.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.7.5.11.3
     */
    audioTracks: (0, import_TlvObject.TlvOptionalField)(2, (0, import_TlvNullable.TlvNullable)((0, import_TlvArray.TlvArray)(ContentLauncher2.TlvTrackPreference)))
  });
  ContentLauncher2.TlvLaunchUrlRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the URL of content to launch. The syntax of this field shall follow the syntax as
     * specified in RFC 1738 and shall use the https scheme.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.7.7.2.1
     */
    contentUrl: (0, import_TlvObject.TlvField)(0, import_TlvString.TlvString),
    /**
     * This field, if present, shall provide a string that may be used to describe the content being accessed at the
     * given URL.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.7.7.2.2
     */
    displayString: (0, import_TlvObject.TlvOptionalField)(1, import_TlvString.TlvString),
    /**
     * This field, if present, shall indicate the branding information that may be displayed when playing back the
     * given content.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.7.7.2.3
     */
    brandingInformation: (0, import_TlvObject.TlvOptionalField)(2, ContentLauncher2.TlvBrandingInformation),
    /**
     * This field, if present, shall indicate the user’s preferred Text/AudioTracks and playbackPosition for the
     * media, sent from the client to the server. If the server does not find an available track for the title being
     * played exactly matching a Track requested here, in the list of available tracks, it may default to picking
     * another track that closely matches the requested track. Alternately, it may go with user preferences set on
     * the server side (it will use this option if these PlaybackPreferences are not specified). In the case of text
     * tracks, that may mean that the subtitle text is not displayed at all. In the cases where the preferred
     * Text/AudioTracks are not available, the server shall return the TextTrackNotAvailable and/or
     * AudioTrackNotAvailable Status(es) in the LauncherResponse.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.7.7.2.4
     */
    playbackPreferences: (0, import_TlvObject.TlvOptionalField)(3, ContentLauncher2.TlvPlaybackPreferences)
  });
  let Status;
  ((Status2) => {
    Status2[Status2["Success"] = 0] = "Success";
    Status2[Status2["UrlNotAvailable"] = 1] = "UrlNotAvailable";
    Status2[Status2["AuthFailed"] = 2] = "AuthFailed";
    Status2[Status2["TextTrackNotAvailable"] = 3] = "TextTrackNotAvailable";
    Status2[Status2["AudioTrackNotAvailable"] = 4] = "AudioTrackNotAvailable";
  })(Status = ContentLauncher2.Status || (ContentLauncher2.Status = {}));
  ContentLauncher2.TlvLauncherResponse = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the status of the command which resulted in this response.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.7.7.3.1
     */
    status: (0, import_TlvObject.TlvField)(0, (0, import_TlvNumber.TlvEnum)()),
    /**
     * This field shall indicate Optional app-specific data.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.7.7.3.2
     */
    data: (0, import_TlvObject.TlvOptionalField)(1, import_TlvString.TlvString)
  });
  let Parameter;
  ((Parameter2) => {
    Parameter2[Parameter2["Actor"] = 0] = "Actor";
    Parameter2[Parameter2["Channel"] = 1] = "Channel";
    Parameter2[Parameter2["Character"] = 2] = "Character";
    Parameter2[Parameter2["Director"] = 3] = "Director";
    Parameter2[Parameter2["Event"] = 4] = "Event";
    Parameter2[Parameter2["Franchise"] = 5] = "Franchise";
    Parameter2[Parameter2["Genre"] = 6] = "Genre";
    Parameter2[Parameter2["League"] = 7] = "League";
    Parameter2[Parameter2["Popularity"] = 8] = "Popularity";
    Parameter2[Parameter2["Provider"] = 9] = "Provider";
    Parameter2[Parameter2["Sport"] = 10] = "Sport";
    Parameter2[Parameter2["SportsTeam"] = 11] = "SportsTeam";
    Parameter2[Parameter2["Type"] = 12] = "Type";
    Parameter2[Parameter2["Video"] = 13] = "Video";
    Parameter2[Parameter2["Season"] = 14] = "Season";
    Parameter2[Parameter2["Episode"] = 15] = "Episode";
    Parameter2[Parameter2["Any"] = 16] = "Any";
  })(Parameter = ContentLauncher2.Parameter || (ContentLauncher2.Parameter = {}));
  ContentLauncher2.TlvAdditionalInfo = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the name of external id, ex. "musicbrainz".
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.7.5.5.1
     */
    name: (0, import_TlvObject.TlvField)(0, import_TlvString.TlvString.bound({ maxLength: 256 })),
    /**
     * This field shall indicate the value for external id, ex. "ST0000000666661".
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.7.5.5.2
     */
    value: (0, import_TlvObject.TlvField)(1, import_TlvString.TlvString.bound({ maxLength: 8192 }))
  });
  ContentLauncher2.TlvParameterStruct = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the entity type.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.7.5.6.1
     */
    type: (0, import_TlvObject.TlvField)(0, (0, import_TlvNumber.TlvEnum)()),
    /**
     * This field shall indicate the entity value, which is a search string, ex. “Manchester by the Sea”.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.7.5.6.2
     */
    value: (0, import_TlvObject.TlvField)(1, import_TlvString.TlvString.bound({ maxLength: 1024 })),
    /**
     * This field shall indicate the list of additional external content identifiers.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.7.5.6.3
     */
    externalIdList: (0, import_TlvObject.TlvOptionalField)(2, (0, import_TlvArray.TlvArray)(ContentLauncher2.TlvAdditionalInfo))
  });
  ContentLauncher2.TlvContentSearch = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the list of parameters comprising the search. If multiple parameters are provided,
     * the search parameters shall be joined with 'AND' logic. e.g. action movies with Tom Cruise will be
     * represented as [{Actor: 'Tom Cruise'}, {Type: 'Movie'}, {Genre: 'Action'}]
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.7.5.7.1
     */
    parameterList: (0, import_TlvObject.TlvField)(0, (0, import_TlvArray.TlvArray)(ContentLauncher2.TlvParameterStruct))
  });
  ContentLauncher2.TlvLaunchContentRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the content to launch.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.7.7.1.1
     */
    search: (0, import_TlvObject.TlvField)(0, ContentLauncher2.TlvContentSearch),
    /**
     * This field shall indicate whether to automatically start playing content, where:
     *
     *   • TRUE means best match should start playing automatically.
     *
     *   • FALSE means matches should be displayed on screen for user selection.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.7.7.1.2
     */
    autoPlay: (0, import_TlvObject.TlvField)(1, import_TlvBoolean.TlvBoolean),
    /**
     * This field, if present, shall indicate app-specific data.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.7.7.1.3
     */
    data: (0, import_TlvObject.TlvOptionalField)(2, import_TlvString.TlvString),
    /**
     * This field, if present, shall indicate the user’s preferred Text/AudioTracks and playbackPosition for the
     * media, sent from the client to the server. If the server does not find an available track for the title being
     * played exactly matching a Track requested here, in the list of available tracks, it may default to picking
     * another track that closely matches the requested track. Alternately, it may go with user preferences set on
     * the server side (it will use this option if these PlaybackPreferences are not specified). In the case of text
     * tracks, that may mean that the subtitle text is not displayed at all. In the cases where the preferred
     * Text/AudioTracks are not available, the server shall return the TextTrackNotAvailable and/or
     * AudioTrackNotAvailable Status(es) in the LauncherResponse.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.7.7.1.4
     */
    playbackPreferences: (0, import_TlvObject.TlvOptionalField)(3, ContentLauncher2.TlvPlaybackPreferences),
    /**
     * This field, if present, shall indicate whether to consider the context of current ongoing activity on the
     * receiver to fulfill the request. For example if the request only includes data in ContentSearch that
     * specifies an Episode number, and UseCurrentContent is set to TRUE, if there is a TV series on going, the
     * request refers to the specific episode of the ongoing season of the TV series. TRUE means current activity
     * context may be considered FALSE means current activity context shall NOT be considered
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.7.7.1.5
     */
    useCurrentContext: (0, import_TlvObject.TlvOptionalField)(4, import_TlvBoolean.TlvBoolean)
  });
  ContentLauncher2.UrlPlaybackComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * This attribute shall provide a list of content types supported by the Video Player or Content App
       *
       * in the form of entries in the HTTP "Accept" request header.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.7.6.1
       */
      acceptHeader: (0, import_Cluster.Attribute)(0, (0, import_TlvArray.TlvArray)(import_TlvString.TlvString, { maxLength: 100 }), { persistent: true, default: [] }),
      /**
       * This attribute shall provide information about supported streaming protocols.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.7.6.2
       */
      supportedStreamingProtocols: (0, import_Cluster.Attribute)(1, (0, import_TlvNumber.TlvBitmap)(import_TlvNumber.TlvUInt32, ContentLauncher2.SupportedProtocols), { persistent: true })
    },
    commands: {
      /**
       * Upon receipt, this shall launch content from the specified URL.
       *
       * The content types supported include those identified in the AcceptHeader and SupportedStreamingProtocols
       * attributes.
       *
       * A check shall be made to ensure the URL is secure (uses HTTPS).
       *
       * When playing a video stream in response to this command, an indication (ex. visual) of the identity of
       * the origin node of the video stream shall be provided. This could be in the form of a friendly name label
       * which uniquely identifies the node to the user. This friendly name label is typically assigned by the
       * Matter Admin (ex. TV) at the time of commissioning and, when it’s a device, is often editable by the
       * user. It might be a combination of a company name and friendly name, for example, ”Acme” or “Acme
       * Streaming Service on Alice’s Phone”.
       *
       * This command returns a Launch Response.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.7.7.2
       */
      launchUrl: (0, import_Cluster.Command)(1, ContentLauncher2.TlvLaunchUrlRequest, 2, ContentLauncher2.TlvLauncherResponse)
    }
  });
  ContentLauncher2.ContentSearchComponent = import_MutableCluster.MutableCluster.Component({
    commands: {
      /**
       * Upon receipt, this shall launch the specified content with optional search criteria. This command returns
       * a Launch Response.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.7.7.1
       */
      launchContent: (0, import_Cluster.Command)(0, ContentLauncher2.TlvLaunchContentRequest, 2, ContentLauncher2.TlvLauncherResponse)
    }
  });
  ContentLauncher2.ContentSearchOrUrlPlaybackComponent = import_MutableCluster.MutableCluster.Component({});
  ContentLauncher2.Base = import_MutableCluster.MutableCluster.Component({
    id: 1290,
    name: "ContentLauncher",
    revision: 2,
    features: {
      /**
       * ContentSearch
       *
       * Device supports content search (non-app specific)
       */
      contentSearch: (0, import_BitmapSchema.BitFlag)(0),
      /**
       * UrlPlayback
       *
       * Device supports basic URL-based file playback
       */
      urlPlayback: (0, import_BitmapSchema.BitFlag)(1),
      /**
       * AdvancedSeek
       *
       * Enables clients to implement more advanced media seeking behavior in their user interface, such as for
       * example a "seek bar".
       */
      advancedSeek: (0, import_BitmapSchema.BitFlag)(2),
      /**
       * TextTracks
       *
       * Device or app supports Text Tracks.
       */
      textTracks: (0, import_BitmapSchema.BitFlag)(3),
      /**
       * AudioTracks
       *
       * Device or app supports Audio Tracks.
       */
      audioTracks: (0, import_BitmapSchema.BitFlag)(4)
    },
    /**
     * This metadata controls which ContentLauncherCluster elements matter.js activates for specific feature
     * combinations.
     */
    extensions: import_MutableCluster.MutableCluster.Extensions(
      { flags: { urlPlayback: true }, component: ContentLauncher2.UrlPlaybackComponent },
      { flags: { contentSearch: true }, component: ContentLauncher2.ContentSearchComponent },
      { flags: { contentSearch: true }, component: ContentLauncher2.ContentSearchOrUrlPlaybackComponent },
      { flags: { urlPlayback: true }, component: ContentLauncher2.ContentSearchOrUrlPlaybackComponent }
    )
  });
  ContentLauncher2.ClusterInstance = (0, import_MutableCluster.MutableCluster)(ContentLauncher2.Base);
  ContentLauncher2.Cluster = ContentLauncher2.ClusterInstance;
  const UP = { urlPlayback: true };
  const CS = { contentSearch: true };
  ContentLauncher2.CompleteInstance = (0, import_MutableCluster.MutableCluster)({
    id: ContentLauncher2.Cluster.id,
    name: ContentLauncher2.Cluster.name,
    revision: ContentLauncher2.Cluster.revision,
    features: ContentLauncher2.Cluster.features,
    attributes: {
      acceptHeader: import_MutableCluster.MutableCluster.AsConditional(
        ContentLauncher2.UrlPlaybackComponent.attributes.acceptHeader,
        { mandatoryIf: [UP] }
      ),
      supportedStreamingProtocols: import_MutableCluster.MutableCluster.AsConditional(
        ContentLauncher2.UrlPlaybackComponent.attributes.supportedStreamingProtocols,
        { mandatoryIf: [UP] }
      )
    },
    commands: {
      launchContent: import_MutableCluster.MutableCluster.AsConditional(
        ContentLauncher2.ContentSearchComponent.commands.launchContent,
        { mandatoryIf: [CS] }
      ),
      launchUrl: import_MutableCluster.MutableCluster.AsConditional(ContentLauncher2.UrlPlaybackComponent.commands.launchUrl, { mandatoryIf: [UP] })
    }
  });
  ContentLauncher2.Complete = ContentLauncher2.CompleteInstance;
})(ContentLauncher || (ContentLauncher = {}));
const ContentLauncherCluster = ContentLauncher.Cluster;
import_ClusterRegistry.ClusterRegistry.register(ContentLauncher.Complete);
//# sourceMappingURL=content-launcher.js.map
