"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var device_energy_management_exports = {};
__export(device_energy_management_exports, {
  DeviceEnergyManagement: () => DeviceEnergyManagement,
  DeviceEnergyManagementCluster: () => DeviceEnergyManagementCluster
});
module.exports = __toCommonJS(device_energy_management_exports);
var import_MutableCluster = require("../cluster/mutation/MutableCluster.js");
var import_Cluster = require("../cluster/Cluster.js");
var import_TlvObject = require("../tlv/TlvObject.js");
var import_TlvArray = require("../tlv/TlvArray.js");
var import_TlvNumber = require("../tlv/TlvNumber.js");
var import_TlvNullable = require("../tlv/TlvNullable.js");
var import_TlvNoArguments = require("../tlv/TlvNoArguments.js");
var import_TlvBoolean = require("../tlv/TlvBoolean.js");
var import_BitmapSchema = require("../schema/BitmapSchema.js");
var import_ClusterRegistry = require("../cluster/ClusterRegistry.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
var DeviceEnergyManagement;
((DeviceEnergyManagement2) => {
  let Feature;
  ((Feature2) => {
    Feature2["PowerAdjustment"] = "PowerAdjustment";
    Feature2["PowerForecastReporting"] = "PowerForecastReporting";
    Feature2["StateForecastReporting"] = "StateForecastReporting";
    Feature2["StartTimeAdjustment"] = "StartTimeAdjustment";
    Feature2["Pausable"] = "Pausable";
    Feature2["ForecastAdjustment"] = "ForecastAdjustment";
    Feature2["ConstraintBasedAdjustment"] = "ConstraintBasedAdjustment";
  })(Feature = DeviceEnergyManagement2.Feature || (DeviceEnergyManagement2.Feature = {}));
  DeviceEnergyManagement2.TlvPowerAdjust = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the minimum power that the ESA can have its power adjusted to.
     *
     * Note that this is a signed value. Negative values indicate power flows out of the node (e.g. discharging a
     * battery).
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.10.1
     */
    minPower: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvInt64),
    /**
     * This field shall indicate the maximum power that the ESA can have its power adjusted to.
     *
     * Note that this is a signed value. Negative values indicate power flows out of the node (e.g. discharging a
     * battery).
     *
     * For example, if the charging current of an EVSE can be adjusted within the range of 6A to 32A on a 230V
     * supply, then the power adjustment range is between 1380W and 7360W. Here the MinPower would be 1380W, and
     * MaxPower would be 7360W.
     *
     * For example, if a battery storage inverter can discharge between 0 to 3000W towards a load, then power is
     * flowing out of the node and is therefore negative. Its MinPower would be -3000W and its MaxPower would be 0W.
     *
     * In another example, if a battery storage inverter can charge its internal battery, between 0W and 2000W. Here
     * power is flowing into the node when charging. As such the MinPower becomes 0W and MaxPower becomes 2000W.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.10.2
     */
    maxPower: (0, import_TlvObject.TlvField)(1, import_TlvNumber.TlvInt64),
    /**
     * This field shall indicate the minimum duration, in seconds, that a controller may invoke an ESA power
     * adjustment. Manufacturers may use this to as an anti-cycling capability to avoid controllers from rapidly
     * making power adjustments.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.10.3
     */
    minDuration: (0, import_TlvObject.TlvField)(2, import_TlvNumber.TlvUInt32),
    /**
     * This field shall indicate the maximum duration, in seconds, that a controller may invoke an ESA power
     * adjustment. Manufacturers may use this to protect the user experience, to avoid over heating of the ESA,
     * ensuring that there is sufficient headroom to use or store energy in the ESA or for any other reason.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.10.4
     */
    maxDuration: (0, import_TlvObject.TlvField)(3, import_TlvNumber.TlvUInt32)
  });
  let PowerAdjustReason;
  ((PowerAdjustReason2) => {
    PowerAdjustReason2[PowerAdjustReason2["NoAdjustment"] = 0] = "NoAdjustment";
    PowerAdjustReason2[PowerAdjustReason2["LocalOptimizationAdjustment"] = 1] = "LocalOptimizationAdjustment";
    PowerAdjustReason2[PowerAdjustReason2["GridOptimizationAdjustment"] = 2] = "GridOptimizationAdjustment";
  })(PowerAdjustReason = DeviceEnergyManagement2.PowerAdjustReason || (DeviceEnergyManagement2.PowerAdjustReason = {}));
  DeviceEnergyManagement2.TlvPowerAdjustCapability = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate how the ESA can be adjusted at the current time.
     *
     * For example, a battery storage inverter may need to regulate its internal temperature, or the charging rate
     * of the battery may be limited due to cold temperatures, or a change in the state of charge of the battery may
     * mean that the maximum charging or discharging rate is limited.
     *
     * An empty list shall indicate that no power adjustment is currently possible.
     *
     * Multiple entries in the list allow indicating that permutations of scenarios may be possible.
     *
     * For example, a 10kWh battery could be at 80% state of charge. If charging at 2kW, then it would be full in 1
     * hour. However, it could be discharged at 2kW for 4 hours.
     *
     * In this example the list of PowerAdjustStructs allows multiple scenarios to be offered as follows:
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.12
     */
    powerAdjustCapability: (0, import_TlvObject.TlvField)(0, (0, import_TlvNullable.TlvNullable)((0, import_TlvArray.TlvArray)(DeviceEnergyManagement2.TlvPowerAdjust, { maxLength: 8 }))),
    cause: (0, import_TlvObject.TlvField)(1, (0, import_TlvNumber.TlvEnum)())
  });
  let AdjustmentCause;
  ((AdjustmentCause2) => {
    AdjustmentCause2[AdjustmentCause2["LocalOptimization"] = 0] = "LocalOptimization";
    AdjustmentCause2[AdjustmentCause2["GridOptimization"] = 1] = "GridOptimization";
  })(AdjustmentCause = DeviceEnergyManagement2.AdjustmentCause || (DeviceEnergyManagement2.AdjustmentCause = {}));
  DeviceEnergyManagement2.TlvPowerAdjustRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the power that the ESA shall use during the adjustment period.
     *
     * This value shall be between the MinPower and MaxPower fields of the PowerAdjustStruct in the
     * PowerAdjustmentCapability attribute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.9.1.1
     */
    power: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvInt64),
    /**
     * This field shall indicate the duration that the ESA shall maintain the requested power for.
     *
     * This value shall be between the MinDuration and MaxDuration fields of the PowerAdjustStruct in the
     * PowerAdjustmentCapability attribute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.9.1.2
     */
    duration: (0, import_TlvObject.TlvField)(1, import_TlvNumber.TlvUInt32),
    /**
     * This field shall indicate the cause of the request from the EMS.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.9.1.3
     */
    cause: (0, import_TlvObject.TlvField)(2, (0, import_TlvNumber.TlvEnum)())
  });
  let Cause;
  ((Cause2) => {
    Cause2[Cause2["NormalCompletion"] = 0] = "NormalCompletion";
    Cause2[Cause2["Offline"] = 1] = "Offline";
    Cause2[Cause2["Fault"] = 2] = "Fault";
    Cause2[Cause2["UserOptOut"] = 3] = "UserOptOut";
    Cause2[Cause2["Cancelled"] = 4] = "Cancelled";
  })(Cause = DeviceEnergyManagement2.Cause || (DeviceEnergyManagement2.Cause = {}));
  DeviceEnergyManagement2.TlvPowerAdjustEndEvent = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the reason why the power adjustment session ended.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.10.2.1
     */
    cause: (0, import_TlvObject.TlvField)(0, (0, import_TlvNumber.TlvEnum)()),
    /**
     * This field shall indicate the number of seconds that the power adjustment session lasted before ending.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.10.2.2
     */
    duration: (0, import_TlvObject.TlvField)(1, import_TlvNumber.TlvUInt32),
    /**
     * This field shall indicate the approximate energy used by the ESA during the session.
     *
     * For example, if the ESA was on and was adjusted to be switched off, then this shall be 0 mWh. If this was a
     * battery inverter that was requested to discharge it would have a negative EnergyUse value. If this was a
     * normal load that was turned on, then it will have positive value.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.10.2.3
     */
    energyUse: (0, import_TlvObject.TlvField)(2, import_TlvNumber.TlvInt64)
  });
  let CostType;
  ((CostType2) => {
    CostType2[CostType2["Financial"] = 0] = "Financial";
    CostType2[CostType2["GhgEmissions"] = 1] = "GhgEmissions";
    CostType2[CostType2["Comfort"] = 2] = "Comfort";
    CostType2[CostType2["Temperature"] = 3] = "Temperature";
  })(CostType = DeviceEnergyManagement2.CostType || (DeviceEnergyManagement2.CostType = {}));
  DeviceEnergyManagement2.TlvCost = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the type of cost being represented (see CostTypeEnum).
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.9.1
     */
    costType: (0, import_TlvObject.TlvField)(0, (0, import_TlvNumber.TlvEnum)()),
    /**
     * This field shall indicate the value of the cost. This may be negative (indicating that it is not a cost, but
     * a free benefit).
     *
     * For example, if the Value was -302 and DecimalPoints was 2, then this would represent a benefit of 3.02.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.9.2
     */
    value: (0, import_TlvObject.TlvField)(1, import_TlvNumber.TlvInt32),
    /**
     * This field shall indicate the number of digits to the right of the decimal point in the Value field. For
     * example, if the Value was 102 and DecimalPoints was 2, then this would represent a cost of 1.02.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.9.3
     */
    decimalPoints: (0, import_TlvObject.TlvField)(2, import_TlvNumber.TlvUInt8),
    /**
     * Indicates the currency for the value in the Value field. The value of the currency field shall match the
     * values defined by [ISO 4217].
     *
     * This is an optional field. It shall be included if CostType is Financial.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.9.4
     */
    currency: (0, import_TlvObject.TlvOptionalField)(3, import_TlvNumber.TlvUInt16.bound({ max: 999 }))
  });
  DeviceEnergyManagement2.TlvSlot = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the minimum time (in seconds) that the appliance expects to be in this slot for.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.14.1
     */
    minDuration: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt32),
    /**
     * This field shall indicate the maximum time (in seconds) that the appliance expects to be in this slot for.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.14.2
     */
    maxDuration: (0, import_TlvObject.TlvField)(1, import_TlvNumber.TlvUInt32),
    /**
     * This field shall indicate the expected time (in seconds) that the appliance expects to be in this slot for.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.14.3
     */
    defaultDuration: (0, import_TlvObject.TlvField)(2, import_TlvNumber.TlvUInt32),
    /**
     * This field shall indicate the time (in seconds) that has already elapsed whilst in this slot. If the slot has
     * not yet been started, then it shall be 0. Once the slot has been completed, then this reflects how much time
     * was spent in this slot.
     *
     * When subscribed to, a change in this field value shall NOT cause the Forecast attribute to be updated since
     * this value may change every 1 second.
     *
     * When the Forecast attribute is read, then this value shall be the most recent value.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.14.4
     */
    elapsedSlotTime: (0, import_TlvObject.TlvField)(3, import_TlvNumber.TlvUInt32),
    /**
     * This field shall indicate the time (in seconds) that is estimated to be remaining.
     *
     * Note that it may not align to the DefaultDuration - ElapsedSlotTime since an appliance may have revised its
     * planned operation based on conditions.
     *
     * When subscribed to, a change in this field value shall NOT cause the Forecast attribute to be updated, since
     * this value may change every 1 second.
     *
     * Note that if the ESA is currently paused, then this value shall NOT change.
     *
     * When the Forecast attribute is read, then this value shall be the most recent value.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.14.5
     */
    remainingSlotTime: (0, import_TlvObject.TlvField)(4, import_TlvNumber.TlvUInt32),
    /**
     * This field shall indicate whether this slot can be paused.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.14.6
     */
    slotIsPausable: (0, import_TlvObject.TlvOptionalField)(5, import_TlvBoolean.TlvBoolean),
    /**
     * This field shall indicate the shortest period that the slot can be paused for. This can be set to avoid
     * controllers trying to pause ESAs for short periods and then resuming operation in a cyclic fashion which may
     * damage or cause excess energy to be consumed with restarting of an operation.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.14.7
     */
    minPauseDuration: (0, import_TlvObject.TlvOptionalField)(6, import_TlvNumber.TlvUInt32),
    /**
     * This field shall indicate the longest period that the slot can be paused for.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.14.8
     */
    maxPauseDuration: (0, import_TlvObject.TlvOptionalField)(7, import_TlvNumber.TlvUInt32),
    /**
     * This field shall indicate a manufacturer defined value indicating the state of the ESA.
     *
     * This may be used by an observing EMS which also has access to the metering data to ascertain the typical
     * power drawn when the ESA is in a manufacturer defined state.
     *
     * Some appliances, such as smart thermostats, may not know how much power is being drawn by the HVAC system,
     * but do know what they have asked the HVAC system to do.
     *
     * Manufacturers can use this value to indicate a variety of states in an unspecified way. For example, they may
     * choose to use values between 0-100 as a percentage of compressor modulation, or could use these values as
     * Enum states meaning heating with fan, heating without fan etc.
     *
     * NOTE An ESA shall always use the same value to represent the same operating state.
     *
     * By providing this information a smart EMS may be able to learn the observed power draw when the ESA is put
     * into a specific state. It can potentially then use the ManufacturerESAState field in the Forecast attribute
     * along with observed power drawn to predict the power draw from the appliance and potentially ask it to modify
     * its timing via one of the adjustment request commands, or adjust other ESAs power to compensate.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.14.9
     */
    manufacturerEsaState: (0, import_TlvObject.TlvOptionalField)(8, import_TlvNumber.TlvUInt16),
    /**
     * This field shall indicate the expected power that the appliance will use during this slot. It may be
     * considered the average value over the slot, and some variation from this would be expected (for example, as
     * it is ramping up).
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.14.10
     */
    nominalPower: (0, import_TlvObject.TlvOptionalField)(9, import_TlvNumber.TlvInt64),
    /**
     * This field shall indicate the lowest power that the appliance expects to use during this slot. (e.g. during a
     * ramp up it may be 0W).
     *
     * Some appliances (e.g. battery inverters which can charge and discharge) may have a negative power.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.14.11
     */
    minPower: (0, import_TlvObject.TlvOptionalField)(10, import_TlvNumber.TlvInt64),
    /**
     * This field shall indicate the maximum power that the appliance expects to use during this slot. (e.g. during
     * a ramp up it may be 0W). This field ignores the effects of short-lived inrush currents.
     *
     * Some appliances (e.g. battery inverters which can charge and discharge) may have a negative power.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.14.12
     */
    maxPower: (0, import_TlvObject.TlvOptionalField)(11, import_TlvNumber.TlvInt64),
    /**
     * This field shall indicate the expected energy that the appliance expects to use or produce during this slot.
     *
     * Some appliances (e.g. battery inverters which can charge and discharge) may have a negative energy.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.14.13
     */
    nominalEnergy: (0, import_TlvObject.TlvOptionalField)(12, import_TlvNumber.TlvInt64),
    /**
     * This field shall indicate the current estimated cost for operating.
     *
     * For example, if the device has access to an Energy pricing server it may be able to use the tariff to
     * estimate the cost of energy for this slot in the power forecast.
     *
     * When an Energy Management System requests a change in the schedule, then the device may suggest a change in
     * the cost as a result of shifting its energy. This can allow a demand side response service to be informed of
     * the relative cost to use energy at a different time.
     *
     * The Costs field is a list of CostStruct structures which allows multiple CostTypeEnum and Values to be shared
     * by the energy appliance. These could be based on GHG emissions, comfort value for the consumer etc.
     *
     * For example, comfort could be expressed in abstract units or in currency. A water heater that is heated
     * earlier in the day is likely to lose some of its heat before it is needed, which could require a top-up
     * heating event to occur later in the day (which may incur additional cost).
     *
     * If the ESA cannot calculate its cost for any reason (such as losing its connection to a Price server) it may
     * omit this field. This is treated as extra meta data that an EMS may use to optimize a system.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.14.14
     */
    costs: (0, import_TlvObject.TlvOptionalField)(13, (0, import_TlvArray.TlvArray)(DeviceEnergyManagement2.TlvCost, { maxLength: 5 })),
    /**
     * This field shall indicate the minimum power that the appliance can be requested to use.
     *
     * For example, some EVSEs cannot be switched on to charge below 6A which may equate to ~1.3kW in EU markets. If
     * the slot indicates a NominalPower of 0W (indicating it is expecting to be off), this allows an ESA to
     * indicate it could be switched on to charge, but this would be the minimum power limit it can be set to.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.14.15
     */
    minPowerAdjustment: (0, import_TlvObject.TlvOptionalField)(14, import_TlvNumber.TlvInt64),
    /**
     * This field shall indicate the maximum power that the appliance can be requested to use.
     *
     * For example, an EVSE may be limited by its electrical supply to 32A which would be ~7.6kW in EU markets. If
     * the slot indicates a NominalPower of 0W (indicating it is expecting to be off), this allows an ESA to
     * indicate it could be switched on to charge, but this would be the maximum power limit it can be set to.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.14.16
     */
    maxPowerAdjustment: (0, import_TlvObject.TlvOptionalField)(15, import_TlvNumber.TlvInt64),
    /**
     * This field shall indicate the minimum time, in seconds, that the slot can be requested to shortened to.
     *
     * For example, if the slot indicates a NominalPower of 0W (indicating it is expecting to be off), this would
     * allow an ESA to specify the minimum time it could be switched on for. This is to help protect the appliance
     * from being damaged by short cycling times.
     *
     * For example, a heat pump compressor may have a minimum cycle time of order a few minutes.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.14.17
     */
    minDurationAdjustment: (0, import_TlvObject.TlvOptionalField)(16, import_TlvNumber.TlvUInt32),
    /**
     * This field shall indicate the maximum time, in seconds, that the slot can be requested to extended to.
     *
     * For example, if the slot indicates a NominalPower of 0W (indicating it is expecting to be off), this allows
     * an ESA to specify the maximum time it could be switched on for. This may allow a battery or water heater to
     * indicate the maximum duration that it can charge for before becoming full. In the case of a battery inverter
     * which can be discharged, it may equally indicate the maximum time the battery could be discharged for (at the
     * MaxPowerAdjustment power level).
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.14.18
     */
    maxDurationAdjustment: (0, import_TlvObject.TlvOptionalField)(17, import_TlvNumber.TlvUInt32)
  });
  let ForecastUpdateReason;
  ((ForecastUpdateReason2) => {
    ForecastUpdateReason2[ForecastUpdateReason2["InternalOptimization"] = 0] = "InternalOptimization";
    ForecastUpdateReason2[ForecastUpdateReason2["LocalOptimization"] = 1] = "LocalOptimization";
    ForecastUpdateReason2[ForecastUpdateReason2["GridOptimization"] = 2] = "GridOptimization";
  })(ForecastUpdateReason = DeviceEnergyManagement2.ForecastUpdateReason || (DeviceEnergyManagement2.ForecastUpdateReason = {}));
  DeviceEnergyManagement2.TlvForecast = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the sequence number for the current forecast. If the ESA updates a forecast, it
     * shall monotonically increase this value.
     *
     * The ESA does not need to persist this value across reboots, since the EMS SHOULD be able to detect that any
     * previous subscriptions are lost if a device reboots. The loss of a subscription and subsequent
     * re-subscription allows the EMS to learn about any new forecasts.
     *
     * The value of ForecastID is allowed to wrap.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.13.1
     */
    forecastId: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt32),
    /**
     * This field shall indicate which element of the Slots list is currently active in the Forecast sequence. A
     * null value indicates that the sequence has not yet started.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.13.2
     */
    activeSlotNumber: (0, import_TlvObject.TlvField)(1, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt16)),
    /**
     * This field shall indicate the planned start time, in UTC, for the entire Forecast.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.13.3
     */
    startTime: (0, import_TlvObject.TlvField)(2, import_TlvNumber.TlvEpochS),
    /**
     * This field shall indicate the planned end time, in UTC, for the entire Forecast.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.13.4
     */
    endTime: (0, import_TlvObject.TlvField)(3, import_TlvNumber.TlvEpochS),
    /**
     * This field shall indicate the earliest start time, in UTC, that the entire Forecast can be shifted to. A null
     * value indicates that it can be started immediately.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.13.5
     */
    earliestStartTime: (0, import_TlvObject.TlvOptionalField)(4, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvEpochS)),
    /**
     * This field shall indicate the latest end time, in UTC, for the entire Forecast.
     *
     * e.g. for an EVSE charging session, this may indicate the departure time for the vehicle, by which time the
     * charging session must end.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.13.6
     */
    latestEndTime: (0, import_TlvObject.TlvOptionalField)(5, import_TlvNumber.TlvEpochS),
    /**
     * This field shall indicate that some part of the Forecast can be paused. It aims to allow a client to read
     * this flag and if it is false, then none of the slots contain SlotIsPausable set to true. This can save a
     * client from having to check each slot in the list.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.13.7
     */
    isPausable: (0, import_TlvObject.TlvField)(6, import_TlvBoolean.TlvBoolean),
    /**
     * This field shall contain a list of SlotStructs.
     *
     * It shall contain at least 1 entry, and a maximum of 10.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.13.8
     */
    slots: (0, import_TlvObject.TlvField)(7, (0, import_TlvArray.TlvArray)(DeviceEnergyManagement2.TlvSlot, { maxLength: 10 })),
    /**
     * This field shall contain the reason the current Forecast was generated.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.13.9
     */
    forecastUpdateReason: (0, import_TlvObject.TlvField)(8, (0, import_TlvNumber.TlvEnum)())
  });
  let OptOutState;
  ((OptOutState2) => {
    OptOutState2[OptOutState2["NoOptOut"] = 0] = "NoOptOut";
    OptOutState2[OptOutState2["LocalOptOut"] = 1] = "LocalOptOut";
    OptOutState2[OptOutState2["GridOptOut"] = 2] = "GridOptOut";
    OptOutState2[OptOutState2["OptOut"] = 3] = "OptOut";
  })(OptOutState = DeviceEnergyManagement2.OptOutState || (DeviceEnergyManagement2.OptOutState = {}));
  DeviceEnergyManagement2.TlvPauseRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the duration that the ESA shall be paused for. This value shall be between the
     * MinPauseDuration and MaxPauseDuration indicated in the ActiveSlotNumber index in the Slots list in the
     * Forecast.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.9.4.1
     */
    duration: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt32),
    /**
     * This field shall indicate the cause of the request from the EMS.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.9.4.2
     */
    cause: (0, import_TlvObject.TlvField)(1, (0, import_TlvNumber.TlvEnum)())
  });
  DeviceEnergyManagement2.TlvResumedEvent = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the reason why the pause ended.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.10.4.1
     */
    cause: (0, import_TlvObject.TlvField)(0, (0, import_TlvNumber.TlvEnum)())
  });
  DeviceEnergyManagement2.TlvStartTimeAdjustRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the requested start time, in UTC, that the client would like the appliance to shift
     * its Forecast to. This value MUST be in the future.
     *
     * A client can estimate the entire Forecast sequence duration by computing the EndTime - StartTime fields from
     * the Forecast attribute, and therefore avoid scheduling the start time too late.
     *
     * This value shall be after the EarliestStartTime in the Forecast attribute. The new EndTime, that can be
     * computed from the RequestedStartTime and the Forecast sequence duration, shall be before the LatestEndTime.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.9.3.1
     */
    requestedStartTime: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvEpochS),
    /**
     * This field shall indicate the cause of the request from the EMS.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.9.3.2
     */
    cause: (0, import_TlvObject.TlvField)(1, (0, import_TlvNumber.TlvEnum)())
  });
  DeviceEnergyManagement2.TlvSlotAdjustment = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the index into the Slots list within the Forecast that is to be modified. It shall
     * be less than the actual length of the Slots list (implicitly it must be in the range 0 to 9 based on the
     * maximum length of the Slots list constraint).
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.15.1
     */
    slotIndex: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt8),
    /**
     * This field shall indicate the new requested power that the ESA shall operate at. It MUST be between the
     * AbsMinPower and AbsMaxPower attributes as advertised by the ESA if it supports PFR.
     *
     * This is a signed value and can be used to indicate charging or discharging. If the ESA does NOT support PFR
     * this value shall be ignored by the ESA.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.15.2
     */
    nominalPower: (0, import_TlvObject.TlvOptionalField)(1, import_TlvNumber.TlvInt64),
    /**
     * This field shall indicate the new requested duration, in seconds, that the ESA shall extend or shorten the
     * slot duration to. It MUST be between the MinDurationAdjustment and MaxDurationAdjustment for the slot as
     * advertised by the ESA.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.15.3
     */
    duration: (0, import_TlvObject.TlvField)(2, import_TlvNumber.TlvUInt32)
  });
  DeviceEnergyManagement2.TlvModifyForecastRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the ForecastID that is to be modified.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.9.6.1
     */
    forecastId: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt32),
    /**
     * This field shall contain a list of SlotAdjustment parameters that should be modified in the corresponding
     * Forecast with matching ForecastID.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.9.6.2
     */
    slotAdjustments: (0, import_TlvObject.TlvField)(1, (0, import_TlvArray.TlvArray)(DeviceEnergyManagement2.TlvSlotAdjustment, { maxLength: 10 })),
    /**
     * This field shall indicate the cause of the request from the EMS.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.9.6.3
     */
    cause: (0, import_TlvObject.TlvField)(2, (0, import_TlvNumber.TlvEnum)())
  });
  DeviceEnergyManagement2.TlvConstraints = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the start time of the constraint period that the client wishes the ESA to compute a
     * new Forecast.
     *
     * This value is in UTC and MUST be in the future.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.16.1
     */
    startTime: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvEpochS),
    /**
     * This field shall indicate the duration of the constraint in seconds.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.16.2
     */
    duration: (0, import_TlvObject.TlvField)(1, import_TlvNumber.TlvUInt32.bound({ max: 86400 })),
    /**
     * This field shall indicate the nominal power that client wishes the ESA to operate at during the constrained
     * period. It MUST be between the AbsMinPower and AbsMaxPower attributes as advertised by the ESA if it supports
     * PFR.
     *
     * This is a signed value and can be used to indicate charging or discharging.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.16.3
     */
    nominalPower: (0, import_TlvObject.TlvOptionalField)(2, import_TlvNumber.TlvInt64),
    /**
     * This field shall indicate the maximum energy that can be transferred to or from the ESA during the constraint
     * period.
     *
     * This is a signed value and can be used to indicate charging or discharging.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.16.4
     */
    maximumEnergy: (0, import_TlvObject.TlvOptionalField)(3, import_TlvNumber.TlvInt64),
    /**
     * This field shall indicate the turn up or turn down nature that the grid wants as the outcome by the ESA
     * during the constraint period.
     *
     * This is expressed as a signed value between -100 to +100. A value of 0 would indicate no bias to using more
     * or less energy. A negative value indicates a request to use less energy. A positive value indicates a request
     * to use more energy.
     *
     * Note that the mapping between values and operation is manufacturer specific.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.7.16.5
     */
    loadControl: (0, import_TlvObject.TlvOptionalField)(4, import_TlvNumber.TlvInt8)
  });
  DeviceEnergyManagement2.TlvRequestConstraintBasedForecastRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the series of turn up or turn down power requests that the ESA is being asked to
     * constrain its operation within. These requests shall be in the future, shall be in chronological order,
     * starting with the earliest start time, and shall NOT overlap in time.
     *
     * For example, a grid event which requires devices to reduce power (turn down) between 4pm and 6pm and due to
     * excess power on the grid overnight, may request ESAs to increase their power demand (turn up) between
     * midnight and 6am.
     *
     * If this ESA supports PFR this would have 2 entries in the list as follows:
     *
     * If this ESA supports SFR where it does not know the actual power, but has an understanding of the functions
     * that use more energy, it could be requested to use more or less energy using the LoadCon
     *
     * trol field as follows:
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.9.7.1
     */
    constraints: (0, import_TlvObject.TlvField)(0, (0, import_TlvArray.TlvArray)(DeviceEnergyManagement2.TlvConstraints, { maxLength: 10 })),
    /**
     * This field shall indicate the cause of the request from the EMS.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.2.9.7.2
     */
    cause: (0, import_TlvObject.TlvField)(1, (0, import_TlvNumber.TlvEnum)())
  });
  let EsaType;
  ((EsaType2) => {
    EsaType2[EsaType2["Evse"] = 0] = "Evse";
    EsaType2[EsaType2["SpaceHeating"] = 1] = "SpaceHeating";
    EsaType2[EsaType2["WaterHeating"] = 2] = "WaterHeating";
    EsaType2[EsaType2["SpaceCooling"] = 3] = "SpaceCooling";
    EsaType2[EsaType2["SpaceHeatingCooling"] = 4] = "SpaceHeatingCooling";
    EsaType2[EsaType2["BatteryStorage"] = 5] = "BatteryStorage";
    EsaType2[EsaType2["SolarPv"] = 6] = "SolarPv";
    EsaType2[EsaType2["FridgeFreezer"] = 7] = "FridgeFreezer";
    EsaType2[EsaType2["WashingMachine"] = 8] = "WashingMachine";
    EsaType2[EsaType2["Dishwasher"] = 9] = "Dishwasher";
    EsaType2[EsaType2["Cooking"] = 10] = "Cooking";
    EsaType2[EsaType2["HomeWaterPump"] = 11] = "HomeWaterPump";
    EsaType2[EsaType2["IrrigationWaterPump"] = 12] = "IrrigationWaterPump";
    EsaType2[EsaType2["PoolPump"] = 13] = "PoolPump";
    EsaType2[EsaType2["Other"] = 255] = "Other";
  })(EsaType = DeviceEnergyManagement2.EsaType || (DeviceEnergyManagement2.EsaType = {}));
  let EsaState;
  ((EsaState2) => {
    EsaState2[EsaState2["Offline"] = 0] = "Offline";
    EsaState2[EsaState2["Online"] = 1] = "Online";
    EsaState2[EsaState2["Fault"] = 2] = "Fault";
    EsaState2[EsaState2["PowerAdjustActive"] = 3] = "PowerAdjustActive";
    EsaState2[EsaState2["Paused"] = 4] = "Paused";
  })(EsaState = DeviceEnergyManagement2.EsaState || (DeviceEnergyManagement2.EsaState = {}));
  DeviceEnergyManagement2.PowerAdjustmentComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * Indicates how the ESA can be adjusted at the current time, and the state of any active adjustment.
       *
       * A null value indicates that no power adjustment is currently possible, and nor is any adjustment
       * currently active.
       *
       * This attribute SHOULD be updated periodically by ESAs to reflect any changes in internal state, for
       * example temperature or stored energy, which would affect the power or duration limits.
       *
       * Changes to this attribute shall only be marked as reportable in the following cases:
       *
       *   • At most once every 10 seconds on changes, or
       *
       *   • When it changes from null to any other value and vice versa.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.2.8.6
       */
      powerAdjustmentCapability: (0, import_Cluster.Attribute)(5, (0, import_TlvNullable.TlvNullable)(DeviceEnergyManagement2.TlvPowerAdjustCapability), { default: null })
    },
    commands: {
      /**
       * Allows a client to request an adjustment in the power consumption of an ESA for a specified duration.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.2.9.1
       */
      powerAdjustRequest: (0, import_Cluster.Command)(0, DeviceEnergyManagement2.TlvPowerAdjustRequest, 0, import_Cluster.TlvNoResponse),
      /**
       * Allows a client to cancel an ongoing PowerAdjustmentRequest operation.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.2.9.2
       */
      cancelPowerAdjustRequest: (0, import_Cluster.Command)(1, import_TlvNoArguments.TlvNoArguments, 1, import_Cluster.TlvNoResponse)
    },
    events: {
      /**
       * This event shall be generated when the Power Adjustment session is started.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.2.10.1
       */
      powerAdjustStart: (0, import_Cluster.Event)(0, import_Cluster.EventPriority.Info, import_TlvNoArguments.TlvNoArguments),
      /**
       * This event shall be generated when the Power Adjustment session ends.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.2.10.2
       */
      powerAdjustEnd: (0, import_Cluster.Event)(1, import_Cluster.EventPriority.Info, DeviceEnergyManagement2.TlvPowerAdjustEndEvent)
    }
  });
  DeviceEnergyManagement2.PowerForecastReportingOrStateForecastReportingComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * This attribute allows an ESA to share its intended forecast with a client (such as an Energy Management
       * System).
       *
       * A null value indicates that there is no forecast currently available (for example, a program has not yet
       * been selected by the user).
       *
       * A server may reset this value attribute to null on a reboot, and it does not need to persist any previous
       * forecasts.
       *
       * Changes to this attribute shall only be marked as reportable in the following cases:
       *
       *   • At most once every 10 seconds on changes, or
       *
       *   • When it changes from null to any other value and vice versa, or
       *
       *   • As a result of a command which causes the forecast to be updated, or
       *
       *   • As a result of a change in the opt-out status which in turn may cause the ESA to recalculate its
       *     forecast.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.2.8.7
       */
      forecast: (0, import_Cluster.Attribute)(6, (0, import_TlvNullable.TlvNullable)(DeviceEnergyManagement2.TlvForecast), { default: null })
    }
  });
  DeviceEnergyManagement2.PowerAdjustmentOrStartTimeAdjustmentOrPausableOrForecastAdjustmentOrConstraintBasedAdjustmentComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * Indicates the current Opt-Out state of the ESA. The ESA may have a local user interface to allow the user
       * to control this OptOutState. An EMS may subscribe to the OptOutState to get notified about changes in
       * operational state.
       *
       * If the ESA is in the LocalOptOut or OptOut states, so it cannot be controlled by an EMS for local
       * optimization reasons, it shall reject any commands which have the AdjustmentCauseEnum value
       * LocalOptimization. If the ESA is in the GridOptOut or OptOut states, so it cannot be controlled by an EMS
       * for grid optimization reasons, it shall reject any commands which have the AdjustmentCauseEnum value
       * GridOptimization.
       *
       * If the user changes the Opt-Out state of the ESA which is currently operating with a Forecast that is due
       * to a previous StartTimeAdjustRequest, ModifyForecastRequest or RequestConstraintBasedForecast command
       * that would now not be permitted due to the new Opt-out state
       *
       * attribute ForecastUpdateReason field currently contains a reason which is now opted out), the ESA shall
       * behave as if it had received a CancelRequest command.
       *
       * If the user changes the Opt-Out state of the ESA which currently has the ESAStateEnum with value Paused
       * due to a previous PauseRequest command that would now not be permitted due to the new Opt-out state, and
       * the ESA supports the PFR or SFR features (i.e. the Forecast attribute ForecastUpdateReason field
       * currently contains a reason which is now opted out), the ESA shall behave as if it had received a
       * ResumeRequest command.
       *
       * If the user changes the Opt-Out state of the ESA which currently has the ESAStateEnum with value
       * PowerAdjustActive due to a previous PowerAdjustRequest command that would now not be permitted due to the
       * new Opt-out state (i.e. the Forecast attribute ForecastUpdateReason field currently contains a reason
       * which is now opted out), the ESA shall behave as if it had received a CancelPowerAdjustRequest command.
       *
       * If the ESA is in the LocalOptOut, GridOptOut, or NoOptOut states, the device is still permitted to
       * optimize its own energy usage, for example, using tariff information it may obtain.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.2.8.8
       */
      optOutState: (0, import_Cluster.Attribute)(7, (0, import_TlvNumber.TlvEnum)(), { default: 0 /* NoOptOut */ })
    }
  });
  DeviceEnergyManagement2.PausableComponent = import_MutableCluster.MutableCluster.Component({
    commands: {
      /**
       * Allows a client to temporarily pause an operation and reduce the ESAs energy demand.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.2.9.4
       */
      pauseRequest: (0, import_Cluster.Command)(3, DeviceEnergyManagement2.TlvPauseRequest, 3, import_Cluster.TlvNoResponse),
      /**
       * Allows a client to cancel the PauseRequest command and enable earlier resumption of operation.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.2.9.5
       */
      resumeRequest: (0, import_Cluster.Command)(4, import_TlvNoArguments.TlvNoArguments, 4, import_Cluster.TlvNoResponse)
    },
    events: {
      /**
       * This event shall be generated when the ESA enters the Paused state. There is no data for this event.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.2.10.3
       */
      paused: (0, import_Cluster.Event)(2, import_Cluster.EventPriority.Info, import_TlvNoArguments.TlvNoArguments),
      /**
       * This event shall be generated when the ESA leaves the Paused state and resumes operation.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.2.10.4
       */
      resumed: (0, import_Cluster.Event)(3, import_Cluster.EventPriority.Info, DeviceEnergyManagement2.TlvResumedEvent)
    }
  });
  DeviceEnergyManagement2.StartTimeAdjustmentComponent = import_MutableCluster.MutableCluster.Component({
    commands: {
      /**
       * Allows a client to adjust the start time of a Forecast sequence that has not yet started operation (i.e.
       * where the current Forecast StartTime is in the future).
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.2.9.3
       */
      startTimeAdjustRequest: (0, import_Cluster.Command)(2, DeviceEnergyManagement2.TlvStartTimeAdjustRequest, 2, import_Cluster.TlvNoResponse)
    }
  });
  DeviceEnergyManagement2.ForecastAdjustmentComponent = import_MutableCluster.MutableCluster.Component({
    commands: {
      /**
       * Allows a client to modify a Forecast within the limits allowed by the ESA.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.2.9.6
       */
      modifyForecastRequest: (0, import_Cluster.Command)(5, DeviceEnergyManagement2.TlvModifyForecastRequest, 5, import_Cluster.TlvNoResponse)
    }
  });
  DeviceEnergyManagement2.ConstraintBasedAdjustmentComponent = import_MutableCluster.MutableCluster.Component({
    commands: {
      /**
       * Allows a client to ask the ESA to recompute its Forecast based on power and time constraints.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.2.9.7
       */
      requestConstraintBasedForecast: (0, import_Cluster.Command)(6, DeviceEnergyManagement2.TlvRequestConstraintBasedForecastRequest, 6, import_Cluster.TlvNoResponse)
    }
  });
  DeviceEnergyManagement2.StartTimeAdjustmentOrForecastAdjustmentOrConstraintBasedAdjustmentComponent = import_MutableCluster.MutableCluster.Component({
    commands: {
      /**
       * Allows a client to request cancellation of a previous adjustment request in a StartTimeAdjustRequest,
       * ModifyForecastRequest or RequestConstraintBasedForecast command.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.2.9.8
       */
      cancelRequest: (0, import_Cluster.Command)(7, import_TlvNoArguments.TlvNoArguments, 7, import_Cluster.TlvNoResponse)
    }
  });
  DeviceEnergyManagement2.Base = import_MutableCluster.MutableCluster.Component({
    id: 152,
    name: "DeviceEnergyManagement",
    revision: 4,
    features: {
      /**
       * PowerAdjustment
       *
       * For Energy Smart Appliances (ESA) the definition of being 'smart' mandates that they can report their
       * current power adjustment capability and have an EMS request a temporary adjustment. This may typically be
       * to curtail power requirements during peak periods, but can also be used to turn on an ESA if there is
       * excess renewable or local generation (Solar PV).
       *
       * For example, a home may have solar PV which often produces more power than the home requires, resulting
       * in the excess power flowing into the grid. This excess power naturally fluctuates when clouds pass
       * overhead and other loads in the home are switched on and off.
       *
       * EVSE Example: An EMS may therefore be able to turn on the EVSE (if the vehicle is plugged in) and can
       * start charging the vehicle, and periodically modify the charging power depending on PV generation and
       * other home loads, so as to minimize import and export to the grid. An EMS may also use this feature to
       * control the discharging (and re-charging) of the vehicle if the EVSE and vehicle support the V2X feature
       * of the EVSE cluster of the associated EVSE device.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.2.4.1
       */
      powerAdjustment: (0, import_BitmapSchema.BitFlag)(0),
      /**
       * PowerForecastReporting
       *
       * For Energy Smart Appliances (ESA) the definition of being 'smart' implies that they can report their
       * indicative forecast power demands or generation, to a greater or lesser extent. For some ESAs this is
       * highly predictable (in terms of both power and time), in other appliances this is more challenging and
       * only a basic level of forecast is possible.
       *
       * Forecasts are defined from a current time, using a slot format, where the slot is akin to a relatively
       * constant operating mode.
       *
       * Washing machine example: a washing machine may have stages of a washing cycle: heating, tumbling, rinse
       * and spin stages. At each stage, the approximate minimum and maximum power consumption may be known, as
       * well as the duration of that stage.
       *
       * In some circumstances the ESA may allow the stage to be delayed or paused (subject to safety and
       * manufacturer’s discretion and user preferences).
       *
       * Typically, appliances with a heating element cannot have their power consumption adjusted and can only be
       * paused or delayed.
       *
       * Some ESAs may not be flexible other than a delayed cycle start (for example, once the washing cycle has
       * been started then they run continuously until the cycle completes).
       *
       * Appliances that only support the PowerForecastReporting and not any of the adjustment features may
       * indicate that they are not flexible in the forecast slot format.
       *
       * The PowerForecastReporting and the adjustment features aim to align to the [SAREF4ENER] ontology.
       *
       * Inverter driven ESAs: some inverter driven ESAs can consume or generate a variable amount of power.
       *
       * For example, a single phase EVSE can be adjusted in the range of 6-32Amps in 0.6 Amp steps in EU or on a
       * hardwired 120V supply in the range of 6-15 Amps in US.
       *
       * For example, a home battery may be adjusted to charge or discharge in steps of 1W.
       *
       * For example, a heat pump may be able to modulate its compressor inverter between 20-100% of its rated
       * power.
       *
       * The ESA indicates its power adjustment range and its nominal power consumption as part of its Forecast.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.2.4.2
       */
      powerForecastReporting: (0, import_BitmapSchema.BitFlag)(1),
      /**
       * StateForecastReporting
       *
       * Some ESAs do not know their actual power consumption, but do know the state of operation. Like the
       * PowerForecastingReporting feature, this uses the same slot structure mechanism to indicate a change in
       * state vs time.
       *
       * An external observing EMS may have access to real-time meter readings, and could learn the typical power
       * consumption based on the advertised internal state of the ESA.
       *
       * To enable this capability, the ESA shall report its internal operational state using an manufacturer
       * specific value.
       *
       * Once the EMS has built a model of the state vs observed power consumption, it may request a forecast
       * adjustment for particular times of the day, encouraging the ESA to use power at alternative times.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.2.4.3
       */
      stateForecastReporting: (0, import_BitmapSchema.BitFlag)(2),
      /**
       * StartTimeAdjustment
       *
       * ESAs which support the Start Time Adjustment feature, allow an EMS to recommend a change to the start
       * time of the energy transfer that the ESA has previously suggested it would use.
       *
       * Washing machine example: A Washing Machine may have been set to start a wash cycle at 9pm when the
       * variable tariff normally reduces.
       *
       * However, the EMS is aware that a grid event has occurred, making it cheaper to run the cycle at a later
       * time, but the washing machine is not aware of this.
       *
       * The EMS first requests the Forecast data from each of its registered ESAs. It determines that the washing
       * machine has a power profile suggesting it will start the wash cycle at 9pm, but the EMS now knows that
       * the grid event means it will be cheaper to delay the start until 11pm.
       *
       * The EMS can then optimize the cost by asking the washing machine to delay starting the wash cycle until
       * 11pm.
       *
       * It does this by sending a StartTimeAdjustRequest to the washing machine to request delaying the start of
       * the washing cycle.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.2.4.4
       */
      startTimeAdjustment: (0, import_BitmapSchema.BitFlag)(3),
      /**
       * Pausable
       *
       * ESAs which support the Pausable feature, allow an EMS to recommend a pause in the middle of a
       *
       * forecast power profile that the ESA is currently using.
       *
       * Washing machine example: A Washing Machine is in operation, and starting its water heating step.
       *
       * However, the EMS becomes aware from the smart meter that the total home load on the grid is close to
       * exceeding its allowed total grid load.
       *
       * The EMS first requests the Forecast data from each of its registered ESAs. It determines that the washing
       * machine has a power profile suggesting its current step in the wash cycle is using power to heat the
       * water, but that this step can be paused.
       *
       * The EMS can then reduce the grid load by asking the washing machine to pause the wash cycle for a short
       * duration.
       *
       * It does this by sending a PauseRequest to the washing machine to request pausing the current step of the
       * forecast power usage for a period to allow other home loads to finish before resuming the washing cycle.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.2.4.5
       */
      pausable: (0, import_BitmapSchema.BitFlag)(4),
      /**
       * ForecastAdjustment
       *
       * ESAs which support the Forecast adjustment feature, allow an EMS to recommend a change to the start,
       * duration and/or power level limits of the steps of the power profile that the ESA has previously
       * suggested it would use.
       *
       * Heat pump and Solar PV example: A heat pump may have the ability to heat hot water as well as heating the
       * home. The heat pump scheduling system may have determined that the home will be unoccupied during the
       * day, or that the indoor temperature is above the set-point and so it knows that it will not need to heat
       * the home.
       *
       * However, the hot water tank is likely to need to be reheated before the homeowner comes home in the
       * evening. The heat pump is not aware that the property also has a solar PV inverter which is also an ESA
       * that is communicating with the EMS.
       *
       * The EMS first requests the Forecast data from each of its registered ESAs. It determines that the heat
       * pump has a power profile suggesting it needs to heat hot water around 6pm. The solar PV inverter has
       * forecast that it will generate 3.6kW of power during the middle of the day and into the afternoon before
       * the sun goes down.
       *
       * The EMS can then optimize the home considering other non-ESA loads and can ask the heat pump to heat the
       * hot water around 3pm when it has forecast that excess solar power will be available.
       *
       * It does this by sending a ModifyForecastRequest to the heat pump and asks the heat pump to expect to run
       * at a lower power consumption (within the solar excess power) which requires the heat pump to run for a
       * longer duration to achieve its required energy demand.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.2.4.6
       */
      forecastAdjustment: (0, import_BitmapSchema.BitFlag)(5),
      /**
       * ConstraintBasedAdjustment
       *
       * ESAs which support the Constraint-Based Adjustment feature allow an EMS to inform the ESA of periods
       * during which power usage should be modified (for example when the EMS has been made aware that the grid
       * supplier has requested reduced energy usage due to overall peak grid demand)
       *
       * and may cause the ESA to modify the intended power profile has previously suggested it would use.
       *
       * EVSE example: An EVSE scheduling system may have determined that the vehicle would be charged starting at
       * a moderate rate at 1am, so that it has enough charge by the time it is needed later that morning.
       *
       * However, the DSR service provider has informed the EMS that due to high forecast winds it is now forecast
       * that there will be very cheap energy available from wind generation between 2am and 3am.
       *
       * The EMS first requests the Forecast data from each of its registered ESAs. It determines that the EVSE
       * has a power profile suggesting it plans to start charging the vehicle at 1am.
       *
       * The EMS can then try to reduce the cost of charging the EV by informing the EVSE of the desire to
       * increase the charging between scheduled times.
       *
       * It does this by sending a RequestConstraintBasedForecast to the EVSE and asks it to run at a higher
       * NominalPower consumption during the constraint period, which may require it to decrease its charge rate
       * outside the constraint period to achieve its required energy demand.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.2.4.7
       */
      constraintBasedAdjustment: (0, import_BitmapSchema.BitFlag)(6)
    },
    attributes: {
      /**
       * Indicates the type of ESA.
       *
       * This attribute enables an EMS to understand some of the basic properties about how the energy may be
       * consumed, generated, and stored by the ESA.
       *
       * For example, the heat energy converted by a heat pump will naturally be lost through the building to the
       * outdoor environment relatively quickly, compared to storing heat in a well-insulated hot water tank.
       * Similarly, battery storage and EVs can store electrical energy for much longer durations.
       *
       * This attribute can also help the EMS display information to a user and to make basic assumptions about
       * typical best use of energy. For example, an EVSE may not always have an EV plugged in, so knowing the
       * type of ESA that is being controlled can allow advanced energy management strategies.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.2.8.1
       */
      esaType: (0, import_Cluster.FixedAttribute)(0, (0, import_TlvNumber.TlvEnum)(), { default: 255 /* Other */ }),
      /**
       * Indicates whether the ESA is classed as a generator or load. This allows an EMS to understand whether the
       * power values reported by the ESA need to have their sign inverted when dealing with forecasts and
       * adjustments.
       *
       * For example, a solar PV inverter (being a generator) may produce negative values to indicate generation
       * (since power is flowing out of the node into the home), however a display showing the power to the
       * consumers may need to present a positive solar production value to the consumer.
       *
       * For example, a home battery storage system (BESS) which needs to charge the battery and then discharge to
       * the home loads, would be classed as a generator. These types of devices shall have this field set to
       * true. When generating its forecast or advertising its PowerAdjustmentCapability, the power values shall
       * be negative to indicate discharging to the loads in the home, and positive to indicate when it is
       * charging its battery.
       *
       * GRID meter = Σ LoadPowers + Σ GeneratorPowers
       *
       * Example:
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.2.8.2
       */
      esaCanGenerate: (0, import_Cluster.FixedAttribute)(1, import_TlvBoolean.TlvBoolean, { default: false }),
      /**
       * Indicates the current state of the ESA.
       *
       * If the ESA is in the Offline or Fault state it cannot be controlled by an EMS, and may not be able to
       * report its Forecast information. An EMS may subscribe to the ESAState to get notified about changes in
       * operational state.
       *
       * The ESA may have a local user interface to allow a service technician to put the ESA into Offline mode,
       * for example to avoid the EMS accidentally starting or stopping the appliance when it is being serviced or
       * tested.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.2.8.3
       */
      esaState: (0, import_Cluster.Attribute)(2, (0, import_TlvNumber.TlvEnum)(), { default: 0 /* Offline */ }),
      /**
       * Indicates the minimum electrical power that the ESA can consume when switched on. This does not include
       * when in power save or standby modes.
       *
       * NOTE
       *
       * For Generator ESAs that can discharge an internal battery (such as a battery storage inverter) to loads
       * in the home, the AbsMinPower will be a negative number representing the maximum power that the ESA can
       * discharge its internal battery.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.2.8.4
       */
      absMinPower: (0, import_Cluster.Attribute)(3, import_TlvNumber.TlvInt64, { default: 0 }),
      /**
       * Indicates the maximum electrical power that the ESA can consume when switched on.
       *
       * Note that for Generator ESAs that can charge a battery by importing power into the node (such as a
       * battery storage inverter), the AbsMaxPower will be a positive number representing the maximum power at
       * which the ESA can charge its internal battery.
       *
       * For example, a battery storage inverter that can charge its battery at a maximum power of 2000W and can
       * discharge the battery at a maximum power of 3000W, would have a AbsMinPower: -3000, AbsMaxPower: 2000W.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.2.8.5
       */
      absMaxPower: (0, import_Cluster.Attribute)(4, import_TlvNumber.TlvInt64, { default: 0 })
    },
    /**
     * This metadata controls which DeviceEnergyManagementCluster elements matter.js activates for specific feature
     * combinations.
     */
    extensions: import_MutableCluster.MutableCluster.Extensions(
      { flags: { powerAdjustment: true }, component: DeviceEnergyManagement2.PowerAdjustmentComponent },
      {
        flags: { powerForecastReporting: true },
        component: DeviceEnergyManagement2.PowerForecastReportingOrStateForecastReportingComponent
      },
      {
        flags: { stateForecastReporting: true },
        component: DeviceEnergyManagement2.PowerForecastReportingOrStateForecastReportingComponent
      },
      {
        flags: { powerAdjustment: true },
        component: DeviceEnergyManagement2.PowerAdjustmentOrStartTimeAdjustmentOrPausableOrForecastAdjustmentOrConstraintBasedAdjustmentComponent
      },
      {
        flags: { startTimeAdjustment: true },
        component: DeviceEnergyManagement2.PowerAdjustmentOrStartTimeAdjustmentOrPausableOrForecastAdjustmentOrConstraintBasedAdjustmentComponent
      },
      {
        flags: { pausable: true },
        component: DeviceEnergyManagement2.PowerAdjustmentOrStartTimeAdjustmentOrPausableOrForecastAdjustmentOrConstraintBasedAdjustmentComponent
      },
      {
        flags: { forecastAdjustment: true },
        component: DeviceEnergyManagement2.PowerAdjustmentOrStartTimeAdjustmentOrPausableOrForecastAdjustmentOrConstraintBasedAdjustmentComponent
      },
      {
        flags: { constraintBasedAdjustment: true },
        component: DeviceEnergyManagement2.PowerAdjustmentOrStartTimeAdjustmentOrPausableOrForecastAdjustmentOrConstraintBasedAdjustmentComponent
      },
      { flags: { pausable: true }, component: DeviceEnergyManagement2.PausableComponent },
      { flags: { startTimeAdjustment: true }, component: DeviceEnergyManagement2.StartTimeAdjustmentComponent },
      { flags: { forecastAdjustment: true }, component: DeviceEnergyManagement2.ForecastAdjustmentComponent },
      { flags: { constraintBasedAdjustment: true }, component: DeviceEnergyManagement2.ConstraintBasedAdjustmentComponent },
      {
        flags: { startTimeAdjustment: true },
        component: DeviceEnergyManagement2.StartTimeAdjustmentOrForecastAdjustmentOrConstraintBasedAdjustmentComponent
      },
      {
        flags: { forecastAdjustment: true },
        component: DeviceEnergyManagement2.StartTimeAdjustmentOrForecastAdjustmentOrConstraintBasedAdjustmentComponent
      },
      {
        flags: { constraintBasedAdjustment: true },
        component: DeviceEnergyManagement2.StartTimeAdjustmentOrForecastAdjustmentOrConstraintBasedAdjustmentComponent
      },
      { flags: { staTrue: true, pauTrue: false, faTrue: false, conTrue: false }, component: false },
      { flags: { powerForecastReporting: true, stateForecastReporting: true }, component: false },
      { flags: { powerForecastReporting: false, stateForecastReporting: false }, component: false }
    )
  });
  DeviceEnergyManagement2.ClusterInstance = import_MutableCluster.MutableCluster.ExtensibleOnly(DeviceEnergyManagement2.Base);
  DeviceEnergyManagement2.Cluster = DeviceEnergyManagement2.ClusterInstance;
  const PA = { powerAdjustment: true };
  const PFR = { powerForecastReporting: true };
  const SFR = { stateForecastReporting: true };
  const STA = { startTimeAdjustment: true };
  const PAU = { pausable: true };
  const FA = { forecastAdjustment: true };
  const CON = { constraintBasedAdjustment: true };
  DeviceEnergyManagement2.CompleteInstance = (0, import_MutableCluster.MutableCluster)({
    id: DeviceEnergyManagement2.Base.id,
    name: DeviceEnergyManagement2.Base.name,
    revision: DeviceEnergyManagement2.Base.revision,
    features: DeviceEnergyManagement2.Base.features,
    attributes: {
      ...DeviceEnergyManagement2.Base.attributes,
      powerAdjustmentCapability: import_MutableCluster.MutableCluster.AsConditional(
        DeviceEnergyManagement2.PowerAdjustmentComponent.attributes.powerAdjustmentCapability,
        { mandatoryIf: [PA] }
      ),
      forecast: import_MutableCluster.MutableCluster.AsConditional(
        DeviceEnergyManagement2.PowerForecastReportingOrStateForecastReportingComponent.attributes.forecast,
        { mandatoryIf: [PFR, SFR] }
      ),
      optOutState: import_MutableCluster.MutableCluster.AsConditional(
        DeviceEnergyManagement2.PowerAdjustmentOrStartTimeAdjustmentOrPausableOrForecastAdjustmentOrConstraintBasedAdjustmentComponent.attributes.optOutState,
        { mandatoryIf: [PA, STA, PAU, FA, CON] }
      )
    },
    commands: {
      powerAdjustRequest: import_MutableCluster.MutableCluster.AsConditional(
        DeviceEnergyManagement2.PowerAdjustmentComponent.commands.powerAdjustRequest,
        { mandatoryIf: [PA] }
      ),
      cancelPowerAdjustRequest: import_MutableCluster.MutableCluster.AsConditional(
        DeviceEnergyManagement2.PowerAdjustmentComponent.commands.cancelPowerAdjustRequest,
        { mandatoryIf: [PA] }
      ),
      startTimeAdjustRequest: import_MutableCluster.MutableCluster.AsConditional(
        DeviceEnergyManagement2.StartTimeAdjustmentComponent.commands.startTimeAdjustRequest,
        { mandatoryIf: [STA] }
      ),
      pauseRequest: import_MutableCluster.MutableCluster.AsConditional(DeviceEnergyManagement2.PausableComponent.commands.pauseRequest, { mandatoryIf: [PAU] }),
      resumeRequest: import_MutableCluster.MutableCluster.AsConditional(
        DeviceEnergyManagement2.PausableComponent.commands.resumeRequest,
        { mandatoryIf: [PAU] }
      ),
      modifyForecastRequest: import_MutableCluster.MutableCluster.AsConditional(
        DeviceEnergyManagement2.ForecastAdjustmentComponent.commands.modifyForecastRequest,
        { mandatoryIf: [FA] }
      ),
      requestConstraintBasedForecast: import_MutableCluster.MutableCluster.AsConditional(
        DeviceEnergyManagement2.ConstraintBasedAdjustmentComponent.commands.requestConstraintBasedForecast,
        { mandatoryIf: [CON] }
      ),
      cancelRequest: import_MutableCluster.MutableCluster.AsConditional(
        DeviceEnergyManagement2.StartTimeAdjustmentOrForecastAdjustmentOrConstraintBasedAdjustmentComponent.commands.cancelRequest,
        { mandatoryIf: [STA, FA, CON] }
      )
    },
    events: {
      powerAdjustStart: import_MutableCluster.MutableCluster.AsConditional(
        DeviceEnergyManagement2.PowerAdjustmentComponent.events.powerAdjustStart,
        { mandatoryIf: [PA] }
      ),
      powerAdjustEnd: import_MutableCluster.MutableCluster.AsConditional(
        DeviceEnergyManagement2.PowerAdjustmentComponent.events.powerAdjustEnd,
        { mandatoryIf: [PA] }
      ),
      paused: import_MutableCluster.MutableCluster.AsConditional(DeviceEnergyManagement2.PausableComponent.events.paused, { mandatoryIf: [PAU] }),
      resumed: import_MutableCluster.MutableCluster.AsConditional(DeviceEnergyManagement2.PausableComponent.events.resumed, { mandatoryIf: [PAU] })
    }
  });
  DeviceEnergyManagement2.Complete = DeviceEnergyManagement2.CompleteInstance;
})(DeviceEnergyManagement || (DeviceEnergyManagement = {}));
const DeviceEnergyManagementCluster = DeviceEnergyManagement.Cluster;
import_ClusterRegistry.ClusterRegistry.register(DeviceEnergyManagement.Complete);
//# sourceMappingURL=device-energy-management.js.map
