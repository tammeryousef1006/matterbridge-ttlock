"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var diagnostic_logs_exports = {};
__export(diagnostic_logs_exports, {
  DiagnosticLogs: () => DiagnosticLogs,
  DiagnosticLogsCluster: () => DiagnosticLogsCluster
});
module.exports = __toCommonJS(diagnostic_logs_exports);
var import_MutableCluster = require("../cluster/mutation/MutableCluster.js");
var import_Cluster = require("../cluster/Cluster.js");
var import_TlvObject = require("../tlv/TlvObject.js");
var import_TlvNumber = require("../tlv/TlvNumber.js");
var import_TlvString = require("../tlv/TlvString.js");
var import_ClusterRegistry = require("../cluster/ClusterRegistry.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
var DiagnosticLogs;
((DiagnosticLogs2) => {
  let Intent;
  ((Intent2) => {
    Intent2[Intent2["EndUserSupport"] = 0] = "EndUserSupport";
    Intent2[Intent2["NetworkDiag"] = 1] = "NetworkDiag";
    Intent2[Intent2["CrashLogs"] = 2] = "CrashLogs";
  })(Intent = DiagnosticLogs2.Intent || (DiagnosticLogs2.Intent = {}));
  let TransferProtocol;
  ((TransferProtocol2) => {
    TransferProtocol2[TransferProtocol2["ResponsePayload"] = 0] = "ResponsePayload";
    TransferProtocol2[TransferProtocol2["Bdx"] = 1] = "Bdx";
  })(TransferProtocol = DiagnosticLogs2.TransferProtocol || (DiagnosticLogs2.TransferProtocol = {}));
  DiagnosticLogs2.TlvRetrieveLogsRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate why the diagnostic logs are being retrieved from the Node. A Node may utilize this
     * field to selectively determine the logs to transfer.
     *
     * @see {@link MatterSpecification.v14.Core} § 11.11.5.1.1
     */
    intent: (0, import_TlvObject.TlvField)(0, (0, import_TlvNumber.TlvEnum)()),
    /**
     * This field shall be used to indicate how the log transfer is to be realized. If the field is set to BDX, then
     * if the receiving Node supports BDX it shall attempt to use BDX to transfer any potential diagnostic logs; if
     * the receiving Node does not support BDX then the Node shall follow the requirements defined for a
     * TransferProtocolEnum of ResponsePayload. If this field is set to ResponsePayload the receiving Node shall
     * only utilize the LogContent field of the RetrieveLogsResponse command to transfer diagnostic log information.
     *
     * @see {@link MatterSpecification.v14.Core} § 11.11.5.1.2
     */
    requestedProtocol: (0, import_TlvObject.TlvField)(1, (0, import_TlvNumber.TlvEnum)()),
    /**
     * This field shall be present if the RequestedProtocol is BDX. The TransferFileDesignator shall be set as the
     * File Designator of the BDX transfer if initiated.
     *
     * Effect on Receipt
     *
     * On receipt of this command, the Node shall respond with a RetrieveLogsResponse command.
     *
     * If the RequestedProtocol is set to BDX the Node SHOULD immediately realize the RetrieveLogsResponse command
     * by initiating a BDX Transfer, sending a BDX SendInit message with the File Designator field of the message
     * set to the value of the TransferFileDesignator field of the RetrieveLogsRequest. On reception of a BDX
     * SendAccept message the Node shall send a RetrieveLogsResponse command with a Status field set to Success and
     * proceed with the log transfer over BDX. If a failure StatusReport is received in response to the SendInit
     * message, the Node shall send a RetrieveLogsResponse command with a Status of Denied. In the case where the
     * Node is able to fit the entirety of the requested logs within the LogContent field, the Status field of the
     * RetrieveLogsResponse shall be set to Exhausted and a BDX session shall NOT be initiated.
     *
     * If the RequestedProtocol is set to BDX and either the Node does not support BDX or it is not possible for the
     * Node to establish a BDX session, then the Node shall utilize the LogContent field of the RetrieveLogsResponse
     * command to transfer as much of the current logs as it can fit within the response, and the Status field of
     * the RetrieveLogsResponse shall be set to Exhausted.
     *
     * If the RequestedProtocol is set to ResponsePayload the Node shall utilize the LogContent field of the
     * RetrieveLogsResponse command to transfer as much of the current logs as it can fit within the response, and a
     * BDX session shall NOT be initiated.
     *
     * If the RequestedProtocol is set to BDX and there is no TransferFileDesignator the command shall fail with a
     * Status Code of INVALID_COMMAND.
     *
     * If the Intent and/or the RequestedProtocol arguments contain invalid (out of range) values the command shall
     * fail with a Status Code of INVALID_COMMAND.
     *
     * @see {@link MatterSpecification.v14.Core} § 11.11.5.1.3
     */
    transferFileDesignator: (0, import_TlvObject.TlvOptionalField)(2, import_TlvString.TlvString.bound({ maxLength: 32 }))
  });
  let Status;
  ((Status2) => {
    Status2[Status2["Success"] = 0] = "Success";
    Status2[Status2["Exhausted"] = 1] = "Exhausted";
    Status2[Status2["NoLogs"] = 2] = "NoLogs";
    Status2[Status2["Busy"] = 3] = "Busy";
    Status2[Status2["Denied"] = 4] = "Denied";
  })(Status = DiagnosticLogs2.Status || (DiagnosticLogs2.Status = {}));
  DiagnosticLogs2.TlvRetrieveLogsResponse = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the result of an attempt to retrieve diagnostic logs.
     *
     * @see {@link MatterSpecification.v14.Core} § 11.11.5.2.1
     */
    status: (0, import_TlvObject.TlvField)(0, (0, import_TlvNumber.TlvEnum)()),
    /**
     * This field shall be included in the command if the Status field has a value of Success or Exhausted. A Node
     * SHOULD utilize this field to transfer the newest diagnostic log entries. This field shall be empty if BDX is
     * requested and the Status field has a value of Success.
     *
     * @see {@link MatterSpecification.v14.Core} § 11.11.5.2.2
     */
    logContent: (0, import_TlvObject.TlvField)(1, import_TlvString.TlvByteString.bound({ maxLength: 1024 })),
    /**
     * This field SHOULD be included in the command if the Status field has a value of Success and the Node
     * maintains a wall clock. When included, the UTCTimeStamp field shall contain the value of the oldest log entry
     * in the diagnostic logs that are being transferred.
     *
     * @see {@link MatterSpecification.v14.Core} § 11.11.5.2.3
     */
    utcTimeStamp: (0, import_TlvObject.TlvOptionalField)(2, import_TlvNumber.TlvEpochUs),
    /**
     * This field SHOULD be included in the command if the Status field has a value of Success. When included, the
     * TimeSinceBoot field shall contain the time of the oldest log entry in the diagnostic logs that are being
     * transferred represented by the number of microseconds since the last time the Node went through a reboot.
     *
     * @see {@link MatterSpecification.v14.Core} § 11.11.5.2.4
     */
    timeSinceBoot: (0, import_TlvObject.TlvOptionalField)(3, import_TlvNumber.TlvSysTimeUs)
  });
  DiagnosticLogs2.ClusterInstance = (0, import_MutableCluster.MutableCluster)({
    id: 50,
    name: "DiagnosticLogs",
    revision: 1,
    commands: {
      /**
       * Reception of this command starts the process of retrieving diagnostic logs from a Node.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.11.5.1
       */
      retrieveLogsRequest: (0, import_Cluster.Command)(0, DiagnosticLogs2.TlvRetrieveLogsRequest, 1, DiagnosticLogs2.TlvRetrieveLogsResponse)
    }
  });
  DiagnosticLogs2.Cluster = DiagnosticLogs2.ClusterInstance;
  DiagnosticLogs2.Complete = DiagnosticLogs2.Cluster;
})(DiagnosticLogs || (DiagnosticLogs = {}));
const DiagnosticLogsCluster = DiagnosticLogs.Cluster;
import_ClusterRegistry.ClusterRegistry.register(DiagnosticLogs.Complete);
//# sourceMappingURL=diagnostic-logs.js.map
