"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var energy_preference_exports = {};
__export(energy_preference_exports, {
  EnergyPreference: () => EnergyPreference,
  EnergyPreferenceCluster: () => EnergyPreferenceCluster
});
module.exports = __toCommonJS(energy_preference_exports);
var import_MutableCluster = require("../cluster/mutation/MutableCluster.js");
var import_Cluster = require("../cluster/Cluster.js");
var import_TlvArray = require("../tlv/TlvArray.js");
var import_TlvObject = require("../tlv/TlvObject.js");
var import_TlvNumber = require("../tlv/TlvNumber.js");
var import_TlvString = require("../tlv/TlvString.js");
var import_BitmapSchema = require("../schema/BitmapSchema.js");
var import_ClusterRegistry = require("../cluster/ClusterRegistry.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
var EnergyPreference;
((EnergyPreference2) => {
  let Feature;
  ((Feature2) => {
    Feature2["EnergyBalance"] = "EnergyBalance";
    Feature2["LowPowerModeSensitivity"] = "LowPowerModeSensitivity";
  })(Feature = EnergyPreference2.Feature || (EnergyPreference2.Feature = {}));
  EnergyPreference2.TlvBalance = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the relative value of this step.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.7.5.2.1
     */
    step: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvPercent),
    /**
     * This field shall indicate an optional string explaining which actions a device might take at the given step
     * value.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.7.5.2.2
     */
    label: (0, import_TlvObject.TlvOptionalField)(1, import_TlvString.TlvString.bound({ maxLength: 64 }))
  });
  let EnergyPriority;
  ((EnergyPriority2) => {
    EnergyPriority2[EnergyPriority2["Comfort"] = 0] = "Comfort";
    EnergyPriority2[EnergyPriority2["Speed"] = 1] = "Speed";
    EnergyPriority2[EnergyPriority2["Efficiency"] = 2] = "Efficiency";
    EnergyPriority2[EnergyPriority2["WaterConsumption"] = 3] = "WaterConsumption";
  })(EnergyPriority = EnergyPreference2.EnergyPriority || (EnergyPreference2.EnergyPriority = {}));
  EnergyPreference2.EnergyBalanceComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * Indicates a list of BalanceStructs, each representing a step along a linear scale of relative priorities.
       * A Step field with a value of zero shall indicate that the device SHOULD entirely favor the priority
       * specified by the first element in EnergyPriorities; whereas a Step field with a value of 100 shall
       * indicate that the device SHOULD entirely favor the priority specified by the second element in
       * EnergyPriorities. The midpoint value of 50 shall indicate an even split between the two priorities.
       *
       * This shall contain at least two BalanceStructs.
       *
       * Each BalanceStruct shall have a Step field larger than the Step field on the previous BalanceStruct in
       * the list.
       *
       * The first BalanceStruct shall have a Step value of zero, and the last BalanceStruct shall have a Step
       * value of 100.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.7.6.1
       */
      energyBalances: (0, import_Cluster.FixedAttribute)(0, (0, import_TlvArray.TlvArray)(EnergyPreference2.TlvBalance, { minLength: 2, maxLength: 10 })),
      /**
       * Indicates the current preference of the user for balancing different priorities during device use. The
       * value of this attribute is the index, 0-based, into the EnergyBalances attribute for the currently
       * selected balance.
       *
       * If an attempt is made to set this attribute to an index outside the maximum index for EnergyBalances, a
       * response with the status code CONSTRAINT_ERROR shall be returned.
       *
       * If the value of EnergyBalances changes after an update, the device shall migrate the value of the
       * CurrentEnergyBalance attribute to the index which the manufacturer specifies most closely matches the
       * previous value, while preserving extreme preferences as follows:
       *
       *   1. If the previous value of CurrentEnergyBalance was zero, indicating a total preference for the
       *      priority specified by the first element in EnergyPriorities, the new value of CurrentEnergyBalance
       *      shall also be zero.
       *
       *   2. If the previous value of CurrentEnergyBalance was the index of the last BalanceStruct in the
       *      previous value of EnergyBalances, indicating a total preference for the priority specified by the
       *      last element in EnergyPriorities, the new value of CurrentEnergyBalance shall be the index of the
       *      last element in the updated value of EnergyBalances.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.7.6.2
       */
      currentEnergyBalance: (0, import_Cluster.WritableAttribute)(1, import_TlvNumber.TlvUInt8, { persistent: true }),
      /**
       * Indicates two extremes for interpreting the values in the EnergyBalances attribute. These two priorities
       * shall be in opposition to each other; e.g. Comfort vs. Efficiency or Speed vs. WaterConsumption.
       *
       * If the value of EnergyPriorities changes after an update to represent a new balance between priorities,
       * the value of the CurrentEnergyBalance attribute shall be set to its default.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.7.6.3
       */
      energyPriorities: (0, import_Cluster.FixedAttribute)(2, (0, import_TlvArray.TlvArray)((0, import_TlvNumber.TlvEnum)(), { length: 2 }))
    }
  });
  EnergyPreference2.LowPowerModeSensitivityComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * Indicates a list of BalanceStructs, each representing a condition or set of conditions for the device to
       * enter a low power mode. This shall contain at least two BalanceStructs.
       *
       * Each BalanceStruct shall have a Step field larger than the Step field on the previous BalanceStruct in
       * the list.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.7.6.4
       */
      lowPowerModeSensitivities: (0, import_Cluster.FixedAttribute)(3, (0, import_TlvArray.TlvArray)(EnergyPreference2.TlvBalance, { minLength: 2, maxLength: 10 })),
      /**
       * Indicates the current preference of the user for determining when the device should enter a low power
       * mode. The value of this attribute is the index, 0-based, into the LowPowerModeSensitivities attribute for
       * the currently selected preference.
       *
       * If an attempt is made to set this attribute to an index outside the maximum index for
       * LowPowerModeSensitivities, a response with the status code CONSTRAINT_ERROR shall be returned.
       *
       * If the value of LowPowerModeSensitivities changes after an update, the device shall migrate the value of
       * the LowPowerModeSensitivity attribute to the index which the manufacturer specifies most closely matches
       * the previous value.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.7.6.5
       */
      currentLowPowerModeSensitivity: (0, import_Cluster.WritableAttribute)(4, import_TlvNumber.TlvUInt8, { persistent: true })
    }
  });
  EnergyPreference2.Base = import_MutableCluster.MutableCluster.Component({
    id: 155,
    name: "EnergyPreference",
    revision: 1,
    features: {
      /**
       * EnergyBalance
       *
       * This feature allows a user to select from a list of energy balances with associated descriptions of which
       * strategies a device will use to target the specified balance.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.7.4.1
       */
      energyBalance: (0, import_BitmapSchema.BitFlag)(0),
      /**
       * LowPowerModeSensitivity
       *
       * This feature allows the user to select a condition or set of conditions which will cause the device to
       * switch to a mode using less power. For example, a device might provide a scale of durations that must
       * elapse without user interaction before it goes to sleep.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.7.4.2
       */
      lowPowerModeSensitivity: (0, import_BitmapSchema.BitFlag)(1)
    },
    /**
     * This metadata controls which EnergyPreferenceCluster elements matter.js activates for specific feature
     * combinations.
     */
    extensions: import_MutableCluster.MutableCluster.Extensions(
      { flags: { energyBalance: true }, component: EnergyPreference2.EnergyBalanceComponent },
      { flags: { lowPowerModeSensitivity: true }, component: EnergyPreference2.LowPowerModeSensitivityComponent },
      { flags: { energyBalance: false, lowPowerModeSensitivity: false }, component: false }
    )
  });
  EnergyPreference2.ClusterInstance = import_MutableCluster.MutableCluster.ExtensibleOnly(EnergyPreference2.Base);
  EnergyPreference2.Cluster = EnergyPreference2.ClusterInstance;
  const BALA = { energyBalance: true };
  const LPMS = { lowPowerModeSensitivity: true };
  EnergyPreference2.CompleteInstance = (0, import_MutableCluster.MutableCluster)({
    id: EnergyPreference2.Base.id,
    name: EnergyPreference2.Base.name,
    revision: EnergyPreference2.Base.revision,
    features: EnergyPreference2.Base.features,
    attributes: {
      energyBalances: import_MutableCluster.MutableCluster.AsConditional(
        EnergyPreference2.EnergyBalanceComponent.attributes.energyBalances,
        { mandatoryIf: [BALA] }
      ),
      currentEnergyBalance: import_MutableCluster.MutableCluster.AsConditional(
        EnergyPreference2.EnergyBalanceComponent.attributes.currentEnergyBalance,
        { mandatoryIf: [BALA] }
      ),
      energyPriorities: import_MutableCluster.MutableCluster.AsConditional(
        EnergyPreference2.EnergyBalanceComponent.attributes.energyPriorities,
        { mandatoryIf: [BALA] }
      ),
      lowPowerModeSensitivities: import_MutableCluster.MutableCluster.AsConditional(
        EnergyPreference2.LowPowerModeSensitivityComponent.attributes.lowPowerModeSensitivities,
        { mandatoryIf: [LPMS] }
      ),
      currentLowPowerModeSensitivity: import_MutableCluster.MutableCluster.AsConditional(
        EnergyPreference2.LowPowerModeSensitivityComponent.attributes.currentLowPowerModeSensitivity,
        { mandatoryIf: [LPMS] }
      )
    }
  });
  EnergyPreference2.Complete = EnergyPreference2.CompleteInstance;
})(EnergyPreference || (EnergyPreference = {}));
const EnergyPreferenceCluster = EnergyPreference.Cluster;
import_ClusterRegistry.ClusterRegistry.register(EnergyPreference.Complete);
//# sourceMappingURL=energy-preference.js.map
