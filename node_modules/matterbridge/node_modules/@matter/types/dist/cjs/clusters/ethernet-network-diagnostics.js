"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ethernet_network_diagnostics_exports = {};
__export(ethernet_network_diagnostics_exports, {
  EthernetNetworkDiagnostics: () => EthernetNetworkDiagnostics,
  EthernetNetworkDiagnosticsCluster: () => EthernetNetworkDiagnosticsCluster
});
module.exports = __toCommonJS(ethernet_network_diagnostics_exports);
var import_MutableCluster = require("../cluster/mutation/MutableCluster.js");
var import_Cluster = require("../cluster/Cluster.js");
var import_TlvNumber = require("../tlv/TlvNumber.js");
var import_TlvNoArguments = require("../tlv/TlvNoArguments.js");
var import_model = require("#model");
var import_BitmapSchema = require("../schema/BitmapSchema.js");
var import_TlvNullable = require("../tlv/TlvNullable.js");
var import_TlvBoolean = require("../tlv/TlvBoolean.js");
var import_ClusterRegistry = require("../cluster/ClusterRegistry.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
var EthernetNetworkDiagnostics;
((EthernetNetworkDiagnostics2) => {
  let Feature;
  ((Feature2) => {
    Feature2["PacketCounts"] = "PacketCounts";
    Feature2["ErrorCounts"] = "ErrorCounts";
  })(Feature = EthernetNetworkDiagnostics2.Feature || (EthernetNetworkDiagnostics2.Feature = {}));
  let PhyRate;
  ((PhyRate2) => {
    PhyRate2[PhyRate2["Rate10M"] = 0] = "Rate10M";
    PhyRate2[PhyRate2["Rate100M"] = 1] = "Rate100M";
    PhyRate2[PhyRate2["Rate1G"] = 2] = "Rate1G";
    PhyRate2[PhyRate2["Rate25G"] = 3] = "Rate25G";
    PhyRate2[PhyRate2["Rate5G"] = 4] = "Rate5G";
    PhyRate2[PhyRate2["Rate10G"] = 5] = "Rate10G";
    PhyRate2[PhyRate2["Rate40G"] = 6] = "Rate40G";
    PhyRate2[PhyRate2["Rate100G"] = 7] = "Rate100G";
    PhyRate2[PhyRate2["Rate200G"] = 8] = "Rate200G";
    PhyRate2[PhyRate2["Rate400G"] = 9] = "Rate400G";
  })(PhyRate = EthernetNetworkDiagnostics2.PhyRate || (EthernetNetworkDiagnostics2.PhyRate = {}));
  EthernetNetworkDiagnostics2.PacketCountsComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * The PacketRxCount attribute shall indicate the number of packets that have been received on the ethernet
       * network interface. The PacketRxCount attribute shall be reset to 0 upon a reboot of the Node.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.16.6.3
       */
      packetRxCount: (0, import_Cluster.Attribute)(2, import_TlvNumber.TlvUInt64, { omitChanges: true, default: 0 }),
      /**
       * The PacketTxCount attribute shall indicate the number of packets that have been successfully transferred
       * on the ethernet network interface. The PacketTxCount attribute shall be reset to 0 upon a reboot of the
       * Node.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.16.6.4
       */
      packetTxCount: (0, import_Cluster.Attribute)(3, import_TlvNumber.TlvUInt64, { omitChanges: true, default: 0 })
    }
  });
  EthernetNetworkDiagnostics2.ErrorCountsComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * The TxErrCount attribute shall indicate the number of failed packet transmissions that have occurred on
       * the ethernet network interface. The TxErrCount attribute shall be reset to 0 upon a reboot of the Node.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.16.6.5
       */
      txErrCount: (0, import_Cluster.Attribute)(4, import_TlvNumber.TlvUInt64, { omitChanges: true, default: 0 }),
      /**
       * The CollisionCount attribute shall indicate the number of collisions that have occurred while attempting
       * to transmit a packet on the ethernet network interface. The CollisionCount attribute shall be reset to 0
       * upon a reboot of the Node.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.16.6.6
       */
      collisionCount: (0, import_Cluster.Attribute)(5, import_TlvNumber.TlvUInt64, { omitChanges: true, default: 0 }),
      /**
       * The OverrunCount attribute shall indicate the number of packets dropped either at ingress or egress, due
       * to lack of buffer memory to retain all packets on the ethernet network interface. The OverrunCount
       * attribute shall be reset to 0 upon a reboot of the Node.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.16.6.7
       */
      overrunCount: (0, import_Cluster.Attribute)(6, import_TlvNumber.TlvUInt64, { omitChanges: true, default: 0 })
    }
  });
  EthernetNetworkDiagnostics2.PacketCountsOrErrorCountsComponent = import_MutableCluster.MutableCluster.Component({
    commands: {
      /**
       * Reception of this command shall reset the following attributes to 0:
       *
       *   • PacketRxCount
       *
       *   • PacketTxCount
       *
       *   • TxErrCount
       *
       *   • CollisionCount
       *
       *   • OverrunCount
       *
       * This command has no associated data.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.16.7.1
       */
      resetCounts: (0, import_Cluster.Command)(0, import_TlvNoArguments.TlvNoArguments, 0, import_Cluster.TlvNoResponse, { invokeAcl: import_model.AccessLevel.Manage })
    }
  });
  EthernetNetworkDiagnostics2.Base = import_MutableCluster.MutableCluster.Component({
    id: 55,
    name: "EthernetNetworkDiagnostics",
    revision: 1,
    features: {
      /**
       * PacketCounts
       *
       * Node makes available the counts for the number of received and transmitted packets on the ethernet
       * interface.
       */
      packetCounts: (0, import_BitmapSchema.BitFlag)(0),
      /**
       * ErrorCounts
       *
       * Node makes available the counts for the number of errors that have occurred during the reception and
       * transmission of packets on the ethernet interface.
       */
      errorCounts: (0, import_BitmapSchema.BitFlag)(1)
    },
    attributes: {
      /**
       * The PHYRate attribute shall indicate the current nominal, usable speed at the top of the physical layer
       * of the Node. A value of null shall indicate that the interface is not currently configured or
       * operational.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.16.6.1
       */
      phyRate: (0, import_Cluster.OptionalAttribute)(0, (0, import_TlvNullable.TlvNullable)((0, import_TlvNumber.TlvEnum)()), { default: null }),
      /**
       * The FullDuplex attribute shall indicate if the Node is currently utilizing the full-duplex operating
       * mode. A value of null shall indicate that the interface is not currently configured or operational.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.16.6.2
       */
      fullDuplex: (0, import_Cluster.OptionalAttribute)(1, (0, import_TlvNullable.TlvNullable)(import_TlvBoolean.TlvBoolean), { default: null }),
      /**
       * The CarrierDetect attribute shall indicate the value of the Carrier Detect control signal present on the
       * ethernet network interface. A value of null shall indicate that the interface is not currently configured
       * or operational.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.16.6.8
       */
      carrierDetect: (0, import_Cluster.OptionalAttribute)(7, (0, import_TlvNullable.TlvNullable)(import_TlvBoolean.TlvBoolean), { omitChanges: true, default: null }),
      /**
       * The TimeSinceReset attribute shall indicate the duration of time, in minutes, that it has been since the
       * ethernet network interface has reset for any reason.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.16.6.9
       */
      timeSinceReset: (0, import_Cluster.OptionalAttribute)(8, import_TlvNumber.TlvUInt64, { omitChanges: true, default: 0 })
    },
    /**
     * This metadata controls which EthernetNetworkDiagnosticsCluster elements matter.js activates for specific
     * feature combinations.
     */
    extensions: import_MutableCluster.MutableCluster.Extensions(
      { flags: { packetCounts: true }, component: EthernetNetworkDiagnostics2.PacketCountsComponent },
      { flags: { errorCounts: true }, component: EthernetNetworkDiagnostics2.ErrorCountsComponent },
      { flags: { packetCounts: true }, component: EthernetNetworkDiagnostics2.PacketCountsOrErrorCountsComponent },
      { flags: { errorCounts: true }, component: EthernetNetworkDiagnostics2.PacketCountsOrErrorCountsComponent }
    )
  });
  EthernetNetworkDiagnostics2.ClusterInstance = (0, import_MutableCluster.MutableCluster)(EthernetNetworkDiagnostics2.Base);
  EthernetNetworkDiagnostics2.Cluster = EthernetNetworkDiagnostics2.ClusterInstance;
  const PKTCNT = { packetCounts: true };
  const ERRCNT = { errorCounts: true };
  EthernetNetworkDiagnostics2.CompleteInstance = (0, import_MutableCluster.MutableCluster)({
    id: EthernetNetworkDiagnostics2.Cluster.id,
    name: EthernetNetworkDiagnostics2.Cluster.name,
    revision: EthernetNetworkDiagnostics2.Cluster.revision,
    features: EthernetNetworkDiagnostics2.Cluster.features,
    attributes: {
      ...EthernetNetworkDiagnostics2.Cluster.attributes,
      packetRxCount: import_MutableCluster.MutableCluster.AsConditional(
        EthernetNetworkDiagnostics2.PacketCountsComponent.attributes.packetRxCount,
        { mandatoryIf: [PKTCNT] }
      ),
      packetTxCount: import_MutableCluster.MutableCluster.AsConditional(
        EthernetNetworkDiagnostics2.PacketCountsComponent.attributes.packetTxCount,
        { mandatoryIf: [PKTCNT] }
      ),
      txErrCount: import_MutableCluster.MutableCluster.AsConditional(
        EthernetNetworkDiagnostics2.ErrorCountsComponent.attributes.txErrCount,
        { mandatoryIf: [ERRCNT] }
      ),
      collisionCount: import_MutableCluster.MutableCluster.AsConditional(
        EthernetNetworkDiagnostics2.ErrorCountsComponent.attributes.collisionCount,
        { mandatoryIf: [ERRCNT] }
      ),
      overrunCount: import_MutableCluster.MutableCluster.AsConditional(
        EthernetNetworkDiagnostics2.ErrorCountsComponent.attributes.overrunCount,
        { mandatoryIf: [ERRCNT] }
      )
    },
    commands: {
      resetCounts: import_MutableCluster.MutableCluster.AsConditional(
        EthernetNetworkDiagnostics2.PacketCountsOrErrorCountsComponent.commands.resetCounts,
        { mandatoryIf: [PKTCNT, ERRCNT] }
      )
    }
  });
  EthernetNetworkDiagnostics2.Complete = EthernetNetworkDiagnostics2.CompleteInstance;
})(EthernetNetworkDiagnostics || (EthernetNetworkDiagnostics = {}));
const EthernetNetworkDiagnosticsCluster = EthernetNetworkDiagnostics.Cluster;
import_ClusterRegistry.ClusterRegistry.register(EthernetNetworkDiagnostics.Complete);
//# sourceMappingURL=ethernet-network-diagnostics.js.map
