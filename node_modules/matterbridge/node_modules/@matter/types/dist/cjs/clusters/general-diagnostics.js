"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var general_diagnostics_exports = {};
__export(general_diagnostics_exports, {
  GeneralDiagnostics: () => GeneralDiagnostics,
  GeneralDiagnosticsCluster: () => GeneralDiagnosticsCluster
});
module.exports = __toCommonJS(general_diagnostics_exports);
var import_MutableCluster = require("../cluster/mutation/MutableCluster.js");
var import_Cluster = require("../cluster/Cluster.js");
var import_TlvObject = require("../tlv/TlvObject.js");
var import_TlvString = require("../tlv/TlvString.js");
var import_TlvNumber = require("../tlv/TlvNumber.js");
var import_model = require("#model");
var import_BitmapSchema = require("../schema/BitmapSchema.js");
var import_TlvArray = require("../tlv/TlvArray.js");
var import_TlvBoolean = require("../tlv/TlvBoolean.js");
var import_TlvNullable = require("../tlv/TlvNullable.js");
var import_TlvNoArguments = require("../tlv/TlvNoArguments.js");
var import_ClusterRegistry = require("../cluster/ClusterRegistry.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
var GeneralDiagnostics;
((GeneralDiagnostics2) => {
  let Feature;
  ((Feature2) => {
    Feature2["DataModelTest"] = "DataModelTest";
  })(Feature = GeneralDiagnostics2.Feature || (GeneralDiagnostics2.Feature = {}));
  GeneralDiagnostics2.TlvPayloadTestRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall have the same meaning and usage as the TestEventTrigger EnableKey field.
     *
     * @see {@link MatterSpecification.v14.Core} § 11.12.7.4.1
     */
    enableKey: (0, import_TlvObject.TlvField)(0, import_TlvString.TlvByteString.bound({ length: 16 })),
    /**
     * This field shall indicate the value to use in every byte of the PayloadTestResponse’s Payload field.
     *
     * @see {@link MatterSpecification.v14.Core} § 11.12.7.4.2
     */
    value: (0, import_TlvObject.TlvField)(1, import_TlvNumber.TlvUInt8),
    /**
     * This field shall indicate the number of times to repeat the Value in the PayloadTestResponse’s Payload field.
     *
     * Effect upon receipt
     *
     * This command shall respond with a response status of CONSTRAINT_ERROR if either:
     *
     *   • The EnableKey field does not match the a-priori value configured on the device.
     *
     *   • The TestEventTriggersEnabled field is currently false.
     *
     * Otherwise, the server shall respond with a PayloadTestResponse command with a Payload field value containing
     * Count instances of the Value byte. If the response is too large to send, the server shall fail the command
     * and respond with a response status of RESOURCE_EXHAUSTED.
     *
     * For example:
     *
     *   • If Value is 0x55 and the Count is zero, then the PayloadTestResponse would have the Payload field set to
     *     an empty octet string.
     *
     *   • If Value is 0xA5 and the Count is 10, the PayloadTestResponse would have the Payload field set
     *
     * to a content whose hexadecimal representation would be A5A5A5A5A5A5A5A5A5A5, and base64 representation would
     * be paWlpaWlpaWlpQ==.
     *
     * @see {@link MatterSpecification.v14.Core} § 11.12.7.4.3
     */
    count: (0, import_TlvObject.TlvField)(2, import_TlvNumber.TlvUInt16.bound({ max: 2048 }))
  });
  GeneralDiagnostics2.TlvPayloadTestResponse = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall contain the computed response of the PayloadTestRequest command.
     *
     * @see {@link MatterSpecification.v14.Core} § 11.12.7.5.1
     */
    payload: (0, import_TlvObject.TlvField)(0, import_TlvString.TlvByteString.bound({ maxLength: 2048 }))
  });
  let InterfaceType;
  ((InterfaceType2) => {
    InterfaceType2[InterfaceType2["Unspecified"] = 0] = "Unspecified";
    InterfaceType2[InterfaceType2["WiFi"] = 1] = "WiFi";
    InterfaceType2[InterfaceType2["Ethernet"] = 2] = "Ethernet";
    InterfaceType2[InterfaceType2["Cellular"] = 3] = "Cellular";
    InterfaceType2[InterfaceType2["Thread"] = 4] = "Thread";
  })(InterfaceType = GeneralDiagnostics2.InterfaceType || (GeneralDiagnostics2.InterfaceType = {}));
  GeneralDiagnostics2.TlvNetworkInterface = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate a human-readable (displayable) name for the network interface, that is different
     * from all other interfaces.
     *
     * @see {@link MatterSpecification.v14.Core} § 11.12.5.6.1
     */
    name: (0, import_TlvObject.TlvField)(0, import_TlvString.TlvString.bound({ maxLength: 32 })),
    /**
     * This field shall indicate if the Node is currently advertising itself operationally on this network interface
     * and is capable of successfully receiving incoming traffic from other Nodes.
     *
     * @see {@link MatterSpecification.v14.Core} § 11.12.5.6.2
     */
    isOperational: (0, import_TlvObject.TlvField)(1, import_TlvBoolean.TlvBoolean),
    /**
     * This field shall indicate whether the Node is currently able to reach off-premise services it uses by
     * utilizing IPv4. The value shall be null if the Node does not use such services or does not know whether it
     * can reach them.
     *
     * @see {@link MatterSpecification.v14.Core} § 11.12.5.6.3
     */
    offPremiseServicesReachableIPv4: (0, import_TlvObject.TlvField)(2, (0, import_TlvNullable.TlvNullable)(import_TlvBoolean.TlvBoolean)),
    /**
     * This field shall indicate whether the Node is currently able to reach off-premise services it uses by
     * utilizing IPv6. The value shall be null if the Node does not use such services or does not know whether it
     * can reach them.
     *
     * @see {@link MatterSpecification.v14.Core} § 11.12.5.6.4
     */
    offPremiseServicesReachableIPv6: (0, import_TlvObject.TlvField)(3, (0, import_TlvNullable.TlvNullable)(import_TlvBoolean.TlvBoolean)),
    /**
     * This field shall contain the current link-layer address for a 802.3 or IEEE 802.11-2020 network
     *
     * interface and contain the current extended MAC address for a 802.15.4 interface. The byte order of the octstr
     * shall be in wire byte order. For addresses values less than 64 bits, the first two bytes shall be zero.
     *
     * @see {@link MatterSpecification.v14.Core} § 11.12.5.6.5
     */
    hardwareAddress: (0, import_TlvObject.TlvField)(4, import_TlvString.TlvByteString),
    /**
     * This field shall provide a list of the IPv4 addresses that are currently assigned to the network interface.
     *
     * @see {@link MatterSpecification.v14.Core} § 11.12.5.6.6
     */
    iPv4Addresses: (0, import_TlvObject.TlvField)(5, (0, import_TlvArray.TlvArray)(import_TlvString.TlvByteString, { maxLength: 4 })),
    /**
     * This field shall provide a list of the unicast IPv6 addresses that are currently assigned to the network
     * interface. This list shall include the Node’s link-local address and SHOULD include any assigned GUA and ULA
     * addresses. This list shall NOT include any multicast group addresses to which the Node is subscribed.
     *
     * @see {@link MatterSpecification.v14.Core} § 11.12.5.6.7
     */
    iPv6Addresses: (0, import_TlvObject.TlvField)(6, (0, import_TlvArray.TlvArray)(import_TlvString.TlvByteString, { maxLength: 8 })),
    /**
     * This field shall indicate the type of the interface using the InterfaceTypeEnum.
     *
     * @see {@link MatterSpecification.v14.Core} § 11.12.5.6.8
     */
    type: (0, import_TlvObject.TlvField)(7, (0, import_TlvNumber.TlvEnum)())
  });
  let BootReason;
  ((BootReason2) => {
    BootReason2[BootReason2["Unspecified"] = 0] = "Unspecified";
    BootReason2[BootReason2["PowerOnReboot"] = 1] = "PowerOnReboot";
    BootReason2[BootReason2["BrownOutReset"] = 2] = "BrownOutReset";
    BootReason2[BootReason2["SoftwareWatchdogReset"] = 3] = "SoftwareWatchdogReset";
    BootReason2[BootReason2["HardwareWatchdogReset"] = 4] = "HardwareWatchdogReset";
    BootReason2[BootReason2["SoftwareUpdateCompleted"] = 5] = "SoftwareUpdateCompleted";
    BootReason2[BootReason2["SoftwareReset"] = 6] = "SoftwareReset";
  })(BootReason = GeneralDiagnostics2.BootReason || (GeneralDiagnostics2.BootReason = {}));
  let HardwareFault;
  ((HardwareFault2) => {
    HardwareFault2[HardwareFault2["Unspecified"] = 0] = "Unspecified";
    HardwareFault2[HardwareFault2["Radio"] = 1] = "Radio";
    HardwareFault2[HardwareFault2["Sensor"] = 2] = "Sensor";
    HardwareFault2[HardwareFault2["ResettableOverTemp"] = 3] = "ResettableOverTemp";
    HardwareFault2[HardwareFault2["NonResettableOverTemp"] = 4] = "NonResettableOverTemp";
    HardwareFault2[HardwareFault2["PowerSource"] = 5] = "PowerSource";
    HardwareFault2[HardwareFault2["VisualDisplayFault"] = 6] = "VisualDisplayFault";
    HardwareFault2[HardwareFault2["AudioOutputFault"] = 7] = "AudioOutputFault";
    HardwareFault2[HardwareFault2["UserInterfaceFault"] = 8] = "UserInterfaceFault";
    HardwareFault2[HardwareFault2["NonVolatileMemoryError"] = 9] = "NonVolatileMemoryError";
    HardwareFault2[HardwareFault2["TamperDetected"] = 10] = "TamperDetected";
  })(HardwareFault = GeneralDiagnostics2.HardwareFault || (GeneralDiagnostics2.HardwareFault = {}));
  let RadioFault;
  ((RadioFault2) => {
    RadioFault2[RadioFault2["Unspecified"] = 0] = "Unspecified";
    RadioFault2[RadioFault2["WiFiFault"] = 1] = "WiFiFault";
    RadioFault2[RadioFault2["CellularFault"] = 2] = "CellularFault";
    RadioFault2[RadioFault2["ThreadFault"] = 3] = "ThreadFault";
    RadioFault2[RadioFault2["NfcFault"] = 4] = "NfcFault";
    RadioFault2[RadioFault2["BleFault"] = 5] = "BleFault";
    RadioFault2[RadioFault2["EthernetFault"] = 6] = "EthernetFault";
  })(RadioFault = GeneralDiagnostics2.RadioFault || (GeneralDiagnostics2.RadioFault = {}));
  let NetworkFault;
  ((NetworkFault2) => {
    NetworkFault2[NetworkFault2["Unspecified"] = 0] = "Unspecified";
    NetworkFault2[NetworkFault2["HardwareFailure"] = 1] = "HardwareFailure";
    NetworkFault2[NetworkFault2["NetworkJammed"] = 2] = "NetworkJammed";
    NetworkFault2[NetworkFault2["ConnectionFailed"] = 3] = "ConnectionFailed";
  })(NetworkFault = GeneralDiagnostics2.NetworkFault || (GeneralDiagnostics2.NetworkFault = {}));
  GeneralDiagnostics2.TlvTestEventTriggerRequest = (0, import_TlvObject.TlvObject)({
    /**
     * The EnableKey is a 128 bit value provided by the client in this command, which needs to match a value chosen
     * by the manufacturer and configured on the server using manufacturer-specific means, such as pre-provisioning.
     * The value of all zeroes is reserved to indicate that no EnableKey is set. Therefore, if the EnableKey field
     * is received with all zeroes, this command shall FAIL with a response status of CONSTRAINT_ERROR.
     *
     * The EnableKey SHOULD be unique per exact set of devices going to a certification test.
     *
     * Devices not targeted towards going to a certification test event shall NOT have a non-zero EnableKey value
     * configured, so that only devices in test environments are responsive to this command.
     *
     * In order to prevent unwittingly actuating a particular trigger, this command shall respond with a response
     * status of CONSTRAINT_ERROR if the EnableKey field does not match the a-priori value configured on the device.
     *
     * @see {@link MatterSpecification.v14.Core} § 11.12.7.1.1
     */
    enableKey: (0, import_TlvObject.TlvField)(0, import_TlvString.TlvByteString.bound({ length: 16 })),
    /**
     * This field shall indicate the test or test mode which the client wants to trigger.
     *
     * The expected side-effects of EventTrigger values are out of scope of this specification and will be described
     * within appropriate certification test literature provided to manufacturers by the Connectivity Standards
     * Alliance, in conjunction with certification test cases documentation.
     *
     * Values of EventTrigger in the range 0xFFFF_FFFF_0000_0000 through 0xFFFF_FFFF_FFFF_FFFF are reserved for
     * testing use by manufacturers and will not appear in CSA certification test literature.
     *
     * If the value of EventTrigger received is not supported by the receiving Node, this command shall
     *
     * fail with a status code of INVALID_COMMAND.
     *
     * Otherwise, if the EnableKey value matches the configured internal value for a particular Node, and the
     * EventTrigger value matches a supported test event trigger value, the command shall succeed and execute the
     * expected trigger action.
     *
     * If no specific test event triggers are required to be supported by certification test requirements for the
     * features that a given product will be certified against, this command may always fail with the
     * INVALID_COMMAND status, equivalent to the situation of receiving an unknown EventTrigger, for all possible
     * EventTrigger values.
     *
     * @see {@link MatterSpecification.v14.Core} § 11.12.7.1.2
     */
    eventTrigger: (0, import_TlvObject.TlvField)(1, import_TlvNumber.TlvUInt64)
  });
  GeneralDiagnostics2.TlvTimeSnapshotResponse = (0, import_TlvObject.TlvObject)({
    /**
     * This shall indicate the current System Time in milliseconds (type system-ms), with the value taken at the
     * time of processing of the TimeSnapshot command that generated this response.
     *
     * The value shall be taken from the same clock which populates the Timestamp field in events when using System
     * Time for the field.
     *
     * @see {@link MatterSpecification.v14.Core} § 11.12.7.3.1
     */
    systemTimeMs: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvSysTimeMS),
    /**
     * This shall indicate the current time in POSIX Time in milliseconds, with the value taken from the same source
     * that could populate the Timestamp field of events. This value shall only be null when any the following are
     * true:
     *
     *   • The node doesn’t support the Time Synchronization cluster.
     *
     *   • The node’s Time Synchronization cluster instance’s UTCTime attribute is null.
     *
     * @see {@link MatterSpecification.v14.Core} § 11.12.7.3.2
     */
    posixTimeMs: (0, import_TlvObject.TlvField)(1, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvPosixMs))
  });
  GeneralDiagnostics2.TlvHardwareFaultChangeEvent = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall represent the set of faults currently detected, as per HardwareFaultEnum.
     *
     * @see {@link MatterSpecification.v14.Core} § 11.12.8.1.1
     */
    current: (0, import_TlvObject.TlvField)(0, (0, import_TlvArray.TlvArray)((0, import_TlvNumber.TlvEnum)(), { maxLength: 11 })),
    /**
     * This field shall represent the set of faults detected prior to this change event, as per HardwareFaultEnum.
     *
     * @see {@link MatterSpecification.v14.Core} § 11.12.8.1.2
     */
    previous: (0, import_TlvObject.TlvField)(1, (0, import_TlvArray.TlvArray)((0, import_TlvNumber.TlvEnum)(), { maxLength: 11 }))
  });
  GeneralDiagnostics2.TlvRadioFaultChangeEvent = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall represent the set of faults currently detected, as per RadioFaultEnum.
     *
     * @see {@link MatterSpecification.v14.Core} § 11.12.8.2.1
     */
    current: (0, import_TlvObject.TlvField)(0, (0, import_TlvArray.TlvArray)((0, import_TlvNumber.TlvEnum)(), { maxLength: 7 })),
    /**
     * This field shall represent the set of faults detected prior to this change event, as per RadioFaultEnum.
     *
     * @see {@link MatterSpecification.v14.Core} § 11.12.8.2.2
     */
    previous: (0, import_TlvObject.TlvField)(1, (0, import_TlvArray.TlvArray)((0, import_TlvNumber.TlvEnum)(), { maxLength: 7 }))
  });
  GeneralDiagnostics2.TlvNetworkFaultChangeEvent = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall represent the set of faults currently detected, as per NetworkFaultEnum.
     *
     * @see {@link MatterSpecification.v14.Core} § 11.12.8.3.1
     */
    current: (0, import_TlvObject.TlvField)(0, (0, import_TlvArray.TlvArray)((0, import_TlvNumber.TlvEnum)(), { maxLength: 4 })),
    /**
     * This field shall represent the set of faults detected prior to this change event, as per NetworkFaultEnum.
     *
     * @see {@link MatterSpecification.v14.Core} § 11.12.8.3.2
     */
    previous: (0, import_TlvObject.TlvField)(1, (0, import_TlvArray.TlvArray)((0, import_TlvNumber.TlvEnum)(), { maxLength: 4 }))
  });
  GeneralDiagnostics2.TlvBootReasonEvent = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall contain the reason for this BootReason event.
     *
     * @see {@link MatterSpecification.v14.Core} § 11.12.8.4.1
     */
    bootReason: (0, import_TlvObject.TlvField)(0, (0, import_TlvNumber.TlvEnum)())
  });
  GeneralDiagnostics2.DataModelTestComponent = import_MutableCluster.MutableCluster.Component({
    commands: {
      /**
       * This command provides a means for certification tests or manufacturer’s internal tests to validate
       * particular command handling and encoding constraints by generating a response of a given size.
       *
       * This command shall use the same EnableKey behavior as the TestEventTrigger command, whereby processing of
       * the command is only enabled when the TestEventTriggersEnabled field is true, which shall NOT be true
       * outside of certification testing or manufacturer’s internal tests.
       *
       * The fields for the PayloadTestRequest command are as follows:
       *
       * @see {@link MatterSpecification.v14.Core} § 11.12.7.4
       */
      payloadTestRequest: (0, import_Cluster.Command)(
        3,
        GeneralDiagnostics2.TlvPayloadTestRequest,
        4,
        GeneralDiagnostics2.TlvPayloadTestResponse,
        { invokeAcl: import_model.AccessLevel.Manage }
      )
    }
  });
  GeneralDiagnostics2.Base = import_MutableCluster.MutableCluster.Component({
    id: 51,
    name: "GeneralDiagnostics",
    revision: 2,
    features: {
      /**
       * DataModelTest
       *
       * This feature indicates support for extended Data Model testing commands, which are required in some
       * situations.
       *
       * This feature shall be supported if the MaxPathsPerInvoke attribute of the Basic Information Cluster has a
       * value > 1.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.12.4.1
       */
      dataModelTest: (0, import_BitmapSchema.BitFlag)(0)
    },
    attributes: {
      /**
       * The NetworkInterfaces attribute shall be a list of NetworkInterface structs. Each logical network
       * interface on the Node shall be represented by a single entry within the NetworkInterfaces attribute.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.12.6.1
       */
      networkInterfaces: (0, import_Cluster.Attribute)(0, (0, import_TlvArray.TlvArray)(GeneralDiagnostics2.TlvNetworkInterface, { maxLength: 8 }), { default: [] }),
      /**
       * The RebootCount attribute shall indicate a best-effort count of the number of times the Node has
       * rebooted. The RebootCount attribute SHOULD be incremented each time the Node reboots. The RebootCount
       * attribute shall NOT be incremented when a Node wakes from a low-power or sleep state. The RebootCount
       * attribute shall only be reset to 0 upon a factory reset of the Node.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.12.6.2
       */
      rebootCount: (0, import_Cluster.Attribute)(1, import_TlvNumber.TlvUInt16, { persistent: true }),
      /**
       * The UpTime attribute shall indicate a best-effort assessment of the length of time, in seconds, since the
       * Node’s last reboot. This attribute SHOULD be incremented to account for the periods of time that a Node
       * is in a low-power or sleep state. This attribute shall only be reset upon a device reboot. This attribute
       * shall be based on the same System Time source as those used to fulfill any usage of the system-us and
       * system-ms data types within the server.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.12.6.3
       */
      upTime: (0, import_Cluster.Attribute)(2, import_TlvNumber.TlvUInt64, { omitChanges: true }),
      /**
       * The TotalOperationalHours attribute shall indicate a best-effort attempt at tracking the length of time,
       * in hours, that the Node has been operational. The TotalOperationalHours attribute SHOULD be incremented
       * to account for the periods of time that a Node is in a low-power or sleep state. The
       * TotalOperationalHours attribute shall only be reset upon a factory reset of the Node.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.12.6.4
       */
      totalOperationalHours: (0, import_Cluster.OptionalAttribute)(3, import_TlvNumber.TlvUInt32, { persistent: true, omitChanges: true }),
      /**
       * The BootReason attribute shall indicate the reason for the Node’s most recent boot.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.12.6.5
       */
      bootReason: (0, import_Cluster.OptionalAttribute)(4, (0, import_TlvNumber.TlvEnum)()),
      /**
       * The ActiveHardwareFaults attribute shall indicate the set of faults currently detected by the Node. When
       * the Node detects a fault has been raised, the appropriate HardwareFaultEnum value shall be added to this
       * list. This list shall NOT contain more than one instance of a specific HardwareFaultEnum value. When the
       * Node detects that all conditions contributing to a fault has been
       *
       * cleared, the corresponding HardwareFaultEnum value shall be removed from this list. An empty list shall
       * indicate there are currently no active faults. The order of this list SHOULD have no significance.
       * Clients interested in monitoring changes in active faults may subscribe to this attribute, or they may
       * subscribe to HardwareFaultChange.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.12.6.6
       */
      activeHardwareFaults: (0, import_Cluster.OptionalAttribute)(
        5,
        (0, import_TlvArray.TlvArray)((0, import_TlvNumber.TlvEnum)(), { maxLength: 11 }),
        { default: [] }
      ),
      /**
       * The ActiveRadioFaults attribute shall indicate the set of faults currently detected by the Node. When the
       * Node detects a fault has been raised, the appropriate RadioFaultEnum value shall be added to this list.
       * This list shall NOT contain more than one instance of a specific RadioFaultEnum value. When the Node
       * detects that all conditions contributing to a fault has been cleared, the corresponding RadioFaultEnum
       * value shall be removed from this list. An empty list shall indicate there are currently no active faults.
       * The order of this list SHOULD have no significance. Clients interested in monitoring changes in active
       * faults may subscribe to this attribute, or they may subscribe to RadioFaultChange.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.12.6.7
       */
      activeRadioFaults: (0, import_Cluster.OptionalAttribute)(
        6,
        (0, import_TlvArray.TlvArray)((0, import_TlvNumber.TlvEnum)(), { maxLength: 7 }),
        { default: [] }
      ),
      /**
       * The ActiveNetworkFaults attribute shall indicate the set of faults currently detected by the Node. When
       * the Node detects a fault has been raised, the appropriate NetworkFaultEnum value shall be added to this
       * list. This list shall NOT contain more than one instance of a specific NetworkFaultEnum value. When the
       * Node detects that all conditions contributing to a fault has been cleared, the corresponding
       * NetworkFaultEnum value shall be removed from this list. An empty list shall indicate there are currently
       * no active faults. The order of this list SHOULD have no significance. Clients interested in monitoring
       * changes in active faults may subscribe to this attribute, or they may subscribe to NetworkFaultChange.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.12.6.8
       */
      activeNetworkFaults: (0, import_Cluster.OptionalAttribute)(
        7,
        (0, import_TlvArray.TlvArray)((0, import_TlvNumber.TlvEnum)(), { maxLength: 4 }),
        { default: [] }
      ),
      /**
       * The TestEventTriggersEnabled attribute shall indicate whether the Node has any TestEventTrigger
       * configured. When this attribute is true, the Node has been configured with one or more test event
       * triggers by virtue of the internally programmed EnableKey value (see TestEventTrigger) being set to a
       * non-zero value. This attribute can be used by Administrators to detect if a device was inadvertently
       * commissioned with test event trigger mode enabled, and take appropriate action (e.g. warn the user and/or
       * offer to remove all fabrics on the Node).
       *
       * @see {@link MatterSpecification.v14.Core} § 11.12.6.9
       */
      testEventTriggersEnabled: (0, import_Cluster.Attribute)(8, import_TlvBoolean.TlvBoolean)
    },
    commands: {
      /**
       * This command shall be supported to provide a means for certification tests to trigger some test-
       * plan-specific events, necessary to assist in automation of device interactions for some certification
       * test cases. This command shall NOT cause any changes to the state of the device that persist after the
       * last fabric is removed.
       *
       * The fields for the TestEventTrigger command are as follows:
       *
       * @see {@link MatterSpecification.v14.Core} § 11.12.7.1
       */
      testEventTrigger: (0, import_Cluster.Command)(
        0,
        GeneralDiagnostics2.TlvTestEventTriggerRequest,
        0,
        import_Cluster.TlvNoResponse,
        { invokeAcl: import_model.AccessLevel.Manage }
      ),
      /**
       * This command may be used by a client to obtain a correlated view of both System Time, and, if currently
       * synchronized and supported, "wall clock time" of the server. This can help clients establish time
       * correlation between their concept of time and the server’s concept of time. This is especially useful
       * when processing event histories where some events only contain System Time.
       *
       * Upon command invocation, the server shall respond with a TimeSnapshotResponse.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.12.7.2
       */
      timeSnapshot: (0, import_Cluster.Command)(1, import_TlvNoArguments.TlvNoArguments, 2, GeneralDiagnostics2.TlvTimeSnapshotResponse)
    },
    events: {
      /**
       * The HardwareFaultChange Event shall indicate a change in the set of hardware faults currently detected by
       * the Node.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.12.8.1
       */
      hardwareFaultChange: (0, import_Cluster.OptionalEvent)(0, import_Cluster.EventPriority.Critical, GeneralDiagnostics2.TlvHardwareFaultChangeEvent),
      /**
       * The RadioFaultChange Event shall indicate a change in the set of radio faults currently detected by the
       * Node.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.12.8.2
       */
      radioFaultChange: (0, import_Cluster.OptionalEvent)(1, import_Cluster.EventPriority.Critical, GeneralDiagnostics2.TlvRadioFaultChangeEvent),
      /**
       * The NetworkFaultChange Event shall indicate a change in the set of network faults currently detected by
       * the Node.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.12.8.3
       */
      networkFaultChange: (0, import_Cluster.OptionalEvent)(2, import_Cluster.EventPriority.Critical, GeneralDiagnostics2.TlvNetworkFaultChangeEvent),
      /**
       * The BootReason Event shall indicate the reason that caused the device to start-up.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.12.8.4
       */
      bootReason: (0, import_Cluster.Event)(3, import_Cluster.EventPriority.Critical, GeneralDiagnostics2.TlvBootReasonEvent)
    },
    /**
     * This metadata controls which GeneralDiagnosticsCluster elements matter.js activates for specific feature
     * combinations.
     */
    extensions: import_MutableCluster.MutableCluster.Extensions({ flags: { dataModelTest: true }, component: GeneralDiagnostics2.DataModelTestComponent })
  });
  GeneralDiagnostics2.ClusterInstance = (0, import_MutableCluster.MutableCluster)(GeneralDiagnostics2.Base);
  GeneralDiagnostics2.Cluster = GeneralDiagnostics2.ClusterInstance;
  const DMTEST = { dataModelTest: true };
  GeneralDiagnostics2.CompleteInstance = (0, import_MutableCluster.MutableCluster)({
    id: GeneralDiagnostics2.Cluster.id,
    name: GeneralDiagnostics2.Cluster.name,
    revision: GeneralDiagnostics2.Cluster.revision,
    features: GeneralDiagnostics2.Cluster.features,
    attributes: GeneralDiagnostics2.Cluster.attributes,
    commands: {
      ...GeneralDiagnostics2.Cluster.commands,
      payloadTestRequest: import_MutableCluster.MutableCluster.AsConditional(
        GeneralDiagnostics2.DataModelTestComponent.commands.payloadTestRequest,
        { mandatoryIf: [DMTEST] }
      )
    },
    events: GeneralDiagnostics2.Cluster.events
  });
  GeneralDiagnostics2.Complete = GeneralDiagnostics2.CompleteInstance;
})(GeneralDiagnostics || (GeneralDiagnostics = {}));
const GeneralDiagnosticsCluster = GeneralDiagnostics.Cluster;
import_ClusterRegistry.ClusterRegistry.register(GeneralDiagnostics.Complete);
//# sourceMappingURL=general-diagnostics.js.map
