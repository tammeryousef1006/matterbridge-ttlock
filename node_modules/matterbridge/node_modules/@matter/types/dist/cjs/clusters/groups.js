"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var groups_exports = {};
__export(groups_exports, {
  Groups: () => Groups,
  GroupsCluster: () => GroupsCluster
});
module.exports = __toCommonJS(groups_exports);
var import_MutableCluster = require("../cluster/mutation/MutableCluster.js");
var import_BitmapSchema = require("../schema/BitmapSchema.js");
var import_Cluster = require("../cluster/Cluster.js");
var import_TlvNumber = require("../tlv/TlvNumber.js");
var import_TlvObject = require("../tlv/TlvObject.js");
var import_GroupId = require("../datatype/GroupId.js");
var import_TlvString = require("../tlv/TlvString.js");
var import_model = require("#model");
var import_TlvArray = require("../tlv/TlvArray.js");
var import_TlvNullable = require("../tlv/TlvNullable.js");
var import_TlvNoArguments = require("../tlv/TlvNoArguments.js");
var import_ClusterRegistry = require("../cluster/ClusterRegistry.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
var Groups;
((Groups2) => {
  let Feature;
  ((Feature2) => {
    Feature2["GroupNames"] = "GroupNames";
  })(Feature = Groups2.Feature || (Groups2.Feature = {}));
  Groups2.NameSupportAttribute = {
    nameSupport: (0, import_BitmapSchema.BitFlag)(7),
    /**
     * The ability to store a name for a group.
     */
    groupNames: (0, import_BitmapSchema.BitFlag)(7)
  };
  Groups2.TlvAddGroupRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall be used to identify the group and any associated key material to which the server endpoint
     * is to be added.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.3.7.1.1
     */
    groupId: (0, import_TlvObject.TlvField)(0, import_GroupId.TlvGroupId),
    /**
     * This field may be set to a human-readable name for the group. If the client has no name for the group, the
     * GroupName field shall be set to the empty string.
     *
     * Support of group names is optional and is indicated by the FeatureMap and NameSupport attribute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.3.7.1.2
     */
    groupName: (0, import_TlvObject.TlvField)(1, import_TlvString.TlvString.bound({ maxLength: 16 }))
  });
  Groups2.TlvAddGroupResponse = (0, import_TlvObject.TlvObject)({
    /**
     * This field is set according to the Effect on Receipt section of the AddGroup command.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.3.7.7.1
     */
    status: (0, import_TlvObject.TlvField)(0, (0, import_TlvNumber.TlvEnum)()),
    /**
     * This field is set to the GroupID field of the received AddGroup command.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.3.7.7.2
     */
    groupId: (0, import_TlvObject.TlvField)(1, import_GroupId.TlvGroupId)
  });
  Groups2.TlvViewGroupRequest = (0, import_TlvObject.TlvObject)({ groupId: (0, import_TlvObject.TlvField)(0, import_GroupId.TlvGroupId) });
  Groups2.TlvViewGroupResponse = (0, import_TlvObject.TlvObject)({
    /**
     * This field is according to the Effect on Receipt section of the ViewGroup command.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.3.7.8.1
     */
    status: (0, import_TlvObject.TlvField)(0, (0, import_TlvNumber.TlvEnum)()),
    /**
     * This field is set to the GroupID field of the received ViewGroup command.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.3.7.8.2
     */
    groupId: (0, import_TlvObject.TlvField)(1, import_GroupId.TlvGroupId),
    /**
     * If the status is SUCCESS, and group names are supported, this field is set to the group name associated with
     * that group in the Group Table; otherwise it is set to the empty string.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.3.7.8.3
     */
    groupName: (0, import_TlvObject.TlvField)(2, import_TlvString.TlvString.bound({ maxLength: 16 }))
  });
  Groups2.TlvGetGroupMembershipRequest = (0, import_TlvObject.TlvObject)({ groupList: (0, import_TlvObject.TlvField)(0, (0, import_TlvArray.TlvArray)(import_GroupId.TlvGroupId)) });
  Groups2.TlvGetGroupMembershipResponse = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall contain the remaining capacity of the Group Table of the node. The following values apply:
     *
     *   • 0 - No further groups may be added.
     *
     *   • 0 < Capacity < 0xFE - Capacity holds the number of groups that may be added.
     *
     *   • 0xFE - At least 1 further group may be added (exact number is unknown).
     *
     *   • null - It is unknown if any further groups may be added.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.3.7.9.1
     */
    capacity: (0, import_TlvObject.TlvField)(0, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt8)),
    /**
     * The GroupList field shall contain either the group IDs of all the groups in the Group Table for which the
     * server endpoint is a member of the group (in the case where the GroupList field of the received
     * GetGroupMembership command was empty), or the group IDs of all the groups in the Group Table for which the
     * server endpoint is a member of the group and for which the group ID was included in the the GroupList field
     * of the received GetGroupMembership command (in the case where the GroupList field of the received
     * GetGroupMembership command was not empty).
     *
     * Zigbee: If the total number of groups will cause the maximum payload length of a frame to be exceeded, then
     * the GroupList field shall contain only as many groups as will fit.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.3.7.9.2
     */
    groupList: (0, import_TlvObject.TlvField)(1, (0, import_TlvArray.TlvArray)(import_GroupId.TlvGroupId))
  });
  Groups2.TlvRemoveGroupRequest = (0, import_TlvObject.TlvObject)({ groupId: (0, import_TlvObject.TlvField)(0, import_GroupId.TlvGroupId) });
  Groups2.TlvRemoveGroupResponse = (0, import_TlvObject.TlvObject)({
    /**
     * This field is according to the Effect on Receipt section of the RemoveGroup command.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.3.7.10.1
     */
    status: (0, import_TlvObject.TlvField)(0, (0, import_TlvNumber.TlvEnum)()),
    /**
     * This field is set to the GroupID field of the received RemoveGroup command.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.3.7.10.2
     */
    groupId: (0, import_TlvObject.TlvField)(1, import_GroupId.TlvGroupId)
  });
  Groups2.TlvAddGroupIfIdentifyingRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall be used to identify the group and any associated key material to which the server endpoint
     * is to be added.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.3.7.6.1
     */
    groupId: (0, import_TlvObject.TlvField)(0, import_GroupId.TlvGroupId),
    /**
     * This field may be set to a human-readable name for the group. If the client has no name for the
     *
     * group, the GroupName field shall be set to the empty string.
     *
     * Support of group names is optional and is indicated by the FeatureMap and NameSupport attribute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.3.7.6.2
     */
    groupName: (0, import_TlvObject.TlvField)(1, import_TlvString.TlvString.bound({ maxLength: 16 }))
  });
  Groups2.NameSupport = {
    /**
     * The ability to store a name for a group.
     */
    groupNames: (0, import_BitmapSchema.BitFlag)(7)
  };
  Groups2.Base = import_MutableCluster.MutableCluster.Component({
    id: 4,
    name: "Groups",
    revision: 4,
    features: {
      /**
       * GroupNames
       *
       * The Group Names feature indicates the ability to store a name for a group when a group is added.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.3.4.1
       */
      groupNames: (0, import_BitmapSchema.BitFlag)(0)
    },
    attributes: {
      /**
       * This attribute provides legacy, read-only access to whether the Group Names feature is supported. The
       * most significant bit, bit 7 (GroupNames), shall be equal to bit 0 of the FeatureMap attribute (GN
       * Feature). All other bits shall be 0.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.3.6.1
       */
      nameSupport: (0, import_Cluster.FixedAttribute)(0, (0, import_TlvNumber.TlvBitmap)(import_TlvNumber.TlvUInt8, Groups2.NameSupportAttribute))
    },
    commands: {
      /**
       * The AddGroup command allows a client to add group membership in a particular group for the server
       * endpoint.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.3.7.1
       */
      addGroup: (0, import_Cluster.Command)(0, Groups2.TlvAddGroupRequest, 0, Groups2.TlvAddGroupResponse, { invokeAcl: import_model.AccessLevel.Manage }),
      /**
       * The ViewGroup command allows a client to request that the server responds with a ViewGroupResponse
       * command containing the name string for a particular group.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.3.7.2
       */
      viewGroup: (0, import_Cluster.Command)(1, Groups2.TlvViewGroupRequest, 1, Groups2.TlvViewGroupResponse),
      /**
       * The GetGroupMembership command allows a client to inquire about the group membership of the server
       * endpoint, in a number of ways.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.3.7.3
       */
      getGroupMembership: (0, import_Cluster.Command)(2, Groups2.TlvGetGroupMembershipRequest, 2, Groups2.TlvGetGroupMembershipResponse),
      /**
       * The RemoveGroup command allows a client to request that the server removes the membership for the server
       * endpoint, if any, in a particular group.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.3.7.4
       */
      removeGroup: (0, import_Cluster.Command)(
        3,
        Groups2.TlvRemoveGroupRequest,
        3,
        Groups2.TlvRemoveGroupResponse,
        { invokeAcl: import_model.AccessLevel.Manage }
      ),
      /**
       * The RemoveAllGroups command allows a client to direct the server to remove all group associations for the
       * server endpoint.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.3.7.5
       */
      removeAllGroups: (0, import_Cluster.Command)(4, import_TlvNoArguments.TlvNoArguments, 4, import_Cluster.TlvNoResponse, { invokeAcl: import_model.AccessLevel.Manage }),
      /**
       * The AddGroupIfIdentifying command allows a client to add group membership in a particular group for the
       * server endpoint, on condition that the endpoint is identifying itself. Identifying functionality is
       * controlled using the Identify cluster, (see Identify Cluster).
       *
       * For correct operation of the AddGroupIfIdentifying command, any endpoint that supports the Groups server
       * cluster shall also support the Identify server cluster.
       *
       * This command might be used to assist configuring group membership in the absence of a commissioning tool.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.3.7.6
       */
      addGroupIfIdentifying: (0, import_Cluster.Command)(
        5,
        Groups2.TlvAddGroupIfIdentifyingRequest,
        5,
        import_Cluster.TlvNoResponse,
        { invokeAcl: import_model.AccessLevel.Manage }
      )
    },
    /**
     * This metadata controls which GroupsCluster elements matter.js activates for specific feature combinations.
     */
    extensions: import_MutableCluster.MutableCluster.Extensions()
  });
  Groups2.ClusterInstance = (0, import_MutableCluster.MutableCluster)({ ...Groups2.Base, supportedFeatures: { groupNames: true } });
  Groups2.Cluster = Groups2.ClusterInstance;
  Groups2.Complete = Groups2.Cluster;
})(Groups || (Groups = {}));
const GroupsCluster = Groups.Cluster;
import_ClusterRegistry.ClusterRegistry.register(Groups.Complete);
//# sourceMappingURL=groups.js.map
