"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var icd_management_exports = {};
__export(icd_management_exports, {
  IcdManagement: () => IcdManagement,
  IcdManagementCluster: () => IcdManagementCluster
});
module.exports = __toCommonJS(icd_management_exports);
var import_MutableCluster = require("../cluster/mutation/MutableCluster.js");
var import_Cluster = require("../cluster/Cluster.js");
var import_TlvArray = require("../tlv/TlvArray.js");
var import_TlvObject = require("../tlv/TlvObject.js");
var import_NodeId = require("../datatype/NodeId.js");
var import_SubjectId = require("../datatype/SubjectId.js");
var import_TlvNumber = require("../tlv/TlvNumber.js");
var import_FabricIndex = require("../datatype/FabricIndex.js");
var import_model = require("#model");
var import_TlvString = require("../tlv/TlvString.js");
var import_BitmapSchema = require("../schema/BitmapSchema.js");
var import_ClusterRegistry = require("../cluster/ClusterRegistry.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
var IcdManagement;
((IcdManagement2) => {
  let Feature;
  ((Feature2) => {
    Feature2["CheckInProtocolSupport"] = "CheckInProtocolSupport";
    Feature2["UserActiveModeTrigger"] = "UserActiveModeTrigger";
    Feature2["LongIdleTimeSupport"] = "LongIdleTimeSupport";
    Feature2["DynamicSitLitSupport"] = "DynamicSitLitSupport";
  })(Feature = IcdManagement2.Feature || (IcdManagement2.Feature = {}));
  let ClientType;
  ((ClientType2) => {
    ClientType2[ClientType2["Permanent"] = 0] = "Permanent";
    ClientType2[ClientType2["Ephemeral"] = 1] = "Ephemeral";
  })(ClientType = IcdManagement2.ClientType || (IcdManagement2.ClientType = {}));
  IcdManagement2.TlvMonitoringRegistration = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the NodeID of the Node to which Check-In messages will be sent when the
     * MonitoredSubject is not subscribed.
     *
     * @see {@link MatterSpecification.v14.Core} § 9.17.5.3.1
     */
    checkInNodeId: (0, import_TlvObject.TlvField)(1, import_NodeId.TlvNodeId),
    /**
     * This field shall indicate the monitored Subject ID. This field shall be used to determine if a particular
     * client has an active subscription for the given entry. The MonitoredSubject, when it is a NodeID, may be the
     * same as the CheckInNodeID. The MonitoredSubject gives the registering client the flexibility of having a
     * different CheckInNodeID from the MonitoredSubject. A subscription shall count as an active subscription for
     * this entry if:
     *
     *   • It is on the associated fabric of this entry, and
     *
     *   • The subject of this entry matches the ISD of the SubscriptionRequest message that created the
     *     subscription. Matching shall be determined using the subject_matches function defined in the Access
     *     Control Privilege Granting Algorithm.
     *
     * For example, if the MonitoredSubject is Node ID 0x1111_2222_3333_AAAA, and one of the subscribers to the
     * server on the entry’s associated fabric bears that Node ID, then the entry matches.
     *
     * Another example is if the MonitoredSubject has the value 0xFFFF_FFFD_AA12_0002, and one of the
     *
     * subscribers to the server on the entry’s associated fabric bears the CASE Authenticated TAG value 0xAA12 and
     * the version 0x0002 or higher within its NOC, then the entry matches.
     *
     * @see {@link MatterSpecification.v14.Core} § 9.17.5.3.2
     */
    monitoredSubject: (0, import_TlvObject.TlvField)(2, import_SubjectId.TlvSubjectId),
    /**
     * This field shall indicate the client’s type to inform the ICD of the availability for communication of the
     * client.
     *
     * @see {@link MatterSpecification.v14.Core} § 9.17.5.4
     */
    clientType: (0, import_TlvObject.TlvField)(4, (0, import_TlvNumber.TlvEnum)()),
    fabricIndex: (0, import_TlvObject.TlvField)(254, import_FabricIndex.TlvFabricIndex)
  });
  IcdManagement2.TlvRegisterClientRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall provide the node ID to which a Check-In message will be sent if there are no active
     * subscriptions matching MonitoredSubject.
     *
     * @see {@link MatterSpecification.v14.Core} § 9.17.7.1.1
     */
    checkInNodeId: (0, import_TlvObject.TlvField)(0, import_NodeId.TlvNodeId),
    /**
     * This field shall provide the monitored subject ID.
     *
     * @see {@link MatterSpecification.v14.Core} § 9.17.7.1.2
     */
    monitoredSubject: (0, import_TlvObject.TlvField)(1, import_SubjectId.TlvSubjectId),
    /**
     * This field shall provide the shared secret between the client and the ICD to encrypt the Check-In message.
     *
     * @see {@link MatterSpecification.v14.Core} § 9.17.7.1.3
     */
    key: (0, import_TlvObject.TlvField)(2, import_TlvString.TlvByteString.bound({ length: 16 })),
    /**
     * This field shall provide the verification key. The verification key represents the key already stored on the
     * server. The verification key provided in this field shall be used by the server to guarantee that a client
     * with manage permissions can only modify entries that contain a Key equal to the verification key. The
     * verification key shall be provided for clients with manage permissions. The verification key SHOULD NOT be
     * provided by clients with administrator permissions for the server cluster. The verification key shall be
     * ignored by the server if it is provided by a client with administrator permissions for the server cluster.
     *
     * @see {@link MatterSpecification.v14.Core} § 9.17.7.1.4
     */
    verificationKey: (0, import_TlvObject.TlvOptionalField)(3, import_TlvString.TlvByteString.bound({ length: 16 })),
    /**
     * This field shall provide the client type of the client registering.
     *
     * @see {@link MatterSpecification.v14.Core} § 9.17.7.1.5
     */
    clientType: (0, import_TlvObject.TlvField)(4, (0, import_TlvNumber.TlvEnum)())
  });
  IcdManagement2.TlvRegisterClientResponse = (0, import_TlvObject.TlvObject)({ icdCounter: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt32) });
  IcdManagement2.TlvUnregisterClientRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall provide the registered client node ID to remove from storage.
     *
     * @see {@link MatterSpecification.v14.Core} § 9.17.7.3.1
     */
    checkInNodeId: (0, import_TlvObject.TlvField)(0, import_NodeId.TlvNodeId),
    /**
     * This field shall provide the verification key associated with the CheckInNodeID to remove from storage. The
     * verification key represents the key already stored on the server. The verification key provided in this field
     * shall be used by the server to guarantee that a client with manage permissions can only remove entries that
     * contain a Key equal to the stored key. The verification key shall be provided for clients with manage
     * permissions. The verification key SHOULD NOT be provided by clients with administrator permissions for the
     * server cluster. The verification key shall be ignored by the server if it is provided by a client with
     * administrator permissions for the server cluster.
     *
     * @see {@link MatterSpecification.v14.Core} § 9.17.7.3.2
     */
    verificationKey: (0, import_TlvObject.TlvOptionalField)(1, import_TlvString.TlvByteString.bound({ length: 16 }))
  });
  IcdManagement2.UserActiveModeTrigger = {
    /**
     * Power Cycle to transition the device to ActiveMode
     */
    powerCycle: (0, import_BitmapSchema.BitFlag)(0),
    /**
     * Settings menu on the device informs how to transition the device to ActiveMode
     */
    settingsMenu: (0, import_BitmapSchema.BitFlag)(1),
    /**
     * Custom Instruction on how to transition the device to ActiveMode
     */
    customInstruction: (0, import_BitmapSchema.BitFlag)(2),
    /**
     * Device Manual informs how to transition the device to ActiveMode
     */
    deviceManual: (0, import_BitmapSchema.BitFlag)(3),
    /**
     * Actuate Sensor to transition the device to ActiveMode
     */
    actuateSensor: (0, import_BitmapSchema.BitFlag)(4),
    /**
     * Actuate Sensor for N seconds to transition the device to ActiveMode
     */
    actuateSensorSeconds: (0, import_BitmapSchema.BitFlag)(5),
    /**
     * Actuate Sensor N times to transition the device to ActiveMode
     */
    actuateSensorTimes: (0, import_BitmapSchema.BitFlag)(6),
    /**
     * Actuate Sensor until light blinks to transition the device to ActiveMode
     */
    actuateSensorLightsBlink: (0, import_BitmapSchema.BitFlag)(7),
    /**
     * Press Reset Button to transition the device to ActiveMode
     */
    resetButton: (0, import_BitmapSchema.BitFlag)(8),
    /**
     * Press Reset Button until light blinks to transition the device to ActiveMode
     */
    resetButtonLightsBlink: (0, import_BitmapSchema.BitFlag)(9),
    /**
     * Press Reset Button for N seconds to transition the device to ActiveMode
     */
    resetButtonSeconds: (0, import_BitmapSchema.BitFlag)(10),
    /**
     * Press Reset Button N times to transition the device to ActiveMode
     */
    resetButtonTimes: (0, import_BitmapSchema.BitFlag)(11),
    /**
     * Press Setup Button to transition the device to ActiveMode
     */
    setupButton: (0, import_BitmapSchema.BitFlag)(12),
    /**
     * Press Setup Button for N seconds to transition the device to ActiveMode
     */
    setupButtonSeconds: (0, import_BitmapSchema.BitFlag)(13),
    /**
     * Press Setup Button until light blinks to transition the device to ActiveMode
     */
    setupButtonLightsBlink: (0, import_BitmapSchema.BitFlag)(14),
    /**
     * Press Setup Button N times to transition the device to ActiveMode
     */
    setupButtonTimes: (0, import_BitmapSchema.BitFlag)(15),
    /**
     * Press the N Button to transition the device to ActiveMode
     */
    appDefinedButton: (0, import_BitmapSchema.BitFlag)(16)
  };
  let OperatingMode;
  ((OperatingMode2) => {
    OperatingMode2[OperatingMode2["Sit"] = 0] = "Sit";
    OperatingMode2[OperatingMode2["Lit"] = 1] = "Lit";
  })(OperatingMode = IcdManagement2.OperatingMode || (IcdManagement2.OperatingMode = {}));
  IcdManagement2.TlvStayActiveRequest = (0, import_TlvObject.TlvObject)({ stayActiveDuration: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt32) });
  IcdManagement2.TlvStayActiveResponse = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall provide the actual duration that the ICD server can stay active from the time it receives
     * the StayActiveRequest command.
     *
     * ### Minimum Value for PromisedActiveDuration
     *
     * The minimum value of the PromisedActiveDuration field shall be equal to either 30000 milliseconds or
     * StayActiveDuration (from the received StayActiveRequest command), whichever is smaller.
     *
     * @see {@link MatterSpecification.v14.Core} § 9.17.7.5.1
     */
    promisedActiveDuration: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt32)
  });
  IcdManagement2.CheckInProtocolSupportComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * This attribute shall contain all clients registered to receive notification if their subscription is
       * lost. The maximum number of entries that can be in the list shall be ClientsSupportedPerFabric for each
       * fabric supported on the server, as indicated by the value of the SupportedFabrics attribute in the
       * Operational Credentials cluster.
       *
       * @see {@link MatterSpecification.v14.Core} § 9.17.6.4
       */
      registeredClients: (0, import_Cluster.FabricScopedAttribute)(
        3,
        (0, import_TlvArray.TlvArray)(IcdManagement2.TlvMonitoringRegistration),
        { persistent: true, default: [], readAcl: import_model.AccessLevel.Administer, writeAcl: import_model.AccessLevel.Administer }
      ),
      /**
       * This attribute returns the value of the ICD Counter.
       *
       * @see {@link MatterSpecification.v14.Core} § 9.17.6.5
       */
      icdCounter: (0, import_Cluster.Attribute)(
        4,
        import_TlvNumber.TlvUInt32,
        {
          persistent: true,
          omitChanges: true,
          default: 0,
          readAcl: import_model.AccessLevel.Administer,
          writeAcl: import_model.AccessLevel.Administer
        }
      ),
      /**
       * Indicates the maximum number of entries that the server is able to store for each fabric in the
       * RegisteredClients attribute.
       *
       * @see {@link MatterSpecification.v14.Core} § 9.17.6.6
       */
      clientsSupportedPerFabric: (0, import_Cluster.FixedAttribute)(5, import_TlvNumber.TlvUInt16.bound({ min: 1 }), { default: 1 }),
      /**
       * Indicates the maximum time in seconds between two Check-In messages when back-off is active. The
       * MaximumCheckInBackoff shall NOT be smaller than the IdleModeDuration.
       *
       * If the MaximumCheckInBackoff is equal to the IdleModeDuration, it means the ICD does notback- off.
       *
       * @see {@link MatterSpecification.v14.Core} § 9.17.6.10
       */
      maximumCheckInBackoff: (0, import_Cluster.FixedAttribute)(9, import_TlvNumber.TlvUInt32.bound({ max: 64800 }), { default: 1 })
    },
    commands: {
      /**
       * This command allows a client to register itself with the ICD to be notified when the device is available
       * for communication.
       *
       * @see {@link MatterSpecification.v14.Core} § 9.17.7.1
       */
      registerClient: (0, import_Cluster.Command)(
        0,
        IcdManagement2.TlvRegisterClientRequest,
        1,
        IcdManagement2.TlvRegisterClientResponse,
        { invokeAcl: import_model.AccessLevel.Manage }
      ),
      /**
       * This command allows a client to unregister itself with the ICD. Example: a client that is leaving the
       * network (e.g. running on a phone which is leaving the home) can (and should) remove its subscriptions and
       * send this UnregisterClient command before leaving to prevent the burden on the ICD of an absent client.
       *
       * @see {@link MatterSpecification.v14.Core} § 9.17.7.3
       */
      unregisterClient: (0, import_Cluster.Command)(
        2,
        IcdManagement2.TlvUnregisterClientRequest,
        2,
        import_Cluster.TlvNoResponse,
        { invokeAcl: import_model.AccessLevel.Manage }
      )
    }
  });
  IcdManagement2.UserActiveModeTriggerComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * Indicates which user action(s) will trigger the ICD to switch to Active mode. If the attribute indicates
       * support for a trigger that is dependent on the UserActiveModeTriggerInstruction in the
       * UserActiveModeTriggerHint table, the UserActiveModeTriggerInstruction attribute shall be implemented and
       * shall provide the required information, unless specified otherwise in the requirement column of the
       * UserActiveModeTriggerHint table.
       *
       * ActuateSensorLightsBlink, ResetButtonLightsBlink and SetupButtonLightsBlink (i.e. bits 7, 9 and 14) have
       * a dependency on the UserActiveModeTriggerInstruction attribute but do not require the attribute to be
       * present.
       *
       * ### An ICD can indicate multiple ways of being put into Active Mode by setting multiple bits in the
       * bitmap at the same time. However, a device shall NOT set more than one bit which has a dependency on the
       * UserActiveModeTriggerInstruction attribute.
       *
       * @see {@link MatterSpecification.v14.Core} § 9.17.6.7
       */
      userActiveModeTriggerHint: (0, import_Cluster.FixedAttribute)(6, (0, import_TlvNumber.TlvBitmap)(import_TlvNumber.TlvUInt32, IcdManagement2.UserActiveModeTrigger))
    }
  });
  IcdManagement2.LongIdleTimeSupportComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * Indicates the operating mode of the ICD as specified in the OperatingModeEnum.
       *
       *   • If the ICD is operating as a LIT ICD, OperatingMode shall be LIT.
       *
       *   • If the ICD is operating as a SIT ICD, OperatingMode shall be SIT.
       *
       * @see {@link MatterSpecification.v14.Core} § 9.17.6.9
       */
      operatingMode: (0, import_Cluster.Attribute)(8, (0, import_TlvNumber.TlvEnum)())
    },
    commands: {
      /**
       * This command allows a client to request that the server stays in active mode for at least a given time
       * duration (in milliseconds) from when this command is received.
       *
       * This StayActiveDuration may be longer than the ActiveModeThreshold value and would, typically, be used by
       * the client to request the server to stay active and responsive for this period to allow a sequence of
       * message exchanges during that period. The client may slightly overestimate the duration it wants the ICD
       * to be active for, in order to account for network delays.
       *
       * @see {@link MatterSpecification.v14.Core} § 9.17.7.4
       */
      stayActiveRequest: (0, import_Cluster.Command)(3, IcdManagement2.TlvStayActiveRequest, 4, IcdManagement2.TlvStayActiveResponse)
    }
  });
  IcdManagement2.Base = import_MutableCluster.MutableCluster.Component({
    id: 70,
    name: "IcdManagement",
    revision: 3,
    features: {
      /**
       * CheckInProtocolSupport
       *
       * When this feature is supported, the device shall support all the associated commands and attributes to
       * properly support the Check-In Protocol.
       *
       * @see {@link MatterSpecification.v14.Core} § 9.17.4.1
       */
      checkInProtocolSupport: (0, import_BitmapSchema.BitFlag)(0),
      /**
       * UserActiveModeTrigger
       *
       * This feature is supported if and only if the device has a user active mode trigger.
       *
       * @see {@link MatterSpecification.v14.Core} § 9.17.4.2
       */
      userActiveModeTrigger: (0, import_BitmapSchema.BitFlag)(1),
      /**
       * LongIdleTimeSupport
       *
       * This feature is supported if and only the device is a Long Idle Time ICD.
       *
       * @see {@link MatterSpecification.v14.Core} § 9.17.4.3
       */
      longIdleTimeSupport: (0, import_BitmapSchema.BitFlag)(2),
      /**
       * DynamicSitLitSupport
       *
       * This feature is supported if and only if the device can switch between SIT and LIT operating modes even
       * if it has a valid registered client. See the dynamic SIT / LIT operating mode switching for more details.
       *
       * @see {@link MatterSpecification.v14.Core} § 9.17.4.4
       */
      dynamicSitLitSupport: (0, import_BitmapSchema.BitFlag)(3)
    },
    attributes: {
      /**
       * Indicates the maximum interval in seconds the server can stay in idle mode. The IdleModeDuration shall
       * NOT be smaller than the ActiveModeDuration.
       *
       * @see {@link MatterSpecification.v14.Core} § 9.17.6.1
       */
      idleModeDuration: (0, import_Cluster.FixedAttribute)(0, import_TlvNumber.TlvUInt32.bound({ min: 1, max: 64800 }), { default: 1 }),
      /**
       * Indicates the minimum interval in milliseconds the server typically will stay in active mode after
       * initial transition out of idle mode. The ActiveModeDuration does not include the ActiveModeThreshold.
       *
       * @see {@link MatterSpecification.v14.Core} § 9.17.6.2
       */
      activeModeDuration: (0, import_Cluster.FixedAttribute)(1, import_TlvNumber.TlvUInt32, { default: 300 }),
      /**
       * Indicates the minimum amount of time in milliseconds the server typically will stay active after network
       * activity when in active mode.
       *
       * @see {@link MatterSpecification.v14.Core} § 9.17.6.3
       */
      activeModeThreshold: (0, import_Cluster.FixedAttribute)(2, import_TlvNumber.TlvUInt16, { default: 300 }),
      /**
       * The meaning of the attribute is dependent upon the UserActiveModeTriggerHint attribute value, and the
       * conformance is in indicated in the "dependency" column in UserActiveModeTriggerHint table. The
       * UserActiveModeTriggerInstruction attribute may give additional information on how to transition the
       * device to Active Mode. If the attribute is present, the value shall be encoded as a valid UTF-8 string
       * with a maximum length of 128 bytes. If the UserActiveModeTriggerHint has the ActuateSensorSeconds,
       * ActuateSensorTimes, ResetButtonSeconds, ResetButtonTimes, SetupButtonSeconds or SetupButtonTimes set, the
       * string shall consist solely of an encoding of N as a decimal unsigned integer using the ASCII digits 0-9,
       * and without leading zeros.
       *
       * For example, given UserActiveModeTriggerHint="2048", ResetButtonTimes is set which indicates "Press Reset
       * Button for N seconds". Therefore, a value of UserActiveModeTriggerInstruction="10" would indicate that N
       * is 10 in that context.
       *
       * When CustomInstruction is set by the UserActiveModeTriggerHint attribute, indicating presence of a custom
       * string, the ICD SHOULD perform localization (translation to user’s preferred language, as indicated in
       * the Device’s currently configured locale). The Custom Instruction option SHOULD NOT be used by an ICD
       * that does not have knowledge of the user’s language preference.
       *
       * When the UserActiveModeTriggerHint key indicates a light to blink (ActuateSensorLightsBlink,
       * ResetButtonLightsBlink or SetupButtonLightsBlink), information on color of light may be made available
       * via the UserActiveModeTriggerInstruction attribute. When using such color indication in the
       * UserActiveModeTriggerInstruction attribute, the string shall consist of exactly 6 hexadecimal digits
       * using the ASCII characters 0-F and encoding the RGB color value as used in HTML encodings.
       *
       * @see {@link MatterSpecification.v14.Core} § 9.17.6.8
       */
      userActiveModeTriggerInstruction: (0, import_Cluster.OptionalFixedAttribute)(
        7,
        import_TlvString.TlvString.bound({ maxLength: 128 }),
        { default: "" }
      )
    },
    commands: {
      /**
       * This command allows a client to request that the server stays in active mode for at least a given time
       * duration (in milliseconds) from when this command is received.
       *
       * This StayActiveDuration may be longer than the ActiveModeThreshold value and would, typically, be used by
       * the client to request the server to stay active and responsive for this period to allow a sequence of
       * message exchanges during that period. The client may slightly overestimate the duration it wants the ICD
       * to be active for, in order to account for network delays.
       *
       * @see {@link MatterSpecification.v14.Core} § 9.17.7.4
       */
      stayActiveRequest: (0, import_Cluster.OptionalCommand)(3, IcdManagement2.TlvStayActiveRequest, 4, IcdManagement2.TlvStayActiveResponse)
    },
    /**
     * This metadata controls which IcdManagementCluster elements matter.js activates for specific feature
     * combinations.
     */
    extensions: import_MutableCluster.MutableCluster.Extensions(
      { flags: { checkInProtocolSupport: true }, component: IcdManagement2.CheckInProtocolSupportComponent },
      { flags: { userActiveModeTrigger: true }, component: IcdManagement2.UserActiveModeTriggerComponent },
      { flags: { longIdleTimeSupport: true }, component: IcdManagement2.LongIdleTimeSupportComponent },
      { flags: { longIdleTimeSupport: true, checkInProtocolSupport: false }, component: false },
      { flags: { longIdleTimeSupport: true, userActiveModeTrigger: false }, component: false },
      { flags: { dynamicSitLitSupport: true, longIdleTimeSupport: false }, component: false }
    )
  });
  IcdManagement2.ClusterInstance = (0, import_MutableCluster.MutableCluster)(IcdManagement2.Base);
  IcdManagement2.Cluster = IcdManagement2.ClusterInstance;
  const CIP = { checkInProtocolSupport: true };
  const UAT = { userActiveModeTrigger: true };
  const LITS = { longIdleTimeSupport: true };
  IcdManagement2.CompleteInstance = (0, import_MutableCluster.MutableCluster)({
    id: IcdManagement2.Cluster.id,
    name: IcdManagement2.Cluster.name,
    revision: IcdManagement2.Cluster.revision,
    features: IcdManagement2.Cluster.features,
    attributes: {
      ...IcdManagement2.Cluster.attributes,
      registeredClients: import_MutableCluster.MutableCluster.AsConditional(
        IcdManagement2.CheckInProtocolSupportComponent.attributes.registeredClients,
        { mandatoryIf: [CIP] }
      ),
      icdCounter: import_MutableCluster.MutableCluster.AsConditional(
        IcdManagement2.CheckInProtocolSupportComponent.attributes.icdCounter,
        { mandatoryIf: [CIP] }
      ),
      clientsSupportedPerFabric: import_MutableCluster.MutableCluster.AsConditional(
        IcdManagement2.CheckInProtocolSupportComponent.attributes.clientsSupportedPerFabric,
        { mandatoryIf: [CIP] }
      ),
      userActiveModeTriggerHint: import_MutableCluster.MutableCluster.AsConditional(
        IcdManagement2.UserActiveModeTriggerComponent.attributes.userActiveModeTriggerHint,
        { mandatoryIf: [UAT] }
      ),
      operatingMode: import_MutableCluster.MutableCluster.AsConditional(
        IcdManagement2.LongIdleTimeSupportComponent.attributes.operatingMode,
        { mandatoryIf: [LITS] }
      ),
      maximumCheckInBackoff: import_MutableCluster.MutableCluster.AsConditional(
        IcdManagement2.CheckInProtocolSupportComponent.attributes.maximumCheckInBackoff,
        { mandatoryIf: [CIP] }
      )
    },
    commands: {
      ...IcdManagement2.Cluster.commands,
      registerClient: import_MutableCluster.MutableCluster.AsConditional(
        IcdManagement2.CheckInProtocolSupportComponent.commands.registerClient,
        { mandatoryIf: [CIP] }
      ),
      unregisterClient: import_MutableCluster.MutableCluster.AsConditional(
        IcdManagement2.CheckInProtocolSupportComponent.commands.unregisterClient,
        { mandatoryIf: [CIP] }
      ),
      stayActiveRequest: import_MutableCluster.MutableCluster.AsConditional(
        IcdManagement2.LongIdleTimeSupportComponent.commands.stayActiveRequest,
        { mandatoryIf: [LITS] }
      )
    }
  });
  IcdManagement2.Complete = IcdManagement2.CompleteInstance;
})(IcdManagement || (IcdManagement = {}));
const IcdManagementCluster = IcdManagement.Cluster;
import_ClusterRegistry.ClusterRegistry.register(IcdManagement.Complete);
//# sourceMappingURL=icd-management.js.map
