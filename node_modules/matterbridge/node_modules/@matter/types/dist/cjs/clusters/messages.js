"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var messages_exports = {};
__export(messages_exports, {
  Messages: () => Messages,
  MessagesCluster: () => MessagesCluster
});
module.exports = __toCommonJS(messages_exports);
var import_MutableCluster = require("../cluster/mutation/MutableCluster.js");
var import_BitmapSchema = require("../schema/BitmapSchema.js");
var import_Cluster = require("../cluster/Cluster.js");
var import_TlvArray = require("../tlv/TlvArray.js");
var import_TlvObject = require("../tlv/TlvObject.js");
var import_TlvString = require("../tlv/TlvString.js");
var import_TlvNumber = require("../tlv/TlvNumber.js");
var import_TlvNullable = require("../tlv/TlvNullable.js");
var import_FabricIndex = require("../datatype/FabricIndex.js");
var import_ClusterRegistry = require("../cluster/ClusterRegistry.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
var Messages;
((Messages2) => {
  let Feature;
  ((Feature2) => {
    Feature2["ReceivedConfirmation"] = "ReceivedConfirmation";
    Feature2["ConfirmationResponse"] = "ConfirmationResponse";
    Feature2["ConfirmationReply"] = "ConfirmationReply";
    Feature2["ProtectedMessages"] = "ProtectedMessages";
  })(Feature = Messages2.Feature || (Messages2.Feature = {}));
  let MessagePriority;
  ((MessagePriority2) => {
    MessagePriority2[MessagePriority2["Low"] = 0] = "Low";
    MessagePriority2[MessagePriority2["Medium"] = 1] = "Medium";
    MessagePriority2[MessagePriority2["High"] = 2] = "High";
    MessagePriority2[MessagePriority2["Critical"] = 3] = "Critical";
  })(MessagePriority = Messages2.MessagePriority || (Messages2.MessagePriority = {}));
  Messages2.MessageControl = {
    /**
     * Message requires confirmation from user
     *
     * This bit shall indicate that the message originator requests a confirmation of receipt by the user. If
     * confirmation is required, the device SHOULD present the message until it is either confirmed by the user
     * selecting a confirmation option, or the message expires.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.16.5.2.1
     */
    confirmationRequired: (0, import_BitmapSchema.BitFlag)(0),
    /**
     * Message requires response from user
     *
     * This bit shall indicate that a MessagePresented event SHOULD be generated based on the response of the user
     * to the message.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.16.5.2.2
     */
    responseRequired: (0, import_BitmapSchema.BitFlag)(1),
    /**
     * Message supports reply message from user
     *
     * This bit shall indicate that a free-form user reply is to be included in the confirmation of receipt.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.16.5.2.3
     */
    replyMessage: (0, import_BitmapSchema.BitFlag)(2),
    /**
     * Message has already been confirmed
     *
     * This bit shall indicate the current confirmation state of a message, which is useful in the event that there
     * are multiple Messages cluster client devices on a network.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.16.5.2.4
     */
    messageConfirmed: (0, import_BitmapSchema.BitFlag)(3),
    /**
     * Message required PIN/password protection
     *
     * This bit shall indicate that user authentication (e.g. by password or PIN) is required before viewing a
     * message.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.16.5.2.5
     */
    messageProtected: (0, import_BitmapSchema.BitFlag)(4)
  };
  Messages2.TlvMessageResponseOption = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate a unique unsigned 32-bit number identifier for this message response option.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.16.5.6.1
     */
    messageResponseId: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt32.bound({ min: 1 })),
    /**
     * This field shall indicate the text for this option; e.g. "Yes", "No", etc.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.16.5.6.2
     */
    label: (0, import_TlvObject.TlvField)(1, import_TlvString.TlvString.bound({ maxLength: 32 }))
  });
  Messages2.TlvMessage = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate a globally unique ID for this message.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.16.5.5.1
     */
    messageId: (0, import_TlvObject.TlvField)(0, import_TlvString.TlvByteString.bound({ length: 16 })),
    /**
     * This field shall indicate the priority level for this message.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.16.5.5.2
     */
    priority: (0, import_TlvObject.TlvField)(1, (0, import_TlvNumber.TlvEnum)()),
    /**
     * This field shall indicate control information related to the message.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.16.5.5.3
     */
    messageControl: (0, import_TlvObject.TlvField)(2, (0, import_TlvNumber.TlvBitmap)(import_TlvNumber.TlvUInt16, Messages2.MessageControl)),
    /**
     * This field shall indicate the time in UTC at which the message becomes available to be presented. A null
     * value shall indicate "now."
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.16.5.5.4
     */
    startTime: (0, import_TlvObject.TlvField)(3, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvEpochS)),
    /**
     * This field shall indicate the amount of time, in milliseconds, after the StartTime during which the message
     * is available to be presented. A null value shall indicate "until changed".
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.16.5.5.5
     */
    duration: (0, import_TlvObject.TlvField)(4, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt64)),
    /**
     * This field shall indicate a string containing the message to be presented.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.16.5.5.6
     */
    messageText: (0, import_TlvObject.TlvField)(5, import_TlvString.TlvString.bound({ maxLength: 256 })),
    /**
     * This field shall indicate a list of potential responses to the message. The entries in this list shall have
     * unique values of MessageResponseID.
     *
     * If the ResponseRequired bit is set on the message but this list is empty, the device shall provide a generic
     * acknowledgement button, e.g. "OK".
     *
     * If the ResponseRequired bit is not set on the message, this list shall be ignored.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.16.5.5.7
     */
    responses: (0, import_TlvObject.TlvOptionalField)(6, (0, import_TlvArray.TlvArray)(Messages2.TlvMessageResponseOption, { maxLength: 4 })),
    fabricIndex: (0, import_TlvObject.TlvField)(254, import_FabricIndex.TlvFabricIndex)
  });
  Messages2.TlvPresentMessagesRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate a globally unique ID for this message. See MessageID.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.16.7.1.1
     */
    messageId: (0, import_TlvObject.TlvField)(0, import_TlvString.TlvByteString.bound({ length: 16 })),
    /**
     * This field shall indicate the priority level for this message. See Priority.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.16.7.1.2
     */
    priority: (0, import_TlvObject.TlvField)(1, (0, import_TlvNumber.TlvEnum)()),
    /**
     * This field shall indicate control information related to the message. See MessageControl.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.16.7.1.3
     */
    messageControl: (0, import_TlvObject.TlvField)(2, (0, import_TlvNumber.TlvBitmap)(import_TlvNumber.TlvUInt16, Messages2.MessageControl)),
    /**
     * This field shall indicate the time in UTC at which the message becomes available to be presented. A null
     * value shall indicate "now." See StartTime.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.16.7.1.4
     */
    startTime: (0, import_TlvObject.TlvField)(3, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvEpochS)),
    /**
     * This field shall indicate the amount of time, in milliseconds, after the StartTime during which the message
     * is available to be presented. A null value shall indicate "until changed". See Duration.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.16.7.1.5
     */
    duration: (0, import_TlvObject.TlvField)(4, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt64)),
    /**
     * This field shall indicate a string containing the message to be presented. See MessageText.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.16.7.1.6
     */
    messageText: (0, import_TlvObject.TlvField)(5, import_TlvString.TlvString.bound({ maxLength: 256 })),
    /**
     * This field shall indicate a list of potential responses to the message. The entries in this list shall have
     * unique values of MessageResponseID.
     *
     * If the ResponseRequired bit is set on the message but this list is empty, the device shall provide a generic
     * acknowledgement button, e.g. "OK".
     *
     * If the ResponseRequired bit is not set on the message, this list shall be ignored. See Responses.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.16.7.1.7
     */
    responses: (0, import_TlvObject.TlvOptionalField)(6, (0, import_TlvArray.TlvArray)(Messages2.TlvMessageResponseOption, { maxLength: 4 }))
  });
  Messages2.TlvCancelMessagesRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the MessageIDs for the messages being cancelled.
     *
     * Cancelling a message shall cause it to be removed from Messages, cause its MessageID to be removed from
     * ActiveMessageIDs and cause any active presentation of the message to cease.
     *
     * Message IDs in this command that indicate messages that do not exist in Messages, or that are not scoped to
     * the fabric of the sender, shall be ignored.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.16.7.2.1
     */
    messageIDs: (0, import_TlvObject.TlvField)(0, (0, import_TlvArray.TlvArray)(import_TlvString.TlvByteString.bound({ length: 16 }), { maxLength: 8 }))
  });
  Messages2.TlvMessageQueuedEvent = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the MessageID for newly added message.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.16.8.1.1
     */
    messageId: (0, import_TlvObject.TlvField)(0, import_TlvString.TlvByteString.bound({ length: 16 })),
    fabricIndex: (0, import_TlvObject.TlvField)(254, import_FabricIndex.TlvFabricIndex)
  });
  Messages2.TlvMessagePresentedEvent = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the MessageID for the message being presented.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.16.8.2.1
     */
    messageId: (0, import_TlvObject.TlvField)(0, import_TlvString.TlvByteString.bound({ length: 16 })),
    fabricIndex: (0, import_TlvObject.TlvField)(254, import_FabricIndex.TlvFabricIndex)
  });
  let FutureMessagePreference;
  ((FutureMessagePreference2) => {
    FutureMessagePreference2[FutureMessagePreference2["Allowed"] = 0] = "Allowed";
    FutureMessagePreference2[FutureMessagePreference2["Increased"] = 1] = "Increased";
    FutureMessagePreference2[FutureMessagePreference2["Reduced"] = 2] = "Reduced";
    FutureMessagePreference2[FutureMessagePreference2["Disallowed"] = 3] = "Disallowed";
    FutureMessagePreference2[FutureMessagePreference2["Banned"] = 4] = "Banned";
  })(FutureMessagePreference = Messages2.FutureMessagePreference || (Messages2.FutureMessagePreference = {}));
  Messages2.TlvMessageCompleteEvent = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the MessageID for the message being confirmed.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.16.8.3.1
     */
    messageId: (0, import_TlvObject.TlvField)(0, import_TlvString.TlvByteString.bound({ length: 16 })),
    /**
     * This field shall indicate the MessageResponseID selected by the user. If there was no response before the
     * Duration of the message has elapsed, this field shall be null.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.16.8.3.2
     */
    responseId: (0, import_TlvObject.TlvOptionalField)(1, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt32)),
    /**
     * This field shall indicate a user-provided reply to the message. If there was no reply, or the message did not
     * have the ReplyRequired bit set, this field shall be null.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.16.8.3.3
     */
    reply: (0, import_TlvObject.TlvOptionalField)(2, (0, import_TlvNullable.TlvNullable)(import_TlvString.TlvString.bound({ maxLength: 256 }))),
    futureMessagesPreference: (0, import_TlvObject.TlvField)(3, (0, import_TlvNullable.TlvNullable)((0, import_TlvNumber.TlvEnum)())),
    fabricIndex: (0, import_TlvObject.TlvField)(254, import_FabricIndex.TlvFabricIndex)
  });
  Messages2.Base = import_MutableCluster.MutableCluster.Component({
    id: 151,
    name: "Messages",
    revision: 3,
    features: {
      /**
       * ReceivedConfirmation
       *
       * This feature shall indicate that the device can get confirmation from a user that the message was
       * received.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.16.4.1
       */
      receivedConfirmation: (0, import_BitmapSchema.BitFlag)(0),
      /**
       * ConfirmationResponse
       *
       * This feature shall indicate that the device is capable of presenting a list of responses to the user and
       * recording the user’s choice of response.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.16.4.2
       */
      confirmationResponse: (0, import_BitmapSchema.BitFlag)(1),
      /**
       * ConfirmationReply
       *
       * This feature shall indicate that the device is capable of collecting a free-form text response to a
       * message.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.16.4.3
       */
      confirmationReply: (0, import_BitmapSchema.BitFlag)(2),
      /**
       * ProtectedMessages
       *
       * This feature shall indicate that the device is capable of requiring the user to authenticate before
       * viewing a message; e.g. entering a PIN or password before viewing a message with billing information.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.16.4.4
       */
      protectedMessages: (0, import_BitmapSchema.BitFlag)(3)
    },
    attributes: {
      /**
       * Indicates a list of queued messages.
       *
       * In addition to filtering based upon fabric, to preserve user privacy, the server may further limit the
       * set of messages returned in a read request. At minimum, the server shall return to a client those
       * messages that the client itself created/submitted.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.16.6.1
       */
      messages: (0, import_Cluster.FabricScopedAttribute)(0, (0, import_TlvArray.TlvArray)(Messages2.TlvMessage, { maxLength: 8 }), { default: [] }),
      /**
       * Indicates a list of the MessageIDs of the Messages currently being presented. If this list is empty, no
       * messages are currently being presented.
       *
       * This list shall NOT be fabric-scoped; it shall contain MessageIDs for all Messages being presented, no
       * matter what fabric the client that queued them is on.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.16.6.2
       */
      activeMessageIDs: (0, import_Cluster.Attribute)(
        1,
        (0, import_TlvArray.TlvArray)(import_TlvString.TlvByteString.bound({ length: 16 }), { maxLength: 8 }),
        { default: [] }
      )
    },
    commands: {
      /**
       * Upon receipt, this shall cause the message in the passed fields to be appended to the Messages attribute.
       *
       * If appending the message would cause the number of messages to be greater than the capacity of the list,
       * the device shall NOT append any message to Messages, and shall return a status code of
       * RESOURCE_EXHAUSTED.
       *
       * When displaying a message in response to this command, an indication (ex. visual) of the origin node of
       * the command shall be provided. This could be in the form of a friendly name label which uniquely
       * identifies the node to the user. This friendly name label is typically assigned by the Matter Admin at
       * the time of commissioning and, when it’s a device, is often editable by the user. It might be a
       * combination of a company name and friendly name, for example, ”Acme” or “Acme Streaming Service on
       * Alice’s Phone”.
       *
       * NOTE
       *
       * It is currently not specified where the friendly name label can be found on the node, meaning that
       * clients SHOULD NOT rely on a certain method they happen to observe in a particular server instance, since
       * other instances could employ a different method.
       *
       * The device SHOULD make it possible for the user to view which nodes have access to this cluster and to
       * individually remove privileges for each node.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.16.7.1
       */
      presentMessagesRequest: (0, import_Cluster.Command)(0, Messages2.TlvPresentMessagesRequest, 0, import_Cluster.TlvNoResponse),
      /**
       * @see {@link MatterSpecification.v14.Cluster} § 1.16.7.2
       */
      cancelMessagesRequest: (0, import_Cluster.Command)(1, Messages2.TlvCancelMessagesRequest, 1, import_Cluster.TlvNoResponse)
    },
    events: {
      /**
       * This event shall be generated when a message is added to the messages attribute.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.16.8.1
       */
      messageQueued: (0, import_Cluster.Event)(0, import_Cluster.EventPriority.Info, Messages2.TlvMessageQueuedEvent),
      /**
       * This event shall be generated when the message is presented to the user.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.16.8.2
       */
      messagePresented: (0, import_Cluster.Event)(1, import_Cluster.EventPriority.Info, Messages2.TlvMessagePresentedEvent),
      /**
       * This event shall be generated when the message is confirmed by the user, or when the Duration of the
       * message has elapsed without confirmation.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.16.8.3
       */
      messageComplete: (0, import_Cluster.Event)(2, import_Cluster.EventPriority.Info, Messages2.TlvMessageCompleteEvent)
    },
    /**
     * This metadata controls which MessagesCluster elements matter.js activates for specific feature combinations.
     */
    extensions: import_MutableCluster.MutableCluster.Extensions(
      { flags: { confirmationResponse: true, receivedConfirmation: false }, component: false },
      { flags: { confirmationReply: true, receivedConfirmation: false }, component: false }
    )
  });
  Messages2.ClusterInstance = (0, import_MutableCluster.MutableCluster)(Messages2.Base);
  Messages2.Cluster = Messages2.ClusterInstance;
  Messages2.Complete = Messages2.Cluster;
})(Messages || (Messages = {}));
const MessagesCluster = Messages.Cluster;
import_ClusterRegistry.ClusterRegistry.register(Messages.Complete);
//# sourceMappingURL=messages.js.map
