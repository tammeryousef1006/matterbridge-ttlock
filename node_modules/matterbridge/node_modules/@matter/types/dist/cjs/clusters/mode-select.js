"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var mode_select_exports = {};
__export(mode_select_exports, {
  ModeSelect: () => ModeSelect,
  ModeSelectCluster: () => ModeSelectCluster
});
module.exports = __toCommonJS(mode_select_exports);
var import_MutableCluster = require("../cluster/mutation/MutableCluster.js");
var import_Cluster = require("../cluster/Cluster.js");
var import_TlvNumber = require("../tlv/TlvNumber.js");
var import_TlvNullable = require("../tlv/TlvNullable.js");
var import_BitmapSchema = require("../schema/BitmapSchema.js");
var import_TlvString = require("../tlv/TlvString.js");
var import_TlvArray = require("../tlv/TlvArray.js");
var import_TlvObject = require("../tlv/TlvObject.js");
var import_VendorId = require("../datatype/VendorId.js");
var import_ClusterRegistry = require("../cluster/ClusterRegistry.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
var ModeSelect;
((ModeSelect2) => {
  let Feature;
  ((Feature2) => {
    Feature2["OnOff"] = "OnOff";
  })(Feature = ModeSelect2.Feature || (ModeSelect2.Feature = {}));
  ModeSelect2.TlvSemanticTag = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate a manufacturer code (Vendor ID), and the Value field shall indicate a semantic tag
     * defined by the manufacturer. Each manufacturer code supports a single namespace of values. The same
     * manufacturer code and semantic tag value in separate cluster instances are part of the same namespace and
     * have the same meaning. For example: a manufacturer tag meaning "pinch", has the same meaning in a cluster
     * whose purpose is to choose the amount of sugar, or amount of salt.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.9.5.1.2
     */
    mfgCode: (0, import_TlvObject.TlvField)(0, import_VendorId.TlvVendorId),
    /**
     * This field shall indicate the semantic tag within a semantic tag namespace which is either manufacturer
     * specific or standard. For semantic tags in a standard namespace, see Standard Namespace.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.9.5.1.1
     */
    value: (0, import_TlvObject.TlvField)(1, import_TlvNumber.TlvUInt16)
  });
  ModeSelect2.TlvModeOption = (0, import_TlvObject.TlvObject)({
    /**
     * This field is readable text that describes the mode option that can be used by a client to indicate to the
     * user what this option means. This field is meant to be readable and understandable by the user.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.9.5.2.1
     */
    label: (0, import_TlvObject.TlvField)(0, import_TlvString.TlvString.bound({ maxLength: 64 })),
    /**
     * The Mode field is used to identify the mode option. The value shall be unique for every item in the
     * SupportedModes attribute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.9.5.2.2
     */
    mode: (0, import_TlvObject.TlvField)(1, import_TlvNumber.TlvUInt8),
    /**
     * This field is a list of semantic tags that map to the mode option. This may be used by clients to determine
     * the meaning of the mode option as defined in a standard or manufacturer specific namespace. Semantic tags can
     * help clients look for options that meet certain criteria. A semantic tag shall be either a standard tag or
     * manufacturer specific tag as defined in each SemanticTagStruct list entry.
     *
     * A mode option may have more than one semantic tag. A mode option may be mapped to a mixture of standard and
     * manufacturer specific semantic tags.
     *
     * All standard semantic tags are from a single namespace indicated by the StandardNamespace attribute.
     *
     * For example: A mode labeled "100%" can have both the HIGH (MS) and MAX (standard) semantic tag. Clients
     * seeking the option for either HIGH or MAX will find the same option in this case.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.9.5.2.3
     */
    semanticTags: (0, import_TlvObject.TlvField)(2, (0, import_TlvArray.TlvArray)(ModeSelect2.TlvSemanticTag, { maxLength: 64 }))
  });
  ModeSelect2.TlvChangeToModeRequest = (0, import_TlvObject.TlvObject)({ newMode: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt8) });
  ModeSelect2.OnOffComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * Indicates the value of CurrentMode that depends on the state of the On/Off cluster on the same endpoint.
       * If this attribute is not present or is set to null, it shall NOT have an effect, otherwise the
       * CurrentMode attribute shall depend on the OnOff attribute of the On/Off cluster
       *
       * The value of this field shall match the Mode field of one of the entries in the SupportedModes
       *
       * attribute.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.9.6.6
       */
      onMode: (0, import_Cluster.WritableAttribute)(5, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt8), { persistent: true, default: null })
    }
  });
  ModeSelect2.Base = import_MutableCluster.MutableCluster.Component({
    id: 80,
    name: "ModeSelect",
    revision: 2,
    features: {
      /**
       * OnOff
       *
       * This feature creates a dependency between an OnOff cluster instance and this cluster instance on the same
       * endpoint. See OnMode for more information.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.9.4.1
       */
      onOff: (0, import_BitmapSchema.BitFlag)(0)
    },
    attributes: {
      /**
       * This attribute describes the purpose of the server, in readable text.
       *
       * For example, a coffee machine may have a Mode Select cluster for the amount of milk to add, and another
       * Mode Select cluster for the amount of sugar to add. In this case, the first instance can have the
       * description Milk and the second instance can have the description Sugar. This allows the user to tell the
       * purpose of each of the instances.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.9.6.1
       */
      description: (0, import_Cluster.FixedAttribute)(0, import_TlvString.TlvString.bound({ maxLength: 64 })),
      /**
       * This attribute, when not null, shall indicate a single standard namespace for any standard semantic tag
       * value supported in this or any other cluster instance with the same value of this attribute. A null value
       * indicates no standard namespace, and therefore, no standard semantic tags are provided in this cluster
       * instance. Each standard namespace and corresponding values and value meanings shall be defined in another
       * document.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.9.6.2
       */
      standardNamespace: (0, import_Cluster.FixedAttribute)(1, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt16), { default: null }),
      /**
       * This attribute is the list of supported modes that may be selected for the CurrentMode attribute. Each
       * item in this list represents a unique mode as indicated by the Mode field of the ModeOptionStruct. Each
       * entry in this list shall have a unique value for the Mode field.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.9.6.3
       */
      supportedModes: (0, import_Cluster.FixedAttribute)(2, (0, import_TlvArray.TlvArray)(ModeSelect2.TlvModeOption, { maxLength: 255 }), { default: [] }),
      /**
       * This attribute represents the current mode of the server.
       *
       * The value of this field must match the Mode field of one of the entries in the SupportedModes
       *
       * attribute.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.9.6.4
       */
      currentMode: (0, import_Cluster.Attribute)(3, import_TlvNumber.TlvUInt8, { persistent: true }),
      /**
       * The StartUpMode attribute value indicates the desired startup mode for the server when it is supplied
       * with power.
       *
       * If this attribute is not null, the CurrentMode attribute shall be set to the StartUpMode value, when the
       * server is powered up, except in the case when the OnMode attribute overrides the StartUpMode attribute
       * (see OnModeWithPowerUp).
       *
       * This behavior does not apply to reboots associated with OTA. After an OTA restart, the CurrentMode
       * attribute shall return to its value prior to the restart.
       *
       * The value of this field shall match the Mode field of one of the entries in the SupportedModes
       *
       * attribute.
       *
       * If this attribute is not implemented, or is set to the null value, it shall have no effect.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.9.6.5
       */
      startUpMode: (0, import_Cluster.OptionalWritableAttribute)(4, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt8), { persistent: true })
    },
    commands: {
      /**
       * On receipt of this command, if the NewMode field indicates a valid mode transition within the supported
       * list, the server shall set the CurrentMode attribute to the NewMode value, otherwise, the server shall
       * respond with an INVALID_COMMAND status response.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.9.7.1
       */
      changeToMode: (0, import_Cluster.Command)(0, ModeSelect2.TlvChangeToModeRequest, 0, import_Cluster.TlvNoResponse)
    },
    /**
     * This metadata controls which ModeSelectCluster elements matter.js activates for specific feature
     * combinations.
     */
    extensions: import_MutableCluster.MutableCluster.Extensions({ flags: { onOff: true }, component: ModeSelect2.OnOffComponent })
  });
  ModeSelect2.ClusterInstance = (0, import_MutableCluster.MutableCluster)(ModeSelect2.Base);
  ModeSelect2.Cluster = ModeSelect2.ClusterInstance;
  const DEPONOFF = { onOff: true };
  ModeSelect2.CompleteInstance = (0, import_MutableCluster.MutableCluster)({
    id: ModeSelect2.Cluster.id,
    name: ModeSelect2.Cluster.name,
    revision: ModeSelect2.Cluster.revision,
    features: ModeSelect2.Cluster.features,
    attributes: {
      ...ModeSelect2.Cluster.attributes,
      onMode: import_MutableCluster.MutableCluster.AsConditional(ModeSelect2.OnOffComponent.attributes.onMode, { mandatoryIf: [DEPONOFF] })
    },
    commands: ModeSelect2.Cluster.commands
  });
  ModeSelect2.Complete = ModeSelect2.CompleteInstance;
})(ModeSelect || (ModeSelect = {}));
const ModeSelectCluster = ModeSelect.Cluster;
import_ClusterRegistry.ClusterRegistry.register(ModeSelect.Complete);
//# sourceMappingURL=mode-select.js.map
