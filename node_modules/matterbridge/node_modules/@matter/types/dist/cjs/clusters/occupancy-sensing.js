"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var occupancy_sensing_exports = {};
__export(occupancy_sensing_exports, {
  OccupancySensing: () => OccupancySensing,
  OccupancySensingCluster: () => OccupancySensingCluster
});
module.exports = __toCommonJS(occupancy_sensing_exports);
var import_MutableCluster = require("../cluster/mutation/MutableCluster.js");
var import_Cluster = require("../cluster/Cluster.js");
var import_TlvNumber = require("../tlv/TlvNumber.js");
var import_model = require("#model");
var import_BitmapSchema = require("../schema/BitmapSchema.js");
var import_TlvObject = require("../tlv/TlvObject.js");
var import_ClusterRegistry = require("../cluster/ClusterRegistry.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
var OccupancySensing;
((OccupancySensing2) => {
  let Feature;
  ((Feature2) => {
    Feature2["Other"] = "Other";
    Feature2["PassiveInfrared"] = "PassiveInfrared";
    Feature2["Ultrasonic"] = "Ultrasonic";
    Feature2["PhysicalContact"] = "PhysicalContact";
    Feature2["ActiveInfrared"] = "ActiveInfrared";
    Feature2["Radar"] = "Radar";
    Feature2["RfSensing"] = "RfSensing";
    Feature2["Vision"] = "Vision";
  })(Feature = OccupancySensing2.Feature || (OccupancySensing2.Feature = {}));
  OccupancySensing2.Occupancy = {
    /**
     * Indicates the sensed occupancy state
     *
     * If this bit is set, it shall indicate the occupied state else if the bit if not set, it shall indicate the
     * unoccupied state.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 2.7.5.1.1
     */
    occupied: (0, import_BitmapSchema.BitFlag)(0)
  };
  let OccupancySensorType;
  ((OccupancySensorType2) => {
    OccupancySensorType2[OccupancySensorType2["Pir"] = 0] = "Pir";
    OccupancySensorType2[OccupancySensorType2["Ultrasonic"] = 1] = "Ultrasonic";
    OccupancySensorType2[OccupancySensorType2["PirAndUltrasonic"] = 2] = "PirAndUltrasonic";
    OccupancySensorType2[OccupancySensorType2["PhysicalContact"] = 3] = "PhysicalContact";
  })(OccupancySensorType = OccupancySensing2.OccupancySensorType || (OccupancySensing2.OccupancySensorType = {}));
  OccupancySensing2.OccupancySensorTypeBitmap = {
    /**
     * Indicates a passive infrared sensor.
     */
    pir: (0, import_BitmapSchema.BitFlag)(0),
    /**
     * Indicates a ultrasonic sensor.
     */
    ultrasonic: (0, import_BitmapSchema.BitFlag)(1),
    /**
     * Indicates a physical contact sensor.
     */
    physicalContact: (0, import_BitmapSchema.BitFlag)(2)
  };
  OccupancySensing2.TlvHoldTimeLimits = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall specify the minimum value of the server’s supported value for the HoldTime attribute, in
     * seconds.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 2.7.5.4.1
     */
    holdTimeMin: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt16.bound({ min: 1 })),
    /**
     * This field shall specify the maximum value of the server’s supported value for the HoldTime attribute, in
     * seconds.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 2.7.5.4.2
     */
    holdTimeMax: (0, import_TlvObject.TlvField)(1, import_TlvNumber.TlvUInt16),
    /**
     * This field shall specify the (manufacturer-determined) default value of the server’s HoldTime attribute, in
     * seconds. This is the value that a client who wants to reset the settings to a valid default SHOULD use.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 2.7.5.4.3
     */
    holdTimeDefault: (0, import_TlvObject.TlvField)(2, import_TlvNumber.TlvUInt16)
  });
  OccupancySensing2.TlvOccupancyChangedEvent = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the new value of the Occupancy attribute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 2.7.7.1.1
     */
    occupancy: (0, import_TlvObject.TlvField)(0, (0, import_TlvNumber.TlvBitmap)(import_TlvNumber.TlvUInt8, OccupancySensing2.Occupancy))
  });
  OccupancySensing2.PassiveInfraredComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * This attribute shall specify the time delay, in seconds, before the PIR sensor changes to its unoccupied
       * state after the last detection of occupancy in the sensed area.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.7.6.6
       */
      pirOccupiedToUnoccupiedDelay: (0, import_Cluster.OptionalWritableAttribute)(
        16,
        import_TlvNumber.TlvUInt16,
        { persistent: true, default: 0, writeAcl: import_model.AccessLevel.Manage }
      ),
      /**
       * This attribute shall specify the time delay, in seconds, before the PIR sensor changes to its occupied
       * state after the first detection of occupancy in the sensed area.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.7.6.7
       */
      pirUnoccupiedToOccupiedDelay: (0, import_Cluster.OptionalWritableAttribute)(
        17,
        import_TlvNumber.TlvUInt16,
        { persistent: true, default: 0, writeAcl: import_model.AccessLevel.Manage }
      ),
      /**
       * This attribute shall specify the number of occupancy detection events that must occur in the period
       * PIRUnoccupiedToOccupiedDelay, before the PIR sensor changes to its occupied state.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.7.6.8
       */
      pirUnoccupiedToOccupiedThreshold: (0, import_Cluster.OptionalWritableAttribute)(
        18,
        import_TlvNumber.TlvUInt8.bound({ min: 1, max: 254 }),
        { persistent: true, default: 1, writeAcl: import_model.AccessLevel.Manage }
      )
    }
  });
  OccupancySensing2.UltrasonicComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * This attribute shall specify the time delay, in seconds, before the Ultrasonic sensor changes to its
       * unoccupied state after the last detection of occupancy in the sensed area.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.7.6.9
       */
      ultrasonicOccupiedToUnoccupiedDelay: (0, import_Cluster.OptionalWritableAttribute)(
        32,
        import_TlvNumber.TlvUInt16,
        { persistent: true, default: 0, writeAcl: import_model.AccessLevel.Manage }
      ),
      /**
       * This attribute shall specify the time delay, in seconds, before the Ultrasonic sensor changes to its
       * occupied state after the first detection of occupancy in the sensed area.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.7.6.10
       */
      ultrasonicUnoccupiedToOccupiedDelay: (0, import_Cluster.OptionalWritableAttribute)(
        33,
        import_TlvNumber.TlvUInt16,
        { persistent: true, default: 0, writeAcl: import_model.AccessLevel.Manage }
      ),
      /**
       * This attribute shall specify the number of occupancy detection events that must occur in the period
       * UltrasonicUnoccupiedToOccupiedDelay, before the Ultrasonic sensor changes to its occupied state.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.7.6.11
       */
      ultrasonicUnoccupiedToOccupiedThreshold: (0, import_Cluster.OptionalWritableAttribute)(
        34,
        import_TlvNumber.TlvUInt8.bound({ min: 1, max: 254 }),
        { persistent: true, default: 1, writeAcl: import_model.AccessLevel.Manage }
      )
    }
  });
  OccupancySensing2.PhysicalContactComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * This attribute shall specify the time delay, in seconds, before the physical contact occupancy sensor
       * changes to its unoccupied state after detecting the unoccupied event.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.7.6.12
       */
      physicalContactOccupiedToUnoccupiedDelay: (0, import_Cluster.OptionalWritableAttribute)(
        48,
        import_TlvNumber.TlvUInt16,
        { persistent: true, default: 0, writeAcl: import_model.AccessLevel.Manage }
      ),
      /**
       * This attribute shall specify the time delay, in seconds, before the physical contact sensor changes to
       * its occupied state after the first detection of the occupied event.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.7.6.13
       */
      physicalContactUnoccupiedToOccupiedDelay: (0, import_Cluster.OptionalWritableAttribute)(
        49,
        import_TlvNumber.TlvUInt16,
        { persistent: true, default: 0, writeAcl: import_model.AccessLevel.Manage }
      ),
      /**
       * This attribute shall specify the number of occupancy detection events that must occur in the period
       * PhysicalContactUnoccupiedToOccupiedDelay, before the PhysicalContact sensor changes to its occupied
       * state.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.7.6.14
       */
      physicalContactUnoccupiedToOccupiedThreshold: (0, import_Cluster.OptionalWritableAttribute)(
        50,
        import_TlvNumber.TlvUInt8.bound({ min: 1, max: 254 }),
        { persistent: true, default: 1, writeAcl: import_model.AccessLevel.Manage }
      )
    }
  });
  OccupancySensing2.Base = import_MutableCluster.MutableCluster.Component({
    id: 1030,
    name: "OccupancySensing",
    revision: 5,
    features: {
      /**
       * Other
       *
       * Supports sensing using a modality not listed in the other bits
       */
      other: (0, import_BitmapSchema.BitFlag)(0),
      /**
       * PassiveInfrared
       *
       * Supports sensing using PIR (Passive InfraRed)
       */
      passiveInfrared: (0, import_BitmapSchema.BitFlag)(1),
      /**
       * Ultrasonic
       *
       * Supports sensing using UltraSound
       */
      ultrasonic: (0, import_BitmapSchema.BitFlag)(2),
      /**
       * PhysicalContact
       *
       * Supports sensing using a physical contact
       */
      physicalContact: (0, import_BitmapSchema.BitFlag)(3),
      /**
       * ActiveInfrared
       *
       * Supports sensing using Active InfraRed measurement (e.g. time-of- flight or transflective/reflective IR
       * sensing)
       */
      activeInfrared: (0, import_BitmapSchema.BitFlag)(4),
      /**
       * Radar
       *
       * Supports sensing using radar waves (microwave)
       */
      radar: (0, import_BitmapSchema.BitFlag)(5),
      /**
       * RfSensing
       *
       * Supports sensing based on RF signal analysis
       */
      rfSensing: (0, import_BitmapSchema.BitFlag)(6),
      /**
       * Vision
       *
       * Supports sensing based on analyzing images
       */
      vision: (0, import_BitmapSchema.BitFlag)(7)
    },
    attributes: {
      /**
       * Indicates the sensed (processed) status of occupancy. For compatibility reasons this is expressed as a
       * bitmap where the status is indicated in bit 0: a value of 1 means occupied, and 0 means unoccupied, with
       * the other bits set to 0; this can be considered equivalent to a boolean.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.7.6.1
       */
      occupancy: (0, import_Cluster.Attribute)(0, (0, import_TlvNumber.TlvBitmap)(import_TlvNumber.TlvUInt8, OccupancySensing2.Occupancy)),
      /**
       * @see {@link MatterSpecification.v14.Cluster} § 2.7.6
       */
      occupancySensorType: (0, import_Cluster.FixedAttribute)(1, (0, import_TlvNumber.TlvEnum)()),
      /**
       * @see {@link MatterSpecification.v14.Cluster} § 2.7.6
       */
      occupancySensorTypeBitmap: (0, import_Cluster.FixedAttribute)(2, (0, import_TlvNumber.TlvBitmap)(import_TlvNumber.TlvUInt8, OccupancySensing2.OccupancySensorTypeBitmap)),
      /**
       * This attribute shall specify the time delay, in seconds, before the sensor changes to its unoccupied
       * state after the last detection of occupancy in the sensed area. This is equivalent to the legacy
       * *OccupiedToUnoccupiedDelay attributes.
       *
       * The value of HoldTime shall be within the limits provided in the HoldTimeLimits attribute, i.e.
       * HoldTimeMin <= HoldTime <= HoldTimeMax
       *
       * Low values of HoldTime SHOULD be avoided since they could lead to many reporting messages. A value 0 for
       * HoldTime shall NOT be used.
       *
       * The figure below illustrates this with an example of how this attribute is used for a PIR sensor. It uses
       * threshold detection to generate an "internal detection" signal, which needs post-processing to become
       * usable for transmission (traffic shaping). The bit in the Occupancy attribute will be set to 1 when the
       * internal detection signal goes high, and will stay at 1 for HoldTime after the (last) instance where the
       * internal detection signal goes low.
       *
       * The top half of the figure shows the case of a single trigger: the bit in the Occupancy attribute will be
       * 1 for the duration of the PIR signal exceeding the threshold plus HoldTime. The bottom half of the figure
       * shows the case of multiple triggers: the second trigger starts before the HoldTime of the first trigger
       * has expired; this results in a single period of the bit in the Occupancy attribute being 1. The bit in
       * the Occupancy attribute will be set to 1 from the start of the first period where the PIR signal exceeds
       * the threshold until HoldTime after the last moment where the PIR exceeded the threshold.
       *
       * Figure 13. Processing of PIR signal towards Occupancy attribute using HoldTime
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.7.6.3
       */
      holdTime: (0, import_Cluster.OptionalWritableAttribute)(3, import_TlvNumber.TlvUInt16, { persistent: true, writeAcl: import_model.AccessLevel.Manage }),
      /**
       * Indicates the server’s limits, and default value, for the HoldTime attribute.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.7.6.4
       */
      holdTimeLimits: (0, import_Cluster.OptionalFixedAttribute)(4, OccupancySensing2.TlvHoldTimeLimits)
    },
    events: {
      /**
       * If this event is supported, it shall be generated when the Occupancy attribute changes.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.7.7.1
       */
      occupancyChanged: (0, import_Cluster.OptionalEvent)(0, import_Cluster.EventPriority.Info, OccupancySensing2.TlvOccupancyChangedEvent)
    },
    /**
     * This metadata controls which OccupancySensingCluster elements matter.js activates for specific feature
     * combinations.
     */
    extensions: import_MutableCluster.MutableCluster.Extensions(
      { flags: { passiveInfrared: true }, component: OccupancySensing2.PassiveInfraredComponent },
      { flags: { ultrasonic: true }, component: OccupancySensing2.UltrasonicComponent },
      { flags: { physicalContact: true }, component: OccupancySensing2.PhysicalContactComponent },
      {
        flags: {
          other: false,
          passiveInfrared: false,
          ultrasonic: false,
          physicalContact: false,
          activeInfrared: false,
          radar: false,
          rfSensing: false,
          vision: false
        },
        component: false
      }
    )
  });
  OccupancySensing2.ClusterInstance = import_MutableCluster.MutableCluster.ExtensibleOnly(OccupancySensing2.Base);
  OccupancySensing2.Cluster = OccupancySensing2.ClusterInstance;
  const PIR = { passiveInfrared: true };
  const US = { ultrasonic: true };
  const PHY = { physicalContact: true };
  OccupancySensing2.CompleteInstance = (0, import_MutableCluster.MutableCluster)({
    id: OccupancySensing2.Base.id,
    name: OccupancySensing2.Base.name,
    revision: OccupancySensing2.Base.revision,
    features: OccupancySensing2.Base.features,
    attributes: {
      ...OccupancySensing2.Base.attributes,
      pirOccupiedToUnoccupiedDelay: import_MutableCluster.MutableCluster.AsConditional(
        OccupancySensing2.PassiveInfraredComponent.attributes.pirOccupiedToUnoccupiedDelay,
        { optionalIf: [PIR] }
      ),
      pirUnoccupiedToOccupiedDelay: import_MutableCluster.MutableCluster.AsConditional(
        OccupancySensing2.PassiveInfraredComponent.attributes.pirUnoccupiedToOccupiedDelay,
        { optionalIf: [PIR] }
      ),
      pirUnoccupiedToOccupiedThreshold: import_MutableCluster.MutableCluster.AsConditional(
        OccupancySensing2.PassiveInfraredComponent.attributes.pirUnoccupiedToOccupiedThreshold,
        { optionalIf: [PIR] }
      ),
      ultrasonicOccupiedToUnoccupiedDelay: import_MutableCluster.MutableCluster.AsConditional(
        OccupancySensing2.UltrasonicComponent.attributes.ultrasonicOccupiedToUnoccupiedDelay,
        { optionalIf: [US] }
      ),
      ultrasonicUnoccupiedToOccupiedDelay: import_MutableCluster.MutableCluster.AsConditional(
        OccupancySensing2.UltrasonicComponent.attributes.ultrasonicUnoccupiedToOccupiedDelay,
        { optionalIf: [US] }
      ),
      ultrasonicUnoccupiedToOccupiedThreshold: import_MutableCluster.MutableCluster.AsConditional(
        OccupancySensing2.UltrasonicComponent.attributes.ultrasonicUnoccupiedToOccupiedThreshold,
        { optionalIf: [US] }
      ),
      physicalContactOccupiedToUnoccupiedDelay: import_MutableCluster.MutableCluster.AsConditional(
        OccupancySensing2.PhysicalContactComponent.attributes.physicalContactOccupiedToUnoccupiedDelay,
        { optionalIf: [PHY] }
      ),
      physicalContactUnoccupiedToOccupiedDelay: import_MutableCluster.MutableCluster.AsConditional(
        OccupancySensing2.PhysicalContactComponent.attributes.physicalContactUnoccupiedToOccupiedDelay,
        { optionalIf: [PHY] }
      ),
      physicalContactUnoccupiedToOccupiedThreshold: import_MutableCluster.MutableCluster.AsConditional(
        OccupancySensing2.PhysicalContactComponent.attributes.physicalContactUnoccupiedToOccupiedThreshold,
        { optionalIf: [PHY] }
      )
    },
    events: OccupancySensing2.Base.events
  });
  OccupancySensing2.Complete = OccupancySensing2.CompleteInstance;
})(OccupancySensing || (OccupancySensing = {}));
const OccupancySensingCluster = OccupancySensing.Cluster;
import_ClusterRegistry.ClusterRegistry.register(OccupancySensing.Complete);
//# sourceMappingURL=occupancy-sensing.js.map
