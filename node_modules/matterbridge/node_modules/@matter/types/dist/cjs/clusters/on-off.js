"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var on_off_exports = {};
__export(on_off_exports, {
  OnOff: () => OnOff,
  OnOffCluster: () => OnOffCluster
});
module.exports = __toCommonJS(on_off_exports);
var import_MutableCluster = require("../cluster/mutation/MutableCluster.js");
var import_Cluster = require("../cluster/Cluster.js");
var import_TlvBoolean = require("../tlv/TlvBoolean.js");
var import_TlvNumber = require("../tlv/TlvNumber.js");
var import_TlvNullable = require("../tlv/TlvNullable.js");
var import_model = require("#model");
var import_TlvObject = require("../tlv/TlvObject.js");
var import_TlvNoArguments = require("../tlv/TlvNoArguments.js");
var import_BitmapSchema = require("../schema/BitmapSchema.js");
var import_ClusterType = require("../cluster/ClusterType.js");
var import_ClusterRegistry = require("../cluster/ClusterRegistry.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
var OnOff;
((OnOff2) => {
  let Feature;
  ((Feature2) => {
    Feature2["Lighting"] = "Lighting";
    Feature2["DeadFrontBehavior"] = "DeadFrontBehavior";
    Feature2["OffOnly"] = "OffOnly";
  })(Feature = OnOff2.Feature || (OnOff2.Feature = {}));
  let StartUpOnOff;
  ((StartUpOnOff2) => {
    StartUpOnOff2[StartUpOnOff2["Off"] = 0] = "Off";
    StartUpOnOff2[StartUpOnOff2["On"] = 1] = "On";
    StartUpOnOff2[StartUpOnOff2["Toggle"] = 2] = "Toggle";
  })(StartUpOnOff = OnOff2.StartUpOnOff || (OnOff2.StartUpOnOff = {}));
  let EffectIdentifier;
  ((EffectIdentifier2) => {
    EffectIdentifier2[EffectIdentifier2["DelayedAllOff"] = 0] = "DelayedAllOff";
    EffectIdentifier2[EffectIdentifier2["DyingLight"] = 1] = "DyingLight";
  })(EffectIdentifier = OnOff2.EffectIdentifier || (OnOff2.EffectIdentifier = {}));
  OnOff2.TlvOffWithEffectRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field specifies the fading effect to use when turning the device off. This field shall contain one of
     * the non-reserved values listed in EffectIdentifierEnum.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.5.7.4.1
     */
    effectIdentifier: (0, import_TlvObject.TlvField)(0, (0, import_TlvNumber.TlvEnum)()),
    /**
     * This field is used to indicate which variant of the effect, indicated in the EffectIdentifier field, SHOULD
     * be triggered. If the server does not support the given variant, it shall use the default variant. This field
     * is dependent on the value of the EffectIdentifier field and shall contain one of the non-reserved values
     * listed in either DelayedAllOffEffectVariantEnum or DyingLightEffectVariantEnum.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.5.7.4.2
     */
    effectVariant: (0, import_TlvObject.TlvField)(1, import_TlvNumber.TlvUInt8)
  });
  OnOff2.OnOffControl = {
    /**
     * Indicates a command is only accepted when in On state.
     */
    acceptOnlyWhenOn: (0, import_BitmapSchema.BitFlag)(0)
  };
  OnOff2.TlvOnWithTimedOffRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field contains information on how the server is to be operated.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.5.7.6.1
     */
    onOffControl: (0, import_TlvObject.TlvField)(0, (0, import_TlvNumber.TlvBitmap)(import_TlvNumber.TlvUInt8, OnOff2.OnOffControl)),
    /**
     * This field is used to adjust the value of the OnTime attribute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.5.7.6.2
     */
    onTime: (0, import_TlvObject.TlvField)(1, import_TlvNumber.TlvUInt16.bound({ max: 65534 })),
    /**
     * This field is used to adjust the value of the OffWaitTime attribute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.5.7.6.3
     */
    offWaitTime: (0, import_TlvObject.TlvField)(2, import_TlvNumber.TlvUInt16.bound({ max: 65534 }))
  });
  let DelayedAllOffEffectVariant;
  ((DelayedAllOffEffectVariant2) => {
    DelayedAllOffEffectVariant2[DelayedAllOffEffectVariant2["DelayedOffFastFade"] = 0] = "DelayedOffFastFade";
    DelayedAllOffEffectVariant2[DelayedAllOffEffectVariant2["NoFade"] = 1] = "NoFade";
    DelayedAllOffEffectVariant2[DelayedAllOffEffectVariant2["DelayedOffSlowFade"] = 2] = "DelayedOffSlowFade";
  })(DelayedAllOffEffectVariant = OnOff2.DelayedAllOffEffectVariant || (OnOff2.DelayedAllOffEffectVariant = {}));
  let DyingLightEffectVariant;
  ((DyingLightEffectVariant2) => {
    DyingLightEffectVariant2[DyingLightEffectVariant2["DyingLightFadeOff"] = 0] = "DyingLightFadeOff";
  })(DyingLightEffectVariant = OnOff2.DyingLightEffectVariant || (OnOff2.DyingLightEffectVariant = {}));
  OnOff2.LightingComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * In order to support the use case where the user gets back the last setting of a set of devices (e.g.
       * level settings for lights), a global scene is introduced which is stored when the devices are turned off
       * and recalled when the devices are turned on. The global scene is defined as the scene that is stored with
       * group identifier 0 and scene identifier 0.
       *
       * This attribute is defined in order to prevent a second Off command storing the all-devices-off situation
       * as a global scene, and to prevent a second On command destroying the current settings by going back to
       * the global scene.
       *
       * This attribute shall be set to TRUE after the reception of a command which causes the OnOff attribute to
       * be set to TRUE, such as a standard On command, a MoveToLevel(WithOnOff) command, a RecallScene command or
       * a OnWithRecallGlobalScene command.
       *
       * This attribute is set to FALSE after reception of a OffWithEffect command.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.5.6.3
       */
      globalSceneControl: (0, import_Cluster.Attribute)(16384, import_TlvBoolean.TlvBoolean, { default: true }),
      /**
       * This attribute specifies the length of time (in 1/10ths second) that the On state shall be maintained
       * before automatically transitioning to the Off state when using the OnWithTimedOff command. This attribute
       * can be written at any time, but writing a value only has effect when in the Timed On state. See
       * OnWithTimedOff for more details.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.5.6.4
       */
      onTime: (0, import_Cluster.WritableAttribute)(16385, import_TlvNumber.TlvUInt16, { default: 0 }),
      /**
       * This attribute specifies the length of time (in 1/10ths second) that the Off state shall be guarded to
       * prevent another OnWithTimedOff command turning the server back to its On state (e.g., when leaving a
       * room, the lights are turned off but an occupancy sensor detects the leaving person and attempts to turn
       * the lights back on). This attribute can be written at any time, but writing a value only has an effect
       * when in the Timed On state followed by a transition to the Delayed Off state, or in the Delayed Off
       * state. See OnWithTimedOff for more details.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.5.6.5
       */
      offWaitTime: (0, import_Cluster.WritableAttribute)(16386, import_TlvNumber.TlvUInt16, { default: 0 }),
      /**
       * This attribute shall define the desired startup behavior of a device when it is supplied with power and
       * this state shall be reflected in the OnOff attribute. If the value is null, the OnOff attribute is set to
       * its previous value. Otherwise, the behavior is defined in the table defining StartUpOnOffEnum.
       *
       * This behavior does not apply to reboots associated with OTA. After an OTA restart, the OnOff attribute
       * shall return to its value prior to the restart.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.5.6.6
       */
      startUpOnOff: (0, import_Cluster.WritableAttribute)(
        16387,
        (0, import_TlvNullable.TlvNullable)((0, import_TlvNumber.TlvEnum)()),
        { persistent: true, writeAcl: import_model.AccessLevel.Manage }
      )
    },
    commands: {
      /**
       * The OffWithEffect command allows devices to be turned off using enhanced ways of fading.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.5.7.4
       */
      offWithEffect: (0, import_Cluster.Command)(64, OnOff2.TlvOffWithEffectRequest, 64, import_Cluster.TlvNoResponse),
      /**
       * This command allows the recall of the settings when the device was turned off.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.5.7.5
       */
      onWithRecallGlobalScene: (0, import_Cluster.Command)(65, import_TlvNoArguments.TlvNoArguments, 65, import_Cluster.TlvNoResponse),
      /**
       * This command allows devices to be turned on for a specific duration with a guarded off duration so that
       * SHOULD the device be subsequently turned off, further OnWithTimedOff commands, received during this time,
       * are prevented from turning the devices back on. Further OnWithTimedOff commands received while the server
       * is turned on, will update the period that the device is turned on.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.5.7.6
       */
      onWithTimedOff: (0, import_Cluster.Command)(66, OnOff2.TlvOnWithTimedOffRequest, 66, import_Cluster.TlvNoResponse)
    }
  });
  OnOff2.NotOffOnlyComponent = import_MutableCluster.MutableCluster.Component({
    commands: {
      /**
       * @see {@link MatterSpecification.v14.Cluster} § 1.5.7.2
       */
      on: (0, import_Cluster.Command)(1, import_TlvNoArguments.TlvNoArguments, 1, import_Cluster.TlvNoResponse),
      /**
       * @see {@link MatterSpecification.v14.Cluster} § 1.5.7.3
       */
      toggle: (0, import_Cluster.Command)(2, import_TlvNoArguments.TlvNoArguments, 2, import_Cluster.TlvNoResponse)
    }
  });
  OnOff2.Base = import_MutableCluster.MutableCluster.Component({
    id: 6,
    name: "OnOff",
    revision: 6,
    features: {
      /**
       * Lighting
       *
       * This cluster is used for a lighting application.
       *
       * On receipt of a Level Control cluster command that causes the OnOff attribute to be set to FALSE, the
       * OnTime attribute shall be set to 0.
       *
       * On receipt of a Level Control cluster command that causes the OnOff attribute to be set to TRUE, if the
       * value of the OnTime attribute is equal to 0, the server shall set the OffWaitTime attribute to 0.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.5.4.1
       */
      lighting: (0, import_BitmapSchema.BitFlag)(0),
      /**
       * DeadFrontBehavior
       *
       * When this feature is supported, the device exposing this server cluster exhibits "dead front" behavior
       * when the "OnOff" attribute is FALSE (Off). This "dead front" behavior includes:
       *
       *   • clusters other than this cluster that are also exposed may respond with failures to Invoke and Write
       *     interactions. Such failure responses when in a "dead front" shall be with an INVALID_IN_STATE status
       *     code.
       *
       *   • clusters other than this cluster may change the values of their attributes to best-effort values, due
       *     to the actual values not being defined or available in this state. Device type specifications that
       *     require support for the DF feature SHOULD define what these best-effort values are.
       *
       *   • Report Transactions shall continue to be generated. Such transactions may include best-effort values
       *     as noted above.
       *
       *   • Event generation logic for clusters other than this cluster is unchanged (noting possible use of
       *     best-effort attribute values as in the preceding bullets).
       *
       * When this feature is supported and the OnOff attribute changes from TRUE to FALSE (e.g. when receiving an
       * Off Command, or due to a manual interaction on the device), it shall start executing this "dead front"
       * behavior.
       *
       * When this feature is supported and the OnOff attribute changes from FALSE to TRUE (e.g. when receiving an
       * On Command, or due to a manual interaction on the device), it shall stop executing this "dead front"
       * behavior.
       *
       * When this feature is supported, and any change of the "dead front" state leads to changes in attributes
       * of other clusters due to the "dead front" feature, these attribute changes shall NOT be skipped or
       * omitted from the usual processing associated with attribute changes. For example, if an attribute changes
       * from value 4 to null on "dead front" behavior due to an Off command being received, this change shall be
       * processed for reporting and subscriptions.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.5.4.2
       */
      deadFrontBehavior: (0, import_BitmapSchema.BitFlag)(1),
      /**
       * OffOnly
       *
       * When this feature is supported, the Off command shall be supported and the On and Toggle commands shall
       * NOT be supported.
       *
       * This feature is useful for devices which can be turned off via the Off command received by an instance of
       * this cluster but cannot be turned on via commands received by an instance of this cluster due to
       * regulatory requirements.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.5.4.3
       */
      offOnly: (0, import_BitmapSchema.BitFlag)(2)
    },
    attributes: {
      /**
       * This attribute indicates whether the device type implemented on the endpoint is turned off or turned on,
       * in these cases the value of the OnOff attribute equals FALSE, or TRUE respectively.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.5.6.2
       */
      onOff: (0, import_Cluster.Attribute)(0, import_TlvBoolean.TlvBoolean, { scene: true, persistent: true, default: false })
    },
    commands: {
      /**
       * @see {@link MatterSpecification.v14.Cluster} § 1.5.7.1
       */
      off: (0, import_Cluster.Command)(0, import_TlvNoArguments.TlvNoArguments, 0, import_Cluster.TlvNoResponse)
    },
    /**
     * This metadata controls which OnOffCluster elements matter.js activates for specific feature combinations.
     */
    extensions: import_MutableCluster.MutableCluster.Extensions(
      { flags: { lighting: true }, component: OnOff2.LightingComponent },
      { flags: { offOnly: false }, component: OnOff2.NotOffOnlyComponent },
      { flags: { lighting: true, offOnly: true }, component: false },
      { flags: { deadFrontBehavior: true, offOnly: true }, component: false },
      { flags: { offOnly: true, lighting: false, deadFrontBehavior: true }, component: false }
    )
  });
  OnOff2.ClusterInstance = (0, import_MutableCluster.MutableCluster)({ ...OnOff2.Base, base: (0, import_ClusterType.ClusterType)(OnOff2.Base) }, OnOff2.NotOffOnlyComponent);
  OnOff2.Cluster = OnOff2.ClusterInstance;
  const LT = { lighting: true };
  OnOff2.CompleteInstance = (0, import_MutableCluster.MutableCluster)({
    id: OnOff2.Cluster.id,
    name: OnOff2.Cluster.name,
    revision: OnOff2.Cluster.revision,
    features: OnOff2.Cluster.features,
    attributes: {
      ...OnOff2.Cluster.attributes,
      globalSceneControl: import_MutableCluster.MutableCluster.AsConditional(
        OnOff2.LightingComponent.attributes.globalSceneControl,
        { mandatoryIf: [LT] }
      ),
      onTime: import_MutableCluster.MutableCluster.AsConditional(OnOff2.LightingComponent.attributes.onTime, { mandatoryIf: [LT] }),
      offWaitTime: import_MutableCluster.MutableCluster.AsConditional(OnOff2.LightingComponent.attributes.offWaitTime, { mandatoryIf: [LT] }),
      startUpOnOff: import_MutableCluster.MutableCluster.AsConditional(
        OnOff2.LightingComponent.attributes.startUpOnOff,
        { mandatoryIf: [LT] }
      )
    },
    commands: {
      ...OnOff2.Cluster.commands,
      on: import_MutableCluster.MutableCluster.AsConditional(OnOff2.NotOffOnlyComponent.commands.on, { mandatoryIf: [] }),
      toggle: import_MutableCluster.MutableCluster.AsConditional(OnOff2.NotOffOnlyComponent.commands.toggle, { mandatoryIf: [] }),
      offWithEffect: import_MutableCluster.MutableCluster.AsConditional(
        OnOff2.LightingComponent.commands.offWithEffect,
        { mandatoryIf: [LT] }
      ),
      onWithRecallGlobalScene: import_MutableCluster.MutableCluster.AsConditional(
        OnOff2.LightingComponent.commands.onWithRecallGlobalScene,
        { mandatoryIf: [LT] }
      ),
      onWithTimedOff: import_MutableCluster.MutableCluster.AsConditional(
        OnOff2.LightingComponent.commands.onWithTimedOff,
        { mandatoryIf: [LT] }
      )
    }
  });
  OnOff2.Complete = OnOff2.CompleteInstance;
})(OnOff || (OnOff = {}));
const OnOffCluster = OnOff.Cluster;
import_ClusterRegistry.ClusterRegistry.register(OnOff.Complete);
//# sourceMappingURL=on-off.js.map
