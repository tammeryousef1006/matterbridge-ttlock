"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var smoke_co_alarm_exports = {};
__export(smoke_co_alarm_exports, {
  SmokeCoAlarm: () => SmokeCoAlarm,
  SmokeCoAlarmCluster: () => SmokeCoAlarmCluster
});
module.exports = __toCommonJS(smoke_co_alarm_exports);
var import_MutableCluster = require("../cluster/mutation/MutableCluster.js");
var import_Cluster = require("../cluster/Cluster.js");
var import_TlvNumber = require("../tlv/TlvNumber.js");
var import_model = require("#model");
var import_TlvObject = require("../tlv/TlvObject.js");
var import_BitmapSchema = require("../schema/BitmapSchema.js");
var import_TlvBoolean = require("../tlv/TlvBoolean.js");
var import_TlvNoArguments = require("../tlv/TlvNoArguments.js");
var import_ClusterRegistry = require("../cluster/ClusterRegistry.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
var SmokeCoAlarm;
((SmokeCoAlarm2) => {
  let Feature;
  ((Feature2) => {
    Feature2["SmokeAlarm"] = "SmokeAlarm";
    Feature2["CoAlarm"] = "CoAlarm";
  })(Feature = SmokeCoAlarm2.Feature || (SmokeCoAlarm2.Feature = {}));
  let AlarmState;
  ((AlarmState2) => {
    AlarmState2[AlarmState2["Normal"] = 0] = "Normal";
    AlarmState2[AlarmState2["Warning"] = 1] = "Warning";
    AlarmState2[AlarmState2["Critical"] = 2] = "Critical";
  })(AlarmState = SmokeCoAlarm2.AlarmState || (SmokeCoAlarm2.AlarmState = {}));
  let ContaminationState;
  ((ContaminationState2) => {
    ContaminationState2[ContaminationState2["Normal"] = 0] = "Normal";
    ContaminationState2[ContaminationState2["Low"] = 1] = "Low";
    ContaminationState2[ContaminationState2["Warning"] = 2] = "Warning";
    ContaminationState2[ContaminationState2["Critical"] = 3] = "Critical";
  })(ContaminationState = SmokeCoAlarm2.ContaminationState || (SmokeCoAlarm2.ContaminationState = {}));
  let Sensitivity;
  ((Sensitivity2) => {
    Sensitivity2[Sensitivity2["High"] = 0] = "High";
    Sensitivity2[Sensitivity2["Standard"] = 1] = "Standard";
    Sensitivity2[Sensitivity2["Low"] = 2] = "Low";
  })(Sensitivity = SmokeCoAlarm2.Sensitivity || (SmokeCoAlarm2.Sensitivity = {}));
  SmokeCoAlarm2.TlvSmokeAlarmEvent = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the current value of the SmokeState attribute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 2.11.8.1.1
     */
    alarmSeverityLevel: (0, import_TlvObject.TlvField)(0, (0, import_TlvNumber.TlvEnum)())
  });
  SmokeCoAlarm2.TlvInterconnectSmokeAlarmEvent = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the current value of the InterconnectSmokeAlarm attribute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 2.11.8.9.1
     */
    alarmSeverityLevel: (0, import_TlvObject.TlvField)(0, (0, import_TlvNumber.TlvEnum)())
  });
  SmokeCoAlarm2.TlvCoAlarmEvent = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the current value of the COState attribute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 2.11.8.2.1
     */
    alarmSeverityLevel: (0, import_TlvObject.TlvField)(0, (0, import_TlvNumber.TlvEnum)())
  });
  SmokeCoAlarm2.TlvInterconnectCoAlarmEvent = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the current value of the InterconnectCOAlarm attribute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 2.11.8.10.1
     */
    alarmSeverityLevel: (0, import_TlvObject.TlvField)(0, (0, import_TlvNumber.TlvEnum)())
  });
  let ExpressedState;
  ((ExpressedState2) => {
    ExpressedState2[ExpressedState2["Normal"] = 0] = "Normal";
    ExpressedState2[ExpressedState2["SmokeAlarm"] = 1] = "SmokeAlarm";
    ExpressedState2[ExpressedState2["CoAlarm"] = 2] = "CoAlarm";
    ExpressedState2[ExpressedState2["BatteryAlert"] = 3] = "BatteryAlert";
    ExpressedState2[ExpressedState2["Testing"] = 4] = "Testing";
    ExpressedState2[ExpressedState2["HardwareFault"] = 5] = "HardwareFault";
    ExpressedState2[ExpressedState2["EndOfService"] = 6] = "EndOfService";
    ExpressedState2[ExpressedState2["InterconnectSmoke"] = 7] = "InterconnectSmoke";
    ExpressedState2[ExpressedState2["InterconnectCo"] = 8] = "InterconnectCo";
  })(ExpressedState = SmokeCoAlarm2.ExpressedState || (SmokeCoAlarm2.ExpressedState = {}));
  let MuteState;
  ((MuteState2) => {
    MuteState2[MuteState2["NotMuted"] = 0] = "NotMuted";
    MuteState2[MuteState2["Muted"] = 1] = "Muted";
  })(MuteState = SmokeCoAlarm2.MuteState || (SmokeCoAlarm2.MuteState = {}));
  let EndOfService;
  ((EndOfService2) => {
    EndOfService2[EndOfService2["Normal"] = 0] = "Normal";
    EndOfService2[EndOfService2["Expired"] = 1] = "Expired";
  })(EndOfService = SmokeCoAlarm2.EndOfService || (SmokeCoAlarm2.EndOfService = {}));
  SmokeCoAlarm2.TlvLowBatteryEvent = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the current value of the BatteryAlert attribute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 2.11.8.3.1
     */
    alarmSeverityLevel: (0, import_TlvObject.TlvField)(0, (0, import_TlvNumber.TlvEnum)())
  });
  SmokeCoAlarm2.SmokeAlarmComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * Indicates whether the device’s smoke sensor is currently triggering a smoke alarm.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.6.2
       */
      smokeState: (0, import_Cluster.Attribute)(1, (0, import_TlvNumber.TlvEnum)(), { persistent: true }),
      /**
       * Indicates the contamination level of the smoke sensor.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.6.11
       */
      contaminationState: (0, import_Cluster.OptionalAttribute)(10, (0, import_TlvNumber.TlvEnum)()),
      /**
       * Indicates the sensitivity level of the smoke sensor configured on the device.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.6.12
       */
      smokeSensitivityLevel: (0, import_Cluster.OptionalWritableAttribute)(
        11,
        (0, import_TlvNumber.TlvEnum)(),
        { writeAcl: import_model.AccessLevel.Manage }
      )
    },
    events: {
      /**
       * This event shall be generated when SmokeState attribute changes to either Warning or Critical state.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.8.1
       */
      smokeAlarm: (0, import_Cluster.Event)(0, import_Cluster.EventPriority.Critical, SmokeCoAlarm2.TlvSmokeAlarmEvent),
      /**
       * This event shall be generated when the device hosting the server receives a smoke alarm from an
       * interconnected sensor.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.8.9
       */
      interconnectSmokeAlarm: (0, import_Cluster.OptionalEvent)(8, import_Cluster.EventPriority.Critical, SmokeCoAlarm2.TlvInterconnectSmokeAlarmEvent)
    }
  });
  SmokeCoAlarm2.CoAlarmComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * Indicates whether the device’s CO sensor is currently triggering a CO alarm.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.6.3
       */
      coState: (0, import_Cluster.Attribute)(2, (0, import_TlvNumber.TlvEnum)(), { persistent: true })
    },
    events: {
      /**
       * This event shall be generated when COState attribute changes to either Warning or Critical state.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.8.2
       */
      coAlarm: (0, import_Cluster.Event)(1, import_Cluster.EventPriority.Critical, SmokeCoAlarm2.TlvCoAlarmEvent),
      /**
       * This event shall be generated when the device hosting the server receives a CO alarm from an
       * interconnected sensor.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.8.10
       */
      interconnectCoAlarm: (0, import_Cluster.OptionalEvent)(9, import_Cluster.EventPriority.Critical, SmokeCoAlarm2.TlvInterconnectCoAlarmEvent)
    }
  });
  SmokeCoAlarm2.Base = import_MutableCluster.MutableCluster.Component({
    id: 92,
    name: "SmokeCoAlarm",
    revision: 1,
    features: {
      /**
       * SmokeAlarm
       *
       * Supports Smoke alarm
       */
      smokeAlarm: (0, import_BitmapSchema.BitFlag)(0),
      /**
       * CoAlarm
       *
       * Supports CO alarm
       */
      coAlarm: (0, import_BitmapSchema.BitFlag)(1)
    },
    attributes: {
      /**
       * Indicates the visibly- and audibly-expressed state of the alarm. When multiple alarm conditions are being
       * reflected in the server, this attribute shall indicate the condition with the highest priority. Priority
       * order of conditions is determined by the manufacturer and shall be supplied as a part of certification
       * procedure. If the value of ExpressedState is not Normal, the attribute corresponding to the value shall
       * NOT be Normal. For example, if the ExpressedState is set to SmokeAlarm, the value of the SmokeState will
       * indicate the severity of the alarm (Warning or Critical). Clients SHOULD also read the other attributes
       * to be aware of further alarm conditions beyond the one indicated in ExpressedState.
       *
       * Visible expression is typically a LED light pattern. Audible expression is a horn or speaker pattern.
       * Audible expression shall BE suppressed if the DeviceMuted attribute is supported and set to Muted.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.6.1
       */
      expressedState: (0, import_Cluster.Attribute)(0, (0, import_TlvNumber.TlvEnum)(), { persistent: true }),
      /**
       * Indicates whether the power resource fault detection mechanism is currently triggered at the device. If
       * the detection mechanism is triggered, this attribute shall be set to Warning or Critical, otherwise it
       * shall be set to Normal. The battery state shall also be reflected in the Power Source cluster
       * representing the device’s battery using the appropriate supported attributes and events.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.6.4
       */
      batteryAlert: (0, import_Cluster.Attribute)(3, (0, import_TlvNumber.TlvEnum)(), { persistent: true }),
      /**
       * Indicates the whether the audible expression of the device is currently muted. Audible expression is
       * typically a horn or speaker pattern.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.6.5
       */
      deviceMuted: (0, import_Cluster.OptionalAttribute)(4, (0, import_TlvNumber.TlvEnum)(), { persistent: true }),
      /**
       * Indicates whether the device self-test is currently activated. If the device self- test is activated,
       * this attribute shall be set to True, otherwise it shall be set to False.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.6.6
       */
      testInProgress: (0, import_Cluster.Attribute)(5, import_TlvBoolean.TlvBoolean),
      /**
       * Indicates whether the hardware fault detection mechanism is currently triggered. If the detection
       * mechanism is triggered, this attribute shall be set to True, otherwise it shall be set to False.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.6.7
       */
      hardwareFaultAlert: (0, import_Cluster.Attribute)(6, import_TlvBoolean.TlvBoolean, { persistent: true }),
      /**
       * Indicates whether the end-of-service has been triggered at the device. This attribute shall be set to
       * Expired when the device reaches the end-of-service.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.6.8
       */
      endOfServiceAlert: (0, import_Cluster.Attribute)(7, (0, import_TlvNumber.TlvEnum)(), { persistent: true }),
      /**
       * Indicates whether the interconnected smoke alarm is currently triggering by branching devices. When the
       * interconnected smoke alarm is being triggered, this attribute shall be set to Warning or Critical,
       * otherwise it shall be set to Normal.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.6.9
       */
      interconnectSmokeAlarm: (0, import_Cluster.OptionalAttribute)(8, (0, import_TlvNumber.TlvEnum)()),
      /**
       * Indicates whether the interconnected CO alarm is currently triggering by branching devices. When the
       * interconnected CO alarm is being triggered, this attribute shall be set to Warning or Critical, otherwise
       * it shall be set to Normal.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.6.10
       */
      interconnectCoAlarm: (0, import_Cluster.OptionalAttribute)(9, (0, import_TlvNumber.TlvEnum)()),
      /**
       * Indicates the date when the device reaches its stated expiry date. After the ExpiryDate has been reached,
       * the EndOfServiceAlert shall start to be triggered. To account for better customer experience across time
       * zones, the EndOfServiceAlert may be delayed by up to 24 hours after the ExpiryDate. Similarly, clients
       * may delay any actions based on the ExpiryDate by up to 24 hours to best align with the local time zone.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.6.13
       */
      expiryDate: (0, import_Cluster.OptionalFixedAttribute)(12, import_TlvNumber.TlvEpochS)
    },
    commands: {
      /**
       * This command shall initiate a device self-test. The return status shall indicate whether the test was
       * successfully initiated. Only one SelfTestRequest may be processed at a time. When the value of the
       * ExpressedState attribute is any of SmokeAlarm, COAlarm, Testing, InterconnectSmoke, InterconnectCO, the
       * device shall NOT execute the self-test, and shall return status code BUSY.
       *
       * Upon successful acceptance of SelfTestRequest, the TestInProgress attribute shall be set to True and
       * ExpressedState attribute shall be set to Testing. Any faults identified during the test shall be
       * reflected in the appropriate attributes and events. Upon completion of the self test procedure, the
       * SelfTestComplete event shall be generated, the TestInProgress attribute shall be set to False and
       * ExpressedState attribute shall be updated to reflect the current state of the server.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.7.1
       */
      selfTestRequest: (0, import_Cluster.OptionalCommand)(0, import_TlvNoArguments.TlvNoArguments, 0, import_Cluster.TlvNoResponse)
    },
    events: {
      /**
       * This event shall be generated when BatteryAlert attribute changes to either Warning or Critical state.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.8.3
       */
      lowBattery: (0, import_Cluster.Event)(2, import_Cluster.EventPriority.Info, SmokeCoAlarm2.TlvLowBatteryEvent),
      /**
       * This event shall be generated when the device detects a hardware fault that leads to setting
       * HardwareFaultAlert to True.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.8.4
       */
      hardwareFault: (0, import_Cluster.Event)(3, import_Cluster.EventPriority.Info, import_TlvNoArguments.TlvNoArguments),
      /**
       * This event shall be generated when the EndOfServiceAlert is set to Expired.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.8.5
       */
      endOfService: (0, import_Cluster.Event)(4, import_Cluster.EventPriority.Info, import_TlvNoArguments.TlvNoArguments),
      /**
       * This event shall be generated when the SelfTest completes, and the attribute TestInProgress changes to
       * False.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.8.6
       */
      selfTestComplete: (0, import_Cluster.Event)(5, import_Cluster.EventPriority.Info, import_TlvNoArguments.TlvNoArguments),
      /**
       * This event shall be generated when the DeviceMuted attribute changes to Muted.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.8.7
       */
      alarmMuted: (0, import_Cluster.OptionalEvent)(6, import_Cluster.EventPriority.Info, import_TlvNoArguments.TlvNoArguments),
      /**
       * This event shall be generated when DeviceMuted attribute changes to NotMuted.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.8.8
       */
      muteEnded: (0, import_Cluster.OptionalEvent)(7, import_Cluster.EventPriority.Info, import_TlvNoArguments.TlvNoArguments),
      /**
       * This event shall be generated when ExpressedState attribute returns to Normal state.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.8.11
       */
      allClear: (0, import_Cluster.Event)(10, import_Cluster.EventPriority.Info, import_TlvNoArguments.TlvNoArguments)
    },
    /**
     * This metadata controls which SmokeCoAlarmCluster elements matter.js activates for specific feature
     * combinations.
     */
    extensions: import_MutableCluster.MutableCluster.Extensions(
      { flags: { smokeAlarm: true }, component: SmokeCoAlarm2.SmokeAlarmComponent },
      { flags: { coAlarm: true }, component: SmokeCoAlarm2.CoAlarmComponent },
      { flags: { smokeAlarm: false, coAlarm: false }, component: false }
    )
  });
  SmokeCoAlarm2.ClusterInstance = import_MutableCluster.MutableCluster.ExtensibleOnly(SmokeCoAlarm2.Base);
  SmokeCoAlarm2.Cluster = SmokeCoAlarm2.ClusterInstance;
  const SMOKE = { smokeAlarm: true };
  const CO = { coAlarm: true };
  SmokeCoAlarm2.CompleteInstance = (0, import_MutableCluster.MutableCluster)({
    id: SmokeCoAlarm2.Base.id,
    name: SmokeCoAlarm2.Base.name,
    revision: SmokeCoAlarm2.Base.revision,
    features: SmokeCoAlarm2.Base.features,
    attributes: {
      ...SmokeCoAlarm2.Base.attributes,
      smokeState: import_MutableCluster.MutableCluster.AsConditional(
        SmokeCoAlarm2.SmokeAlarmComponent.attributes.smokeState,
        { mandatoryIf: [SMOKE] }
      ),
      coState: import_MutableCluster.MutableCluster.AsConditional(SmokeCoAlarm2.CoAlarmComponent.attributes.coState, { mandatoryIf: [CO] }),
      contaminationState: import_MutableCluster.MutableCluster.AsConditional(
        SmokeCoAlarm2.SmokeAlarmComponent.attributes.contaminationState,
        { optionalIf: [SMOKE] }
      ),
      smokeSensitivityLevel: import_MutableCluster.MutableCluster.AsConditional(
        SmokeCoAlarm2.SmokeAlarmComponent.attributes.smokeSensitivityLevel,
        { optionalIf: [SMOKE] }
      )
    },
    commands: SmokeCoAlarm2.Base.commands,
    events: {
      ...SmokeCoAlarm2.Base.events,
      smokeAlarm: import_MutableCluster.MutableCluster.AsConditional(SmokeCoAlarm2.SmokeAlarmComponent.events.smokeAlarm, { mandatoryIf: [SMOKE] }),
      coAlarm: import_MutableCluster.MutableCluster.AsConditional(SmokeCoAlarm2.CoAlarmComponent.events.coAlarm, { mandatoryIf: [CO] }),
      interconnectSmokeAlarm: import_MutableCluster.MutableCluster.AsConditional(
        SmokeCoAlarm2.SmokeAlarmComponent.events.interconnectSmokeAlarm,
        { optionalIf: [SMOKE] }
      ),
      interconnectCoAlarm: import_MutableCluster.MutableCluster.AsConditional(
        SmokeCoAlarm2.CoAlarmComponent.events.interconnectCoAlarm,
        { optionalIf: [CO] }
      )
    }
  });
  SmokeCoAlarm2.Complete = SmokeCoAlarm2.CompleteInstance;
})(SmokeCoAlarm || (SmokeCoAlarm = {}));
const SmokeCoAlarmCluster = SmokeCoAlarm.Cluster;
import_ClusterRegistry.ClusterRegistry.register(SmokeCoAlarm.Complete);
//# sourceMappingURL=smoke-co-alarm.js.map
