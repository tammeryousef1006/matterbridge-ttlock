"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var thread_border_router_management_exports = {};
__export(thread_border_router_management_exports, {
  ThreadBorderRouterManagement: () => ThreadBorderRouterManagement,
  ThreadBorderRouterManagementCluster: () => ThreadBorderRouterManagementCluster
});
module.exports = __toCommonJS(thread_border_router_management_exports);
var import_MutableCluster = require("../cluster/mutation/MutableCluster.js");
var import_Cluster = require("../cluster/Cluster.js");
var import_TlvObject = require("../tlv/TlvObject.js");
var import_TlvString = require("../tlv/TlvString.js");
var import_model = require("#model");
var import_BitmapSchema = require("../schema/BitmapSchema.js");
var import_TlvNumber = require("../tlv/TlvNumber.js");
var import_TlvBoolean = require("../tlv/TlvBoolean.js");
var import_TlvNullable = require("../tlv/TlvNullable.js");
var import_TlvNoArguments = require("../tlv/TlvNoArguments.js");
var import_ClusterRegistry = require("../cluster/ClusterRegistry.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
var ThreadBorderRouterManagement;
((ThreadBorderRouterManagement2) => {
  let Feature;
  ((Feature2) => {
    Feature2["PanChange"] = "PanChange";
  })(Feature = ThreadBorderRouterManagement2.Feature || (ThreadBorderRouterManagement2.Feature = {}));
  ThreadBorderRouterManagement2.TlvSetPendingDatasetRequest = (0, import_TlvObject.TlvObject)({
    pendingDataset: (0, import_TlvObject.TlvField)(0, import_TlvString.TlvByteString.bound({ maxLength: 254 }))
  });
  ThreadBorderRouterManagement2.TlvDatasetResponse = (0, import_TlvObject.TlvObject)({
    /**
     * If no dataset (active or pending as requested) is configured, this field shall be set to empty.
     *
     * Otherwise, this field shall contain the active or pending dataset of the Thread network to which the Border
     * Router is connected as an octet string containing the raw Thread TLV value of the dataset, as defined in the
     * Thread specification.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 10.3.6.3.1
     */
    dataset: (0, import_TlvObject.TlvField)(0, import_TlvString.TlvByteString.bound({ maxLength: 254 }))
  });
  ThreadBorderRouterManagement2.TlvSetActiveDatasetRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall contain the active dataset to set of the Thread network to configure in the Border Router as
     * an octet string containing the raw Thread TLV value of the dataset, as defined in the Thread specification.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 10.3.6.4.1
     */
    activeDataset: (0, import_TlvObject.TlvField)(0, import_TlvString.TlvByteString.bound({ maxLength: 254 })),
    /**
     * See Breadcrumb Attribute section of General Commissioning Cluster in [MatterCore] for usage.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 10.3.6.4.2
     */
    breadcrumb: (0, import_TlvObject.TlvOptionalField)(1, import_TlvNumber.TlvUInt64)
  });
  ThreadBorderRouterManagement2.PanChangeComponent = import_MutableCluster.MutableCluster.Component({
    commands: {
      /**
       * This command shall be used to set or update the pending Dataset of the Thread network to which the Border
       * Router is connected, if the Border Router supports PAN Change.
       *
       * If the command is not executed via a CASE session, the command shall fail with a status code of
       * UNSUPPORTED_ACCESS.
       *
       * This PendingDataset field shall contain the pending dataset to which the Thread network should be
       * updated. The format of the data shall be an octet string containing the raw Thread TLV value of the
       * pending dataset, as defined in the Thread specification.
       *
       * If any of the parameters in the PendingDataset is invalid, the command shall fail with a status of
       * INVALID_COMMAND.
       *
       * Otherwise, this command shall configure the pending dataset of the Thread network to which the Border
       * Router is connected, with the value given in the PendingDataset parameter. The Border Router will manage
       * activation of the pending dataset as defined in the Thread specification.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 10.3.6.5
       */
      setPendingDatasetRequest: (0, import_Cluster.Command)(
        4,
        ThreadBorderRouterManagement2.TlvSetPendingDatasetRequest,
        4,
        import_Cluster.TlvNoResponse,
        { invokeAcl: import_model.AccessLevel.Manage, timed: true }
      )
    }
  });
  ThreadBorderRouterManagement2.Base = import_MutableCluster.MutableCluster.Component({
    id: 1106,
    name: "ThreadBorderRouterManagement",
    revision: 1,
    features: {
      /**
       * PanChange
       *
       * This feature shall indicate the ability of the Border Router to change its already configured PAN to
       * another, by setting a pending dataset.
       *
       * NOTE
       *
       * This feature flag can be used to protect an already-configured network from accidental configuration
       * change, e.g. when the Thread Border Router serves non-Matter devices that do not support PAN change for
       * an implementation-specific reason.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 10.3.4.1
       */
      panChange: (0, import_BitmapSchema.BitFlag)(0)
    },
    attributes: {
      /**
       * Indicates a user-friendly name identifying the device model or product of the Border Router in MeshCOP
       * (DNS-SD service name) as defined in the Thread specification, and has the following recommended format:
       * <VendorName> <ProductName>._meshcop._udp. An example name would be ACME Border Router
       * (74be)._meshcop._udp.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 10.3.5.1
       */
      borderRouterName: (0, import_Cluster.Attribute)(0, import_TlvString.TlvString.bound({ minLength: 1, maxLength: 63 })),
      /**
       * Indicates a 16-byte globally unique ID for a Thread Border Router device. This ID is
       * manufacturer-specific, and it is created and managed by the border router’s implementation.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 10.3.5.2
       */
      borderAgentId: (0, import_Cluster.Attribute)(1, import_TlvString.TlvByteString.bound({ length: 16 })),
      /**
       * Indicates the Thread version supported by the Thread interface configured by the cluster instance.
       *
       * The format shall match the value mapping defined in the "Version TLV" section of the Thread
       * specification. For example, Thread 1.3.0 would have ThreadVersion set to 4.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 10.3.5.3
       */
      threadVersion: (0, import_Cluster.FixedAttribute)(2, import_TlvNumber.TlvUInt16),
      /**
       * Indicates whether the associated IEEE 802.15.4 Thread interface is enabled or disabled.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 10.3.5.4
       */
      interfaceEnabled: (0, import_Cluster.Attribute)(3, import_TlvBoolean.TlvBoolean, { persistent: true, default: false }),
      /**
       * Null if the Thread Border Router has no dataset configured, otherwise it shall be the timestamp value
       * extracted from the Active Dataset value configured by the Thread Node to which the border router is
       * connected. This attribute shall be updated when a new Active dataset is configured on the Thread network
       * to which the border router is connected.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 10.3.5.5
       */
      activeDatasetTimestamp: (0, import_Cluster.Attribute)(4, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt64), { persistent: true, default: 0 }),
      /**
       * Null if the Thread Border Router has no Pending dataset configured, otherwise it shall be the timestamp
       * value extracted from the Pending Dataset value configured by the Thread Node to which the border router
       * is connected. This attribute shall be updated when a new Pending dataset is configured on the Thread
       * network to which the border router is connected.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 10.3.5.6
       */
      pendingDatasetTimestamp: (0, import_Cluster.Attribute)(5, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt64), { persistent: true, default: 0 })
    },
    commands: {
      /**
       * This command shall be used to request the active operational dataset of the Thread network to which the
       * border router is connected.
       *
       * If the command is not executed via a CASE session, the command shall fail with a status code of
       * UNSUPPORTED_ACCESS.
       *
       * If an internal error occurs, then this command shall fail with a FAILURE status code sent back to the
       * initiator.
       *
       * Otherwise, this shall generate a DatasetResponse command.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 10.3.6.1
       */
      getActiveDatasetRequest: (0, import_Cluster.Command)(
        0,
        import_TlvNoArguments.TlvNoArguments,
        2,
        ThreadBorderRouterManagement2.TlvDatasetResponse,
        { invokeAcl: import_model.AccessLevel.Manage }
      ),
      /**
       * This command shall be used to request the pending dataset of the Thread network to which the border
       * router is connected.
       *
       * If the command is not executed via a CASE session, the command shall fail with a status code of
       * UNSUPPORTED_ACCESS.
       *
       * If an internal error occurs, then this command shall fail with a FAILURE status code sent back to the
       * initiator.
       *
       * Otherwise, this shall generate a DatasetResponse command.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 10.3.6.2
       */
      getPendingDatasetRequest: (0, import_Cluster.Command)(
        1,
        import_TlvNoArguments.TlvNoArguments,
        2,
        ThreadBorderRouterManagement2.TlvDatasetResponse,
        { invokeAcl: import_model.AccessLevel.Manage }
      ),
      /**
       * This command shall be used to set the active Dataset of the Thread network to which the Border Router is
       * connected, when there is no active dataset already.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 10.3.6.4
       */
      setActiveDatasetRequest: (0, import_Cluster.Command)(
        3,
        ThreadBorderRouterManagement2.TlvSetActiveDatasetRequest,
        3,
        import_Cluster.TlvNoResponse,
        { invokeAcl: import_model.AccessLevel.Manage, timed: true }
      )
    },
    /**
     * This metadata controls which ThreadBorderRouterManagementCluster elements matter.js activates for specific
     * feature combinations.
     */
    extensions: import_MutableCluster.MutableCluster.Extensions({ flags: { panChange: true }, component: ThreadBorderRouterManagement2.PanChangeComponent })
  });
  ThreadBorderRouterManagement2.ClusterInstance = (0, import_MutableCluster.MutableCluster)(ThreadBorderRouterManagement2.Base);
  ThreadBorderRouterManagement2.Cluster = ThreadBorderRouterManagement2.ClusterInstance;
  const PC = { panChange: true };
  ThreadBorderRouterManagement2.CompleteInstance = (0, import_MutableCluster.MutableCluster)({
    id: ThreadBorderRouterManagement2.Cluster.id,
    name: ThreadBorderRouterManagement2.Cluster.name,
    revision: ThreadBorderRouterManagement2.Cluster.revision,
    features: ThreadBorderRouterManagement2.Cluster.features,
    attributes: ThreadBorderRouterManagement2.Cluster.attributes,
    commands: {
      ...ThreadBorderRouterManagement2.Cluster.commands,
      setPendingDatasetRequest: import_MutableCluster.MutableCluster.AsConditional(
        ThreadBorderRouterManagement2.PanChangeComponent.commands.setPendingDatasetRequest,
        { mandatoryIf: [PC] }
      )
    }
  });
  ThreadBorderRouterManagement2.Complete = ThreadBorderRouterManagement2.CompleteInstance;
})(ThreadBorderRouterManagement || (ThreadBorderRouterManagement = {}));
const ThreadBorderRouterManagementCluster = ThreadBorderRouterManagement.Cluster;
import_ClusterRegistry.ClusterRegistry.register(ThreadBorderRouterManagement.Complete);
//# sourceMappingURL=thread-border-router-management.js.map
