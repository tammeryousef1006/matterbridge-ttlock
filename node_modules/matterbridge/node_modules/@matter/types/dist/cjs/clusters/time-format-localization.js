"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var time_format_localization_exports = {};
__export(time_format_localization_exports, {
  TimeFormatLocalization: () => TimeFormatLocalization,
  TimeFormatLocalizationCluster: () => TimeFormatLocalizationCluster
});
module.exports = __toCommonJS(time_format_localization_exports);
var import_MutableCluster = require("../cluster/mutation/MutableCluster.js");
var import_Cluster = require("../cluster/Cluster.js");
var import_TlvNumber = require("../tlv/TlvNumber.js");
var import_model = require("#model");
var import_TlvArray = require("../tlv/TlvArray.js");
var import_BitmapSchema = require("../schema/BitmapSchema.js");
var import_ClusterRegistry = require("../cluster/ClusterRegistry.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
var TimeFormatLocalization;
((TimeFormatLocalization2) => {
  let Feature;
  ((Feature2) => {
    Feature2["CalendarFormat"] = "CalendarFormat";
  })(Feature = TimeFormatLocalization2.Feature || (TimeFormatLocalization2.Feature = {}));
  let CalendarType;
  ((CalendarType2) => {
    CalendarType2[CalendarType2["Buddhist"] = 0] = "Buddhist";
    CalendarType2[CalendarType2["Chinese"] = 1] = "Chinese";
    CalendarType2[CalendarType2["Coptic"] = 2] = "Coptic";
    CalendarType2[CalendarType2["Ethiopian"] = 3] = "Ethiopian";
    CalendarType2[CalendarType2["Gregorian"] = 4] = "Gregorian";
    CalendarType2[CalendarType2["Hebrew"] = 5] = "Hebrew";
    CalendarType2[CalendarType2["Indian"] = 6] = "Indian";
    CalendarType2[CalendarType2["Islamic"] = 7] = "Islamic";
    CalendarType2[CalendarType2["Japanese"] = 8] = "Japanese";
    CalendarType2[CalendarType2["Korean"] = 9] = "Korean";
    CalendarType2[CalendarType2["Persian"] = 10] = "Persian";
    CalendarType2[CalendarType2["Taiwanese"] = 11] = "Taiwanese";
    CalendarType2[CalendarType2["UseActiveLocale"] = 255] = "UseActiveLocale";
  })(CalendarType = TimeFormatLocalization2.CalendarType || (TimeFormatLocalization2.CalendarType = {}));
  let HourFormat;
  ((HourFormat2) => {
    HourFormat2[HourFormat2["12Hr"] = 0] = "12Hr";
    HourFormat2[HourFormat2["24Hr"] = 1] = "24Hr";
    HourFormat2[HourFormat2["UseActiveLocale"] = 255] = "UseActiveLocale";
  })(HourFormat = TimeFormatLocalization2.HourFormat || (TimeFormatLocalization2.HourFormat = {}));
  TimeFormatLocalization2.CalendarFormatComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * Indicates the calendar format that the Node is currently configured to use when conveying dates.
       *
       * If not UseActiveLocale, this value shall take priority over any unit implied through the ActiveLocale
       * attribute.
       *
       * If UseActiveLocale, any unit implied through the ActiveLocale attribute is used as the calendar type, and
       * if ActiveLocale is not present, the calendar type is unknown.
       *
       * @see {@link MatterSpecification.v14.Core} ยง 11.4.6.2
       */
      activeCalendarType: (0, import_Cluster.WritableAttribute)(
        1,
        (0, import_TlvNumber.TlvEnum)(),
        { persistent: true, writeAcl: import_model.AccessLevel.Manage }
      ),
      /**
       * Indicates a list of CalendarTypeEnum values that are supported by the Node. The list shall NOT contain
       * any duplicate entries. The ordering of items within the list SHOULD NOT express any meaning. The maximum
       * length of the SupportedCalendarTypes list shall be equivalent to the number of enumerations within
       * CalendarTypeEnum.
       *
       * @see {@link MatterSpecification.v14.Core} ยง 11.4.6.3
       */
      supportedCalendarTypes: (0, import_Cluster.FixedAttribute)(2, (0, import_TlvArray.TlvArray)((0, import_TlvNumber.TlvEnum)()), { default: [] })
    }
  });
  TimeFormatLocalization2.Base = import_MutableCluster.MutableCluster.Component({
    id: 44,
    name: "TimeFormatLocalization",
    revision: 1,
    features: {
      /**
       * CalendarFormat
       *
       * The Node can be configured to use different calendar formats when conveying values to a user.
       */
      calendarFormat: (0, import_BitmapSchema.BitFlag)(0)
    },
    attributes: {
      /**
       * Indicates the format that the Node is currently configured to use when conveying the hour unit of time.
       *
       * If not UseActiveLocale, this value shall take priority over any unit implied through the ActiveLocale
       * attribute.
       *
       * If UseActiveLocale, any unit implied through the ActiveLocale attribute is used as the hour format, and
       * if ActiveLocale is not present, the hour format is unknown.
       *
       * @see {@link MatterSpecification.v14.Core} ยง 11.4.6.1
       */
      hourFormat: (0, import_Cluster.WritableAttribute)(
        0,
        (0, import_TlvNumber.TlvEnum)(),
        { persistent: true, writeAcl: import_model.AccessLevel.Manage }
      )
    },
    /**
     * This metadata controls which TimeFormatLocalizationCluster elements matter.js activates for specific feature
     * combinations.
     */
    extensions: import_MutableCluster.MutableCluster.Extensions({ flags: { calendarFormat: true }, component: TimeFormatLocalization2.CalendarFormatComponent })
  });
  TimeFormatLocalization2.ClusterInstance = (0, import_MutableCluster.MutableCluster)(TimeFormatLocalization2.Base);
  TimeFormatLocalization2.Cluster = TimeFormatLocalization2.ClusterInstance;
  const CALFMT = { calendarFormat: true };
  TimeFormatLocalization2.CompleteInstance = (0, import_MutableCluster.MutableCluster)({
    id: TimeFormatLocalization2.Cluster.id,
    name: TimeFormatLocalization2.Cluster.name,
    revision: TimeFormatLocalization2.Cluster.revision,
    features: TimeFormatLocalization2.Cluster.features,
    attributes: {
      ...TimeFormatLocalization2.Cluster.attributes,
      activeCalendarType: import_MutableCluster.MutableCluster.AsConditional(
        TimeFormatLocalization2.CalendarFormatComponent.attributes.activeCalendarType,
        { mandatoryIf: [CALFMT] }
      ),
      supportedCalendarTypes: import_MutableCluster.MutableCluster.AsConditional(
        TimeFormatLocalization2.CalendarFormatComponent.attributes.supportedCalendarTypes,
        { mandatoryIf: [CALFMT] }
      )
    }
  });
  TimeFormatLocalization2.Complete = TimeFormatLocalization2.CompleteInstance;
})(TimeFormatLocalization || (TimeFormatLocalization = {}));
const TimeFormatLocalizationCluster = TimeFormatLocalization.Cluster;
import_ClusterRegistry.ClusterRegistry.register(TimeFormatLocalization.Complete);
//# sourceMappingURL=time-format-localization.js.map
