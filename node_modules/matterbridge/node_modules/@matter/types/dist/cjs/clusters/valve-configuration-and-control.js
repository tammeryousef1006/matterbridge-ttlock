"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var valve_configuration_and_control_exports = {};
__export(valve_configuration_and_control_exports, {
  ValveConfigurationAndControl: () => ValveConfigurationAndControl,
  ValveConfigurationAndControlCluster: () => ValveConfigurationAndControlCluster
});
module.exports = __toCommonJS(valve_configuration_and_control_exports);
var import_MutableCluster = require("../cluster/mutation/MutableCluster.js");
var import_Cluster = require("../cluster/Cluster.js");
var import_TlvNumber = require("../tlv/TlvNumber.js");
var import_TlvNullable = require("../tlv/TlvNullable.js");
var import_BitmapSchema = require("../schema/BitmapSchema.js");
var import_TlvObject = require("../tlv/TlvObject.js");
var import_TlvNoArguments = require("../tlv/TlvNoArguments.js");
var import_ClusterRegistry = require("../cluster/ClusterRegistry.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
var ValveConfigurationAndControl;
((ValveConfigurationAndControl2) => {
  let Feature;
  ((Feature2) => {
    Feature2["TimeSync"] = "TimeSync";
    Feature2["Level"] = "Level";
  })(Feature = ValveConfigurationAndControl2.Feature || (ValveConfigurationAndControl2.Feature = {}));
  let ValveState;
  ((ValveState2) => {
    ValveState2[ValveState2["Closed"] = 0] = "Closed";
    ValveState2[ValveState2["Open"] = 1] = "Open";
    ValveState2[ValveState2["Transitioning"] = 2] = "Transitioning";
  })(ValveState = ValveConfigurationAndControl2.ValveState || (ValveConfigurationAndControl2.ValveState = {}));
  ValveConfigurationAndControl2.ValveFault = {
    /**
     * Unspecified fault detected
     */
    generalFault: (0, import_BitmapSchema.BitFlag)(0),
    /**
     * Valve is blocked
     */
    blocked: (0, import_BitmapSchema.BitFlag)(1),
    /**
     * Valve has detected a leak
     */
    leaking: (0, import_BitmapSchema.BitFlag)(2),
    /**
     * No valve is connected to controller
     */
    notConnected: (0, import_BitmapSchema.BitFlag)(3),
    /**
     * Short circuit is detected
     */
    shortCircuit: (0, import_BitmapSchema.BitFlag)(4),
    /**
     * The available current has been exceeded
     */
    currentExceeded: (0, import_BitmapSchema.BitFlag)(5)
  };
  ValveConfigurationAndControl2.TlvOpenRequest = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the duration that the valve will remain open for this specific Open command.
     *
     * A value of null shall indicate the duration is not set, meaning that the valve will remain open until closed
     * by the user or some other automation.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 4.6.8.1.1
     */
    openDuration: (0, import_TlvObject.TlvOptionalField)(0, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt32.bound({ min: 1 }))),
    /**
     * This field shall indicate the target level used for this specific Open command.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 4.6.8.1.2
     */
    targetLevel: (0, import_TlvObject.TlvOptionalField)(1, import_TlvNumber.TlvPercent.bound({ min: 1 }))
  });
  ValveConfigurationAndControl2.TlvValveStateChangedEvent = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the new state of the valve.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 4.6.9.1.1
     */
    valveState: (0, import_TlvObject.TlvField)(0, (0, import_TlvNumber.TlvEnum)()),
    /**
     * This field shall indicate the new level of the valve.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 4.6.9.1.2
     */
    valveLevel: (0, import_TlvObject.TlvOptionalField)(1, import_TlvNumber.TlvPercent)
  });
  ValveConfigurationAndControl2.TlvValveFaultEvent = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall indicate the value of the ValveFault attribute, at the time this event is generated.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 4.6.9.2.1
     */
    valveFault: (0, import_TlvObject.TlvField)(0, (0, import_TlvNumber.TlvBitmap)(import_TlvNumber.TlvUInt16, ValveConfigurationAndControl2.ValveFault))
  });
  let StatusCode;
  ((StatusCode2) => {
    StatusCode2[StatusCode2["FailureDueToFault"] = 2] = "FailureDueToFault";
  })(StatusCode = ValveConfigurationAndControl2.StatusCode || (ValveConfigurationAndControl2.StatusCode = {}));
  ValveConfigurationAndControl2.TimeSyncComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * Indicates the UTC time when the valve will close, depending on value of the OpenDuration attribute.
       *
       * Null:
       *
       *   • When OpenDuration is null, or
       *
       *   • When the valve does not have a synchronized UTCTime in the Time Synchronization cluster, or
       *
       *   • When the valve is closed.
       *
       * When the value of this attribute is earlier or equal to the current UTC time, the valve shall
       * automatically transition to its closed position. The behavior of transitioning to the closed position,
       * shall match the behavior described in the Close command.
       *
       * If this attribute is not null and the Time Synchronization cluster receives a SetUTCTime command,
       * modifying the current UTC time of the device, the value of this attribute shall be adjusted to match the
       * new UTC time plus the value of the RemainingDuration attribute.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 4.6.7.3
       */
      autoCloseTime: (0, import_Cluster.Attribute)(2, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvEpochUs), { default: null })
    }
  });
  ValveConfigurationAndControl2.LevelComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * Indicates the current level of the valve as a percentage value, between fully closed and fully open.
       * During a transition from one level to another level, the valve SHOULD keep this attribute updated to the
       * best of its ability, in order to represent the actual level of the valve during the movement.
       *
       * A value of 100 percent shall indicate the fully open position. A value of 0 percent shall indicate the
       * fully closed position.
       *
       * A value of null shall indicate that the current state is not known.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 4.6.7.7
       */
      currentLevel: (0, import_Cluster.Attribute)(6, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvPercent), { default: null }),
      /**
       * Indicates the target level of the valve as a percentage value, between fully closed and fully open.
       *
       * The interpretation of the percentage value is the same as for the CurrentLevel attribute.
       *
       * A value of null shall indicate that no target position is set, since the change of level is either done
       * or failed.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 4.6.7.8
       */
      targetLevel: (0, import_Cluster.Attribute)(7, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvPercent), { default: null }),
      /**
       * Indicates the default value used for the TargetLevel attribute, when a valve transitions from the closed
       * to the open state, caused by an Open command, if a TargetLevel field is not present in the Open command.
       *
       * If the LevelStep attribute is present and the value of a write interaction to this attribute field is not
       * 100, the value shall be a supported value as defined by the LevelStep attribute, such that (Value
       * received in the write interaction) % (Value of LevelStep attribute) equals 0. If the resulting value is
       * not 0, the requested DefaultOpenLevel value is considered an unsupported value and a CONSTRAINT_ERROR
       * status shall be returned.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 4.6.7.9
       */
      defaultOpenLevel: (0, import_Cluster.OptionalWritableAttribute)(
        8,
        import_TlvNumber.TlvPercent.bound({ min: 1 }),
        { persistent: true, default: 100 }
      ),
      /**
       * Indicates the step size the valve can support.
       *
       * The step size defined by this attribute is counted from 0 and the final step towards 100 may be different
       * than what is defined in this attribute. For example, if the value of this attribute is 15, it results in
       * these target values being supported; 0, 15, 30, 45, 60, 75, 90 and 100.
       *
       * The values of 0 and 100 shall always be supported, regardless of the value of this attribute.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 4.6.7.11
       */
      levelStep: (0, import_Cluster.OptionalFixedAttribute)(10, import_TlvNumber.TlvUInt8.bound({ min: 1, max: 50 }), { default: 1 })
    }
  });
  ValveConfigurationAndControl2.Base = import_MutableCluster.MutableCluster.Component({
    id: 129,
    name: "ValveConfigurationAndControl",
    revision: 1,
    features: {
      /**
       * TimeSync
       *
       * This feature shall indicate that the valve uses Time Synchronization and UTC time to indicate duration
       * and auto close time.
       *
       * This feature shall NOT be supported unless the device supports the Time Synchronization cluster.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 4.6.4.1
       */
      timeSync: (0, import_BitmapSchema.BitFlag)(0),
      /**
       * Level
       *
       * This feature shall indicate that the valve is capable of being adjusted to a specific position, as a
       * percentage, of its full range of motion.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 4.6.4.2
       */
      level: (0, import_BitmapSchema.BitFlag)(1)
    },
    attributes: {
      /**
       * Indicates the total duration, in seconds, for which the valve will remain open for this current opening.
       *
       * A value of null shall indicate the duration is not set, meaning that the valve will remain open until
       * closed by the user or some other automation.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 4.6.7.1
       */
      openDuration: (0, import_Cluster.Attribute)(0, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt32.bound({ min: 1 })), { default: null }),
      /**
       * Indicates the default duration, in seconds, for which the valve will remain open, if the OpenDuration
       * field is not present in the Open command.
       *
       * A value of null shall indicate the duration is not set, meaning that the valve will remain open until
       * closed by the user or some other automation.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 4.6.7.2
       */
      defaultOpenDuration: (0, import_Cluster.WritableAttribute)(
        1,
        (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt32.bound({ min: 1 })),
        { persistent: true, default: null }
      ),
      /**
       * Indicates the remaining duration, in seconds, until the valve closes. Null:
       *
       *   • When OpenDuration is null, or
       *
       *   • When the valve is closed.
       *
       * The value of this attribute shall only be reported in the following cases:
       *
       *   • When it changes from null to any other value and vice versa, or
       *
       *   • When it changes to 0, or
       *
       *   • When it increases, or
       *
       *   • When the closing time changes.
       *
       * Meaning that clients SHOULD NOT rely on the reporting of this attribute in order to keep track of the
       * remaining duration, due to this attribute not being reported during regular countdown.
       *
       * When reading this attribute it shall return the remaining duration, in seconds, until the valve closes.
       *
       * When the value of this attribute counts down to 0, the valve shall automatically transition to its closed
       * position. The behavior of transitioning to the closed position shall match the behavior described in the
       * Close command.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 4.6.7.4
       */
      remainingDuration: (0, import_Cluster.Attribute)(3, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt32), { default: null }),
      /**
       * Indicates the current state of the valve.
       *
       * A value of null shall indicate that the current state is not known.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 4.6.7.5
       */
      currentState: (0, import_Cluster.Attribute)(4, (0, import_TlvNullable.TlvNullable)((0, import_TlvNumber.TlvEnum)()), { default: null }),
      /**
       * Indicates the target state, while changing the state, of the valve.
       *
       * A value of null shall indicate that no target position is set, since the change in state is either done
       * or failed.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 4.6.7.6
       */
      targetState: (0, import_Cluster.Attribute)(5, (0, import_TlvNullable.TlvNullable)((0, import_TlvNumber.TlvEnum)()), { default: null }),
      /**
       * Indicates any faults registered by the valve.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 4.6.7.10
       */
      valveFault: (0, import_Cluster.OptionalAttribute)(9, (0, import_TlvNumber.TlvBitmap)(import_TlvNumber.TlvUInt16, ValveConfigurationAndControl2.ValveFault))
    },
    commands: {
      /**
       * This command is used to set the valve to its open position.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 4.6.8.1
       */
      open: (0, import_Cluster.Command)(0, ValveConfigurationAndControl2.TlvOpenRequest, 0, import_Cluster.TlvNoResponse),
      /**
       * This command is used to set the valve to its closed position.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 4.6.8.2
       */
      close: (0, import_Cluster.Command)(1, import_TlvNoArguments.TlvNoArguments, 1, import_Cluster.TlvNoResponse)
    },
    events: {
      /**
       * This event shall be generated when the valve state changed. For level changes, after the end of movement,
       * for state changes when the new state has been reached.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 4.6.9.1
       */
      valveStateChanged: (0, import_Cluster.OptionalEvent)(0, import_Cluster.EventPriority.Info, ValveConfigurationAndControl2.TlvValveStateChangedEvent),
      /**
       * This event shall be generated when the valve registers or clears a fault, e.g. not being able to
       * transition to the requested target level or state.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 4.6.9.2
       */
      valveFault: (0, import_Cluster.OptionalEvent)(1, import_Cluster.EventPriority.Info, ValveConfigurationAndControl2.TlvValveFaultEvent)
    },
    /**
     * This metadata controls which ValveConfigurationAndControlCluster elements matter.js activates for specific
     * feature combinations.
     */
    extensions: import_MutableCluster.MutableCluster.Extensions(
      { flags: { timeSync: true }, component: ValveConfigurationAndControl2.TimeSyncComponent },
      { flags: { level: true }, component: ValveConfigurationAndControl2.LevelComponent }
    )
  });
  ValveConfigurationAndControl2.ClusterInstance = (0, import_MutableCluster.MutableCluster)(ValveConfigurationAndControl2.Base);
  ValveConfigurationAndControl2.Cluster = ValveConfigurationAndControl2.ClusterInstance;
  const TS = { timeSync: true };
  const LVL = { level: true };
  ValveConfigurationAndControl2.CompleteInstance = (0, import_MutableCluster.MutableCluster)({
    id: ValveConfigurationAndControl2.Cluster.id,
    name: ValveConfigurationAndControl2.Cluster.name,
    revision: ValveConfigurationAndControl2.Cluster.revision,
    features: ValveConfigurationAndControl2.Cluster.features,
    attributes: {
      ...ValveConfigurationAndControl2.Cluster.attributes,
      autoCloseTime: import_MutableCluster.MutableCluster.AsConditional(
        ValveConfigurationAndControl2.TimeSyncComponent.attributes.autoCloseTime,
        { mandatoryIf: [TS] }
      ),
      currentLevel: import_MutableCluster.MutableCluster.AsConditional(ValveConfigurationAndControl2.LevelComponent.attributes.currentLevel, { mandatoryIf: [LVL] }),
      targetLevel: import_MutableCluster.MutableCluster.AsConditional(ValveConfigurationAndControl2.LevelComponent.attributes.targetLevel, { mandatoryIf: [LVL] }),
      defaultOpenLevel: import_MutableCluster.MutableCluster.AsConditional(
        ValveConfigurationAndControl2.LevelComponent.attributes.defaultOpenLevel,
        { optionalIf: [LVL] }
      ),
      levelStep: import_MutableCluster.MutableCluster.AsConditional(ValveConfigurationAndControl2.LevelComponent.attributes.levelStep, { optionalIf: [LVL] })
    },
    commands: ValveConfigurationAndControl2.Cluster.commands,
    events: ValveConfigurationAndControl2.Cluster.events
  });
  ValveConfigurationAndControl2.Complete = ValveConfigurationAndControl2.CompleteInstance;
})(ValveConfigurationAndControl || (ValveConfigurationAndControl = {}));
const ValveConfigurationAndControlCluster = ValveConfigurationAndControl.Cluster;
import_ClusterRegistry.ClusterRegistry.register(ValveConfigurationAndControl.Complete);
//# sourceMappingURL=valve-configuration-and-control.js.map
