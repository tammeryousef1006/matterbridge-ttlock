"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var wi_fi_network_diagnostics_exports = {};
__export(wi_fi_network_diagnostics_exports, {
  WiFiNetworkDiagnostics: () => WiFiNetworkDiagnostics,
  WiFiNetworkDiagnosticsCluster: () => WiFiNetworkDiagnosticsCluster
});
module.exports = __toCommonJS(wi_fi_network_diagnostics_exports);
var import_MutableCluster = require("../cluster/mutation/MutableCluster.js");
var import_Cluster = require("../cluster/Cluster.js");
var import_TlvNumber = require("../tlv/TlvNumber.js");
var import_TlvNullable = require("../tlv/TlvNullable.js");
var import_TlvNoArguments = require("../tlv/TlvNoArguments.js");
var import_BitmapSchema = require("../schema/BitmapSchema.js");
var import_TlvString = require("../tlv/TlvString.js");
var import_TlvObject = require("../tlv/TlvObject.js");
var import_ClusterRegistry = require("../cluster/ClusterRegistry.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
var WiFiNetworkDiagnostics;
((WiFiNetworkDiagnostics2) => {
  let Feature;
  ((Feature2) => {
    Feature2["PacketCounts"] = "PacketCounts";
    Feature2["ErrorCounts"] = "ErrorCounts";
  })(Feature = WiFiNetworkDiagnostics2.Feature || (WiFiNetworkDiagnostics2.Feature = {}));
  let SecurityType;
  ((SecurityType2) => {
    SecurityType2[SecurityType2["Unspecified"] = 0] = "Unspecified";
    SecurityType2[SecurityType2["None"] = 1] = "None";
    SecurityType2[SecurityType2["Wep"] = 2] = "Wep";
    SecurityType2[SecurityType2["Wpa"] = 3] = "Wpa";
    SecurityType2[SecurityType2["Wpa2"] = 4] = "Wpa2";
    SecurityType2[SecurityType2["Wpa3"] = 5] = "Wpa3";
  })(SecurityType = WiFiNetworkDiagnostics2.SecurityType || (WiFiNetworkDiagnostics2.SecurityType = {}));
  let WiFiVersion;
  ((WiFiVersion2) => {
    WiFiVersion2[WiFiVersion2["A"] = 0] = "A";
    WiFiVersion2[WiFiVersion2["B"] = 1] = "B";
    WiFiVersion2[WiFiVersion2["G"] = 2] = "G";
    WiFiVersion2[WiFiVersion2["N"] = 3] = "N";
    WiFiVersion2[WiFiVersion2["Ac"] = 4] = "Ac";
    WiFiVersion2[WiFiVersion2["Ax"] = 5] = "Ax";
    WiFiVersion2[WiFiVersion2["Ah"] = 6] = "Ah";
  })(WiFiVersion = WiFiNetworkDiagnostics2.WiFiVersion || (WiFiNetworkDiagnostics2.WiFiVersion = {}));
  WiFiNetworkDiagnostics2.TlvDisconnectionEvent = (0, import_TlvObject.TlvObject)({
    /**
     * This field shall contain the Reason Code field value for the Disassociation or Deauthentication event that
     * caused the disconnection and the value shall align with Table 9-49 "Reason codes" of IEEE 802.11-2020.
     *
     * @see {@link MatterSpecification.v14.Core} § 11.15.8.1.1
     */
    reasonCode: (0, import_TlvObject.TlvField)(0, import_TlvNumber.TlvUInt16)
  });
  let AssociationFailureCause;
  ((AssociationFailureCause2) => {
    AssociationFailureCause2[AssociationFailureCause2["Unknown"] = 0] = "Unknown";
    AssociationFailureCause2[AssociationFailureCause2["AssociationFailed"] = 1] = "AssociationFailed";
    AssociationFailureCause2[AssociationFailureCause2["AuthenticationFailed"] = 2] = "AuthenticationFailed";
    AssociationFailureCause2[AssociationFailureCause2["SsidNotFound"] = 3] = "SsidNotFound";
  })(AssociationFailureCause = WiFiNetworkDiagnostics2.AssociationFailureCause || (WiFiNetworkDiagnostics2.AssociationFailureCause = {}));
  WiFiNetworkDiagnostics2.TlvAssociationFailureEvent = (0, import_TlvObject.TlvObject)({
    /**
     * The Status field shall be set to a value from the AssociationFailureCauseEnum.
     *
     * @see {@link MatterSpecification.v14.Core} § 11.15.8.2.1
     */
    associationFailureCause: (0, import_TlvObject.TlvField)(0, (0, import_TlvNumber.TlvEnum)()),
    /**
     * The Status field shall be set to the Status Code value that was present in the last frame related to
     * association where Status Code was not equal to zero and which caused the failure of a last trial attempt, if
     * this last failure was due to one of the following Management frames:
     *
     *   • Association Response (Type 0, Subtype 1)
     *
     *   • Reassociation Response (Type 0, Subtype 3)
     *
     *   • Authentication (Type 0, Subtype 11)
     *
     * Table 9-50 "Status codes" of IEEE 802.11-2020 contains a description of all values possible.
     *
     * @see {@link MatterSpecification.v14.Core} § 11.15.8.2.2
     */
    status: (0, import_TlvObject.TlvField)(1, import_TlvNumber.TlvUInt16)
  });
  let ConnectionStatus;
  ((ConnectionStatus2) => {
    ConnectionStatus2[ConnectionStatus2["Connected"] = 0] = "Connected";
    ConnectionStatus2[ConnectionStatus2["NotConnected"] = 1] = "NotConnected";
  })(ConnectionStatus = WiFiNetworkDiagnostics2.ConnectionStatus || (WiFiNetworkDiagnostics2.ConnectionStatus = {}));
  WiFiNetworkDiagnostics2.TlvConnectionStatusEvent = (0, import_TlvObject.TlvObject)({ connectionStatus: (0, import_TlvObject.TlvField)(0, (0, import_TlvNumber.TlvEnum)()) });
  WiFiNetworkDiagnostics2.ErrorCountsComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * The BeaconLostCount attribute shall indicate the count of the number of missed beacons the Node has
       * detected. If the Node does not have an ability to count beacons expected and not received, this value may
       * remain set to zero.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.15.6.6
       */
      beaconLostCount: (0, import_Cluster.Attribute)(5, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt32), { omitChanges: true, default: 0 }),
      /**
       * The OverrunCount attribute shall indicate the number of packets dropped either at ingress or egress, due
       * to lack of buffer memory to retain all packets on the network interface. The OverrunCount attribute shall
       * be reset to 0 upon a reboot of the Node.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.15.6.13
       */
      overrunCount: (0, import_Cluster.Attribute)(12, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt64), { omitChanges: true, default: 0 })
    },
    commands: {
      /**
       * Reception of this command shall reset the following attributes to 0:
       *
       *   • BeaconLostCount
       *
       *   • BeaconRxCount
       *
       *   • PacketMulticastRxCount
       *
       *   • PacketMulticastTxCount
       *
       *   • PacketUnicastRxCount
       *
       *   • PacketUnicastTxCount
       *
       * This command has no associated data.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.15.7.1
       */
      resetCounts: (0, import_Cluster.Command)(0, import_TlvNoArguments.TlvNoArguments, 0, import_Cluster.TlvNoResponse)
    }
  });
  WiFiNetworkDiagnostics2.PacketCountsComponent = import_MutableCluster.MutableCluster.Component({
    attributes: {
      /**
       * The BeaconRxCount attribute shall indicate the count of the number of received beacons. The total number
       * of expected beacons that could have been received during the interval since association SHOULD match the
       * sum of BeaconRxCount and BeaconLostCount. If the Node does not have an ability to report count of beacons
       * received, this value may remain set to zero.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.15.6.7
       */
      beaconRxCount: (0, import_Cluster.Attribute)(6, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt32), { omitChanges: true, default: 0 }),
      /**
       * The PacketMulticastRxCount attribute shall indicate the number of multicast packets received by the Node.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.15.6.8
       */
      packetMulticastRxCount: (0, import_Cluster.Attribute)(7, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt32), { omitChanges: true, default: 0 }),
      /**
       * The PacketMulticastTxCount attribute shall indicate the number of multicast packets transmitted by the
       * Node.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.15.6.9
       */
      packetMulticastTxCount: (0, import_Cluster.Attribute)(8, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt32), { omitChanges: true, default: 0 }),
      /**
       * The PacketUnicastRxCount attribute shall indicate the number of unicast packets received by the Node.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.15.6.10
       */
      packetUnicastRxCount: (0, import_Cluster.Attribute)(9, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt32), { omitChanges: true, default: 0 }),
      /**
       * The PacketUnicastTxCount attribute shall indicate the number of unicast packets transmitted by the Node.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.15.6.11
       */
      packetUnicastTxCount: (0, import_Cluster.Attribute)(10, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt32), { omitChanges: true, default: 0 })
    }
  });
  WiFiNetworkDiagnostics2.Base = import_MutableCluster.MutableCluster.Component({
    id: 54,
    name: "WiFiNetworkDiagnostics",
    revision: 1,
    features: {
      /**
       * PacketCounts
       *
       * Node makes available the counts for the number of received and transmitted packets on the Wi-Fi
       * interface.
       */
      packetCounts: (0, import_BitmapSchema.BitFlag)(0),
      /**
       * ErrorCounts
       *
       * Node makes available the counts for the number of errors that have occurred during the reception and
       * transmission of packets on the Wi-Fi interface.
       */
      errorCounts: (0, import_BitmapSchema.BitFlag)(1)
    },
    attributes: {
      /**
       * The BSSID attribute shall indicate the BSSID for which the Wi-Fi network the Node is currently connected.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.15.6.1
       */
      bssid: (0, import_Cluster.Attribute)(0, (0, import_TlvNullable.TlvNullable)(import_TlvString.TlvByteString.bound({ length: 6 })), { default: null }),
      /**
       * The SecurityType attribute shall indicate the current type of Wi-Fi security used.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.15.6.2
       */
      securityType: (0, import_Cluster.Attribute)(1, (0, import_TlvNullable.TlvNullable)((0, import_TlvNumber.TlvEnum)()), { default: null }),
      /**
       * The WiFiVersion attribute shall indicate the current 802.11 standard version in use by the Node, per the
       * table below.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.15.6.3
       */
      wiFiVersion: (0, import_Cluster.Attribute)(2, (0, import_TlvNullable.TlvNullable)((0, import_TlvNumber.TlvEnum)()), { default: null }),
      /**
       * The ChannelNumber attribute shall indicate the channel that Wi-Fi communication is currently operating
       * on.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.15.6.4
       */
      channelNumber: (0, import_Cluster.Attribute)(3, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt16), { default: null }),
      /**
       * The RSSI attribute shall indicate the current RSSI of the Node’s Wi-Fi radio in dBm.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.15.6.5
       */
      rssi: (0, import_Cluster.Attribute)(
        4,
        (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvInt8.bound({ min: -120, max: 0 })),
        { omitChanges: true, default: null }
      ),
      /**
       * The CurrentMaxRate attribute shall indicate the current maximum PHY rate of transfer of data in
       * bits-per-second.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.15.6.12
       */
      currentMaxRate: (0, import_Cluster.OptionalAttribute)(11, (0, import_TlvNullable.TlvNullable)(import_TlvNumber.TlvUInt64), { omitChanges: true, default: 0 })
    },
    events: {
      /**
       * The Disconnection Event shall indicate that a Node’s Wi-Fi connection has been disconnected as a result
       * of de-authenticated or dis-association and indicates the reason.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.15.8.1
       */
      disconnection: (0, import_Cluster.OptionalEvent)(0, import_Cluster.EventPriority.Info, WiFiNetworkDiagnostics2.TlvDisconnectionEvent),
      /**
       * The AssociationFailure event shall indicate that a Node has attempted to connect, or reconnect, to a
       * Wi-Fi access point, but is unable to successfully associate or authenticate, after exhausting all
       * internal retries of its supplicant.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.15.8.2
       */
      associationFailure: (0, import_Cluster.OptionalEvent)(1, import_Cluster.EventPriority.Info, WiFiNetworkDiagnostics2.TlvAssociationFailureEvent),
      /**
       * The ConnectionStatus Event shall indicate that a Node’s connection status to a Wi-Fi network has changed.
       * Connected, in this context, shall mean that a Node acting as a Wi-Fi station is successfully associated
       * to a Wi-Fi Access Point.
       *
       * @see {@link MatterSpecification.v14.Core} § 11.15.8.3
       */
      connectionStatus: (0, import_Cluster.OptionalEvent)(2, import_Cluster.EventPriority.Info, WiFiNetworkDiagnostics2.TlvConnectionStatusEvent)
    },
    /**
     * This metadata controls which WiFiNetworkDiagnosticsCluster elements matter.js activates for specific feature
     * combinations.
     */
    extensions: import_MutableCluster.MutableCluster.Extensions(
      { flags: { errorCounts: true }, component: WiFiNetworkDiagnostics2.ErrorCountsComponent },
      { flags: { packetCounts: true }, component: WiFiNetworkDiagnostics2.PacketCountsComponent }
    )
  });
  WiFiNetworkDiagnostics2.ClusterInstance = (0, import_MutableCluster.MutableCluster)(WiFiNetworkDiagnostics2.Base);
  WiFiNetworkDiagnostics2.Cluster = WiFiNetworkDiagnostics2.ClusterInstance;
  const ERRCNT = { errorCounts: true };
  const PKTCNT = { packetCounts: true };
  WiFiNetworkDiagnostics2.CompleteInstance = (0, import_MutableCluster.MutableCluster)({
    id: WiFiNetworkDiagnostics2.Cluster.id,
    name: WiFiNetworkDiagnostics2.Cluster.name,
    revision: WiFiNetworkDiagnostics2.Cluster.revision,
    features: WiFiNetworkDiagnostics2.Cluster.features,
    attributes: {
      ...WiFiNetworkDiagnostics2.Cluster.attributes,
      beaconLostCount: import_MutableCluster.MutableCluster.AsConditional(
        WiFiNetworkDiagnostics2.ErrorCountsComponent.attributes.beaconLostCount,
        { mandatoryIf: [ERRCNT] }
      ),
      beaconRxCount: import_MutableCluster.MutableCluster.AsConditional(
        WiFiNetworkDiagnostics2.PacketCountsComponent.attributes.beaconRxCount,
        { mandatoryIf: [PKTCNT] }
      ),
      packetMulticastRxCount: import_MutableCluster.MutableCluster.AsConditional(
        WiFiNetworkDiagnostics2.PacketCountsComponent.attributes.packetMulticastRxCount,
        { mandatoryIf: [PKTCNT] }
      ),
      packetMulticastTxCount: import_MutableCluster.MutableCluster.AsConditional(
        WiFiNetworkDiagnostics2.PacketCountsComponent.attributes.packetMulticastTxCount,
        { mandatoryIf: [PKTCNT] }
      ),
      packetUnicastRxCount: import_MutableCluster.MutableCluster.AsConditional(
        WiFiNetworkDiagnostics2.PacketCountsComponent.attributes.packetUnicastRxCount,
        { mandatoryIf: [PKTCNT] }
      ),
      packetUnicastTxCount: import_MutableCluster.MutableCluster.AsConditional(
        WiFiNetworkDiagnostics2.PacketCountsComponent.attributes.packetUnicastTxCount,
        { mandatoryIf: [PKTCNT] }
      ),
      overrunCount: import_MutableCluster.MutableCluster.AsConditional(
        WiFiNetworkDiagnostics2.ErrorCountsComponent.attributes.overrunCount,
        { mandatoryIf: [ERRCNT] }
      )
    },
    commands: {
      resetCounts: import_MutableCluster.MutableCluster.AsConditional(
        WiFiNetworkDiagnostics2.ErrorCountsComponent.commands.resetCounts,
        { mandatoryIf: [ERRCNT] }
      )
    },
    events: WiFiNetworkDiagnostics2.Cluster.events
  });
  WiFiNetworkDiagnostics2.Complete = WiFiNetworkDiagnostics2.CompleteInstance;
})(WiFiNetworkDiagnostics || (WiFiNetworkDiagnostics = {}));
const WiFiNetworkDiagnosticsCluster = WiFiNetworkDiagnostics.Cluster;
import_ClusterRegistry.ClusterRegistry.register(WiFiNetworkDiagnostics.Complete);
//# sourceMappingURL=wi-fi-network-diagnostics.js.map
