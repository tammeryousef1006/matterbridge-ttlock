/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Schema } from "../schema/Schema.js";
import { TlvTag, TlvToPrimitive, TlvTypeLength } from "./TlvCodec.js";
export type TlvEncodingOptions = {
    /**
     * When true, the fabricIndex field will be excluded from the TLV encoding for list entries.
     * This flag must not be set together with the following flag.
     */
    forWriteInteraction?: boolean;
    /**
     * When true, mandatory field validation is skipped when encoding TLV for list entries.
     * This flag must not be set together with the former flag.
     */
    allowMissingFieldsForNonFabricFilteredRead?: boolean;
};
export declare abstract class TlvSchema<T> extends Schema<T, Uint8Array> implements TlvSchema<T> {
    decodeInternal(encoded: Uint8Array): T;
    encodeInternal(value: T): Uint8Array;
    encodeTlv(value: T, options?: TlvEncodingOptions): TlvStream;
    decodeTlv(encoded: TlvStream): T;
    decodeTlvInternal(reader: TlvReader): {
        value: T;
        tag?: TlvTag;
    };
    abstract decodeTlvInternalValue(reader: TlvReader, typeLength: TlvTypeLength): T;
    abstract encodeTlvInternal(writer: TlvWriter, value: T, tag?: TlvTag, options?: TlvEncodingOptions): void;
    injectField(value: T, _fieldId: number, _fieldValue: any, _injectChecker: (fieldValue: any) => boolean): T;
    removeField(value: T, _fieldId: number, _removeChecker: (fieldValue: any) => boolean): T;
}
export type TlvStream = TlvElement<any>[];
export type TlvElement<T extends TlvTypeLength> = {
    tag?: TlvTag;
    typeLength: T;
    value?: TlvToPrimitive[T["type"]];
};
export declare class TlvArrayWriter implements TlvWriter {
    private readonly tlvArray;
    writeTag(typeLength: TlvTypeLength, tag?: TlvTag): void;
    writePrimitive<T extends TlvTypeLength>(_typeLength: T, value: TlvToPrimitive[T["type"]]): void;
    toTlvArray(): TlvElement<any>[];
}
export declare class TlvArrayReader implements TlvReader {
    private readonly tlvElements;
    private index;
    constructor(tlvElements: TlvElement<any>[]);
    readTagType(): TlvElement<any>;
    readPrimitive<T extends TlvTypeLength, V = TlvToPrimitive[T["type"]]>(_typeLength: T): V;
}
/** Type defined by the TLV schema. */
export type TypeFromSchema<S extends TlvSchema<any>> = S extends TlvSchema<infer T> ? T : never;
export interface TlvReader {
    readTagType(): {
        tag?: TlvTag;
        typeLength: TlvTypeLength;
    };
    readPrimitive<T extends TlvTypeLength, V = TlvToPrimitive[T["type"]]>(typeLength: T): V;
}
export interface TlvWriter {
    writeTag(typeLength: TlvTypeLength, tag?: TlvTag): void;
    writePrimitive<T extends TlvTypeLength>(typeLength: T, value: TlvToPrimitive[T["type"]]): void;
}
export declare class TlvByteArrayWriter implements TlvWriter {
    private readonly writer;
    writeTag(typeLength: TlvTypeLength, tag?: TlvTag): void;
    writePrimitive<T extends TlvTypeLength>(typeLength: T, value: TlvToPrimitive[T["type"]]): void;
    toByteArray(): Uint8Array<ArrayBufferLike>;
}
export declare class TlvByteArrayReader implements TlvReader {
    private readonly reader;
    constructor(byteArray: Uint8Array);
    readTagType(): {
        tag?: TlvTag;
        typeLength: TlvTypeLength;
    };
    readPrimitive<T extends TlvTypeLength, V = TlvToPrimitive[T["type"]]>(typeLength: T): V;
}
//# sourceMappingURL=TlvSchema.d.ts.map