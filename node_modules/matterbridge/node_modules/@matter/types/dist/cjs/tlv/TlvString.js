"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var TlvString_exports = {};
__export(TlvString_exports, {
  StringSchema: () => StringSchema,
  TlvByteString: () => TlvByteString,
  TlvHardwareAddress: () => TlvHardwareAddress,
  TlvString: () => TlvString,
  TlvString256max: () => TlvString256max,
  TlvString32max: () => TlvString32max,
  TlvString64max: () => TlvString64max
});
module.exports = __toCommonJS(TlvString_exports);
var import_general = require("#general");
var import_ValidationError = require("../common/ValidationError.js");
var import_TlvCodec = require("./TlvCodec.js");
var import_TlvSchema = require("./TlvSchema.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
class StringSchema extends import_TlvSchema.TlvSchema {
  constructor(type, minLength = 0, maxLength = 1024) {
    super();
    this.type = type;
    this.minLength = minLength;
    this.maxLength = maxLength;
    if (minLength < 0) throw new import_general.InternalError("Minimum length should be a positive number.");
  }
  encodeTlvInternal(writer, value, tag) {
    const typeLength = { type: this.type, length: import_TlvCodec.TlvCodec.getUIntTlvLength(value.length) };
    writer.writeTag(typeLength, tag);
    writer.writePrimitive(typeLength, value);
  }
  decodeTlvInternalValue(reader, typeLength) {
    if (typeLength.type !== this.type) throw new import_general.UnexpectedDataError(`Unexpected type ${typeLength.type}.`);
    return reader.readPrimitive(typeLength);
  }
  validate(value) {
    if (this.type === import_TlvCodec.TlvType.Utf8String && typeof value !== "string")
      throw new import_ValidationError.ValidationDatatypeMismatchError(`Expected string, got ${typeof value}.`);
    if (this.type === import_TlvCodec.TlvType.ByteString && !(value instanceof Uint8Array))
      throw new import_ValidationError.ValidationDatatypeMismatchError(`Expected Uint8Array, got ${typeof value}.`);
    if (value.length > this.maxLength)
      throw new import_ValidationError.ValidationOutOfBoundsError(
        `String ${(0, import_general.serialize)(value)} is too long: ${value.length}, max ${this.maxLength}.`
      );
    if (value.length < this.minLength)
      throw new import_ValidationError.ValidationOutOfBoundsError(
        `String ${(0, import_general.serialize)(value)} is too short: ${value.length}, min ${this.minLength}.`
      );
  }
  bound({ minLength, maxLength, length }) {
    return new StringSchema(
      this.type,
      length ?? (0, import_general.maxValue)(this.minLength, minLength),
      length ?? (0, import_general.minValue)(this.maxLength, maxLength)
    );
  }
}
const TlvByteString = new StringSchema(import_TlvCodec.TlvType.ByteString);
const TlvString = new StringSchema(import_TlvCodec.TlvType.Utf8String);
const TlvString32max = TlvString.bound({ maxLength: 32 });
const TlvString64max = TlvString.bound({ maxLength: 64 });
const TlvString256max = TlvString.bound({ maxLength: 256 });
const TlvHardwareAddress = TlvByteString.bound({ minLength: 6, maxLength: 8 });
//# sourceMappingURL=TlvString.js.map
