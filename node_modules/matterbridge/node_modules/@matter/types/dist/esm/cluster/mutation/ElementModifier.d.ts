/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { ClusterType } from "../ClusterType.js";
/**
 * An "element modifier" mutates cluster elements based on a predefined set of
 * alterations described in the Matter device library.
 */
export declare class ElementModifier<const T extends ClusterType> {
    cluster: T;
    constructor(cluster: T);
    /**
     * Create a new cluster with modified elements.
     */
    alter<const AlterationsT extends ElementModifier.Alterations<T>>(alterations: AlterationsT): ElementModifier.WithAlterations<T, AlterationsT>;
    /**
     * Create a new cluster with different attribute defaults.
     *
     * This "sets" the values of attributes when the cluster is created
     * for the first time with no persistent state.
     */
    set<const ValuesT extends Partial<ClusterType.InputAttributeValues<T>>>(values: ValuesT): ElementModifier.WithValues<T, ValuesT>;
    /**
     * Create a new cluster with additional features marked "mandatory".
     *
     * This informs matter.js that an application supports these elements.
     */
    enable<const FlagsT extends ElementModifier.ElementFlags<T>>(flags: FlagsT): ElementModifier.WithAlterations<T, ElementModifier.ElementFlagAlterations<FlagsT>>;
}
export declare namespace ElementModifier {
    /**
     * A set of modifications to cluster elements of a specific type.
     */
    type ElementSetAlterations<AlterationT extends ElementAlteration, ElementSetT> = {
        [name in keyof ElementSetT]?: AlterationT;
    };
    interface ElementAlteration {
        optional?: boolean;
    }
    interface AttributeAlteration extends ElementAlteration {
        default?: any;
        min?: any;
        max?: any;
    }
    /**
     * A set of modifications to a cluster's elements.
     *
     * Note - cannot specify ElementsT as extending ClusterElements because it
     * triggers a bug in TS 5.2 declaration generation
     */
    type Alterations<OriginalT extends ClusterType> = {
        attributes?: ElementSetAlterations<AttributeAlteration, OriginalT["attributes"]>;
        commands?: ElementSetAlterations<ElementAlteration, OriginalT["commands"]>;
        events?: ElementSetAlterations<ElementAlteration, OriginalT["events"]>;
    };
    /**
     * Alterations applied to a specific element set, element or element field.
     */
    type AlteredElements<OriginalT, ElementT, AlterationT> = {
        [name in keyof OriginalT]: OriginalT[name] extends infer OrigT extends ElementT ? AlterationT extends {
            [n in name]: {
                optional: infer O extends boolean;
            };
        } ? Omit<OrigT, "optional"> & {
            optional: O;
        } : OrigT : never;
    };
    /**
     * A definition with alterations applied.
     */
    type WithAlterations<T extends ClusterType, AlterationsT extends Alterations<any>> = Omit<T, "attributes" | "commands" | "events"> & {
        attributes: AlteredElements<T["attributes"], ClusterType.Attribute, AlterationsT["attributes"]>;
        commands: AlteredElements<T["commands"], ClusterType.Command, AlterationsT["commands"]>;
        events: AlteredElements<T["events"], ClusterType.Event, AlterationsT["events"]>;
    };
    /**
     * A definition with attribute defaults updated.
     */
    type WithValues<T extends ClusterType, ValuesT extends Partial<ClusterType.InputAttributeValues<T>>> = WithAlterations<T, AttributeValueAlterations<ValuesT>>;
    /**
     * A definition with elements enabled.
     */
    type WithFlags<T extends ClusterType, FlagsT extends ElementFlags<T>> = WithAlterations<T, ElementFlagAlterations<FlagsT>>;
    /**
     * Alterations implied by AttributeValues.
     */
    type AttributeValueAlterations<ValuesT extends Partial<ClusterType.InputAttributeValues<any>>> = {
        attributes: {
            [K in keyof ValuesT]: {
                default: ValuesT[K];
            };
        };
    };
    type ElementSetFlags<ElementsT extends ClusterType.ElementSet<any> | undefined> = {
        [key in keyof ElementsT]?: boolean;
    };
    /**
     * Flags indicating elements to enable.
     */
    type ElementFlags<ClusterT extends ClusterType> = {
        attributes?: ElementSetFlags<ClusterType.AttributesOf<ClusterT>>;
        commands?: ElementSetFlags<ClusterType.CommandsOf<ClusterT>>;
        events?: ElementSetFlags<ClusterType.EventsOf<ClusterT>>;
    };
    type ElementSetFlagAlterations<ElementsT extends ElementSetFlags<any> | undefined> = ElementsT extends {} ? {
        [key in keyof ElementsT]: {
            optional: ElementsT[key] extends true ? false : true;
        };
    } : undefined;
    /**
     * Alterations implied by ElementFlags.
     */
    type ElementFlagAlterations<T extends ElementFlags<any>> = {
        [K in keyof T]: T[K] extends ElementSetFlags<any> ? ElementSetFlagAlterations<T[K]> : never;
    };
    /**
     * An "extender" is a function that creates a cluster with specific
     * features enabled.
     */
    type Extender = (...features: any) => ClusterType;
}
//# sourceMappingURL=ElementModifier.d.ts.map