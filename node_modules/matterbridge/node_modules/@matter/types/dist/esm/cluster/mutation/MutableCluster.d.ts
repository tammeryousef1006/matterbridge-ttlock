/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { ClusterId } from "../../datatype/ClusterId.js";
import { ConditionalFeatureList } from "../Cluster.js";
import { ClusterType } from "../ClusterType.js";
import { ClusterComposer } from "./ClusterComposer.js";
import { ElementModifier } from "./ElementModifier.js";
/**
 * A "mutable cluster" is a {@link ClusterType} with builder methods that support a limited number of modifications as
 * defined by the Matter specification.
 */
export type MutableCluster<T extends ClusterType.Options, C extends ClusterComposer.Component[] = []> = ClusterComposer.WithComponents<ClusterType.Of<T>, C> & MutableCluster.Methods<ClusterType.Of<T>>;
/**
 * Define a new {@link MutableCluster}.
 */
export declare function MutableCluster<const T extends ClusterType.Options, const C extends ClusterComposer.Component[]>(options: T, ...components: C): MutableCluster<T, C>;
export declare namespace MutableCluster {
    /**
     * Define a component.
     */
    function Component<const T extends Partial<ClusterType.Options>>(elements: T): T;
    /**
     * Define a cluster's extension set.
     */
    function Extensions<const T extends readonly ClusterType.Extension[]>(...extensions: T): T;
    interface Methods<T extends ClusterType> {
        /**
         * Select features using {@link ClusterComposer.compose}.
         */
        with<const SelectionT extends ClusterComposer.FeatureSelection<T>>(...selection: SelectionT): ClusterComposer.Of<T, SelectionT>;
        /**
         * Modify elements using {@link ElementModifier.alter}.
         */
        alter<const AlterationsT extends ElementModifier.Alterations<T>>(alterations: AlterationsT): ElementModifier.WithAlterations<T, AlterationsT>;
        /**
         * Modify elements using {@link ElementModifier.set}.
         */
        set<const ValuesT extends ClusterType.InputAttributeValues<T>>(values: ValuesT): ElementModifier.WithValues<T, ValuesT>;
        /**
         * Modify elements using {@link ElementModifier.enable}.
         */
        enable<const FlagsT extends ElementModifier.ElementFlags<T>>(flags: FlagsT): ElementModifier.WithFlags<T, FlagsT>;
    }
    /**
     * ExtensibleOnly creates a factory that produces a {@link MutableCluster} when the user selects features.
     *
     * We define clusters this way if the Matter specification defines a cluster with a set of features, one of which is
     * required, but none of which is required if others are enabled.
     */
    interface ExtensibleOnly<T extends ClusterType.Options> {
        id: ClusterId;
        name: string;
        with: Methods<ClusterType.Of<T>>["with"];
    }
    /**
     * Create a factory for clusters that require extension.
     */
    function ExtensibleOnly<const T extends ClusterType.Options>(options: T): ExtensibleOnly<T>;
    /**
     * Create a conditional version of an unconditional element definition.
     */
    function AsConditional<const ClusterT extends ClusterType, const E extends ClusterType.Attribute | ClusterType.Command | ClusterType.Event, const OI extends ConditionalFeatureList<ClusterT["features"]>, const MI extends ConditionalFeatureList<ClusterT["features"]>>(element: E, { optionalIf, mandatoryIf }: {
        optionalIf?: OI;
        mandatoryIf?: MI;
    }): E & {
        readonly optional: true;
        readonly isConditional: true;
        readonly optionalIf: [] | OI;
        readonly mandatoryIf: [] | MI;
    };
}
//# sourceMappingURL=MutableCluster.d.ts.map