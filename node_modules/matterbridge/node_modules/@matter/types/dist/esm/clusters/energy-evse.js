/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { MutableCluster } from "../cluster/mutation/MutableCluster.js";
import {
  Attribute,
  Command,
  TlvNoResponse,
  OptionalWritableAttribute,
  OptionalEvent,
  EventPriority,
  OptionalCommand,
  Event
} from "../cluster/Cluster.js";
import {
  TlvEpochS,
  TlvInt64,
  TlvPercent,
  TlvUInt16,
  TlvUInt8,
  TlvBitmap,
  TlvEnum,
  TlvUInt32
} from "../tlv/TlvNumber.js";
import { TlvNullable } from "../tlv/TlvNullable.js";
import { TlvField, TlvObject, TlvOptionalField } from "../tlv/TlvObject.js";
import { AccessLevel } from "#model";
import { TlvArray } from "../tlv/TlvArray.js";
import { BitFlag } from "../schema/BitmapSchema.js";
import { TlvNoArguments } from "../tlv/TlvNoArguments.js";
import { TlvString, TlvByteString } from "../tlv/TlvString.js";
import { ClusterRegistry } from "../cluster/ClusterRegistry.js";
var EnergyEvse;
((EnergyEvse2) => {
  let Feature;
  ((Feature2) => {
    Feature2["ChargingPreferences"] = "ChargingPreferences";
    Feature2["SoCReporting"] = "SoCReporting";
    Feature2["PlugAndCharge"] = "PlugAndCharge";
    Feature2["Rfid"] = "Rfid";
    Feature2["V2X"] = "V2X";
  })(Feature = EnergyEvse2.Feature || (EnergyEvse2.Feature = {}));
  EnergyEvse2.TlvEnableDischargingRequest = TlvObject({
    /**
     * This field shall indicate the expiry time, in UTC, when discharging will be automatically disabled.
     *
     * A value in the past in this field shall disable the EVSE discharging whereas a null value shall enable EVSE
     * discharging permanently.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.3.9.3.1
     */
    dischargingEnabledUntil: TlvField(0, TlvNullable(TlvEpochS)),
    /**
     * This field shall indicate the maximum current that can be received by the EVSE from the EV. The EVSE current
     * limit can be advertised to an EV in 0.6A steps. The value of the MaximumDischargeCurrent attribute shall be
     * stored and persisted across reboots by the EVSE to the value of this field.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.3.9.3.2
     */
    maximumDischargeCurrent: TlvField(1, TlvInt64.bound({ min: 0 }))
  });
  EnergyEvse2.TargetDayOfWeek = {
    /**
     * Sunday
     */
    sunday: BitFlag(0),
    /**
     * Monday
     */
    monday: BitFlag(1),
    /**
     * Tuesday
     */
    tuesday: BitFlag(2),
    /**
     * Wednesday
     */
    wednesday: BitFlag(3),
    /**
     * Thursday
     */
    thursday: BitFlag(4),
    /**
     * Friday
     */
    friday: BitFlag(5),
    /**
     * Saturday
     */
    saturday: BitFlag(6)
  };
  EnergyEvse2.TlvChargingTarget = TlvObject({
    /**
     * This field shall indicate the desired charging completion time of the associated day. The time will be
     * represented by a 16 bits unsigned integer to designate the minutes since midnight. For example, 6am will be
     * represented by 360 minutes since midnight and 11:30pm will be represented by 1410 minutes since midnight.
     *
     * This field is based on local wall clock time. In case of Daylight Savings Time transition which may result in
     * an extra hour or one hour less in the day, the charging algorithm should take into account the shift
     * appropriately.
     *
     * Note that if the TargetTimeMinutesPastMidnight values are too close together (e.g. 2 per day) these may
     * overlap. The EVSE may have to coalesce the charging targets into a single target. e.g. if the 1st charging
     * target cannot be met in the time available, the EVSE may be forced to begin working towards the 2nd charging
     * target and immediately continue until both targets have been satisfied (or the vehicle becomes full).
     *
     * The EVSE itself cannot predict the behavior of the vehicle (i.e. if it cannot obtain the SoC from the
     * vehicle), so should attempt to perform a sensible operation based on these targets. It is recommended that
     * the charging schedule is pessimistic (i.e. starts earlier) since the vehicle may charge more slowly than the
     * electrical supply may provide power (especially if it is cold).
     *
     * If the user configures large charging targets (e.g. high values of AddedEnergy or SoC) then it is expected
     * that the EVSE may need to begin charging immediately, and may not be able to guarantee that the vehicle will
     * be able to reach the target.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.3.7.6.1
     */
    targetTimeMinutesPastMidnight: TlvField(0, TlvUInt16.bound({ max: 1439 })),
    /**
     * This field represents the target SoC that the vehicle should be charged to before the
     * TargetTimeMinutesPastMidnight.
     *
     * If the EVSE supports the SOC feature and can obtain the SoC of the vehicle:
     *
     *   • the TargetSoC field shall take precedence over the AddedEnergy field.
     *
     *   • the EVSE SHOULD charge to the TargetSoC and then stop the charging automatically when it reaches that
     *     point.
     *
     *   • if the TargetSoC value is set to 100% then the EVSE SHOULD continue to charge the vehicle until the
     *     vehicle decides to stop charging.
     *
     * If the EVSE does not support the SOC feature or cannot obtain the SoC of the vehicle:
     *
     *   • the AddedEnergy field shall take precedence over the TargetSoC field, and if the EVSE does not support
     *     the SOC feature then the TargetSoC field may only take the values null or 100%.
     *
     *   • if the AddedEnergy field has not been provided, the EVSE SHOULD assume the vehicle is empty
     *
     * and charge until the vehicle stops demanding a charge.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.3.7.6.2
     */
    targetSoC: TlvOptionalField(1, TlvPercent),
    /**
     * This field represents the amount of energy that the user would like to have added to the vehicle before the
     * TargetTimeMinutesPastMidnight.
     *
     * This represents a positive value in mWh that SHOULD be added during the session (i.e. if the vehicle charging
     * is stopped and started several times, this equates to the total energy since the vehicle has been plugged
     * in).
     *
     * The maximum value (500kWh) is much larger than most EV batteries on the market today. If the client tries to
     * set this value too high then the EVSE will need to start charging immediately and continue charging until the
     * vehicle stops demanding charge (i.e. it is full). Therefore the maximum value should be set based on typical
     * battery size of the vehicles on the market (e.g. 70000Wh), however this is up to the client to carefully
     * choose a value.
     *
     * NOTE
     *
     * If the EVSE can obtain the Battery Capacity of the vehicle, it SHOULD NOT limit this AddedEnergy value to the
     * Battery Capacity of the vehicle, since the EV may also require energy for heating and cooling of the battery
     * during charging, or for heating or cooling the cabin.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.3.7.6.3
     */
    addedEnergy: TlvOptionalField(2, TlvInt64.bound({ min: 0 }))
  });
  EnergyEvse2.TlvChargingTargetSchedule = TlvObject({
    /**
     * This field shall indicate the days of the week that the charging targets SHOULD be associated to. This field
     * is a bitmap and therefore the associated targets could be applied to multiple days.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.3.7.8
     */
    dayOfWeekForSequence: TlvField(0, TlvBitmap(TlvUInt8, EnergyEvse2.TargetDayOfWeek)),
    /**
     * This field shall indicate a list of up to 10 charging targets for each of the associated days of the week.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.3.7.9
     */
    chargingTargets: TlvField(1, TlvArray(EnergyEvse2.TlvChargingTarget, { maxLength: 10 }))
  });
  EnergyEvse2.TlvSetTargetsRequest = TlvObject({
    /**
     * This field shall indicate a list of up to 7 sets of daily charging targets together with their associated
     * days of the week. Each of the days of the week may only be included in a single ChargingTargetSchedule within
     * this list field.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.3.9.5.1
     */
    chargingTargetSchedules: TlvField(0, TlvArray(EnergyEvse2.TlvChargingTargetSchedule, { maxLength: 7 }))
  });
  EnergyEvse2.TlvGetTargetsResponse = TlvObject({
    /**
     * This field shall indicate a list of up to 7 sets of daily charging targets together with their associated
     * days of the week.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.3.9.7.1
     */
    chargingTargetSchedules: TlvField(0, TlvArray(EnergyEvse2.TlvChargingTargetSchedule, { maxLength: 7 }))
  });
  EnergyEvse2.TlvRfidEvent = TlvObject({
    /**
     * The UID field (ISO 14443A UID) is either 4, 7 or 10 bytes.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.3.10.6.1
     */
    uid: TlvField(0, TlvByteString.bound({ maxLength: 10 }))
  });
  let State;
  ((State2) => {
    State2[State2["NotPluggedIn"] = 0] = "NotPluggedIn";
    State2[State2["PluggedInNoDemand"] = 1] = "PluggedInNoDemand";
    State2[State2["PluggedInDemand"] = 2] = "PluggedInDemand";
    State2[State2["PluggedInCharging"] = 3] = "PluggedInCharging";
    State2[State2["PluggedInDischarging"] = 4] = "PluggedInDischarging";
    State2[State2["SessionEnding"] = 5] = "SessionEnding";
    State2[State2["Fault"] = 6] = "Fault";
  })(State = EnergyEvse2.State || (EnergyEvse2.State = {}));
  let SupplyState;
  ((SupplyState2) => {
    SupplyState2[SupplyState2["Disabled"] = 0] = "Disabled";
    SupplyState2[SupplyState2["ChargingEnabled"] = 1] = "ChargingEnabled";
    SupplyState2[SupplyState2["DischargingEnabled"] = 2] = "DischargingEnabled";
    SupplyState2[SupplyState2["DisabledError"] = 3] = "DisabledError";
    SupplyState2[SupplyState2["DisabledDiagnostics"] = 4] = "DisabledDiagnostics";
    SupplyState2[SupplyState2["Enabled"] = 5] = "Enabled";
  })(SupplyState = EnergyEvse2.SupplyState || (EnergyEvse2.SupplyState = {}));
  let FaultState;
  ((FaultState2) => {
    FaultState2[FaultState2["NoError"] = 0] = "NoError";
    FaultState2[FaultState2["MeterFailure"] = 1] = "MeterFailure";
    FaultState2[FaultState2["OverVoltage"] = 2] = "OverVoltage";
    FaultState2[FaultState2["UnderVoltage"] = 3] = "UnderVoltage";
    FaultState2[FaultState2["OverCurrent"] = 4] = "OverCurrent";
    FaultState2[FaultState2["ContactWetFailure"] = 5] = "ContactWetFailure";
    FaultState2[FaultState2["ContactDryFailure"] = 6] = "ContactDryFailure";
    FaultState2[FaultState2["GroundFault"] = 7] = "GroundFault";
    FaultState2[FaultState2["PowerLoss"] = 8] = "PowerLoss";
    FaultState2[FaultState2["PowerQuality"] = 9] = "PowerQuality";
    FaultState2[FaultState2["PilotShortCircuit"] = 10] = "PilotShortCircuit";
    FaultState2[FaultState2["EmergencyStop"] = 11] = "EmergencyStop";
    FaultState2[FaultState2["EvDisconnected"] = 12] = "EvDisconnected";
    FaultState2[FaultState2["WrongPowerSupply"] = 13] = "WrongPowerSupply";
    FaultState2[FaultState2["LiveNeutralSwap"] = 14] = "LiveNeutralSwap";
    FaultState2[FaultState2["OverTemperature"] = 15] = "OverTemperature";
    FaultState2[FaultState2["Other"] = 255] = "Other";
  })(FaultState = EnergyEvse2.FaultState || (EnergyEvse2.FaultState = {}));
  EnergyEvse2.TlvEnableChargingRequest = TlvObject({
    /**
     * This field shall indicate the expiry time, in UTC, when charging will be automatically disabled.
     *
     * A value in the past in this field shall disable the EVSE charging whereas a null value shall enable it
     * permanently.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.3.9.2.1
     */
    chargingEnabledUntil: TlvField(0, TlvNullable(TlvEpochS)),
    /**
     * This field shall indicate the minimum current that can be delivered by the EVSE to the EV in trickle mode.
     * The EVSE current limit can be advertised to an EV in 0.6A steps.
     *
     * The value of the MinimumChargeCurrent attribute shall be set to the value of this field (see
     * MinimumChargeCurrent attribute for further details).
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.3.9.2.2
     */
    minimumChargeCurrent: TlvField(1, TlvInt64.bound({ min: 0 })),
    /**
     * This field shall indicate the maximum current that can be delivered by the EVSE to the EV. The EVSE current
     * limit can be advertised to an EV in 0.6A steps.
     *
     * The value of the this field shall be stored by the EVSE to determine the value of MaximumChargeCurrent
     * attribute. For example, if the UserMaximumChargeCurrent attribute is adjusted below then this value, and then
     * later adjusted above this value, the resulting MaximumChargeCurrent attribute will be limited to this value.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.3.9.2.3
     */
    maximumChargeCurrent: TlvField(2, TlvInt64.bound({ min: 0 }))
  });
  EnergyEvse2.TlvEvConnectedEvent = TlvObject({
    /**
     * This is the new session ID created after the vehicle is plugged in.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.3.10.1.1
     */
    sessionId: TlvField(0, TlvUInt32)
  });
  EnergyEvse2.TlvEvNotDetectedEvent = TlvObject({
    /**
     * This field shall indicate the current value of the SessionID attribute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.3.10.2.1
     */
    sessionId: TlvField(0, TlvUInt32),
    /**
     * This field shall indicate the value of the State attribute prior to the EV not being detected.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.3.10.2.2
     */
    state: TlvField(1, TlvEnum()),
    /**
     * This field shall indicate the total duration of the session, from the start of the session when the EV was
     * plugged in, until it was unplugged.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.3.10.2.3
     */
    sessionDuration: TlvField(2, TlvUInt32),
    /**
     * This field shall indicate the total amount of energy transferred from the EVSE to the EV during the session.
     *
     * Note that if bi-directional charging occurs during the session, then this value shall only include the sum of
     * energy transferred from the EVSE to the EV, and shall NOT be a net value of charging and discharging energy.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.3.10.2.4
     */
    sessionEnergyCharged: TlvField(3, TlvInt64.bound({ min: 0 })),
    /**
     * This field shall indicate the total amount of energy transferred from the EV to the EVSE during the session.
     *
     * Note that if bi-directional discharging occurs during the session, then this value shall only include the sum
     * of energy transferred from the EV to the EVSE, and shall NOT be a net value of charging and discharging
     * energy.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.3.10.2.5
     */
    sessionEnergyDischarged: TlvOptionalField(4, TlvInt64.bound({ min: 0 }))
  });
  EnergyEvse2.TlvEnergyTransferStartedEvent = TlvObject({
    /**
     * This field shall indicate the value of the SessionID attribute at the time the event was generated.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.3.10.3.1
     */
    sessionId: TlvField(0, TlvUInt32),
    /**
     * This field shall indicate the value of the State attribute at the time the event was generated.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.3.10.3.2
     */
    state: TlvField(1, TlvEnum()),
    /**
     * This field shall indicate the value of the maximum charging current at the time the event was generated.
     *
     * A non-zero value indicates that the EV has been enabled for charging and the value is taken directly from the
     * MaximumChargeCurrent attribute. A zero value indicates that the EV has not been enabled for charging.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.3.10.3.3
     */
    maximumCurrent: TlvField(2, TlvInt64.bound({ min: 0 })),
    /**
     * This field shall indicate the value of the maximum discharging current at the time the event was generated.
     *
     * A non-zero value indicates that the EV has been enabled for discharging and the value is taken directly from
     * the MaximumDischargeCurrent attribute. A zero value indicates that the EV has not been enabled for
     * discharging.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.3.10.3.4
     */
    maximumDischargeCurrent: TlvOptionalField(3, TlvInt64.bound({ min: 0 }))
  });
  let EnergyTransferStoppedReason;
  ((EnergyTransferStoppedReason2) => {
    EnergyTransferStoppedReason2[EnergyTransferStoppedReason2["EvStopped"] = 0] = "EvStopped";
    EnergyTransferStoppedReason2[EnergyTransferStoppedReason2["EvseStopped"] = 1] = "EvseStopped";
    EnergyTransferStoppedReason2[EnergyTransferStoppedReason2["Other"] = 2] = "Other";
  })(EnergyTransferStoppedReason = EnergyEvse2.EnergyTransferStoppedReason || (EnergyEvse2.EnergyTransferStoppedReason = {}));
  EnergyEvse2.TlvEnergyTransferStoppedEvent = TlvObject({
    /**
     * This field shall indicate the value of the SessionID attribute prior to the energy transfer stopping.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.3.10.4.1
     */
    sessionId: TlvField(0, TlvUInt32),
    /**
     * This field shall indicate the value of the State attribute prior to the energy transfer stopping.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.3.10.4.2
     */
    state: TlvField(1, TlvEnum()),
    /**
     * This field shall indicate the reason why the energy transferred stopped.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.3.10.4.3
     */
    reason: TlvField(2, TlvEnum()),
    /**
     * This field shall indicate the amount of energy transferred from the EVSE to the EV since the previous
     * EnergyTransferStarted event, in mWh.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.3.10.4.4
     */
    energyTransferred: TlvField(4, TlvInt64.bound({ min: 0 })),
    /**
     * This field shall indicate the amount of energy transferred from the EV to the EVSE since the previous
     * EnergyTransferStarted event, in mWh.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.3.10.4.5
     */
    energyDischarged: TlvOptionalField(5, TlvInt64.bound({ min: 0 }))
  });
  EnergyEvse2.TlvFaultEvent = TlvObject({
    /**
     * This field shall indicate the value of the SessionID attribute prior to the Fault State being changed. A
     * value of null indicates no sessions have occurred before the fault occurred.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.3.10.5.1
     */
    sessionId: TlvField(0, TlvNullable(TlvUInt32)),
    /**
     * This field shall indicate the value of the State attribute prior to the Fault State being changed.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.3.10.5.2
     */
    state: TlvField(1, TlvEnum()),
    /**
     * This field shall indicate the value of the FaultState attribute prior to the Fault State being changed.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.3.10.5.3
     */
    faultStatePreviousState: TlvField(2, TlvEnum()),
    /**
     * This field shall indicate the current value of the FaultState attribute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 9.3.10.5.4
     */
    faultStateCurrentState: TlvField(4, TlvEnum())
  });
  EnergyEvse2.V2XComponent = MutableCluster.Component({
    attributes: {
      /**
       * Indicates the time, in UTC, that the EVSE will automatically stop current flow from the EV.
       *
       * A null value indicates the EVSE is always enabled for discharging.
       *
       * A value in the past or 0x0 indicates that EVSE discharging shall be disabled. The attribute is only set
       * via the payload of the EnableDischarging command.
       *
       * This attribute shall be persisted, for example a temporary power failure should not stop the vehicle from
       * being discharged.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.8.5
       */
      dischargingEnabledUntil: Attribute(4, TlvNullable(TlvEpochS), { persistent: true, default: 0 }),
      /**
       * Indicates the maximum current that can be received by the EVSE from the EV. This attribute can be set
       * using the EnableDischarging command.
       *
       * This attribute value shall be the minimum of:
       *
       *   • CircuitCapacity - Electrician’s installation setting
       *
       *   • CableAssemblyCurrentLimit (detected by the EVSE when the cable is plugged in)
       *
       *   • MaximumDischargeCurrent field in the EnableDischarging command
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.8.9
       */
      maximumDischargeCurrent: Attribute(8, TlvInt64.bound({ min: 0 }), { persistent: true, default: 0 }),
      /**
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.8
       */
      sessionEnergyDischarged: Attribute(
        67,
        TlvNullable(TlvInt64.bound({ min: 0 })),
        { persistent: true, default: null }
      )
    },
    commands: {
      /**
       * Upon receipt, this shall allow a client to enable the discharge of an EV, and to provide or update the
       * maximum discharge current.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.9.3
       */
      enableDischarging: Command(3, EnergyEvse2.TlvEnableDischargingRequest, 3, TlvNoResponse, { timed: true })
    }
  });
  EnergyEvse2.ChargingPreferencesComponent = MutableCluster.Component({
    attributes: {
      /**
       * Indicates the time, in UTC, when the EVSE plans to start the next scheduled charge based on the charging
       * preferences.
       *
       * A null value indicates that there is no scheduled charging (for example, the EVSE Mode is set to use
       * Manual mode tag), or that the vehicle is not plugged in with the SupplyState indicating that charging is
       * enabled.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.8.12
       */
      nextChargeStartTime: Attribute(35, TlvNullable(TlvEpochS), { default: null }),
      /**
       * Indicates the time, in UTC, when the EVSE SHOULD complete the next scheduled charge based on the charging
       * preferences.
       *
       * A null value indicates that there is no scheduled charging (for example, the EVSE Mode is set to use
       * Manual mode tag), or that the vehicle is not plugged in with the SupplyState indicating that charging is
       * enabled.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.8.13
       */
      nextChargeTargetTime: Attribute(36, TlvNullable(TlvEpochS), { default: null }),
      /**
       * Indicates the amount of energy that the EVSE is going to attempt to add to the vehicle in the next
       * charging target.
       *
       * A null value indicates that there is no scheduled charging (for example, the EVSE Mode is set to use
       * Manual mode tag), or that the vehicle is not plugged in with the SupplyState indicating that charging is
       * enabled, or that the next ChargingTargetStruct is using the TargetSoC value to charge the vehicle.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.8.14
       */
      nextChargeRequiredEnergy: Attribute(37, TlvNullable(TlvInt64.bound({ min: 0 })), { default: null }),
      /**
       * Indicates the target SoC the EVSE is going to attempt to reach when the vehicle is next charged.
       *
       * A null value indicates that there is no scheduled charging
       *
       * Manual mode tag), or that the vehicle is not plugged in with the SupplyState indicating that charging is
       * enabled, or that the next ChargingTargetStruct is using the AddedEnergy value to charge the vehicle.
       *
       * If the SOC feature is not supported, only the values null and 100% are supported.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.8.15
       */
      nextChargeTargetSoC: Attribute(38, TlvNullable(TlvPercent), { default: null }),
      /**
       * Indicates the vehicle efficiency rating for a connected vehicle.
       *
       * This can be used to help indicate to the user approximately how many miles or km of range will be added.
       * It allows user interfaces to display to the user simpler terms that they can relate to compared to kWh.
       *
       * This is value is stored in km per kWh multiplied by a scaling factor of 1000.
       *
       * A null value indicates that the EV efficiency is unknown and the NextChargeRequiredEnergy attribute
       * cannot be converted from Wh to miles or km.
       *
       * To convert from Wh into Range:
       *
       * AddedRange (km) = AddedEnergy (Wh) x ApproxEVEfficiency (km/kWh x 1000) AddedRange (Miles) = AddedEnergy
       * (Wh) x ApproxEVEfficiency (km/kWh x 1000) x 0.6213
       *
       * Example:
       *
       * ApproxEVEfficiency (km/kWh x 1000): 4800 (i.e. 4.8km/kWh x 1000)
       *
       * AddedEnergy (Wh): 10,000
       *
       * AddedRange (km) = 10,000 x 4800 / 1,000,000 = 48 km
       *
       * AddedRange (Miles) = AddedEnergy (Wh) x ApproxEVEfficiency (km/kWh x 1000) x
       *
       * 0.6213
       *
       * = 29.82 Miles
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.8.16
       */
      approximateEvEfficiency: OptionalWritableAttribute(
        39,
        TlvNullable(TlvUInt16),
        { persistent: true, default: null, writeAcl: AccessLevel.Manage }
      )
    },
    commands: {
      /**
       * Allows a client to set the user specified charging targets.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.9.5
       */
      setTargets: Command(5, EnergyEvse2.TlvSetTargetsRequest, 5, TlvNoResponse, { timed: true }),
      /**
       * Allows a client to retrieve the current set of charging targets.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.9.6
       */
      getTargets: Command(6, TlvNoArguments, 0, EnergyEvse2.TlvGetTargetsResponse, { timed: true }),
      /**
       * Allows a client to clear all stored charging targets.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.9.8
       */
      clearTargets: Command(7, TlvNoArguments, 7, TlvNoResponse, { timed: true })
    }
  });
  EnergyEvse2.SoCReportingComponent = MutableCluster.Component({
    attributes: {
      /**
       * Indicates the state of charge of the EV battery in steps of 1%. The values are in the 0-100%. This
       * attribute is only available on EVSEs which can read the state of charge from the vehicle and that support
       * the SOC feature. If the StateOfCharge cannot be read from the vehicle it shall be returned with a NULL
       * value.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.8.17
       */
      stateOfCharge: Attribute(48, TlvNullable(TlvPercent), { default: null }),
      /**
       * Indicates the capacity of the EV battery in mWh. This value is always positive.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.8.18
       */
      batteryCapacity: Attribute(49, TlvNullable(TlvInt64.bound({ min: 0 })), { default: null })
    }
  });
  EnergyEvse2.PlugAndChargeComponent = MutableCluster.Component({
    attributes: {
      /**
       * Indicates the vehicle ID read by the EVSE via ISO-15118 using the PNC feature, if the EVSE supports this
       * capability.
       *
       * The field may be based on the e-Mobility Account Identifier (EMAID). A null value shall indicate that
       * this is unknown.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.8.19
       */
      vehicleId: Attribute(50, TlvNullable(TlvString.bound({ maxLength: 32 })), { default: null })
    }
  });
  EnergyEvse2.RfidComponent = MutableCluster.Component({
    events: {
      /**
       * This event shall be generated when a RFID card has been read. This allows a controller to register the
       * card ID and use this to authenticate and start the charging session.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.10.6
       */
      rfid: OptionalEvent(5, EventPriority.Info, EnergyEvse2.TlvRfidEvent)
    }
  });
  EnergyEvse2.Base = MutableCluster.Component({
    id: 153,
    name: "EnergyEvse",
    revision: 3,
    features: {
      /**
       * ChargingPreferences
       *
       * Since some EVSEs cannot obtain the SoC from the vehicle, some EV charging solutions allow the consumer to
       * specify a daily charging target (for adding energy to the EV’s battery). This feature allows the consumer
       * to specify how many miles or km of additional range they need for their typical daily commute. This range
       * requirement can be converted into a daily energy demand with a target charging completion time.
       *
       * The EVSE itself can use this information (or may allow a controller such as an EMS) to compute an
       * optimized charging schedule.
       *
       * An EVSE device which includes a Device Energy Management device with the Device Energy Management cluster
       * PFR (Power Forecast Reporting) feature can use the charging preferences information to produce its power
       * forecast.
       *
       * EVSE devices that support the Device Energy Management cluster’s FA feature can have their charging
       * profiles set by a controller device such as an EMS. For example, if the EVSE advertises a simple power
       * forecast which allows the EMS to adjust over a wide range of power and time durations, then the EVSE may
       * allow the EMS to propose a revised optimized forecast (which is the charging profile). For example, a
       * solar PV ESA may also share its Forecast, so enabling an EMS to adjust the EVSE forecast to the best time
       * to charge so that any excess solar generation is used to charge the EV.
       *
       * See the Device Energy Management Cluster for more details.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.4.1
       */
      chargingPreferences: BitFlag(0),
      /**
       * SoCReporting
       *
       * Vehicles and EVSEs which support ISO 15118 may allow the vehicle to report its battery size and state of
       * charge. If the EVSE supports PLC it may have a vehicle connected which optionally supports reporting of
       * its battery size and current State of Charge (SoC).
       *
       * If the EVSE supports reporting of State of Charge this feature will only work if a compatible EV is
       * connected.
       *
       * Note some EVSEs may use other undefined mechanisms to obtain vehicle State of Charge outside the scope of
       * this cluster.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.4.2
       */
      soCReporting: BitFlag(1),
      /**
       * PlugAndCharge
       *
       * If the EVSE supports PLC, it may be able to support the Plug and Charge feature. e.g. this may allow the
       * vehicle ID to be obtained which may allow an energy management system to track energy usage per vehicle
       * (e.g. to give the owner an indicative cost of charging, or for work place charging).
       *
       * If the EVSE supports the Plug and Charge feature, it will only work if a compatible EV is connected.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.4.3
       */
      plugAndCharge: BitFlag(2),
      /**
       * Rfid
       *
       * If the EVSE is fitted with an RFID reader, it may be possible to obtain the User or Vehicle ID from an
       * RFID card. This may be used to record a charging session against a specific charging account, and may
       * optionally be used to authorize a charging session.
       *
       * An RFID event can be generated when a user taps an RFID card onto the RFID reader. The event must be
       * subscribed to by the EVSE Management cluster client. This client may use this to enable the EV to charge
       * or discharge. The lookup and authorization of RIFD UID is outside the scope of this cluster.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.4.4
       */
      rfid: BitFlag(3),
      /**
       * V2X
       *
       * If the EVSE can support bi-directional charging, it may be possible to request that the vehicle can
       * discharge to the home or grid.
       *
       * The charging and discharging may be controlled by a home Energy Management System (EMS) using the Device
       * Energy Management cluster of the associated Device Energy Management device. For example, an EMS may use
       * the PA (Power Adjustment) feature to continually adjust the charge/discharge current to/from the EV so as
       * to minimise the energy flow from/to the grid as the demand in the home and the solar supply to the home
       * both fluctuate.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.4.5
       */
      v2X: BitFlag(4)
    },
    attributes: {
      /**
       * Indicates the current status of the EVSE. This higher-level status is partly derived from the signaling
       * protocol as communicated between the EVSE and the vehicle through the pilot signal.
       *
       * The State attribute shall change when the EVSE detects change of condition of the EV (plugged in or
       * unplugged, whether the vehicle is asking for demand or not, and if it is charging or discharging).
       *
       * NOTE
       *
       * SessionEnding is not really a state but a transition. However, the transition period may take a few
       * seconds and is useful for some clean up purposes.
       *
       * The Fault state is used to indicate that the FaultState attribute is not NoError.
       *
       * A null value shall indicate that the state cannot be determined.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.8.1
       */
      state: Attribute(0, TlvNullable(TlvEnum())),
      /**
       * Indicates whether the EV is currently allowed to charge from or discharge to the EVSE.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.8.2
       */
      supplyState: Attribute(1, TlvEnum()),
      /**
       * Indicates the type of fault detected by the EVSE (internally or as detected in the pilot signal).
       *
       * When the SupplyState attribute is DisabledError, the FaultState attribute will be one of the values
       * listed in FaultStateEnum, except NoError. For all values of SupplyState other than DisabledError, the
       * FaultState attribute shall be NoError.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.8.3
       */
      faultState: Attribute(2, TlvEnum()),
      /**
       * Indicates the time, in UTC, that the EVSE will automatically stop current flow to the EV.
       *
       * A null value indicates the EVSE is always enabled for charging.
       *
       * A value in the past or 0x0 indicates that EVSE charging shall be disabled. The attribute is only set via
       * the payload of the EnableCharging command.
       *
       * This attribute shall be persisted, for example a temporary power failure should not stop the vehicle from
       * being charged.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.8.4
       */
      chargingEnabledUntil: Attribute(3, TlvNullable(TlvEpochS), { persistent: true, default: 0 }),
      /**
       * Indicates the capacity that the circuit that the EVSE is connected to can provide. It is intended to
       * allow implementation of a self-managed network of EVSEs. It is assumed that the device will allow the
       * setting of such values by an installer.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.8.6
       */
      circuitCapacity: Attribute(5, TlvInt64.bound({ min: 0 }), { persistent: true, default: 0 }),
      /**
       * Indicates the minimum current that can be delivered by the EVSE to the EV.
       *
       * The attribute can be set using the EnableCharging command.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.8.7
       */
      minimumChargeCurrent: Attribute(6, TlvInt64.bound({ min: 0 }), { persistent: true, default: 6e3 }),
      /**
       * Indicates the maximum current that can be delivered by the EVSE to the EV.
       *
       * This shall represent the actual maximum current offered to the EV at any time. Note that the EV can draw
       * less current than this value. For example, the EV may be limiting its power draw based on the operating
       * conditions of the battery, such as temperature and state of charge.
       *
       * The attribute can be initially set using the EnableCharging command or by adjusting the
       * UserMaximumChargeCurrent attribute.
       *
       * This attribute value shall be the minimum of:
       *
       *   • CircuitCapacity - Electrician’s installation setting
       *
       *   • CableAssemblyCurrentLimit (detected by the EVSE when the cable is plugged in)
       *
       *   • MaximumChargeCurrent field in the EnableCharging command
       *
       *   • UserMaximumChargeCurrent attribute
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.8.8
       */
      maximumChargeCurrent: Attribute(7, TlvInt64.bound({ min: 0 }), { persistent: true, default: 0 }),
      /**
       * Indicates a maximum current that can set by the consumer (e.g. via an app) as a preference to further
       * reduce the charging rate. This may be desirable if the home owner has a solar PV or battery storage
       * system which may only be able to deliver a limited amount of power. The consumer can manually control how
       * much they allow the EV to take.
       *
       * This attribute value shall be limited by the EVSE to be in the range of:
       *
       * MinimumChargeCurrent <= UserMaximumChargeCurrent <= MaximumChargeCurrent
       *
       * where MinimumChargeCurrent and MaximumChargeCurrent are the values received in the EnableCharging
       * command.
       *
       * Its default value SHOULD be initialized to the same as the CircuitCapacity attribute. This value shall be
       * persisted across reboots to ensure it does not cause charging issues during temporary power failures.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.8.10
       */
      userMaximumChargeCurrent: OptionalWritableAttribute(
        9,
        TlvInt64,
        { persistent: true, default: 0, writeAcl: AccessLevel.Manage }
      ),
      /**
       * Indicates the size of a random window over which the EVSE will randomize the start of a charging session.
       * This value is in seconds.
       *
       * This is a feature that is mandated in some markets (such as UK) where the EVSE should by default
       * randomize its start time within the randomization window. By default in the UK this should be 600s.
       *
       * For example, if the RandomizationDelayWindow is 600s (i.e. 10 minutes) and if there was a cheap rate
       * energy starting at 00:30, then the EVSE must compute a random delay between 0-599s and add this to its
       * initial planned start time.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.8.11
       */
      randomizationDelayWindow: OptionalWritableAttribute(
        10,
        TlvUInt32.bound({ max: 86400 }),
        { persistent: true, default: 600, writeAcl: AccessLevel.Manage }
      ),
      /**
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.8
       */
      sessionId: Attribute(64, TlvNullable(TlvUInt32), { persistent: true, default: null }),
      /**
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.8
       */
      sessionDuration: Attribute(65, TlvNullable(TlvUInt32), { persistent: true, default: null }),
      /**
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.8
       */
      sessionEnergyCharged: Attribute(
        66,
        TlvNullable(TlvInt64.bound({ min: 0 })),
        { persistent: true, default: null }
      )
    },
    commands: {
      /**
       * Allows a client to disable the EVSE from charging and discharging.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.9.1
       */
      disable: Command(1, TlvNoArguments, 1, TlvNoResponse, { timed: true }),
      /**
       * This command allows a client to enable the EVSE to charge an EV, and to provide or update the maximum and
       * minimum charge current.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.9.2
       */
      enableCharging: Command(2, EnergyEvse2.TlvEnableChargingRequest, 2, TlvNoResponse, { timed: true }),
      /**
       * Allows a client to put the EVSE into a self-diagnostics mode.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.9.4
       */
      startDiagnostics: OptionalCommand(4, TlvNoArguments, 4, TlvNoResponse, { timed: true })
    },
    events: {
      /**
       * This event shall be generated when the EV is plugged in.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.10.1
       */
      evConnected: Event(0, EventPriority.Info, EnergyEvse2.TlvEvConnectedEvent),
      /**
       * This event shall be generated when the EV is unplugged or not detected (having been previously plugged
       * in). When the vehicle is unplugged then the session is ended.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.10.2
       */
      evNotDetected: Event(1, EventPriority.Info, EnergyEvse2.TlvEvNotDetectedEvent),
      /**
       * This event shall be generated whenever the EV starts charging or discharging, except when an EV has
       * switched between charging and discharging under the control of the PowerAdjustment feature of the Device
       * Energy Management cluster of the associated Device Energy Management device.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.10.3
       */
      energyTransferStarted: Event(2, EventPriority.Info, EnergyEvse2.TlvEnergyTransferStartedEvent),
      /**
       * This event shall be generated whenever the EV stops charging or discharging, except when an EV has
       * switched between charging and discharging under the control of the PowerAdjustment feature of the Device
       * Energy Management cluster of the associated Device Energy Management device.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.10.4
       */
      energyTransferStopped: Event(3, EventPriority.Info, EnergyEvse2.TlvEnergyTransferStoppedEvent),
      /**
       * If the EVSE detects a fault it shall generate a Fault Event. The SupplyState attribute shall be set to
       * DisabledError and the type of fault detected by the EVSE shall be stored in the FaultState attribute.
       *
       * This event shall be generated when the FaultState changes from any error state. i.e. if it changes from
       * NoError to any other state and if the error then clears, this would generate 2 events.
       *
       * It is assumed that the fault will be cleared locally on the EVSE device. When all faults have been
       * cleared, the EVSE device shall set the FaultState attribute to NoError and the SupplyState attribute
       * shall be set back to its previous state.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 9.3.10.5
       */
      fault: Event(4, EventPriority.Critical, EnergyEvse2.TlvFaultEvent)
    },
    /**
     * This metadata controls which EnergyEvseCluster elements matter.js activates for specific feature
     * combinations.
     */
    extensions: MutableCluster.Extensions(
      { flags: { v2X: true }, component: EnergyEvse2.V2XComponent },
      { flags: { chargingPreferences: true }, component: EnergyEvse2.ChargingPreferencesComponent },
      { flags: { soCReporting: true }, component: EnergyEvse2.SoCReportingComponent },
      { flags: { plugAndCharge: true }, component: EnergyEvse2.PlugAndChargeComponent },
      { flags: { rfid: true }, component: EnergyEvse2.RfidComponent },
      { flags: { chargingPreferences: false }, component: false }
    )
  });
  EnergyEvse2.ClusterInstance = MutableCluster(EnergyEvse2.Base);
  EnergyEvse2.Cluster = EnergyEvse2.ClusterInstance;
  const V2X = { v2X: true };
  const PREF = { chargingPreferences: true };
  const SOC = { soCReporting: true };
  const PNC = { plugAndCharge: true };
  const RFID = { rfid: true };
  EnergyEvse2.CompleteInstance = MutableCluster({
    id: EnergyEvse2.Cluster.id,
    name: EnergyEvse2.Cluster.name,
    revision: EnergyEvse2.Cluster.revision,
    features: EnergyEvse2.Cluster.features,
    attributes: {
      ...EnergyEvse2.Cluster.attributes,
      dischargingEnabledUntil: MutableCluster.AsConditional(
        EnergyEvse2.V2XComponent.attributes.dischargingEnabledUntil,
        { mandatoryIf: [V2X] }
      ),
      maximumDischargeCurrent: MutableCluster.AsConditional(
        EnergyEvse2.V2XComponent.attributes.maximumDischargeCurrent,
        { mandatoryIf: [V2X] }
      ),
      nextChargeStartTime: MutableCluster.AsConditional(
        EnergyEvse2.ChargingPreferencesComponent.attributes.nextChargeStartTime,
        { mandatoryIf: [PREF] }
      ),
      nextChargeTargetTime: MutableCluster.AsConditional(
        EnergyEvse2.ChargingPreferencesComponent.attributes.nextChargeTargetTime,
        { mandatoryIf: [PREF] }
      ),
      nextChargeRequiredEnergy: MutableCluster.AsConditional(
        EnergyEvse2.ChargingPreferencesComponent.attributes.nextChargeRequiredEnergy,
        { mandatoryIf: [PREF] }
      ),
      nextChargeTargetSoC: MutableCluster.AsConditional(
        EnergyEvse2.ChargingPreferencesComponent.attributes.nextChargeTargetSoC,
        { mandatoryIf: [PREF] }
      ),
      approximateEvEfficiency: MutableCluster.AsConditional(
        EnergyEvse2.ChargingPreferencesComponent.attributes.approximateEvEfficiency,
        { optionalIf: [PREF] }
      ),
      stateOfCharge: MutableCluster.AsConditional(
        EnergyEvse2.SoCReportingComponent.attributes.stateOfCharge,
        { mandatoryIf: [SOC] }
      ),
      batteryCapacity: MutableCluster.AsConditional(
        EnergyEvse2.SoCReportingComponent.attributes.batteryCapacity,
        { mandatoryIf: [SOC] }
      ),
      vehicleId: MutableCluster.AsConditional(
        EnergyEvse2.PlugAndChargeComponent.attributes.vehicleId,
        { mandatoryIf: [PNC] }
      ),
      sessionEnergyDischarged: MutableCluster.AsConditional(
        EnergyEvse2.V2XComponent.attributes.sessionEnergyDischarged,
        { mandatoryIf: [V2X] }
      )
    },
    commands: {
      ...EnergyEvse2.Cluster.commands,
      enableDischarging: MutableCluster.AsConditional(
        EnergyEvse2.V2XComponent.commands.enableDischarging,
        { mandatoryIf: [V2X] }
      ),
      setTargets: MutableCluster.AsConditional(
        EnergyEvse2.ChargingPreferencesComponent.commands.setTargets,
        { mandatoryIf: [PREF] }
      ),
      getTargets: MutableCluster.AsConditional(
        EnergyEvse2.ChargingPreferencesComponent.commands.getTargets,
        { mandatoryIf: [PREF] }
      ),
      clearTargets: MutableCluster.AsConditional(
        EnergyEvse2.ChargingPreferencesComponent.commands.clearTargets,
        { mandatoryIf: [PREF] }
      )
    },
    events: {
      ...EnergyEvse2.Cluster.events,
      rfid: MutableCluster.AsConditional(EnergyEvse2.RfidComponent.events.rfid, { optionalIf: [RFID] })
    }
  });
  EnergyEvse2.Complete = EnergyEvse2.CompleteInstance;
})(EnergyEvse || (EnergyEvse = {}));
const EnergyEvseCluster = EnergyEvse.Cluster;
ClusterRegistry.register(EnergyEvse.Complete);
export {
  EnergyEvse,
  EnergyEvseCluster
};
//# sourceMappingURL=energy-evse.js.map
