/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { MutableCluster } from "../cluster/mutation/MutableCluster.js";
import { FixedAttribute, WritableAttribute, Attribute, Command, TlvNoResponse } from "../cluster/Cluster.js";
import { TlvUInt8, TlvBitmap, TlvEnum, TlvPercent } from "../tlv/TlvNumber.js";
import { TlvNullable } from "../tlv/TlvNullable.js";
import { BitFlag } from "../schema/BitmapSchema.js";
import { TlvField, TlvOptionalField, TlvObject } from "../tlv/TlvObject.js";
import { TlvBoolean } from "../tlv/TlvBoolean.js";
import { ClusterRegistry } from "../cluster/ClusterRegistry.js";
var FanControl;
((FanControl2) => {
  let Feature;
  ((Feature2) => {
    Feature2["MultiSpeed"] = "MultiSpeed";
    Feature2["Auto"] = "Auto";
    Feature2["Rocking"] = "Rocking";
    Feature2["Wind"] = "Wind";
    Feature2["Step"] = "Step";
    Feature2["AirflowDirection"] = "AirflowDirection";
  })(Feature = FanControl2.Feature || (FanControl2.Feature = {}));
  FanControl2.Rock = {
    /**
     * Indicate rock left to right
     */
    rockLeftRight: BitFlag(0),
    /**
     * Indicate rock up and down
     */
    rockUpDown: BitFlag(1),
    /**
     * Indicate rock around
     */
    rockRound: BitFlag(2)
  };
  FanControl2.Wind = {
    /**
     * Indicate sleep wind
     */
    sleepWind: BitFlag(0),
    /**
     * Indicate natural wind
     */
    naturalWind: BitFlag(1)
  };
  let AirflowDirection;
  ((AirflowDirection2) => {
    AirflowDirection2[AirflowDirection2["Forward"] = 0] = "Forward";
    AirflowDirection2[AirflowDirection2["Reverse"] = 1] = "Reverse";
  })(AirflowDirection = FanControl2.AirflowDirection || (FanControl2.AirflowDirection = {}));
  let StepDirection;
  ((StepDirection2) => {
    StepDirection2[StepDirection2["Increase"] = 0] = "Increase";
    StepDirection2[StepDirection2["Decrease"] = 1] = "Decrease";
  })(StepDirection = FanControl2.StepDirection || (FanControl2.StepDirection = {}));
  FanControl2.TlvStepRequest = TlvObject({
    /**
     * This field shall indicate whether the fan speed increases or decreases to the next step value.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 4.4.7.1.1
     */
    direction: TlvField(0, TlvEnum()),
    /**
     * This field shall indicate if the fan speed wraps between highest and lowest step value.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 4.4.7.1.2
     */
    wrap: TlvOptionalField(1, TlvBoolean),
    /**
     * This field shall indicate that the fan being off (speed value 0) is included as a step value.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 4.4.7.1.3
     */
    lowestOff: TlvOptionalField(2, TlvBoolean)
  });
  let FanMode;
  ((FanMode2) => {
    FanMode2[FanMode2["Off"] = 0] = "Off";
    FanMode2[FanMode2["Low"] = 1] = "Low";
    FanMode2[FanMode2["Medium"] = 2] = "Medium";
    FanMode2[FanMode2["High"] = 3] = "High";
    FanMode2[FanMode2["On"] = 4] = "On";
    FanMode2[FanMode2["Auto"] = 5] = "Auto";
    FanMode2[FanMode2["Smart"] = 6] = "Smart";
  })(FanMode = FanControl2.FanMode || (FanControl2.FanMode = {}));
  let FanModeSequence;
  ((FanModeSequence2) => {
    FanModeSequence2[FanModeSequence2["OffLowMedHigh"] = 0] = "OffLowMedHigh";
    FanModeSequence2[FanModeSequence2["OffLowHigh"] = 1] = "OffLowHigh";
    FanModeSequence2[FanModeSequence2["OffLowMedHighAuto"] = 2] = "OffLowMedHighAuto";
    FanModeSequence2[FanModeSequence2["OffLowHighAuto"] = 3] = "OffLowHighAuto";
    FanModeSequence2[FanModeSequence2["OffHighAuto"] = 4] = "OffHighAuto";
    FanModeSequence2[FanModeSequence2["OffHigh"] = 5] = "OffHigh";
  })(FanModeSequence = FanControl2.FanModeSequence || (FanControl2.FanModeSequence = {}));
  FanControl2.MultiSpeedComponent = MutableCluster.Component({
    attributes: {
      /**
       * Indicates that the fan has one speed (value of 1) or the maximum speed, if the fan is capable of multiple
       * speeds.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 4.4.6.5
       */
      speedMax: FixedAttribute(4, TlvUInt8.bound({ min: 1, max: 100 })),
      /**
       * Indicates the speed setting for the fan. This attribute may be written by the client to indicate a new
       * fan speed. If the client writes null to this attribute, the attribute value shall NOT change. A server
       * shall return INVALID_IN_STATE to indicate that the fan is not in a state where the SpeedSetting can be
       * changed to the requested value.
       *
       * If this is successfully written to 0, the server shall set the FanMode attribute value to Off. Please see
       * the Section 4.4.6.6.1 for details on other values.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 4.4.6.6
       */
      speedSetting: WritableAttribute(5, TlvNullable(TlvUInt8), { default: 0 }),
      /**
       * Indicates the actual currently operating fan speed, or zero to indicate that the fan is off. There may be
       * a temporary mismatch between the value of this attribute and the value of the SpeedSetting attribute due
       * to other system requirements that would not allow the fan to operate at the requested setting.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 4.4.6.7
       */
      speedCurrent: Attribute(6, TlvUInt8)
    }
  });
  FanControl2.RockingComponent = MutableCluster.Component({
    attributes: {
      /**
       * This attribute is a bitmap that indicates what rocking motions the server supports.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 4.4.6.8
       */
      rockSupport: FixedAttribute(7, TlvBitmap(TlvUInt8, FanControl2.Rock)),
      /**
       * This attribute is a bitmap that indicates the current active fan rocking motion settings. Each bit shall
       * only be set to 1, if the corresponding bit in the RockSupport attribute is set to 1, otherwise a status
       * code of CONSTRAINT_ERROR shall be returned.
       *
       * If a combination of supported bits is set by the client, and the server does not support the combination,
       * the lowest supported single bit in the combination shall be set and active, and all other bits shall
       * indicate zero.
       *
       * For example: If RockUpDown and RockRound are both set, but this combination is not possible, then only
       * RockUpDown becomes active.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 4.4.6.9
       */
      rockSetting: WritableAttribute(8, TlvBitmap(TlvUInt8, FanControl2.Rock))
    }
  });
  FanControl2.WindComponent = MutableCluster.Component({
    attributes: {
      /**
       * This attribute is a bitmap that indicates what wind modes the server supports. At least one wind mode bit
       * shall be set.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 4.4.6.10
       */
      windSupport: FixedAttribute(9, TlvBitmap(TlvUInt8, FanControl2.Wind)),
      /**
       * This attribute is a bitmap that indicates the current active fan wind feature settings. Each bit shall
       * only be set to 1, if the corresponding bit in the WindSupport attribute is set to 1, otherwise a status
       * code of CONSTRAINT_ERROR shall be returned.
       *
       * If a combination of supported bits is set by the client, and the server does not support the combination,
       * the lowest supported single bit in the combination shall be set and active, and all other bits shall
       * indicate zero.
       *
       * For example: If Sleep Wind and Natural Wind are set, but this combination is not possible, then only
       * Sleep Wind becomes active.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 4.4.6.11
       */
      windSetting: WritableAttribute(10, TlvBitmap(TlvUInt8, FanControl2.Wind))
    }
  });
  FanControl2.AirflowDirectionComponent = MutableCluster.Component({
    attributes: {
      /**
       * Indicates the current airflow direction of the fan. This attribute may be written by the client to
       * indicate a new airflow direction for the fan. This attribute shall be set to one of the values in the
       * AirflowDirectionEnum table.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 4.4.6.12
       */
      airflowDirection: WritableAttribute(
        11,
        TlvEnum(),
        { default: 0 /* Forward */ }
      )
    }
  });
  FanControl2.StepComponent = MutableCluster.Component({
    commands: {
      /**
       * This command speeds up or slows down the fan, in steps, without the client having to know the fan speed.
       * This command supports, for example, a user operated wall switch, where the user provides the feedback or
       * control to stop sending this command when the proper speed is reached. The step speed values are
       * implementation specific. How many step speeds are implemented is implementation specific.
       *
       * This command supports these fields:
       *
       * @see {@link MatterSpecification.v14.Cluster} § 4.4.7.1
       */
      step: Command(0, FanControl2.TlvStepRequest, 0, TlvNoResponse)
    }
  });
  FanControl2.Base = MutableCluster.Component({
    id: 514,
    name: "FanControl",
    revision: 4,
    features: {
      /**
       * MultiSpeed
       *
       * Legacy Fan Control cluster revision 0-1 defined 3 speeds (low, medium and high) plus automatic speed
       * control but left it up to the implementer to decide what was supported. Therefore, it is assumed that
       * legacy client implementations are capable of determining, from the server, the number of speeds supported
       * between 1, 2, or 3, and whether automatic speed control is supported.
       *
       * The MultiSpeed feature includes new attributes that support a running fan speed value from 0 to SpeedMax,
       * which has a maximum of 100.
       *
       * See Section 4.4.6.6.1 for more details.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 4.4.4.1
       */
      multiSpeed: BitFlag(0),
      /**
       * Auto
       *
       * Automatic mode supported for fan speed
       */
      auto: BitFlag(1),
      /**
       * Rocking
       *
       * Rocking movement supported
       */
      rocking: BitFlag(2),
      /**
       * Wind
       *
       * Wind emulation supported
       */
      wind: BitFlag(3),
      /**
       * Step
       *
       * Step command supported
       */
      step: BitFlag(4),
      /**
       * AirflowDirection
       *
       * Airflow Direction attribute is supported
       */
      airflowDirection: BitFlag(5)
    },
    attributes: {
      /**
       * Indicates the current speed mode of the fan. This attribute may be written by the client to request a
       * different fan mode. A server shall return INVALID_IN_STATE to indicate that the fan is not in a state
       * where the FanMode can be changed to the requested value. A server may have FanMode values that it can
       * never be set to. For example, where this cluster appears on the same or another endpoint as other
       * clusters with a system dependency, for example the Thermostat cluster, attempting to set the FanMode
       * attribute of this cluster to Off may not be allowed by the system.
       *
       * This attribute shall be set to one of the values in FanModeEnum.
       *
       * When the FanMode attribute is successfully written to, the PercentSetting and SpeedSetting (if present)
       * attributes shall be set to appropriate values, as defined by the Section 4.4.6.3.1 and Section 4.4.6.6.1
       * respectively, unless otherwise specified below.
       *
       * When the FanMode attribute is set to any given mode, the PercentCurrent and SpeedCurrent (if present)
       * shall indicate the actual currently operating fan speed, unless otherwise specified below.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 4.4.6.1
       */
      fanMode: WritableAttribute(0, TlvEnum(), { persistent: true, default: 0 /* Off */ }),
      /**
       * This attribute indicates the fan speed ranges that shall be supported.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 4.4.6.2
       */
      fanModeSequence: FixedAttribute(1, TlvEnum()),
      /**
       * Indicates the speed setting for the fan. This attribute may be written by the client to indicate a new
       * fan speed. If the client writes null to this attribute, the attribute value shall NOT change. A server
       * shall return INVALID_IN_STATE to indicate that the fan is not in a state where the PercentSetting can be
       * changed to the requested value.
       *
       * If this is successfully written to 0, the server shall set the FanMode attribute value to Off.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 4.4.6.3
       */
      percentSetting: WritableAttribute(2, TlvNullable(TlvPercent), { default: 0 }),
      /**
       * Indicates the actual currently operating fan speed, or zero to indicate that the fan is off. There may be
       * a temporary mismatch between the value of this attribute and the value of the PercentSetting attribute
       * due to other system requirements that would not allow the fan to operate at the requested setting. See
       * Section 4.4.6.3.1 for more details.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 4.4.6.4
       */
      percentCurrent: Attribute(3, TlvPercent)
    },
    /**
     * This metadata controls which FanControlCluster elements matter.js activates for specific feature
     * combinations.
     */
    extensions: MutableCluster.Extensions(
      { flags: { multiSpeed: true }, component: FanControl2.MultiSpeedComponent },
      { flags: { rocking: true }, component: FanControl2.RockingComponent },
      { flags: { wind: true }, component: FanControl2.WindComponent },
      { flags: { airflowDirection: true }, component: FanControl2.AirflowDirectionComponent },
      { flags: { step: true }, component: FanControl2.StepComponent }
    )
  });
  FanControl2.ClusterInstance = MutableCluster(FanControl2.Base);
  FanControl2.Cluster = FanControl2.ClusterInstance;
  const SPD = { multiSpeed: true };
  const RCK = { rocking: true };
  const WND = { wind: true };
  const DIR = { airflowDirection: true };
  const STEP = { step: true };
  FanControl2.CompleteInstance = MutableCluster({
    id: FanControl2.Cluster.id,
    name: FanControl2.Cluster.name,
    revision: FanControl2.Cluster.revision,
    features: FanControl2.Cluster.features,
    attributes: {
      ...FanControl2.Cluster.attributes,
      speedMax: MutableCluster.AsConditional(FanControl2.MultiSpeedComponent.attributes.speedMax, { mandatoryIf: [SPD] }),
      speedSetting: MutableCluster.AsConditional(
        FanControl2.MultiSpeedComponent.attributes.speedSetting,
        { mandatoryIf: [SPD] }
      ),
      speedCurrent: MutableCluster.AsConditional(
        FanControl2.MultiSpeedComponent.attributes.speedCurrent,
        { mandatoryIf: [SPD] }
      ),
      rockSupport: MutableCluster.AsConditional(FanControl2.RockingComponent.attributes.rockSupport, { mandatoryIf: [RCK] }),
      rockSetting: MutableCluster.AsConditional(FanControl2.RockingComponent.attributes.rockSetting, { mandatoryIf: [RCK] }),
      windSupport: MutableCluster.AsConditional(FanControl2.WindComponent.attributes.windSupport, { mandatoryIf: [WND] }),
      windSetting: MutableCluster.AsConditional(FanControl2.WindComponent.attributes.windSetting, { mandatoryIf: [WND] }),
      airflowDirection: MutableCluster.AsConditional(
        FanControl2.AirflowDirectionComponent.attributes.airflowDirection,
        { mandatoryIf: [DIR] }
      )
    },
    commands: { step: MutableCluster.AsConditional(FanControl2.StepComponent.commands.step, { mandatoryIf: [STEP] }) }
  });
  FanControl2.Complete = FanControl2.CompleteInstance;
})(FanControl || (FanControl = {}));
const FanControlCluster = FanControl.Cluster;
ClusterRegistry.register(FanControl.Complete);
export {
  FanControl,
  FanControlCluster
};
//# sourceMappingURL=fan-control.js.map
