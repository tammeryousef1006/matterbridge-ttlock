/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
/*** THIS FILE IS GENERATED, DO NOT EDIT ***/
import { MutableCluster } from "../cluster/mutation/MutableCluster.js";
import { ResourceMonitoring } from "./resource-monitoring.js";
import { Identity } from "#general";
export declare namespace HepaFilterMonitoring {
    const Base: {
        readonly id: 113;
        readonly name: "HepaFilterMonitoring";
        readonly features: {
            readonly condition: import("../index.js").BitFlag;
            readonly warning: import("../index.js").BitFlag;
            readonly replacementProductList: import("../index.js").BitFlag;
        };
        readonly revision: 1;
        readonly attributes: {
            readonly changeIndication: import("../index.js").Attribute<ResourceMonitoring.ChangeIndication, any>;
            readonly inPlaceIndicator: import("../index.js").OptionalAttribute<boolean, any>;
            readonly lastChangedTime: import("../index.js").OptionalWritableAttribute<number | null, any>;
        };
        readonly commands: {
            readonly resetCondition: import("../index.js").OptionalCommand<void, void, any>;
        };
        readonly extensions: readonly [{
            readonly flags: {
                readonly condition: true;
            };
            readonly component: {
                readonly attributes: {
                    readonly condition: import("../index.js").Attribute<number, any>;
                    readonly degradationDirection: import("../index.js").FixedAttribute<ResourceMonitoring.DegradationDirection, any>;
                };
            };
        }, {
            readonly flags: {
                readonly replacementProductList: true;
            };
            readonly component: {
                readonly attributes: {
                    readonly replacementProductList: import("../index.js").FixedAttribute<import("../index.js").TypeFromFields<{
                        productIdentifierType: import("../index.js").FieldType<ResourceMonitoring.ProductIdentifierType>;
                        productIdentifierValue: import("../index.js").FieldType<string>;
                    }>[], any>;
                };
            };
        }];
    };
    /**
     * @see {@link Cluster}
     */
    const ClusterInstance: MutableCluster<{
        readonly id: 113;
        readonly name: "HepaFilterMonitoring";
        readonly features: {
            readonly condition: import("../index.js").BitFlag;
            readonly warning: import("../index.js").BitFlag;
            readonly replacementProductList: import("../index.js").BitFlag;
        };
        readonly revision: 1;
        readonly attributes: {
            readonly changeIndication: import("../index.js").Attribute<ResourceMonitoring.ChangeIndication, any>;
            readonly inPlaceIndicator: import("../index.js").OptionalAttribute<boolean, any>;
            readonly lastChangedTime: import("../index.js").OptionalWritableAttribute<number | null, any>;
        };
        readonly commands: {
            readonly resetCondition: import("../index.js").OptionalCommand<void, void, any>;
        };
        readonly extensions: readonly [{
            readonly flags: {
                readonly condition: true;
            };
            readonly component: {
                readonly attributes: {
                    readonly condition: import("../index.js").Attribute<number, any>;
                    readonly degradationDirection: import("../index.js").FixedAttribute<ResourceMonitoring.DegradationDirection, any>;
                };
            };
        }, {
            readonly flags: {
                readonly replacementProductList: true;
            };
            readonly component: {
                readonly attributes: {
                    readonly replacementProductList: import("../index.js").FixedAttribute<import("../index.js").TypeFromFields<{
                        productIdentifierType: import("../index.js").FieldType<ResourceMonitoring.ProductIdentifierType>;
                        productIdentifierValue: import("../index.js").FieldType<string>;
                    }>[], any>;
                };
            };
        }];
    }, []>;
    /**
     * This alias specializes the semantics of {@link ResourceMonitoring.Base}.
     *
     * HepaFilterMonitoringCluster supports optional features that you can enable with the
     * HepaFilterMonitoringCluster.with() factory method.
     */
    interface Cluster extends Identity<typeof ClusterInstance> {
    }
    const Cluster: Cluster;
    /**
     * This cluster supports all HepaFilterMonitoring features. It may support illegal feature combinations.
     *
     * If you use this cluster you must manually specify which features are active and ensure the set of active features
     * is legal per the Matter specification.
     */
    const CompleteInstance: MutableCluster<{
        readonly id: 113;
        readonly name: "HepaFilterMonitoring";
        readonly revision: 1;
        readonly features: {
            readonly condition: import("../index.js").BitFlag;
            readonly warning: import("../index.js").BitFlag;
            readonly replacementProductList: import("../index.js").BitFlag;
        };
        readonly attributes: {
            readonly condition: import("../index.js").Attribute<number, any> & {
                readonly optional: true;
                readonly isConditional: true;
                readonly optionalIf: [] | import("../index.js").ConditionalFeatureList<import("../index.js").BitSchema>;
                readonly mandatoryIf: [] | [{
                    condition: boolean;
                }];
            };
            readonly degradationDirection: import("../index.js").FixedAttribute<ResourceMonitoring.DegradationDirection, any> & {
                readonly optional: true;
                readonly isConditional: true;
                readonly optionalIf: [] | import("../index.js").ConditionalFeatureList<import("../index.js").BitSchema>;
                readonly mandatoryIf: [] | [{
                    condition: boolean;
                }];
            };
            readonly replacementProductList: import("../index.js").FixedAttribute<import("../index.js").TypeFromFields<{
                productIdentifierType: import("../index.js").FieldType<ResourceMonitoring.ProductIdentifierType>;
                productIdentifierValue: import("../index.js").FieldType<string>;
            }>[], any> & {
                readonly optional: true;
                readonly isConditional: true;
                readonly optionalIf: [] | import("../index.js").ConditionalFeatureList<import("../index.js").BitSchema>;
                readonly mandatoryIf: [] | [{
                    replacementProductList: boolean;
                }];
            };
            readonly changeIndication: import("../index.js").Attribute<ResourceMonitoring.ChangeIndication, any>;
            readonly inPlaceIndicator: import("../index.js").OptionalAttribute<boolean, any>;
            readonly lastChangedTime: import("../index.js").OptionalWritableAttribute<number | null, any>;
        };
        readonly commands: {
            readonly resetCondition: import("../index.js").OptionalCommand<void, void, any>;
        };
    }, []>;
    interface Complete extends Identity<typeof CompleteInstance> {
    }
    const Complete: Complete;
}
export type HepaFilterMonitoringCluster = HepaFilterMonitoring.Cluster;
export declare const HepaFilterMonitoringCluster: HepaFilterMonitoring.Cluster;
//# sourceMappingURL=hepa-filter-monitoring.d.ts.map