/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { MutableCluster } from "../cluster/mutation/MutableCluster.js";
import {
  Attribute,
  Command,
  TlvNoResponse,
  OptionalCommand,
  OptionalEvent,
  EventPriority
} from "../cluster/Cluster.js";
import { TlvEpochUs, TlvUInt64, TlvFloat, TlvEnum, TlvUInt8 } from "../tlv/TlvNumber.js";
import { TlvNullable } from "../tlv/TlvNullable.js";
import { TlvField, TlvObject, TlvOptionalField } from "../tlv/TlvObject.js";
import { TlvString, TlvByteString } from "../tlv/TlvString.js";
import { TlvArray } from "../tlv/TlvArray.js";
import { TlvNoArguments } from "../tlv/TlvNoArguments.js";
import { TlvBoolean } from "../tlv/TlvBoolean.js";
import { BitFlag } from "../schema/BitmapSchema.js";
import { ClusterRegistry } from "../cluster/ClusterRegistry.js";
var MediaPlayback;
((MediaPlayback2) => {
  let Feature;
  ((Feature2) => {
    Feature2["AdvancedSeek"] = "AdvancedSeek";
    Feature2["VariableSpeed"] = "VariableSpeed";
    Feature2["TextTracks"] = "TextTracks";
    Feature2["AudioTracks"] = "AudioTracks";
    Feature2["AudioAdvance"] = "AudioAdvance";
  })(Feature = MediaPlayback2.Feature || (MediaPlayback2.Feature = {}));
  MediaPlayback2.TlvPlaybackPosition = TlvObject({
    /**
     * This field shall indicate the time when the position was last updated.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.10.5.4.1
     */
    updatedAt: TlvField(0, TlvEpochUs),
    /**
     * This field shall indicate the associated discrete position within the media stream, in milliseconds from the
     * beginning of the stream, being associated with the time indicated by the UpdatedAt field. The Position shall
     * NOT be greater than the duration of the media if duration is specified. The Position shall NOT be greater
     * than the time difference between current time and start time of the media when start time is specified.
     *
     * A value of null shall indicate that playback position is not applicable for the current state of the media
     * playback (For example : Live media with no known duration and where seek is not supported).
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.10.5.4.2
     */
    position: TlvField(1, TlvNullable(TlvUInt64))
  });
  MediaPlayback2.TlvSeekRequest = TlvObject({
    /**
     * This field shall indicate the position (in milliseconds) in the media to seek to. In case the position falls
     * in the middle of a frame, the server shall set the position to the beginning of that frame and set the
     * SampledPosition attribute on the cluster accordingly. If the position falls before the earliest valid
     * position or beyond the furthest valid position to which a client may seek back or forward to respectively,
     * the status of SEEK_OUT_OF_RANGE shall be returned and no change shall be made to the position of the
     * playback.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.10.7.11.1
     */
    position: TlvField(0, TlvUInt64)
  });
  let Status;
  ((Status2) => {
    Status2[Status2["Success"] = 0] = "Success";
    Status2[Status2["InvalidStateForCommand"] = 1] = "InvalidStateForCommand";
    Status2[Status2["NotAllowed"] = 2] = "NotAllowed";
    Status2[Status2["NotActive"] = 3] = "NotActive";
    Status2[Status2["SpeedOutOfRange"] = 4] = "SpeedOutOfRange";
    Status2[Status2["SeekOutOfRange"] = 5] = "SeekOutOfRange";
  })(Status = MediaPlayback2.Status || (MediaPlayback2.Status = {}));
  MediaPlayback2.TlvPlaybackResponse = TlvObject({
    /**
     * This field shall indicate the status of the command which resulted in this response.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.10.7.12.1
     */
    status: TlvField(0, TlvEnum()),
    /**
     * This field shall indicate Optional app-specific data.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.10.7.12.2
     */
    data: TlvOptionalField(1, TlvString)
  });
  let Characteristic;
  ((Characteristic2) => {
    Characteristic2[Characteristic2["ForcedSubtitles"] = 0] = "ForcedSubtitles";
    Characteristic2[Characteristic2["DescribesVideo"] = 1] = "DescribesVideo";
    Characteristic2[Characteristic2["EasyToRead"] = 2] = "EasyToRead";
    Characteristic2[Characteristic2["FrameBased"] = 3] = "FrameBased";
    Characteristic2[Characteristic2["MainProgram"] = 4] = "MainProgram";
    Characteristic2[Characteristic2["OriginalContent"] = 5] = "OriginalContent";
    Characteristic2[Characteristic2["VoiceOverTranslation"] = 6] = "VoiceOverTranslation";
    Characteristic2[Characteristic2["Caption"] = 7] = "Caption";
    Characteristic2[Characteristic2["Subtitle"] = 8] = "Subtitle";
    Characteristic2[Characteristic2["Alternate"] = 9] = "Alternate";
    Characteristic2[Characteristic2["Supplementary"] = 10] = "Supplementary";
    Characteristic2[Characteristic2["Commentary"] = 11] = "Commentary";
    Characteristic2[Characteristic2["DubbedTranslation"] = 12] = "DubbedTranslation";
    Characteristic2[Characteristic2["Description"] = 13] = "Description";
    Characteristic2[Characteristic2["Metadata"] = 14] = "Metadata";
    Characteristic2[Characteristic2["EnhancedAudioIntelligibility"] = 15] = "EnhancedAudioIntelligibility";
    Characteristic2[Characteristic2["Emergency"] = 16] = "Emergency";
    Characteristic2[Characteristic2["Karaoke"] = 17] = "Karaoke";
  })(Characteristic = MediaPlayback2.Characteristic || (MediaPlayback2.Characteristic = {}));
  MediaPlayback2.TlvTrackAttributes = TlvObject({
    /**
     * The value is a String containing one of the standard Tags for Identifying Languages RFC 5646, which
     * identifies the primary language used in the Track.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.10.5.6.1
     */
    languageCode: TlvField(0, TlvString.bound({ maxLength: 32 })),
    /**
     * This is a list of enumerated CharacteristicEnum values that indicate a purpose, trait or feature associated
     * with the Track. A value of null shall indicate that there are no Characteristics corresponding to the Track.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.10.5.6.2
     */
    characteristics: TlvOptionalField(1, TlvNullable(TlvArray(TlvEnum()))),
    /**
     * The value is a String containing a user displayable name for the Track. A value of null shall indicate that
     * there is no DisplayName corresponding to the Track.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.10.5.6.3
     */
    displayName: TlvOptionalField(2, TlvNullable(TlvString.bound({ maxLength: 256 })))
  });
  MediaPlayback2.TlvTrack = TlvObject({
    /**
     * This field shall indicate the Identifier for the Track which is unique within the Track catalog. The Track
     * catalog contains all the Text/Audio tracks corresponding to the main media content.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.10.5.5.1
     */
    id: TlvField(0, TlvString.bound({ maxLength: 32 })),
    /**
     * This field shall indicate the Attributes associated to the Track, like languageCode.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.10.5.5.2
     */
    trackAttributes: TlvField(1, MediaPlayback2.TlvTrackAttributes)
  });
  MediaPlayback2.TlvActivateAudioTrackRequest = TlvObject({
    /**
     * This field shall indicate the Audio Track to activate.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.10.7.13.1
     */
    trackId: TlvField(0, TlvString.bound({ maxLength: 32 })),
    /**
     * This value is the index field of the OutputInfoStruct from the OutputList attribute (from the AudioOutput
     * cluster) and indicates which audio output the Audio Track should be played on. This field is absent for Text
     * Tracks and only present for Audio Tracks. A value of null shall indicate that the server can choose the audio
     * output(s) to play the Audio Track on.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.10.7.13.2
     */
    audioOutputIndex: TlvOptionalField(1, TlvNullable(TlvUInt8))
  });
  MediaPlayback2.TlvActivateTextTrackRequest = TlvObject({
    /**
     * This field shall indicate the Text Track to activate.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.10.7.14.1
     */
    trackId: TlvField(0, TlvString.bound({ maxLength: 32 }))
  });
  MediaPlayback2.TlvRewindRequest = TlvObject({
    /**
     * This field shall indicate whether audio should be unmuted by the player during rewind.
     *
     * A value of true does not guarantee that audio can be heard by the user since the speaker may be muted, turned
     * down to a low level and/or unplugged.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.10.7.7.1
     */
    audioAdvanceUnmuted: TlvOptionalField(0, TlvBoolean)
  });
  MediaPlayback2.TlvFastForwardRequest = TlvObject({
    /**
     * This field shall indicate whether audio should be unmuted by the player during fast forward.
     *
     * A value of true does not guarantee that audio can be heard by the user since the speaker may be muted, turned
     * down to a low level and/or unplugged.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.10.7.8.1
     */
    audioAdvanceUnmuted: TlvOptionalField(0, TlvBoolean)
  });
  let PlaybackState;
  ((PlaybackState2) => {
    PlaybackState2[PlaybackState2["Playing"] = 0] = "Playing";
    PlaybackState2[PlaybackState2["Paused"] = 1] = "Paused";
    PlaybackState2[PlaybackState2["NotPlaying"] = 2] = "NotPlaying";
    PlaybackState2[PlaybackState2["Buffering"] = 3] = "Buffering";
  })(PlaybackState = MediaPlayback2.PlaybackState || (MediaPlayback2.PlaybackState = {}));
  MediaPlayback2.TlvSkipForwardRequest = TlvObject({
    /**
     * This field shall indicate the duration of the time span to skip forward in the media, in milliseconds. In
     * case the resulting position falls in the middle of a frame, the server shall set the position to the
     * beginning of that frame and set the SampledPosition attribute on the cluster accordingly. If the resultant
     * position falls beyond the furthest valid position in the media the client may seek forward to, the position
     * should be set to that furthest valid position. If the SampledPosition attribute is supported it shall be
     * updated on the cluster accordingly.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.10.7.9.1
     */
    deltaPositionMilliseconds: TlvField(0, TlvUInt64)
  });
  MediaPlayback2.TlvSkipBackwardRequest = TlvObject({
    /**
     * This field shall indicate the duration of the time span to skip backward in the media, in milliseconds. In
     * case the resulting position falls in the middle of a frame, the server shall set the position to the
     * beginning of that frame and set the SampledPosition attribute on the cluster accordingly. If the resultant
     * position falls before the earliest valid position to which a client may seek back to, the position should be
     * set to that earliest valid position. If the SampledPosition attribute is supported it shall be updated on the
     * cluster accordingly.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.10.7.10.1
     */
    deltaPositionMilliseconds: TlvField(0, TlvUInt64)
  });
  MediaPlayback2.TlvStateChangedEvent = TlvObject({
    /**
     * This field shall indicate the updated playback state as defined by the CurrentState attribute, and has the
     * same constraint as that attribute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.10.8.1.1
     */
    currentState: TlvField(0, TlvEnum()),
    /**
     * This field shall indicate the updated start time as defined by the StartTime attribute, and has the same
     * constraint as that attribute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.10.8.1.2
     */
    startTime: TlvOptionalField(1, TlvEpochUs),
    /**
     * This field shall indicate the updated duration as defined by the Duration attribute, and has the same
     * constraint as that attribute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.10.8.1.3
     */
    duration: TlvOptionalField(2, TlvUInt64),
    /**
     * This field shall indicate the updated position of playback as defined by the SampledPosition attribute, and
     * has the same constraint as that attribute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.10.8.1.4
     */
    sampledPosition: TlvOptionalField(3, MediaPlayback2.TlvPlaybackPosition),
    /**
     * This field shall indicate the updated speed at which the current media is being played as defined by the
     * PlaybackSpeed attribute, and has the same constraint as that attribute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.10.8.1.5
     */
    playbackSpeed: TlvOptionalField(4, TlvFloat),
    /**
     * This field shall indicate the updated start of the seek range end as defined by the SeekRangeEnd attribute,
     * and has the same constraint as that attribute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.10.8.1.7
     */
    seekRangeEnd: TlvOptionalField(5, TlvUInt64),
    /**
     * This field shall indicate the updated start of the seek range start as defined by the SeekRangeStart
     * attribute, and has the same constraint as that attribute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.10.8.1.6
     */
    seekRangeStart: TlvOptionalField(6, TlvUInt64),
    /**
     * This field shall indicate Optional app-specific data.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.10.8.1.8
     */
    data: TlvOptionalField(7, TlvByteString.bound({ maxLength: 900 })),
    /**
     * This field shall indicate whether audio is unmuted by the player due to a FF or REW command. This field is
     * only meaningful when the PlaybackSpeed is present and not equal to 0 (paused) or 1 (normal playback).
     * Typically the value will be false (muted), however, some players will play audio during certain fast forward
     * and rewind speeds, and in these cases, the value will be true (not muted).
     *
     * A value of true does not guarantee that audio can be heard by the user since the speaker may be muted, turned
     * down to a low level and/or unplugged.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 6.10.8.1.9
     */
    audioAdvanceUnmuted: TlvOptionalField(8, TlvBoolean)
  });
  MediaPlayback2.AdvancedSeekComponent = MutableCluster.Component({
    attributes: {
      /**
       * Indicates the start time of the media, in case the media has a fixed start time (for example, live stream
       * or television broadcast), or null when start time does not apply to the current media (for example,
       * video-on-demand). This time is a UTC time. The client needs to handle conversion to local time, as
       * required, taking in account time zone and possible local DST offset.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.10.6.2
       */
      startTime: Attribute(1, TlvNullable(TlvEpochUs), { default: null }),
      /**
       * Indicates the duration, in milliseconds, of the current media being played back
       *
       * or null when duration is not applicable (for example, in live streaming content with no known duration).
       * This attribute shall never be 0.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.10.6.3
       */
      duration: Attribute(2, TlvNullable(TlvUInt64), { default: null }),
      /**
       * Indicates the position of playback (Position field) at the time (UpdateAt field) specified in the
       * attribute. The client may use the SampledPosition attribute to compute the current position within the
       * media stream based on the PlaybackSpeed, PlaybackPositionStruct.UpdatedAt and
       * PlaybackPositionStruct.Position fields. To enable this, the SampledPosition attribute shall be updated
       * whenever a change in either the playback speed or the playback position is triggered outside the normal
       * playback of the media. The events which may cause this to happen include:
       *
       *   • Starting or resumption of playback
       *
       *   • Seeking
       *
       *   • Skipping forward or backward
       *
       *   • Fast-forwarding or rewinding
       *
       *   • Updating of playback speed as a result of explicit request, or as a result of buffering events
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.10.6.4
       */
      sampledPosition: Attribute(3, TlvNullable(MediaPlayback2.TlvPlaybackPosition), { default: null }),
      /**
       * Indicates the speed at which the current media is being played. The new PlaybackSpeed shall be reflected
       * in this attribute whenever any of the following occurs:
       *
       *   • Starting of playback
       *
       *   • Resuming of playback
       *
       *   • Fast-forwarding
       *
       *   • Rewinding
       *
       * The PlaybackSpeed shall reflect the ratio of time elapsed in the media to the actual time taken for the
       * playback assuming no changes to media playback (for example buffering events or requests to
       * pause/rewind/forward).
       *
       *   • A value for PlaybackSpeed of 1 shall indicate normal playback where, for example, playback for 1
       *     second causes the media to advance by 1 second within the duration of the media.
       *
       *   • A value for PlaybackSpeed which is greater than 0 shall indicate that as playback is happening the
       *     media is currently advancing in time within the duration of the media.
       *
       *   • A value for PlaybackSpeed which is less than 0 shall indicate that as playback is happening the media
       *     is currently going back in time within the duration of the media.
       *
       *   • A value for PlaybackSpeed of 0 shall indicate that the media is currently not playing back. When the
       *     CurrentState attribute has the value of PAUSED, NOT_PLAYING or BUFFERING, the PlaybackSpeed shall be
       *     set to 0 to reflect that the media is not playing.
       *
       * Following examples illustrate the PlaybackSpeed attribute values in various conditions.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.10.6.5
       */
      playbackSpeed: Attribute(4, TlvFloat, { default: 0 }),
      /**
       * Indicates the furthest forward valid position to which a client may seek forward, in milliseconds from
       * the start of the media. When the media has an associated StartTime, a value of null shall indicate that a
       * seek forward is valid only until the current time within the media, using a position computed from the
       * difference between the current time offset and StartTime, in milliseconds from start of the media,
       * truncating fractional milliseconds towards 0. A value of Nas when StartTime is not specified shall
       * indicate that seeking forward is not allowed.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.10.6.7
       */
      seekRangeEnd: Attribute(5, TlvNullable(TlvUInt64), { default: null }),
      /**
       * Indicates the earliest valid position to which a client may seek back, in milliseconds from start of the
       * media. A value of Nas shall indicate that seeking backwards is not allowed.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.10.6.6
       */
      seekRangeStart: Attribute(6, TlvNullable(TlvUInt64), { default: null })
    },
    commands: {
      /**
       * Upon receipt, this shall change the playback position in the media to the given position.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.10.7.11
       */
      seek: Command(11, MediaPlayback2.TlvSeekRequest, 10, MediaPlayback2.TlvPlaybackResponse)
    }
  });
  MediaPlayback2.AudioTracksComponent = MutableCluster.Component({
    attributes: {
      /**
       * ActiveTrack refers to the Audio track currently set and being used for the streaming media. A value of
       * null shall indicate that no Audio Track corresponding to the current media is currently being played.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.10.6.8
       */
      activeAudioTrack: Attribute(7, TlvNullable(MediaPlayback2.TlvTrack), { default: null }),
      /**
       * AvailableAudioTracks refers to the list of Audio tracks available for the current title being played. A
       * value of null shall indicate that no Audio Tracks corresponding to the current media are selectable by
       * the client.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.10.6.9
       */
      availableAudioTracks: Attribute(8, TlvNullable(TlvArray(MediaPlayback2.TlvTrack)), { default: null })
    },
    commands: {
      /**
       * Upon receipt, the server shall set the active Audio Track to the one identified by the TrackID in the
       * Track catalog for the streaming media. If the TrackID does not exist in the Track catalog, OR does not
       * correspond to the streaming media OR no media is being streamed at the time of receipt of this command,
       * the server will return an error status of INVALID_ARGUMENT.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.10.7.13
       */
      activateAudioTrack: Command(12, MediaPlayback2.TlvActivateAudioTrackRequest, 12, TlvNoResponse)
    }
  });
  MediaPlayback2.TextTracksComponent = MutableCluster.Component({
    attributes: {
      /**
       * ActiveTrack refers to the Text track currently set and being used for the streaming media. This can be
       * nil. A value of null shall indicate that no Text Track corresponding to the current media is currently
       * being displayed.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.10.6.10
       */
      activeTextTrack: Attribute(9, TlvNullable(MediaPlayback2.TlvTrack), { default: null }),
      /**
       * AvailableTextTracks refers to the list of Text tracks available for the current title being played. This
       * can be an empty list. A value of null shall indicate that no Text Tracks corresponding to the current
       * media are selectable by the client.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.10.6.11
       */
      availableTextTracks: Attribute(10, TlvNullable(TlvArray(MediaPlayback2.TlvTrack)), { default: null })
    },
    commands: {
      /**
       * Upon receipt, the server shall set the active Text Track to the one identified by the TrackID in the
       * Track catalog for the streaming media. If the TrackID does not exist in the Track catalog, OR does not
       * correspond to the streaming media OR no media is being streamed at the time of receipt of this command,
       * the server shall return an error status of INVALID_ARGUMENT.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.10.7.14
       */
      activateTextTrack: Command(13, MediaPlayback2.TlvActivateTextTrackRequest, 13, TlvNoResponse),
      /**
       * If a Text Track is active (i.e. being displayed), upon receipt of this command, the server shall stop
       * displaying it.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.10.7.15
       */
      deactivateTextTrack: Command(14, TlvNoArguments, 14, TlvNoResponse)
    }
  });
  MediaPlayback2.VariableSpeedComponent = MutableCluster.Component({
    commands: {
      /**
       * Upon receipt, this shall start playback of the media backward in case the media is currently playing in
       * the forward direction or is not playing. If the playback is already happening in the backwards direction
       * receipt of this command shall increase the speed of the media playback backwards.
       *
       * Different "rewind" speeds may be reflected on the media playback device based upon the number of
       * sequential calls to this function and the capability of the device. This is to avoid needing to define
       * every speed (multiple fast, slow motion, etc). If the PlaybackSpeed attribute is supported it shall be
       * updated to reflect the new speed of playback. If the playback speed cannot be changed for the media being
       * played(for example, in live streaming content not supporting seek), the status of NOT_ALLOWED shall be
       * returned. If the playback speed has reached the maximum supported speed for media playing backwards, the
       * status of SPEED_OUT_OF_RANGE shall be returned.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.10.7.7
       */
      rewind: Command(6, MediaPlayback2.TlvRewindRequest, 10, MediaPlayback2.TlvPlaybackResponse),
      /**
       * Upon receipt, this shall start playback of the media in the forward direction in case the media is
       *
       * currently playing in the backward direction or is not playing. If the playback is already happening in
       * the forward direction receipt of this command shall increase the speed of the media playback.
       *
       * Different "fast-forward" speeds may be reflected on the media playback device based upon the number of
       * sequential calls to this function and the capability of the device. This is to avoid needing to define
       * every speed (multiple fast, slow motion, etc). If the PlaybackSpeed attribute is supported it shall be
       * updated to reflect the new speed of playback. If the playback speed cannot be changed for the media being
       * played(for example, in live streaming content not supporting seek), the status of NOT_ALLOWED shall be
       * returned. If the playback speed has reached the maximum supported speed for media playing forward, the
       * status of SPEED_OUT_OF_RANGE shall be returned.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.10.7.8
       */
      fastForward: Command(7, MediaPlayback2.TlvFastForwardRequest, 10, MediaPlayback2.TlvPlaybackResponse)
    }
  });
  MediaPlayback2.Base = MutableCluster.Component({
    id: 1286,
    name: "MediaPlayback",
    revision: 2,
    features: {
      /**
       * AdvancedSeek
       *
       * This feature provides access to the time offset location within current playback media and allows for
       * jumping to a specific location using time offsets. This enables clients to implement more advanced media
       * seeking behavior in their user interface, for instance a "seek bar".
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.10.4.1
       */
      advancedSeek: BitFlag(0),
      /**
       * VariableSpeed
       *
       * This feature is for a device which supports variable speed playback on media that supports it.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.10.4.2
       */
      variableSpeed: BitFlag(1),
      /**
       * TextTracks
       *
       * This feature is for a device or app that supports Text Tracks.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.10.4.3
       */
      textTracks: BitFlag(2),
      /**
       * AudioTracks
       *
       * This feature is for a device or app that supports Audio Tracks.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.10.4.4
       */
      audioTracks: BitFlag(3),
      /**
       * AudioAdvance
       *
       * This feature is for a device or app that supports playing audio during fast and slow advance and
       *
       * rewind (e.g., while playback speed is not 1). A device that supports this feature may only support
       * playing audio during certain speeds.
       *
       * A cluster implementing AA shall implement AS.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.10.4.5
       */
      audioAdvance: BitFlag(4)
    },
    attributes: {
      /**
       * Indicates the current playback state of media.
       *
       * During fast-forward, rewind, and other seek operations; this attribute shall be set to PLAYING.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.10.6.1
       */
      currentState: Attribute(0, TlvEnum())
    },
    commands: {
      /**
       * Upon receipt, this shall play media. If content is currently in a FastForward or Rewind state. Play shall
       * return media to normal playback speed.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.10.7.1
       */
      play: Command(0, TlvNoArguments, 10, MediaPlayback2.TlvPlaybackResponse),
      /**
       * Upon receipt, this shall pause playback of the media.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.10.7.2
       */
      pause: Command(1, TlvNoArguments, 10, MediaPlayback2.TlvPlaybackResponse),
      /**
       * Upon receipt, this shall stop playback of the media. User-visible outcome is context-specific. This may
       * navigate the user back to the location from where the media was originally launched.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.10.7.3
       */
      stop: Command(2, TlvNoArguments, 10, MediaPlayback2.TlvPlaybackResponse),
      /**
       * Upon receipt, this shall Start Over with the current media playback item.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.10.7.4
       */
      startOver: OptionalCommand(3, TlvNoArguments, 10, MediaPlayback2.TlvPlaybackResponse),
      /**
       * Upon receipt, this shall cause the handler to be invoked for "Previous". User experience is
       * context-specific. This will often Go back to the previous media playback item.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.10.7.5
       */
      previous: OptionalCommand(4, TlvNoArguments, 10, MediaPlayback2.TlvPlaybackResponse),
      /**
       * Upon receipt, this shall cause the handler to be invoked for "Next". User experience is context-
       * specific. This will often Go forward to the next media playback item.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.10.7.6
       */
      next: OptionalCommand(5, TlvNoArguments, 10, MediaPlayback2.TlvPlaybackResponse),
      /**
       * Upon receipt, this shall Skip forward in the media by the given number of milliseconds.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.10.7.9
       */
      skipForward: OptionalCommand(8, MediaPlayback2.TlvSkipForwardRequest, 10, MediaPlayback2.TlvPlaybackResponse),
      /**
       * Upon receipt, this shall Skip backward in the media by the given number of milliseconds.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.10.7.10
       */
      skipBackward: OptionalCommand(9, MediaPlayback2.TlvSkipBackwardRequest, 10, MediaPlayback2.TlvPlaybackResponse)
    },
    events: {
      /**
       * If supported, this event shall be generated when there is a change in any of the supported attributes of
       * the Media Playback cluster.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 6.10.8.1
       */
      stateChanged: OptionalEvent(0, EventPriority.Info, MediaPlayback2.TlvStateChangedEvent)
    },
    /**
     * This metadata controls which MediaPlaybackCluster elements matter.js activates for specific feature
     * combinations.
     */
    extensions: MutableCluster.Extensions(
      { flags: { advancedSeek: true }, component: MediaPlayback2.AdvancedSeekComponent },
      { flags: { audioTracks: true }, component: MediaPlayback2.AudioTracksComponent },
      { flags: { textTracks: true }, component: MediaPlayback2.TextTracksComponent },
      { flags: { variableSpeed: true }, component: MediaPlayback2.VariableSpeedComponent }
    )
  });
  MediaPlayback2.ClusterInstance = MutableCluster(MediaPlayback2.Base);
  MediaPlayback2.Cluster = MediaPlayback2.ClusterInstance;
  const AS = { advancedSeek: true };
  const AT = { audioTracks: true };
  const TT = { textTracks: true };
  const VS = { variableSpeed: true };
  MediaPlayback2.CompleteInstance = MutableCluster({
    id: MediaPlayback2.Cluster.id,
    name: MediaPlayback2.Cluster.name,
    revision: MediaPlayback2.Cluster.revision,
    features: MediaPlayback2.Cluster.features,
    attributes: {
      ...MediaPlayback2.Cluster.attributes,
      startTime: MutableCluster.AsConditional(MediaPlayback2.AdvancedSeekComponent.attributes.startTime, { mandatoryIf: [AS] }),
      duration: MutableCluster.AsConditional(MediaPlayback2.AdvancedSeekComponent.attributes.duration, { mandatoryIf: [AS] }),
      sampledPosition: MutableCluster.AsConditional(
        MediaPlayback2.AdvancedSeekComponent.attributes.sampledPosition,
        { mandatoryIf: [AS] }
      ),
      playbackSpeed: MutableCluster.AsConditional(
        MediaPlayback2.AdvancedSeekComponent.attributes.playbackSpeed,
        { mandatoryIf: [AS] }
      ),
      seekRangeEnd: MutableCluster.AsConditional(
        MediaPlayback2.AdvancedSeekComponent.attributes.seekRangeEnd,
        { mandatoryIf: [AS] }
      ),
      seekRangeStart: MutableCluster.AsConditional(
        MediaPlayback2.AdvancedSeekComponent.attributes.seekRangeStart,
        { mandatoryIf: [AS] }
      ),
      activeAudioTrack: MutableCluster.AsConditional(
        MediaPlayback2.AudioTracksComponent.attributes.activeAudioTrack,
        { mandatoryIf: [AT] }
      ),
      availableAudioTracks: MutableCluster.AsConditional(
        MediaPlayback2.AudioTracksComponent.attributes.availableAudioTracks,
        { mandatoryIf: [AT] }
      ),
      activeTextTrack: MutableCluster.AsConditional(
        MediaPlayback2.TextTracksComponent.attributes.activeTextTrack,
        { mandatoryIf: [TT] }
      ),
      availableTextTracks: MutableCluster.AsConditional(
        MediaPlayback2.TextTracksComponent.attributes.availableTextTracks,
        { mandatoryIf: [TT] }
      )
    },
    commands: {
      ...MediaPlayback2.Cluster.commands,
      rewind: MutableCluster.AsConditional(MediaPlayback2.VariableSpeedComponent.commands.rewind, { mandatoryIf: [VS] }),
      fastForward: MutableCluster.AsConditional(
        MediaPlayback2.VariableSpeedComponent.commands.fastForward,
        { mandatoryIf: [VS] }
      ),
      seek: MutableCluster.AsConditional(MediaPlayback2.AdvancedSeekComponent.commands.seek, { mandatoryIf: [AS] }),
      activateAudioTrack: MutableCluster.AsConditional(
        MediaPlayback2.AudioTracksComponent.commands.activateAudioTrack,
        { mandatoryIf: [AT] }
      ),
      activateTextTrack: MutableCluster.AsConditional(
        MediaPlayback2.TextTracksComponent.commands.activateTextTrack,
        { mandatoryIf: [TT] }
      ),
      deactivateTextTrack: MutableCluster.AsConditional(
        MediaPlayback2.TextTracksComponent.commands.deactivateTextTrack,
        { mandatoryIf: [TT] }
      )
    },
    events: MediaPlayback2.Cluster.events
  });
  MediaPlayback2.Complete = MediaPlayback2.CompleteInstance;
})(MediaPlayback || (MediaPlayback = {}));
const MediaPlaybackCluster = MediaPlayback.Cluster;
ClusterRegistry.register(MediaPlayback.Complete);
export {
  MediaPlayback,
  MediaPlaybackCluster
};
//# sourceMappingURL=media-playback.js.map
