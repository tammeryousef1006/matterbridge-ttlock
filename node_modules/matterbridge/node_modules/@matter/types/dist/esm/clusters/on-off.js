/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { MutableCluster } from "../cluster/mutation/MutableCluster.js";
import { Attribute, WritableAttribute, Command, TlvNoResponse } from "../cluster/Cluster.js";
import { TlvBoolean } from "../tlv/TlvBoolean.js";
import { TlvUInt16, TlvEnum, TlvUInt8, TlvBitmap } from "../tlv/TlvNumber.js";
import { TlvNullable } from "../tlv/TlvNullable.js";
import { AccessLevel } from "#model";
import { TlvField, TlvObject } from "../tlv/TlvObject.js";
import { TlvNoArguments } from "../tlv/TlvNoArguments.js";
import { BitFlag } from "../schema/BitmapSchema.js";
import { ClusterType } from "../cluster/ClusterType.js";
import { ClusterRegistry } from "../cluster/ClusterRegistry.js";
var OnOff;
((OnOff2) => {
  let Feature;
  ((Feature2) => {
    Feature2["Lighting"] = "Lighting";
    Feature2["DeadFrontBehavior"] = "DeadFrontBehavior";
    Feature2["OffOnly"] = "OffOnly";
  })(Feature = OnOff2.Feature || (OnOff2.Feature = {}));
  let StartUpOnOff;
  ((StartUpOnOff2) => {
    StartUpOnOff2[StartUpOnOff2["Off"] = 0] = "Off";
    StartUpOnOff2[StartUpOnOff2["On"] = 1] = "On";
    StartUpOnOff2[StartUpOnOff2["Toggle"] = 2] = "Toggle";
  })(StartUpOnOff = OnOff2.StartUpOnOff || (OnOff2.StartUpOnOff = {}));
  let EffectIdentifier;
  ((EffectIdentifier2) => {
    EffectIdentifier2[EffectIdentifier2["DelayedAllOff"] = 0] = "DelayedAllOff";
    EffectIdentifier2[EffectIdentifier2["DyingLight"] = 1] = "DyingLight";
  })(EffectIdentifier = OnOff2.EffectIdentifier || (OnOff2.EffectIdentifier = {}));
  OnOff2.TlvOffWithEffectRequest = TlvObject({
    /**
     * This field specifies the fading effect to use when turning the device off. This field shall contain one of
     * the non-reserved values listed in EffectIdentifierEnum.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.5.7.4.1
     */
    effectIdentifier: TlvField(0, TlvEnum()),
    /**
     * This field is used to indicate which variant of the effect, indicated in the EffectIdentifier field, SHOULD
     * be triggered. If the server does not support the given variant, it shall use the default variant. This field
     * is dependent on the value of the EffectIdentifier field and shall contain one of the non-reserved values
     * listed in either DelayedAllOffEffectVariantEnum or DyingLightEffectVariantEnum.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.5.7.4.2
     */
    effectVariant: TlvField(1, TlvUInt8)
  });
  OnOff2.OnOffControl = {
    /**
     * Indicates a command is only accepted when in On state.
     */
    acceptOnlyWhenOn: BitFlag(0)
  };
  OnOff2.TlvOnWithTimedOffRequest = TlvObject({
    /**
     * This field contains information on how the server is to be operated.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.5.7.6.1
     */
    onOffControl: TlvField(0, TlvBitmap(TlvUInt8, OnOff2.OnOffControl)),
    /**
     * This field is used to adjust the value of the OnTime attribute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.5.7.6.2
     */
    onTime: TlvField(1, TlvUInt16.bound({ max: 65534 })),
    /**
     * This field is used to adjust the value of the OffWaitTime attribute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 1.5.7.6.3
     */
    offWaitTime: TlvField(2, TlvUInt16.bound({ max: 65534 }))
  });
  let DelayedAllOffEffectVariant;
  ((DelayedAllOffEffectVariant2) => {
    DelayedAllOffEffectVariant2[DelayedAllOffEffectVariant2["DelayedOffFastFade"] = 0] = "DelayedOffFastFade";
    DelayedAllOffEffectVariant2[DelayedAllOffEffectVariant2["NoFade"] = 1] = "NoFade";
    DelayedAllOffEffectVariant2[DelayedAllOffEffectVariant2["DelayedOffSlowFade"] = 2] = "DelayedOffSlowFade";
  })(DelayedAllOffEffectVariant = OnOff2.DelayedAllOffEffectVariant || (OnOff2.DelayedAllOffEffectVariant = {}));
  let DyingLightEffectVariant;
  ((DyingLightEffectVariant2) => {
    DyingLightEffectVariant2[DyingLightEffectVariant2["DyingLightFadeOff"] = 0] = "DyingLightFadeOff";
  })(DyingLightEffectVariant = OnOff2.DyingLightEffectVariant || (OnOff2.DyingLightEffectVariant = {}));
  OnOff2.LightingComponent = MutableCluster.Component({
    attributes: {
      /**
       * In order to support the use case where the user gets back the last setting of a set of devices (e.g.
       * level settings for lights), a global scene is introduced which is stored when the devices are turned off
       * and recalled when the devices are turned on. The global scene is defined as the scene that is stored with
       * group identifier 0 and scene identifier 0.
       *
       * This attribute is defined in order to prevent a second Off command storing the all-devices-off situation
       * as a global scene, and to prevent a second On command destroying the current settings by going back to
       * the global scene.
       *
       * This attribute shall be set to TRUE after the reception of a command which causes the OnOff attribute to
       * be set to TRUE, such as a standard On command, a MoveToLevel(WithOnOff) command, a RecallScene command or
       * a OnWithRecallGlobalScene command.
       *
       * This attribute is set to FALSE after reception of a OffWithEffect command.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.5.6.3
       */
      globalSceneControl: Attribute(16384, TlvBoolean, { default: true }),
      /**
       * This attribute specifies the length of time (in 1/10ths second) that the On state shall be maintained
       * before automatically transitioning to the Off state when using the OnWithTimedOff command. This attribute
       * can be written at any time, but writing a value only has effect when in the Timed On state. See
       * OnWithTimedOff for more details.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.5.6.4
       */
      onTime: WritableAttribute(16385, TlvUInt16, { default: 0 }),
      /**
       * This attribute specifies the length of time (in 1/10ths second) that the Off state shall be guarded to
       * prevent another OnWithTimedOff command turning the server back to its On state (e.g., when leaving a
       * room, the lights are turned off but an occupancy sensor detects the leaving person and attempts to turn
       * the lights back on). This attribute can be written at any time, but writing a value only has an effect
       * when in the Timed On state followed by a transition to the Delayed Off state, or in the Delayed Off
       * state. See OnWithTimedOff for more details.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.5.6.5
       */
      offWaitTime: WritableAttribute(16386, TlvUInt16, { default: 0 }),
      /**
       * This attribute shall define the desired startup behavior of a device when it is supplied with power and
       * this state shall be reflected in the OnOff attribute. If the value is null, the OnOff attribute is set to
       * its previous value. Otherwise, the behavior is defined in the table defining StartUpOnOffEnum.
       *
       * This behavior does not apply to reboots associated with OTA. After an OTA restart, the OnOff attribute
       * shall return to its value prior to the restart.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.5.6.6
       */
      startUpOnOff: WritableAttribute(
        16387,
        TlvNullable(TlvEnum()),
        { persistent: true, writeAcl: AccessLevel.Manage }
      )
    },
    commands: {
      /**
       * The OffWithEffect command allows devices to be turned off using enhanced ways of fading.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.5.7.4
       */
      offWithEffect: Command(64, OnOff2.TlvOffWithEffectRequest, 64, TlvNoResponse),
      /**
       * This command allows the recall of the settings when the device was turned off.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.5.7.5
       */
      onWithRecallGlobalScene: Command(65, TlvNoArguments, 65, TlvNoResponse),
      /**
       * This command allows devices to be turned on for a specific duration with a guarded off duration so that
       * SHOULD the device be subsequently turned off, further OnWithTimedOff commands, received during this time,
       * are prevented from turning the devices back on. Further OnWithTimedOff commands received while the server
       * is turned on, will update the period that the device is turned on.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.5.7.6
       */
      onWithTimedOff: Command(66, OnOff2.TlvOnWithTimedOffRequest, 66, TlvNoResponse)
    }
  });
  OnOff2.NotOffOnlyComponent = MutableCluster.Component({
    commands: {
      /**
       * @see {@link MatterSpecification.v14.Cluster} § 1.5.7.2
       */
      on: Command(1, TlvNoArguments, 1, TlvNoResponse),
      /**
       * @see {@link MatterSpecification.v14.Cluster} § 1.5.7.3
       */
      toggle: Command(2, TlvNoArguments, 2, TlvNoResponse)
    }
  });
  OnOff2.Base = MutableCluster.Component({
    id: 6,
    name: "OnOff",
    revision: 6,
    features: {
      /**
       * Lighting
       *
       * This cluster is used for a lighting application.
       *
       * On receipt of a Level Control cluster command that causes the OnOff attribute to be set to FALSE, the
       * OnTime attribute shall be set to 0.
       *
       * On receipt of a Level Control cluster command that causes the OnOff attribute to be set to TRUE, if the
       * value of the OnTime attribute is equal to 0, the server shall set the OffWaitTime attribute to 0.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.5.4.1
       */
      lighting: BitFlag(0),
      /**
       * DeadFrontBehavior
       *
       * When this feature is supported, the device exposing this server cluster exhibits "dead front" behavior
       * when the "OnOff" attribute is FALSE (Off). This "dead front" behavior includes:
       *
       *   • clusters other than this cluster that are also exposed may respond with failures to Invoke and Write
       *     interactions. Such failure responses when in a "dead front" shall be with an INVALID_IN_STATE status
       *     code.
       *
       *   • clusters other than this cluster may change the values of their attributes to best-effort values, due
       *     to the actual values not being defined or available in this state. Device type specifications that
       *     require support for the DF feature SHOULD define what these best-effort values are.
       *
       *   • Report Transactions shall continue to be generated. Such transactions may include best-effort values
       *     as noted above.
       *
       *   • Event generation logic for clusters other than this cluster is unchanged (noting possible use of
       *     best-effort attribute values as in the preceding bullets).
       *
       * When this feature is supported and the OnOff attribute changes from TRUE to FALSE (e.g. when receiving an
       * Off Command, or due to a manual interaction on the device), it shall start executing this "dead front"
       * behavior.
       *
       * When this feature is supported and the OnOff attribute changes from FALSE to TRUE (e.g. when receiving an
       * On Command, or due to a manual interaction on the device), it shall stop executing this "dead front"
       * behavior.
       *
       * When this feature is supported, and any change of the "dead front" state leads to changes in attributes
       * of other clusters due to the "dead front" feature, these attribute changes shall NOT be skipped or
       * omitted from the usual processing associated with attribute changes. For example, if an attribute changes
       * from value 4 to null on "dead front" behavior due to an Off command being received, this change shall be
       * processed for reporting and subscriptions.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.5.4.2
       */
      deadFrontBehavior: BitFlag(1),
      /**
       * OffOnly
       *
       * When this feature is supported, the Off command shall be supported and the On and Toggle commands shall
       * NOT be supported.
       *
       * This feature is useful for devices which can be turned off via the Off command received by an instance of
       * this cluster but cannot be turned on via commands received by an instance of this cluster due to
       * regulatory requirements.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.5.4.3
       */
      offOnly: BitFlag(2)
    },
    attributes: {
      /**
       * This attribute indicates whether the device type implemented on the endpoint is turned off or turned on,
       * in these cases the value of the OnOff attribute equals FALSE, or TRUE respectively.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 1.5.6.2
       */
      onOff: Attribute(0, TlvBoolean, { scene: true, persistent: true, default: false })
    },
    commands: {
      /**
       * @see {@link MatterSpecification.v14.Cluster} § 1.5.7.1
       */
      off: Command(0, TlvNoArguments, 0, TlvNoResponse)
    },
    /**
     * This metadata controls which OnOffCluster elements matter.js activates for specific feature combinations.
     */
    extensions: MutableCluster.Extensions(
      { flags: { lighting: true }, component: OnOff2.LightingComponent },
      { flags: { offOnly: false }, component: OnOff2.NotOffOnlyComponent },
      { flags: { lighting: true, offOnly: true }, component: false },
      { flags: { deadFrontBehavior: true, offOnly: true }, component: false },
      { flags: { offOnly: true, lighting: false, deadFrontBehavior: true }, component: false }
    )
  });
  OnOff2.ClusterInstance = MutableCluster({ ...OnOff2.Base, base: ClusterType(OnOff2.Base) }, OnOff2.NotOffOnlyComponent);
  OnOff2.Cluster = OnOff2.ClusterInstance;
  const LT = { lighting: true };
  OnOff2.CompleteInstance = MutableCluster({
    id: OnOff2.Cluster.id,
    name: OnOff2.Cluster.name,
    revision: OnOff2.Cluster.revision,
    features: OnOff2.Cluster.features,
    attributes: {
      ...OnOff2.Cluster.attributes,
      globalSceneControl: MutableCluster.AsConditional(
        OnOff2.LightingComponent.attributes.globalSceneControl,
        { mandatoryIf: [LT] }
      ),
      onTime: MutableCluster.AsConditional(OnOff2.LightingComponent.attributes.onTime, { mandatoryIf: [LT] }),
      offWaitTime: MutableCluster.AsConditional(OnOff2.LightingComponent.attributes.offWaitTime, { mandatoryIf: [LT] }),
      startUpOnOff: MutableCluster.AsConditional(
        OnOff2.LightingComponent.attributes.startUpOnOff,
        { mandatoryIf: [LT] }
      )
    },
    commands: {
      ...OnOff2.Cluster.commands,
      on: MutableCluster.AsConditional(OnOff2.NotOffOnlyComponent.commands.on, { mandatoryIf: [] }),
      toggle: MutableCluster.AsConditional(OnOff2.NotOffOnlyComponent.commands.toggle, { mandatoryIf: [] }),
      offWithEffect: MutableCluster.AsConditional(
        OnOff2.LightingComponent.commands.offWithEffect,
        { mandatoryIf: [LT] }
      ),
      onWithRecallGlobalScene: MutableCluster.AsConditional(
        OnOff2.LightingComponent.commands.onWithRecallGlobalScene,
        { mandatoryIf: [LT] }
      ),
      onWithTimedOff: MutableCluster.AsConditional(
        OnOff2.LightingComponent.commands.onWithTimedOff,
        { mandatoryIf: [LT] }
      )
    }
  });
  OnOff2.Complete = OnOff2.CompleteInstance;
})(OnOff || (OnOff = {}));
const OnOffCluster = OnOff.Cluster;
ClusterRegistry.register(OnOff.Complete);
export {
  OnOff,
  OnOffCluster
};
//# sourceMappingURL=on-off.js.map
