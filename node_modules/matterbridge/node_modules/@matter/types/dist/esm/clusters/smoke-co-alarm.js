/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { MutableCluster } from "../cluster/mutation/MutableCluster.js";
import {
  Attribute,
  OptionalAttribute,
  OptionalWritableAttribute,
  Event,
  EventPriority,
  OptionalEvent,
  OptionalFixedAttribute,
  OptionalCommand,
  TlvNoResponse
} from "../cluster/Cluster.js";
import { TlvEnum, TlvEpochS } from "../tlv/TlvNumber.js";
import { AccessLevel } from "#model";
import { TlvField, TlvObject } from "../tlv/TlvObject.js";
import { BitFlag } from "../schema/BitmapSchema.js";
import { TlvBoolean } from "../tlv/TlvBoolean.js";
import { TlvNoArguments } from "../tlv/TlvNoArguments.js";
import { ClusterRegistry } from "../cluster/ClusterRegistry.js";
var SmokeCoAlarm;
((SmokeCoAlarm2) => {
  let Feature;
  ((Feature2) => {
    Feature2["SmokeAlarm"] = "SmokeAlarm";
    Feature2["CoAlarm"] = "CoAlarm";
  })(Feature = SmokeCoAlarm2.Feature || (SmokeCoAlarm2.Feature = {}));
  let AlarmState;
  ((AlarmState2) => {
    AlarmState2[AlarmState2["Normal"] = 0] = "Normal";
    AlarmState2[AlarmState2["Warning"] = 1] = "Warning";
    AlarmState2[AlarmState2["Critical"] = 2] = "Critical";
  })(AlarmState = SmokeCoAlarm2.AlarmState || (SmokeCoAlarm2.AlarmState = {}));
  let ContaminationState;
  ((ContaminationState2) => {
    ContaminationState2[ContaminationState2["Normal"] = 0] = "Normal";
    ContaminationState2[ContaminationState2["Low"] = 1] = "Low";
    ContaminationState2[ContaminationState2["Warning"] = 2] = "Warning";
    ContaminationState2[ContaminationState2["Critical"] = 3] = "Critical";
  })(ContaminationState = SmokeCoAlarm2.ContaminationState || (SmokeCoAlarm2.ContaminationState = {}));
  let Sensitivity;
  ((Sensitivity2) => {
    Sensitivity2[Sensitivity2["High"] = 0] = "High";
    Sensitivity2[Sensitivity2["Standard"] = 1] = "Standard";
    Sensitivity2[Sensitivity2["Low"] = 2] = "Low";
  })(Sensitivity = SmokeCoAlarm2.Sensitivity || (SmokeCoAlarm2.Sensitivity = {}));
  SmokeCoAlarm2.TlvSmokeAlarmEvent = TlvObject({
    /**
     * This field shall indicate the current value of the SmokeState attribute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 2.11.8.1.1
     */
    alarmSeverityLevel: TlvField(0, TlvEnum())
  });
  SmokeCoAlarm2.TlvInterconnectSmokeAlarmEvent = TlvObject({
    /**
     * This field shall indicate the current value of the InterconnectSmokeAlarm attribute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 2.11.8.9.1
     */
    alarmSeverityLevel: TlvField(0, TlvEnum())
  });
  SmokeCoAlarm2.TlvCoAlarmEvent = TlvObject({
    /**
     * This field shall indicate the current value of the COState attribute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 2.11.8.2.1
     */
    alarmSeverityLevel: TlvField(0, TlvEnum())
  });
  SmokeCoAlarm2.TlvInterconnectCoAlarmEvent = TlvObject({
    /**
     * This field shall indicate the current value of the InterconnectCOAlarm attribute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 2.11.8.10.1
     */
    alarmSeverityLevel: TlvField(0, TlvEnum())
  });
  let ExpressedState;
  ((ExpressedState2) => {
    ExpressedState2[ExpressedState2["Normal"] = 0] = "Normal";
    ExpressedState2[ExpressedState2["SmokeAlarm"] = 1] = "SmokeAlarm";
    ExpressedState2[ExpressedState2["CoAlarm"] = 2] = "CoAlarm";
    ExpressedState2[ExpressedState2["BatteryAlert"] = 3] = "BatteryAlert";
    ExpressedState2[ExpressedState2["Testing"] = 4] = "Testing";
    ExpressedState2[ExpressedState2["HardwareFault"] = 5] = "HardwareFault";
    ExpressedState2[ExpressedState2["EndOfService"] = 6] = "EndOfService";
    ExpressedState2[ExpressedState2["InterconnectSmoke"] = 7] = "InterconnectSmoke";
    ExpressedState2[ExpressedState2["InterconnectCo"] = 8] = "InterconnectCo";
  })(ExpressedState = SmokeCoAlarm2.ExpressedState || (SmokeCoAlarm2.ExpressedState = {}));
  let MuteState;
  ((MuteState2) => {
    MuteState2[MuteState2["NotMuted"] = 0] = "NotMuted";
    MuteState2[MuteState2["Muted"] = 1] = "Muted";
  })(MuteState = SmokeCoAlarm2.MuteState || (SmokeCoAlarm2.MuteState = {}));
  let EndOfService;
  ((EndOfService2) => {
    EndOfService2[EndOfService2["Normal"] = 0] = "Normal";
    EndOfService2[EndOfService2["Expired"] = 1] = "Expired";
  })(EndOfService = SmokeCoAlarm2.EndOfService || (SmokeCoAlarm2.EndOfService = {}));
  SmokeCoAlarm2.TlvLowBatteryEvent = TlvObject({
    /**
     * This field shall indicate the current value of the BatteryAlert attribute.
     *
     * @see {@link MatterSpecification.v14.Cluster} § 2.11.8.3.1
     */
    alarmSeverityLevel: TlvField(0, TlvEnum())
  });
  SmokeCoAlarm2.SmokeAlarmComponent = MutableCluster.Component({
    attributes: {
      /**
       * Indicates whether the device’s smoke sensor is currently triggering a smoke alarm.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.6.2
       */
      smokeState: Attribute(1, TlvEnum(), { persistent: true }),
      /**
       * Indicates the contamination level of the smoke sensor.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.6.11
       */
      contaminationState: OptionalAttribute(10, TlvEnum()),
      /**
       * Indicates the sensitivity level of the smoke sensor configured on the device.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.6.12
       */
      smokeSensitivityLevel: OptionalWritableAttribute(
        11,
        TlvEnum(),
        { writeAcl: AccessLevel.Manage }
      )
    },
    events: {
      /**
       * This event shall be generated when SmokeState attribute changes to either Warning or Critical state.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.8.1
       */
      smokeAlarm: Event(0, EventPriority.Critical, SmokeCoAlarm2.TlvSmokeAlarmEvent),
      /**
       * This event shall be generated when the device hosting the server receives a smoke alarm from an
       * interconnected sensor.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.8.9
       */
      interconnectSmokeAlarm: OptionalEvent(8, EventPriority.Critical, SmokeCoAlarm2.TlvInterconnectSmokeAlarmEvent)
    }
  });
  SmokeCoAlarm2.CoAlarmComponent = MutableCluster.Component({
    attributes: {
      /**
       * Indicates whether the device’s CO sensor is currently triggering a CO alarm.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.6.3
       */
      coState: Attribute(2, TlvEnum(), { persistent: true })
    },
    events: {
      /**
       * This event shall be generated when COState attribute changes to either Warning or Critical state.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.8.2
       */
      coAlarm: Event(1, EventPriority.Critical, SmokeCoAlarm2.TlvCoAlarmEvent),
      /**
       * This event shall be generated when the device hosting the server receives a CO alarm from an
       * interconnected sensor.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.8.10
       */
      interconnectCoAlarm: OptionalEvent(9, EventPriority.Critical, SmokeCoAlarm2.TlvInterconnectCoAlarmEvent)
    }
  });
  SmokeCoAlarm2.Base = MutableCluster.Component({
    id: 92,
    name: "SmokeCoAlarm",
    revision: 1,
    features: {
      /**
       * SmokeAlarm
       *
       * Supports Smoke alarm
       */
      smokeAlarm: BitFlag(0),
      /**
       * CoAlarm
       *
       * Supports CO alarm
       */
      coAlarm: BitFlag(1)
    },
    attributes: {
      /**
       * Indicates the visibly- and audibly-expressed state of the alarm. When multiple alarm conditions are being
       * reflected in the server, this attribute shall indicate the condition with the highest priority. Priority
       * order of conditions is determined by the manufacturer and shall be supplied as a part of certification
       * procedure. If the value of ExpressedState is not Normal, the attribute corresponding to the value shall
       * NOT be Normal. For example, if the ExpressedState is set to SmokeAlarm, the value of the SmokeState will
       * indicate the severity of the alarm (Warning or Critical). Clients SHOULD also read the other attributes
       * to be aware of further alarm conditions beyond the one indicated in ExpressedState.
       *
       * Visible expression is typically a LED light pattern. Audible expression is a horn or speaker pattern.
       * Audible expression shall BE suppressed if the DeviceMuted attribute is supported and set to Muted.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.6.1
       */
      expressedState: Attribute(0, TlvEnum(), { persistent: true }),
      /**
       * Indicates whether the power resource fault detection mechanism is currently triggered at the device. If
       * the detection mechanism is triggered, this attribute shall be set to Warning or Critical, otherwise it
       * shall be set to Normal. The battery state shall also be reflected in the Power Source cluster
       * representing the device’s battery using the appropriate supported attributes and events.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.6.4
       */
      batteryAlert: Attribute(3, TlvEnum(), { persistent: true }),
      /**
       * Indicates the whether the audible expression of the device is currently muted. Audible expression is
       * typically a horn or speaker pattern.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.6.5
       */
      deviceMuted: OptionalAttribute(4, TlvEnum(), { persistent: true }),
      /**
       * Indicates whether the device self-test is currently activated. If the device self- test is activated,
       * this attribute shall be set to True, otherwise it shall be set to False.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.6.6
       */
      testInProgress: Attribute(5, TlvBoolean),
      /**
       * Indicates whether the hardware fault detection mechanism is currently triggered. If the detection
       * mechanism is triggered, this attribute shall be set to True, otherwise it shall be set to False.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.6.7
       */
      hardwareFaultAlert: Attribute(6, TlvBoolean, { persistent: true }),
      /**
       * Indicates whether the end-of-service has been triggered at the device. This attribute shall be set to
       * Expired when the device reaches the end-of-service.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.6.8
       */
      endOfServiceAlert: Attribute(7, TlvEnum(), { persistent: true }),
      /**
       * Indicates whether the interconnected smoke alarm is currently triggering by branching devices. When the
       * interconnected smoke alarm is being triggered, this attribute shall be set to Warning or Critical,
       * otherwise it shall be set to Normal.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.6.9
       */
      interconnectSmokeAlarm: OptionalAttribute(8, TlvEnum()),
      /**
       * Indicates whether the interconnected CO alarm is currently triggering by branching devices. When the
       * interconnected CO alarm is being triggered, this attribute shall be set to Warning or Critical, otherwise
       * it shall be set to Normal.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.6.10
       */
      interconnectCoAlarm: OptionalAttribute(9, TlvEnum()),
      /**
       * Indicates the date when the device reaches its stated expiry date. After the ExpiryDate has been reached,
       * the EndOfServiceAlert shall start to be triggered. To account for better customer experience across time
       * zones, the EndOfServiceAlert may be delayed by up to 24 hours after the ExpiryDate. Similarly, clients
       * may delay any actions based on the ExpiryDate by up to 24 hours to best align with the local time zone.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.6.13
       */
      expiryDate: OptionalFixedAttribute(12, TlvEpochS)
    },
    commands: {
      /**
       * This command shall initiate a device self-test. The return status shall indicate whether the test was
       * successfully initiated. Only one SelfTestRequest may be processed at a time. When the value of the
       * ExpressedState attribute is any of SmokeAlarm, COAlarm, Testing, InterconnectSmoke, InterconnectCO, the
       * device shall NOT execute the self-test, and shall return status code BUSY.
       *
       * Upon successful acceptance of SelfTestRequest, the TestInProgress attribute shall be set to True and
       * ExpressedState attribute shall be set to Testing. Any faults identified during the test shall be
       * reflected in the appropriate attributes and events. Upon completion of the self test procedure, the
       * SelfTestComplete event shall be generated, the TestInProgress attribute shall be set to False and
       * ExpressedState attribute shall be updated to reflect the current state of the server.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.7.1
       */
      selfTestRequest: OptionalCommand(0, TlvNoArguments, 0, TlvNoResponse)
    },
    events: {
      /**
       * This event shall be generated when BatteryAlert attribute changes to either Warning or Critical state.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.8.3
       */
      lowBattery: Event(2, EventPriority.Info, SmokeCoAlarm2.TlvLowBatteryEvent),
      /**
       * This event shall be generated when the device detects a hardware fault that leads to setting
       * HardwareFaultAlert to True.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.8.4
       */
      hardwareFault: Event(3, EventPriority.Info, TlvNoArguments),
      /**
       * This event shall be generated when the EndOfServiceAlert is set to Expired.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.8.5
       */
      endOfService: Event(4, EventPriority.Info, TlvNoArguments),
      /**
       * This event shall be generated when the SelfTest completes, and the attribute TestInProgress changes to
       * False.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.8.6
       */
      selfTestComplete: Event(5, EventPriority.Info, TlvNoArguments),
      /**
       * This event shall be generated when the DeviceMuted attribute changes to Muted.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.8.7
       */
      alarmMuted: OptionalEvent(6, EventPriority.Info, TlvNoArguments),
      /**
       * This event shall be generated when DeviceMuted attribute changes to NotMuted.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.8.8
       */
      muteEnded: OptionalEvent(7, EventPriority.Info, TlvNoArguments),
      /**
       * This event shall be generated when ExpressedState attribute returns to Normal state.
       *
       * @see {@link MatterSpecification.v14.Cluster} § 2.11.8.11
       */
      allClear: Event(10, EventPriority.Info, TlvNoArguments)
    },
    /**
     * This metadata controls which SmokeCoAlarmCluster elements matter.js activates for specific feature
     * combinations.
     */
    extensions: MutableCluster.Extensions(
      { flags: { smokeAlarm: true }, component: SmokeCoAlarm2.SmokeAlarmComponent },
      { flags: { coAlarm: true }, component: SmokeCoAlarm2.CoAlarmComponent },
      { flags: { smokeAlarm: false, coAlarm: false }, component: false }
    )
  });
  SmokeCoAlarm2.ClusterInstance = MutableCluster.ExtensibleOnly(SmokeCoAlarm2.Base);
  SmokeCoAlarm2.Cluster = SmokeCoAlarm2.ClusterInstance;
  const SMOKE = { smokeAlarm: true };
  const CO = { coAlarm: true };
  SmokeCoAlarm2.CompleteInstance = MutableCluster({
    id: SmokeCoAlarm2.Base.id,
    name: SmokeCoAlarm2.Base.name,
    revision: SmokeCoAlarm2.Base.revision,
    features: SmokeCoAlarm2.Base.features,
    attributes: {
      ...SmokeCoAlarm2.Base.attributes,
      smokeState: MutableCluster.AsConditional(
        SmokeCoAlarm2.SmokeAlarmComponent.attributes.smokeState,
        { mandatoryIf: [SMOKE] }
      ),
      coState: MutableCluster.AsConditional(SmokeCoAlarm2.CoAlarmComponent.attributes.coState, { mandatoryIf: [CO] }),
      contaminationState: MutableCluster.AsConditional(
        SmokeCoAlarm2.SmokeAlarmComponent.attributes.contaminationState,
        { optionalIf: [SMOKE] }
      ),
      smokeSensitivityLevel: MutableCluster.AsConditional(
        SmokeCoAlarm2.SmokeAlarmComponent.attributes.smokeSensitivityLevel,
        { optionalIf: [SMOKE] }
      )
    },
    commands: SmokeCoAlarm2.Base.commands,
    events: {
      ...SmokeCoAlarm2.Base.events,
      smokeAlarm: MutableCluster.AsConditional(SmokeCoAlarm2.SmokeAlarmComponent.events.smokeAlarm, { mandatoryIf: [SMOKE] }),
      coAlarm: MutableCluster.AsConditional(SmokeCoAlarm2.CoAlarmComponent.events.coAlarm, { mandatoryIf: [CO] }),
      interconnectSmokeAlarm: MutableCluster.AsConditional(
        SmokeCoAlarm2.SmokeAlarmComponent.events.interconnectSmokeAlarm,
        { optionalIf: [SMOKE] }
      ),
      interconnectCoAlarm: MutableCluster.AsConditional(
        SmokeCoAlarm2.CoAlarmComponent.events.interconnectCoAlarm,
        { optionalIf: [CO] }
      )
    }
  });
  SmokeCoAlarm2.Complete = SmokeCoAlarm2.CompleteInstance;
})(SmokeCoAlarm || (SmokeCoAlarm = {}));
const SmokeCoAlarmCluster = SmokeCoAlarm.Cluster;
ClusterRegistry.register(SmokeCoAlarm.Complete);
export {
  SmokeCoAlarm,
  SmokeCoAlarmCluster
};
//# sourceMappingURL=smoke-co-alarm.js.map
