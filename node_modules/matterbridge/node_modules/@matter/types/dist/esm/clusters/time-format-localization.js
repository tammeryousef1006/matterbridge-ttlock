/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { MutableCluster } from "../cluster/mutation/MutableCluster.js";
import { WritableAttribute, FixedAttribute } from "../cluster/Cluster.js";
import { TlvEnum } from "../tlv/TlvNumber.js";
import { AccessLevel } from "#model";
import { TlvArray } from "../tlv/TlvArray.js";
import { BitFlag } from "../schema/BitmapSchema.js";
import { ClusterRegistry } from "../cluster/ClusterRegistry.js";
var TimeFormatLocalization;
((TimeFormatLocalization2) => {
  let Feature;
  ((Feature2) => {
    Feature2["CalendarFormat"] = "CalendarFormat";
  })(Feature = TimeFormatLocalization2.Feature || (TimeFormatLocalization2.Feature = {}));
  let CalendarType;
  ((CalendarType2) => {
    CalendarType2[CalendarType2["Buddhist"] = 0] = "Buddhist";
    CalendarType2[CalendarType2["Chinese"] = 1] = "Chinese";
    CalendarType2[CalendarType2["Coptic"] = 2] = "Coptic";
    CalendarType2[CalendarType2["Ethiopian"] = 3] = "Ethiopian";
    CalendarType2[CalendarType2["Gregorian"] = 4] = "Gregorian";
    CalendarType2[CalendarType2["Hebrew"] = 5] = "Hebrew";
    CalendarType2[CalendarType2["Indian"] = 6] = "Indian";
    CalendarType2[CalendarType2["Islamic"] = 7] = "Islamic";
    CalendarType2[CalendarType2["Japanese"] = 8] = "Japanese";
    CalendarType2[CalendarType2["Korean"] = 9] = "Korean";
    CalendarType2[CalendarType2["Persian"] = 10] = "Persian";
    CalendarType2[CalendarType2["Taiwanese"] = 11] = "Taiwanese";
    CalendarType2[CalendarType2["UseActiveLocale"] = 255] = "UseActiveLocale";
  })(CalendarType = TimeFormatLocalization2.CalendarType || (TimeFormatLocalization2.CalendarType = {}));
  let HourFormat;
  ((HourFormat2) => {
    HourFormat2[HourFormat2["12Hr"] = 0] = "12Hr";
    HourFormat2[HourFormat2["24Hr"] = 1] = "24Hr";
    HourFormat2[HourFormat2["UseActiveLocale"] = 255] = "UseActiveLocale";
  })(HourFormat = TimeFormatLocalization2.HourFormat || (TimeFormatLocalization2.HourFormat = {}));
  TimeFormatLocalization2.CalendarFormatComponent = MutableCluster.Component({
    attributes: {
      /**
       * Indicates the calendar format that the Node is currently configured to use when conveying dates.
       *
       * If not UseActiveLocale, this value shall take priority over any unit implied through the ActiveLocale
       * attribute.
       *
       * If UseActiveLocale, any unit implied through the ActiveLocale attribute is used as the calendar type, and
       * if ActiveLocale is not present, the calendar type is unknown.
       *
       * @see {@link MatterSpecification.v14.Core} ยง 11.4.6.2
       */
      activeCalendarType: WritableAttribute(
        1,
        TlvEnum(),
        { persistent: true, writeAcl: AccessLevel.Manage }
      ),
      /**
       * Indicates a list of CalendarTypeEnum values that are supported by the Node. The list shall NOT contain
       * any duplicate entries. The ordering of items within the list SHOULD NOT express any meaning. The maximum
       * length of the SupportedCalendarTypes list shall be equivalent to the number of enumerations within
       * CalendarTypeEnum.
       *
       * @see {@link MatterSpecification.v14.Core} ยง 11.4.6.3
       */
      supportedCalendarTypes: FixedAttribute(2, TlvArray(TlvEnum()), { default: [] })
    }
  });
  TimeFormatLocalization2.Base = MutableCluster.Component({
    id: 44,
    name: "TimeFormatLocalization",
    revision: 1,
    features: {
      /**
       * CalendarFormat
       *
       * The Node can be configured to use different calendar formats when conveying values to a user.
       */
      calendarFormat: BitFlag(0)
    },
    attributes: {
      /**
       * Indicates the format that the Node is currently configured to use when conveying the hour unit of time.
       *
       * If not UseActiveLocale, this value shall take priority over any unit implied through the ActiveLocale
       * attribute.
       *
       * If UseActiveLocale, any unit implied through the ActiveLocale attribute is used as the hour format, and
       * if ActiveLocale is not present, the hour format is unknown.
       *
       * @see {@link MatterSpecification.v14.Core} ยง 11.4.6.1
       */
      hourFormat: WritableAttribute(
        0,
        TlvEnum(),
        { persistent: true, writeAcl: AccessLevel.Manage }
      )
    },
    /**
     * This metadata controls which TimeFormatLocalizationCluster elements matter.js activates for specific feature
     * combinations.
     */
    extensions: MutableCluster.Extensions({ flags: { calendarFormat: true }, component: TimeFormatLocalization2.CalendarFormatComponent })
  });
  TimeFormatLocalization2.ClusterInstance = MutableCluster(TimeFormatLocalization2.Base);
  TimeFormatLocalization2.Cluster = TimeFormatLocalization2.ClusterInstance;
  const CALFMT = { calendarFormat: true };
  TimeFormatLocalization2.CompleteInstance = MutableCluster({
    id: TimeFormatLocalization2.Cluster.id,
    name: TimeFormatLocalization2.Cluster.name,
    revision: TimeFormatLocalization2.Cluster.revision,
    features: TimeFormatLocalization2.Cluster.features,
    attributes: {
      ...TimeFormatLocalization2.Cluster.attributes,
      activeCalendarType: MutableCluster.AsConditional(
        TimeFormatLocalization2.CalendarFormatComponent.attributes.activeCalendarType,
        { mandatoryIf: [CALFMT] }
      ),
      supportedCalendarTypes: MutableCluster.AsConditional(
        TimeFormatLocalization2.CalendarFormatComponent.attributes.supportedCalendarTypes,
        { mandatoryIf: [CALFMT] }
      )
    }
  });
  TimeFormatLocalization2.Complete = TimeFormatLocalization2.CompleteInstance;
})(TimeFormatLocalization || (TimeFormatLocalization = {}));
const TimeFormatLocalizationCluster = TimeFormatLocalization.Cluster;
ClusterRegistry.register(TimeFormatLocalization.Complete);
export {
  TimeFormatLocalization,
  TimeFormatLocalizationCluster
};
//# sourceMappingURL=time-format-localization.js.map
