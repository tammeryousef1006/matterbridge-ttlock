/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { ValidationError, ValidationOutOfBoundsError, validatorOf } from "../common/ValidationError.js";
import { TlvUInt32 } from "../tlv/TlvNumber.js";
import { TlvWrapper } from "../tlv/TlvWrapper.js";
import { Mei } from "./ManufacturerExtensibleIdentifier.js";
function ClusterId(clusterId, validate = true) {
  if (!validate) {
    return clusterId;
  }
  const { vendorPrefix, typeSuffix } = Mei.fromMei(clusterId);
  if (typeSuffix >= 0 && typeSuffix <= 32767 && vendorPrefix === 0 || // Standard cluster
  typeSuffix >= 64512 && typeSuffix <= 65534 && vendorPrefix !== 0) {
    return clusterId;
  }
  throw new ValidationOutOfBoundsError(`Invalid cluster ID: ${clusterId}`);
}
((ClusterId2) => {
  ClusterId2.isVendorSpecific = (clusterId) => {
    try {
      const { vendorPrefix } = Mei.fromMei(clusterId);
      return vendorPrefix !== 0;
    } catch (e) {
      ValidationError.accept(e);
      return false;
    }
  };
  ClusterId2.isValid = validatorOf(ClusterId2);
  ClusterId2.buildVendorSpecific = (vendorPrefix, clusterSuffix) => {
    return ClusterId2(Mei.asMei(vendorPrefix, clusterSuffix));
  };
})(ClusterId || (ClusterId = {}));
const TlvClusterId = new TlvWrapper(
  TlvUInt32,
  (clusterId) => clusterId,
  (value) => ClusterId(value, false)
  // No automatic validation on decode
);
export {
  ClusterId,
  TlvClusterId
};
//# sourceMappingURL=ClusterId.js.map
