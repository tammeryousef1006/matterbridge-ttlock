/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Merge } from "#general";
import { Schema } from "./Schema.js";
declare const enum BitRangeType {
    Flag = 0,
    Number = 1,
    Enum = 2
}
type BitRange<T, TType extends BitRangeType = BitRangeType> = {
    type: TType;
    offset: number;
    length: number;
    _type?: T;
};
declare const BitRange: <T, TType extends BitRangeType = BitRangeType>(type: TType, offset: number, length: number) => BitRange<T, TType>;
/** Defines the bit position of a boolean flag. */
export type BitFlag = BitRange<boolean, BitRangeType.Flag>;
export declare const BitFlag: (offset: number) => BitFlag;
/** Defines the bit position and bit length of a numeric value. */
export type BitField = BitRange<number, BitRangeType.Number>;
export declare const BitField: (offset: number, length: number) => BitField;
/** Defines the bit position and bit length of an enum flag. */
export type BitFieldEnum<E extends number> = BitRange<E, BitRangeType.Enum>;
export declare const BitFieldEnum: <E extends number>(offset: number, length: number) => BitFieldEnum<E>;
export type BitSchema = {
    [key: string]: BitFlag | BitField | BitFieldEnum<any>;
};
export type TypeFromBitSchema<T extends BitSchema> = {
    [K in keyof T]: T[K] extends BitFieldEnum<infer E> ? E : T[K] extends BitField ? number : boolean;
};
export type TypeFromPartialBitSchema<T extends BitSchema> = {
    [K in keyof T]?: T[K] extends BitFieldEnum<infer E> ? E : T[K] extends BitField ? number : boolean;
};
export type TypeFromBitmapSchema<S extends Schema<any, any>> = S extends Schema<infer T, any> ? T : never;
export declare class BitmapSchemaInternal<T extends BitSchema> extends Schema<TypeFromBitSchema<T>, number> {
    private readonly bitSchemas;
    private readonly masks;
    constructor(bitSchemas: T);
    /**
     * Allow to use a fully defined Bitmap schema as input, but also allow one where only the entries of bits set are
     * provided, rest is unset.
     */
    encode(value: TypeFromPartialBitSchema<T>): number;
    encodeInternal(value: TypeFromPartialBitSchema<T>): number;
    decodeInternal(bitmap: number): TypeFromBitSchema<T>;
}
export declare class ByteArrayBitmapSchemaInternal<T extends BitSchema> extends Schema<TypeFromBitSchema<T>, Uint8Array> {
    private readonly bitSchemas;
    private readonly byteArrayLength;
    private readonly maskOffset;
    constructor(bitSchemas: T);
    encodeInternal(value: TypeFromBitSchema<T>): Uint8Array<ArrayBuffer>;
    decodeInternal(bitmap: Uint8Array): TypeFromBitSchema<T>;
}
/** Create a partial bitmap from a flag sequence */
export type FlagsToBitmap<T extends string[]> = {
    [name in Uncapitalize<T[number]>]: true;
};
/** Create a type with specified bit flags set */
export type BitFlags<T extends BitSchema, F extends Capitalize<Extract<keyof T, string>>[]> = Merge<{
    [key in keyof T]: false;
}, FlagsToBitmap<F>>;
/** Create a bitmap schema with a named subset of flags set */
export declare function BitFlags<T extends BitSchema, F extends Capitalize<Extract<keyof T, string>>[]>(bitSchemas: T, ...flags: [...F]): BitFlags<T, F>;
/** Create a full bitmap schema from a partial bitmap schema */
export declare function BitsFromPartial<S extends BitSchema, P extends TypeFromPartialBitSchema<S>>(schema: S, bits: P): TypeFromBitSchema<S>;
/** Declares a bitmap schema by indicating the bit position and their names. */
export declare const BitmapSchema: <T extends BitSchema>(bitSchemas: T) => BitmapSchemaInternal<T>;
/** Declares a bitmap schema backed by a ByteArray by indicating the bit position and their names. */
export declare const ByteArrayBitmapSchema: <T extends BitSchema>(bitSchemas: T) => ByteArrayBitmapSchemaInternal<T>;
export {};
//# sourceMappingURL=BitmapSchema.d.ts.map