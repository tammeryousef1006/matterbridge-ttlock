/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { TlvTag, TlvTypeLength } from "./TlvCodec.js";
import { TlvEncodingOptions, TlvReader, TlvSchema, TlvStream, TlvWriter } from "./TlvSchema.js";
export type LengthConstraints = {
    minLength?: number;
    maxLength?: number;
    length?: number;
};
type ArrayChunkData = {
    listIndex: number | null | undefined;
    element: TlvStream;
};
export type ArrayAsChunked = ArrayChunkData[];
/**
 * Schema to encode an array or string in TLV.
 *
 * @see {@link MatterSpecification.v10.Core} ยง A.11.2 and A.11.4
 */
export declare class ArraySchema<T> extends TlvSchema<T[]> {
    readonly elementSchema: TlvSchema<T>;
    readonly minLength: number;
    readonly maxLength: number;
    constructor(elementSchema: TlvSchema<T>, minLength?: number, maxLength?: number);
    encodeTlvInternal(writer: TlvWriter, value: T[], tag?: TlvTag, options?: TlvEncodingOptions): void;
    decodeTlvInternalValue(reader: TlvReader, typeLength: TlvTypeLength): T[];
    injectField(value: T[], fieldId: number, fieldValue: any, injectChecker: (fieldValue: any) => boolean): T[];
    removeField(value: T[], fieldId: number, removeChecker: (fieldValue: any) => boolean): T[];
    validate(data: T[]): void;
    decodeFromChunkedArray(chunks: ArrayAsChunked, currentValue?: T[]): T[];
    encodeAsChunkedArray(value: T[], options?: TlvEncodingOptions): ArrayAsChunked;
}
/** Array TLV schema. */
export declare const TlvArray: <T>(elementSchema: TlvSchema<T>, { minLength, maxLength, length }?: LengthConstraints) => ArraySchema<T>;
export {};
//# sourceMappingURL=TlvArray.d.ts.map