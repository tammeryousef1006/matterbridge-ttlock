/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { InternalError, maxValue, minValue, serialize, UnexpectedDataError } from "#general";
import { ValidationDatatypeMismatchError, ValidationOutOfBoundsError } from "../common/ValidationError.js";
import { TlvCodec, TlvType } from "./TlvCodec.js";
import { TlvSchema } from "./TlvSchema.js";
class StringSchema extends TlvSchema {
  constructor(type, minLength = 0, maxLength = 1024) {
    super();
    this.type = type;
    this.minLength = minLength;
    this.maxLength = maxLength;
    if (minLength < 0) throw new InternalError("Minimum length should be a positive number.");
  }
  encodeTlvInternal(writer, value, tag) {
    const typeLength = { type: this.type, length: TlvCodec.getUIntTlvLength(value.length) };
    writer.writeTag(typeLength, tag);
    writer.writePrimitive(typeLength, value);
  }
  decodeTlvInternalValue(reader, typeLength) {
    if (typeLength.type !== this.type) throw new UnexpectedDataError(`Unexpected type ${typeLength.type}.`);
    return reader.readPrimitive(typeLength);
  }
  validate(value) {
    if (this.type === TlvType.Utf8String && typeof value !== "string")
      throw new ValidationDatatypeMismatchError(`Expected string, got ${typeof value}.`);
    if (this.type === TlvType.ByteString && !(value instanceof Uint8Array))
      throw new ValidationDatatypeMismatchError(`Expected Uint8Array, got ${typeof value}.`);
    if (value.length > this.maxLength)
      throw new ValidationOutOfBoundsError(
        `String ${serialize(value)} is too long: ${value.length}, max ${this.maxLength}.`
      );
    if (value.length < this.minLength)
      throw new ValidationOutOfBoundsError(
        `String ${serialize(value)} is too short: ${value.length}, min ${this.minLength}.`
      );
  }
  bound({ minLength, maxLength, length }) {
    return new StringSchema(
      this.type,
      length ?? maxValue(this.minLength, minLength),
      length ?? minValue(this.maxLength, maxLength)
    );
  }
}
const TlvByteString = new StringSchema(TlvType.ByteString);
const TlvString = new StringSchema(TlvType.Utf8String);
const TlvString32max = TlvString.bound({ maxLength: 32 });
const TlvString64max = TlvString.bound({ maxLength: 64 });
const TlvString256max = TlvString.bound({ maxLength: 256 });
const TlvHardwareAddress = TlvByteString.bound({ minLength: 6, maxLength: 8 });
export {
  StringSchema,
  TlvByteString,
  TlvHardwareAddress,
  TlvString,
  TlvString256max,
  TlvString32max,
  TlvString64max
};
//# sourceMappingURL=TlvString.js.map
